From m.dejonge at tudelft.nl  Mon Aug  1 10:38:23 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 01 Aug 2011 08:38:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23164 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util
Message-ID: <20110801083823.2AC07108C014@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug  1 08:38:22 2011
New Revision: 23164
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23164&sc=1

Log:
- diff origin / origin of desugared-term
- remove: in-local-context

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str
   spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str	Sat Jul 30 09:29:06 2011	(r23163)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/construct-text.str	Mon Aug  1 08:38:22 2011	(r23164)
@@ -104,7 +104,7 @@
 	where //guarantees that node can be formatted from the origin node, preventing non-termination
 		<is-tuple> t; //debug(!"ast-changes?: ");
 		<has-origin-term> origin-node;
-		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); 
+		ast-changes := <collect-ast-changes> (origin-node, node); 
 		<is-terminating-diff(|node)> ast-changes //prevent non termination
 		//; debug(!"ast-changes!: ")
 	with
@@ -145,7 +145,7 @@
 		<is-tuple> t;
 		<has-origin-term> origin-node
 	with //termination check is not needed (we need to Replace to keep comments), since it is called on a subterm in construct-text-by-pp
-		ast-changes := <collect-ast-changes(in-parent-context(|origin-node))> (origin-node, node); //debug(!"--ast-changes: ");
+		ast-changes := <collect-ast-changes> (origin-node, node); //debug(!"--ast-changes: ");
 		text-changes := <map(ast-change-to-text-change(pp))> ast-changes; //debug(!"--txt-changes: ");
 		full-text := <origin-text-with-layout> origin-node; 
 		full-text-start-offset := <origin-layout-prefix-start-offset> origin-node; 
@@ -160,13 +160,14 @@
 
 rules //ast-diff
 
-collect-ast-changes(in-local-context) = 
+collect-ast-changes = 
 	where(is-tuple); 
 	try(remove-superfluous-parentethical);
 	(collect-ast-changes-eq <+
-	collect-ast-changes-rec-node(in-local-context) <+
-	collect-ast-changes-rec-list(in-local-context) <+
-	collect-ast-changes-replace(in-local-context))
+	collect-ast-changes-rec-node <+
+	collect-ast-changes-rec-list <+
+	collect-ast-changes-resugared <+
+	collect-ast-changes-replace)
 
 remove-superfluous-parentethical:
 	(origin-node, Parenthetical(node)) -> (origin-node, node)
@@ -178,16 +179,14 @@
 	where
 		<equal> (origin-node, node)
 
-collect-ast-changes-rec-node(in-local-context):
+collect-ast-changes-rec-node:
 	(origin-node, node) -> ast-changes
 	where
 		<same-signature <+ ?([_],[_])> (origin-node, node);
 		arg-tuples := <zip>(<get-arguments> origin-node, <get-arguments> node); 
-		ast-changes := <map(collect-ast-changes(in-local-context)); flatten-list> arg-tuples 
-	where
-		<map(in-local-context)> ast-changes
+		ast-changes := <map(collect-ast-changes); flatten-list> arg-tuples 
  
-collect-ast-changes-rec-list(in-local-context):
+collect-ast-changes-rec-list:
 	(origin-lst, lst) -> ast-changes
 	where 
 		<is-list> lst;
@@ -195,22 +194,28 @@
 		<not(violates-homomorphism-list)> (origin-lst, lst)
 	where
 		ast-changes := <
-			list-diff(in-local-context|origin-lst);
+			list-diff(|origin-lst);
 			filter(not(?INSERT_BEFORE(_, [])));
 			filter(not(?INSERT_AT_END(_, [])))
 		> (origin-lst, lst)
+
+collect-ast-changes-resugared:
+	(origin-node, node) -> ast-changes
 	where
-		<map(in-local-context)> ast-changes
+		ast-changes := <collect-ast-changes-rec-node> (origin-node, <origin-term> node)
+	where
+		<is-origin-term-desugared> node;
+		<not(is-origin-term)> node
 
-collect-ast-changes-replace(in-local-context):
+collect-ast-changes-replace:
 	(origin-node, node) -> [REPLACEMENT(origin-node, node)]
 	where
 		<has-origin-term> origin-node;
-		<not(is-list)> node; //list-text can only be constructed in a context  
-		<in-local-context> REPLACEMENT(origin-node, node)
+		<not(is-list)> node //list-text can only be constructed in a context  
 
 rules //validity
 
+/*
 //desugaring: changes must fall inside region of original text
 //issue: is it correct if we simply filter context sensitive changes?
 in-parent-context(|origin-parent):
@@ -219,18 +224,19 @@
 		start-offset-node := <origin-deletion-start-offset> origin-parent; 
 		end-offset-node := <origin-deletion-end-offset> origin-parent; 
 		start-offset-change := <get-arguments; Hd; origin-start-offset> ast-change; 
-		end-offset-change := <get-arguments; Hd; origin-end-offset> ast-change; 
+		end-offset-change := <get-arguments; Hd; origin-end-offset> ast-change
+	where 
 		<leq> (start-offset-node, start-offset-change); 
 		<leq> (end-offset-change, end-offset-node) 
-		
+*/
 	
 rules //list diff
 
-list-diff(in-local-context|origin-lst) = 
-	(list-diff-fuzzy(in-local-context|origin-lst) <+
-	list-diff-origin-related(in-local-context|origin-lst)) 
+list-diff(|origin-lst) = 
+	(list-diff-fuzzy(|origin-lst) <+
+	list-diff-origin-related(|origin-lst)) 
 	
-list-diff-fuzzy(in-local-context|origin-lst):
+list-diff-fuzzy(|origin-lst):
 	([origin-elem|origin-rest], [new-elem|new-rest]) -> ast-changes
 	where
 		<is-deletion(|new-rest)> origin-elem;
@@ -238,31 +244,31 @@
 		<is-related-to-fuzzy(|origin-elem)> new-elem //fuzzy to prevent deletion + insertion
 	with
 		ast-changes := <flatten-list>[
-			<collect-ast-changes(in-local-context)>(origin-elem, new-elem)|
-			<list-diff(in-local-context|origin-lst)> (origin-rest, new-rest)
+			<collect-ast-changes>(origin-elem, new-elem)|
+			<list-diff(|origin-lst)> (origin-rest, new-rest)
 		]
 
-list-diff-origin-related(in-local-context|origin-lst): 
+list-diff-origin-related(|origin-lst): 
 	(origin-elems, new-elems) -> ast-changes
 	where 
 		deleted-elems := <take-while(is-deletion(|new-elems))> origin-elems;  
 		origin-rest := <drop-while(is-deletion(|new-elems))> origin-elems;
 		<not(?[])> deleted-elems 
 	with
-		ast-changes := <flatten-list>[DELETION(deleted-elems)|<list-diff(in-local-context|origin-lst)> (origin-rest, new-elems)]
+		ast-changes := <flatten-list>[DELETION(deleted-elems)|<list-diff(|origin-lst)> (origin-rest, new-elems)]
 
-list-diff-origin-related(in-local-context|origin-lst):
+list-diff-origin-related(|origin-lst):
 	([origin-elem|origin-rest], new-elems) -> ast-changes
 	where
 		(inserted, elem, rest) := <split-fetch-keep(is-related-to(|origin-elem))> new-elems
 	with
 		ast-changes := <flatten-list>[
 			INSERT_BEFORE(origin-elem, inserted), 
-			<collect-ast-changes(in-local-context)>(origin-elem, elem)|
-			<list-diff(in-local-context|origin-lst)> (origin-rest, rest)
+			<collect-ast-changes>(origin-elem, elem)|
+			<list-diff(|origin-lst)> (origin-rest, rest)
 		]
 
-list-diff-origin-related(in-local-context|origin-lst):
+list-diff-origin-related(|origin-lst):
 	([], new-elems) -> [INSERT_AT_END(origin-lst, new-elems)]
 
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str	Sat Jul 30 09:29:06 2011	(r23163)
+++ spoofax-imp/trunk/org.strategoxt.imp.generator/src/sdf2imp/util/origin-tracking.str	Mon Aug  1 08:38:22 2011	(r23164)
@@ -35,6 +35,7 @@
 origin-layout-prefix-start-offset = origin-insert-before-offset
 
 is-origin-term = <equal> (<origin-term>, <id>)
+is-origin-term-desugared = <equal> (<origin-term-desugared>, <id>)
 has-origin-term = where(origin-term)
 has-origin-sublist-term = where(origin-sublist-term)
 is-origin-sublist-term = <equal> (<origin-sublist-term>, <id>)

From m.dejonge at tudelft.nl  Mon Aug  1 20:19:04 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 01 Aug 2011 18:19:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23165 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing:
	editor/java/org/strategoxt/imp/testing/strategies trans
Message-ID: <20110801181904.F1FCDCC36D@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug  1 18:19:04 2011
New Revision: 23165
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23165&sc=1

Log:
input term refactoring: userinput, (source), semantic nodes

Added:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/get_service_input_term_refactoring_0_1.java   (contents, props changed)
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/InteropRegisterer.java
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/InteropRegisterer.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/InteropRegisterer.java	Mon Aug  1 08:38:22 2011	(r23164)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/InteropRegisterer.java	Mon Aug  1 18:19:04 2011	(r23165)
@@ -16,6 +16,7 @@
         		   plugin_strategy_evaluate_1_2.instance,
         		   plugin_get_property_values_0_1.instance,
         		   get_service_input_term_0_1.instance,
+        		   get_service_input_term_refactoring_0_1.instance,
         		   open_editor_0_0.instance,
         		   testview_init_0_0.instance,
         		   testview_add_testsuite_0_2.instance,

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/get_service_input_term_refactoring_0_1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/java/org/strategoxt/imp/testing/strategies/get_service_input_term_refactoring_0_1.java	Mon Aug  1 18:19:04 2011	(r23165)
@@ -0,0 +1,43 @@
+package org.strategoxt.imp.testing.strategies;
+
+import static org.spoofax.interpreter.core.Tools.isTermAppl;
+import static org.spoofax.interpreter.core.Tools.termAt;
+import static org.spoofax.terms.Term.*;
+
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.strategoxt.HybridInterpreter;
+import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+import org.strategoxt.imp.runtime.dynamicloading.TermReader;
+import org.strategoxt.imp.runtime.services.InputTermBuilder;
+import org.strategoxt.imp.runtime.services.StrategoReferenceResolver;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.Strategy;
+
+/**
+ * @author Maartje de Jonge>
+ */
+public class get_service_input_term_refactoring_0_1 extends Strategy {
+
+	public static get_service_input_term_refactoring_0_1 instance = new get_service_input_term_refactoring_0_1();
+
+	@Override
+	public IStrategoTerm invoke(Context context, IStrategoTerm info, IStrategoTerm analyzedAst) {
+		// TODO: adapt to latest strategy of StrategoReferenceResolver?
+		if (isTermAppl(analyzedAst) && ((IStrategoAppl) analyzedAst).getName().equals("None"))
+			analyzedAst = null;
+		IStrategoTerm[] semNodes = termAt(info, 1).getAllSubterms();
+		boolean onSource = TermReader.findTerm(info, "Source") != null;
+		IStrategoTerm current = termAt(info, 0);
+		try {
+			current = InputTermBuilder.getMatchingNode(semNodes, current, false);
+			if(current == null) return null;
+		} catch (BadDescriptorException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		HybridInterpreter runtime = HybridInterpreter.getInterpreter(context);
+		InputTermBuilder inputBuilder = new InputTermBuilder(runtime, analyzedAst);
+		return inputBuilder.makeInputTermRefactoring(termAt(info, 3), current, true, onSource);
+	}
+}

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Mon Aug  1 08:38:22 2011	(r23164)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Mon Aug  1 18:19:04 2011	(r23165)
@@ -29,7 +29,7 @@
 
   check-expectation(|ast, selections, messages) :
     c at Refactor(builder, arg, expected) ->
-    <check-builder(|ast, selections, messages, c)> (builder, arg, expected)
+    <check-refactoring(|ast, selections, messages, c)> (builder, arg, expected)
   
   check-builder(|ast, selections, messages, condition):
     (builder, arg, expected) -> error
@@ -39,7 +39,26 @@
       if !arg => Argument(arg') then
         plugin-strategy-evaluate(id |<Language>, OVERRIDE_INPUT(arg'))
       end;
-      output := <execute-service(|input)> builder
+      output := <execute-service(|input)> builder;
+      error := <check-builder> (output, input, expected, condition)
+
+  check-refactoring(|ast, selections, messages, condition):
+    (builder, arg, expected) -> error
+    with 
+      (semnodes, _, options) := <spt-find-refactoring-description> builder;
+      selected := <resolve-selection(|selections) <+ !ast> Numbered("1"); 
+      user-input := <try(?Argument(<id>))> arg;
+      if  
+        input    := <get-service-input-term-refactoring> (selected, semnodes, options, user-input)
+      then
+      	output := <execute-service(|input)> builder
+      else 
+      	output := Error("Selection is not matched with expected sort/constructor")
+      end;
+      error := <check-builder> (output, input, expected, condition)
+	
+  check-builder:
+	(output, input, expected, condition) -> error
     where
       switch !output
         case ?Some(output'):
@@ -67,11 +86,7 @@
   fetch-builder-result(|input, output):
     Refactor(_, _, _) -> result
     with
-      !output => <one(?(input, _); ?(_, result))>
-    <+
-      !output => [(_, result) | _]
-    <+
-      !output => (_, result)
+      <?([(_,result)], _, _, _)> output
     <+
       !output => result
    

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Mon Aug  1 08:38:22 2011	(r23164)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Mon Aug  1 18:19:04 2011	(r23165)
@@ -147,6 +147,17 @@
   spt-get-builders =
     <plugin-get-property-values(|<Language>)> "Builder";
     map(\"Builder"#([_, d, s]) -> (d, s)\)
+
+  spt-get-refactorings =
+    <plugin-get-property-values(|<Language>)> "Refactoring";
+    map(\"Refactoring"#([semnodes, _, strategy, options, _]) -> (semnodes, strategy, options)\)
+    
+  spt-find-refactoring-description:
+  	strategy -> (semnodes, strategy, options)
+  	where
+  	  spt-get-refactorings;
+  	  fetch-elem(?(_, "Strategy"#([strategy]), _)); 
+  	  ?(semnodes, _, options)
   
   spt-exists-language(|language) =
     where(<plugin-get-property-values(|language)> "LanguageName")
@@ -178,8 +189,13 @@
   
   get-service-input-term =
     get-service-input-term(|<LastAnalyzedAst>)
+
+  get-service-input-term-refactoring =
+    get-service-input-term-refactoring(|<LastAnalyzedAst>)
   
   execute-service(|node):
     resolver -> <plugin-strategy-invoke(|<Language>, resolver)> node
   
   external get-service-input-term(|analyzed-ast)
+
+  external get-service-input-term-refactoring(|analyzed-ast)

From m.dejonge at tudelft.nl  Mon Aug  1 20:52:48 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 01 Aug 2011 18:52:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23166 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110801185248.35BFC7F8106@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug  1 18:52:47 2011
New Revision: 23166
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23166&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Mon Aug  1 18:19:04 2011	(r23165)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Mon Aug  1 18:52:47 2011	(r23166)
@@ -39,7 +39,8 @@
       if !arg => Argument(arg') then
         plugin-strategy-evaluate(id |<Language>, OVERRIDE_INPUT(arg'))
       end;
-      output := <execute-service(|input)> builder;
+      output := <execute-service(|input)> builder
+    where
       error := <check-builder> (output, input, expected, condition)
 
   check-refactoring(|ast, selections, messages, condition):
@@ -54,7 +55,8 @@
       	output := <execute-service(|input)> builder
       else 
       	output := Error("Selection is not matched with expected sort/constructor")
-      end;
+      end
+    where
       error := <check-builder> (output, input, expected, condition)
 	
   check-builder:

From m.dejonge at tudelft.nl  Tue Aug  2 11:42:09 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 02 Aug 2011 09:42:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23167 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin
Message-ID: <20110802094209.2307BCC491@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  2 09:42:07 2011
New Revision: 23167
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23167&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin/SSL_EXT_enable_desugared_origins.java   (contents, props changed)
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin/OriginLibrary.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin/OriginLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin/OriginLibrary.java	Mon Aug  1 18:52:47 2011	(r23166)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin/OriginLibrary.java	Tue Aug  2 09:42:07 2011	(r23167)
@@ -11,6 +11,7 @@
 
     public OriginLibrary() {
         add(new SSL_EXT_enable_origins());
+        add(new SSL_EXT_enable_desugared_origins());
         add(new SSL_EXT_clone_and_set_parents());
         add(new SSL_EXT_get_parent());
 		add(new OriginLocationPrimitive());

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin/SSL_EXT_enable_desugared_origins.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.jsglr/src/org/spoofax/interpreter/library/jsglr/origin/SSL_EXT_enable_desugared_origins.java	Tue Aug  2 09:42:07 2011	(r23167)
@@ -0,0 +1,34 @@
+package org.spoofax.interpreter.library.jsglr.origin;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.jsglr.client.imploder.ImploderOriginTermFactory;
+import org.spoofax.terms.attachments.OriginTermFactory;
+
+/**
+ * @author Maartje de Jonge
+ */
+public class SSL_EXT_enable_desugared_origins extends AbstractPrimitive {
+    
+    public SSL_EXT_enable_desugared_origins() {
+        super("SSL_EXT_enable_desugared_origins", 0, 0);
+    }
+
+    @Override
+    public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
+    	ITermFactory factory = env.getFactory();
+    	if (!(factory instanceof OriginTermFactory)){
+       		((OriginTermFactory)env.getFactory()).setAssignDesugaredOrigins(true);    		
+    	}
+    	else{
+    		OriginTermFactory originFactory = new ImploderOriginTermFactory(factory);
+    		originFactory.setAssignDesugaredOrigins(true);
+    		env.setFactory(originFactory);
+    	}
+    	return true;
+    }
+
+}

From m.dejonge at tudelft.nl  Tue Aug  2 13:23:16 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 02 Aug 2011 11:23:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23168 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110802112316.C3B187F807A@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  2 11:23:16 2011
New Revision: 23168
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23168&sc=1

Log:
improvement: compare desugared forms (not sufficient in case refactoring result contains sugar for example when new terms are inserted)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Aug  2 09:42:07 2011	(r23167)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Aug  2 11:23:16 2011	(r23168)
@@ -9,13 +9,14 @@
   spoofax_testing
   check
   check-resolve
+  //ast-compare
 
 overlays
   
   OVERRIDE_INPUT(s) = Prim("\"SSL_EXT_overrideinput\"", [NoAnnoList(Str(s))])
 
 rules
-  
+ 
   spt-desugar:
     Run(x, arg, p) -> Build(x, arg, p)
 
@@ -48,10 +49,11 @@
     with 
       (semnodes, _, options) := <spt-find-refactoring-description> builder;
       selected := <resolve-selection(|selections) <+ !ast> Numbered("1"); 
-      user-input := <try(?Argument(<id>))> arg;
+      selected' := <repeat(\_#([arg]) -> arg\)> selected; //Var(Id(x)) start looking for matching nodes from x
+      user-input := <try(?Argument(<id>)); try(trim-chars(?'"'))> arg;
       if  
-        input    := <get-service-input-term-refactoring> (selected, semnodes, options, user-input)
-      then
+        input    := <get-service-input-term-refactoring> (selected', semnodes, options, user-input)
+      then 
       	output := <execute-service(|input)> builder
       else 
       	output := Error("Selection is not matched with expected sort/constructor")
@@ -101,12 +103,19 @@
   check-builder-expectation(|result) :
     Fragment(_{^[ast | _]}) -> $[Unexpected output: [result']]
     where
-      not(<eq> (result, ast))
+      not(<eq> (ast, result) <+ <equal-in-desugared-form> (ast, result)) //TODO compare-ast
     with
       result' := <spt-pp-string> result
     <+
       result' := $[[<write-to-string> result] instead of [<write-to-string> ast]]
-   
+  
+  equal-in-desugared-form:
+  	(ast, result) -> (ast, result)
+  	where
+      input-observer := (ast, <InputFile>, <project-path>);
+      ast-desugared := <plugin-strategy-invoke(|<Language>, <spt-get-observer>); try(?Some(<Fst>))> input-observer;
+      <eq> (<strip-annos> ast-desugared, <strip-annos> result) //TODO compare-ast with sugar aware diff function
+  		
   check-builder-expectation(|result) :
     ATerm(p) -> $[Unexpected output: [<write-to-string> result]]
     where

From m.dejonge at tudelft.nl  Tue Aug  2 15:12:38 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 02 Aug 2011 13:12:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23169 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110802131238.DC77B108C053@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  2 13:12:36 2011
New Revision: 23169
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23169&sc=1

Log:
- topdown compare refactor output with desugared expected output
- terms in expected output can be resugared by taking the origin term

Added:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str

Added: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str	Tue Aug  2 13:12:36 2011	(r23169)
@@ -0,0 +1,46 @@
+module ast-compare
+
+rules
+
+compare-desugared-asts:
+  (expected, result) -> (expected, result)
+  where
+  	<compare-ast> (<topdown(strip-annos)> expected, <topdown(strip-annos)> result)
+	
+compare-ast =
+  compare-ast-eq <+
+  compare-ast-rec <+
+  compare-ast-resugar-expected 
+  
+compare-ast-eq:
+  (expected, result) -> (expected, result)
+  where
+  	<equal> (expected, result)
+
+compare-ast-rec:
+  (expected, result) -> (expected, result)
+  where
+  	<?c#(expected-args)> expected;
+  	<?c#(result-args)> result;
+  	<zip; map(compare-ast)> (expected-args, result-args)
+
+compare-ast-resugar-expected:
+  (expected, result) -> (expected, result)
+  where
+  	//<is-origin-term-desugared> expected;
+  	<not(is-origin-term)> expected;
+  	<not(same-signature)> (expected, result);
+  	<compare-ast> (<origin-term> expected, result) 
+  	//TODO: we assume that 'expected' is a desugared origin. 
+ 
+same-signature:
+  (expected, result) -> (expected, result)
+  where
+  	<?c#(expected-args)> expected;
+  	<?c#(result-args)> result;
+  	<zip> (expected-args, result-args)
+	  	
+origin-term = prim("SSL_EXT_origin_term", <id>)
+is-origin-term = <equal> (<origin-term>, <id>)
+//origin-term-desugared = prim("SSL_EXT_origin_term_desugared", <id>)
+//is-origin-term-desugared = <equal> (<origin-term-desugared>, <id>)

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Aug  2 11:23:16 2011	(r23168)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Aug  2 13:12:36 2011	(r23169)
@@ -9,7 +9,7 @@
   spoofax_testing
   check
   check-resolve
-  //ast-compare
+  ast-compare
 
 overlays
   
@@ -114,7 +114,7 @@
   	where
       input-observer := (ast, <InputFile>, <project-path>);
       ast-desugared := <plugin-strategy-invoke(|<Language>, <spt-get-observer>); try(?Some(<Fst>))> input-observer;
-      <eq> (<strip-annos> ast-desugared, <strip-annos> result) //TODO compare-ast with sugar aware diff function
+      <compare-desugared-asts> (ast-desugared, result) //TODO compare-ast with sugar aware diff function
   		
   check-builder-expectation(|result) :
     ATerm(p) -> $[Unexpected output: [<write-to-string> result]]

From m.dejonge at tudelft.nl  Tue Aug  2 19:13:28 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 02 Aug 2011 17:13:28 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23170 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110802171328.56F41108C027@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  2 17:13:27 2011
New Revision: 23170
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23170&sc=1

Log:
refactor errors, warnings
todo: fatal-errors

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Aug  2 13:12:36 2011	(r23169)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Aug  2 17:13:27 2011	(r23170)
@@ -88,11 +88,12 @@
       !output => result
   
   fetch-builder-result(|input, output):
-    Refactor(_, _, _) -> result
+    Refactor(_, _, _) -> refactor-result
     with
-      <?([(_,result)], _, _, _)> output
+      <?([(_,result)], fatals, errors, warnings)> output;
+      refactor-result := (result, fatals, errors, warnings)
     <+
-      !output => result
+      !output => refactor-result
    
   check-builder-expectation(|result) :
     Fails() -> $[Builder was expected to fail, but produced: [result]]
@@ -121,3 +122,35 @@
     where
       result' := <explode-aterm> result;
       not(<aterm-eq> (result', p))
+
+  check-builder-expectation(|result) :
+  	(expected-ast, expected-problems) -> <separate-by(|"; "); concat-strings> refactor-errors
+  	where
+  	  <?(result-ast, fatals, errors, warnings)> result;
+  	  refactor-errors := <filter(check-refactor-expectation(|result))> [expected-ast|expected-problems];
+  	  <not(?[])> refactor-errors
+  		
+  check-refactor-expectation(|result) :
+    expected-ast -> <check-builder-expectation(|result-ast)> expected-ast
+    where
+      <?(result-ast, _, _, _)> result
+ 
+  check-refactor-expectation(|result) :
+    Warnings(n) -> $[[n] refactor warning(s) expected: [<write-to-string> warnings]]
+    where
+      <?(_, _, _, warnings)> result
+    ; not(<eq> (<length> warnings, <string-to-int> n))
+
+  check-refactor-expectation(|result) :
+    Errors(n) -> $[[n] refactor error(s) expected: [<write-to-string> errors]]
+    where
+      <?(_, _, errors, _)> result
+    ; not(<eq> (<length> errors, <string-to-int> n))
+
+  /* //TODO
+  check-refactor-issues-expectation(|result) :
+    Fatals(n) -> $[[n] refactor fatal-error(s) expected: [<write-to-string> fatals]]
+    where
+      <?(_, fatals, _, _)> result
+    ; not(<eq> (<length> fatals, <string-to-int> n))
+  */

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Tue Aug  2 13:12:36 2011	(r23169)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Tue Aug  2 17:13:27 2011	(r23170)
@@ -24,7 +24,12 @@
   
   spt-desugar:
     Warning(n) -> Warnings(n)
-  
+
+  spt-desugar:
+  	Test(t1, t2, t3, expectations) -> Test(t1, t2, t3, expectations')
+  	where
+  	  expectations' := <at-suffix-rev(process-refactor-expectations)> expectations
+
   check-note = fail
   
   check-warning:
@@ -66,8 +71,14 @@
       else
         warnings := <filter(check-expectation(|input, selections, messages'))> expectations
       end
-    ; not([])
+    ; not([]) 
 
+  process-refactor-expectations:
+  	[Refactor(strategy, arg, expected-ast)|expectations] -> 
+  	[Refactor(strategy, arg, (expected-ast, expectations))]
+  	where
+  		<not(?(_, <is-list>))> expected-ast //already done
+   
   strip-and-record-analyzed-ast:
     (t, e, w, n) -> (e, w, n)
     where

From m.dejonge at tudelft.nl  Tue Aug  2 21:17:54 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 02 Aug 2011 19:17:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23171 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110802191754.9AE627F822B@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug  2 19:17:53 2011
New Revision: 23171
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23171&sc=1

Log:
0 errors, 0 warnings as default values

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Tue Aug  2 17:13:27 2011	(r23170)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Tue Aug  2 19:17:53 2011	(r23171)
@@ -25,10 +25,16 @@
   spt-desugar:
     Warning(n) -> Warnings(n)
 
-  spt-desugar:
-  	Test(t1, t2, t3, expectations) -> Test(t1, t2, t3, expectations')
+  spt-desugar-refactoring-conditions =
+    at-suffix-rev(spt-desugar-refactor-expectations)
+
+  spt-desugar-refactor-expectations:
+  	[Refactor(strategy, arg, expected-ast)|expectations] -> 
+  	[Refactor(strategy, arg, (expected-ast, refactor-expectations))]
   	where
-  	  expectations' := <at-suffix-rev(process-refactor-expectations)> expectations
+  		zeros := [Errors("0"), Warnings("0")]; //TODO Fatals(0)
+  		refactor-expectations := 
+  			<union(?(Errors(_), Errors(_)) <+ ?(Warnings(_), Warnings(_)))> (zeros, expectations)
 
   check-note = fail
   
@@ -72,12 +78,6 @@
         warnings := <filter(check-expectation(|input, selections, messages'))> expectations
       end
     ; not([]) 
-
-  process-refactor-expectations:
-  	[Refactor(strategy, arg, expected-ast)|expectations] -> 
-  	[Refactor(strategy, arg, (expected-ast, expectations))]
-  	where
-  		<not(?(_, <is-list>))> expected-ast //already done
    
   strip-and-record-analyzed-ast:
     (t, e, w, n) -> (e, w, n)

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Aug  2 17:13:27 2011	(r23170)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/spoofax_testing.str	Tue Aug  2 19:17:53 2011	(r23171)
@@ -19,7 +19,7 @@
     (ast', errors', warnings', notes')
     with
       editor-init;
-      ast' := <topdown(repeat(spt-desugar))> ast
+      ast' := <topdown(repeat(spt-desugar)); alltd(spt-desugar-refactoring-conditions)> ast
     with
       (errors', warnings', notes') := <report-invalid-language> ast'
     <+

From m.dejonge at tudelft.nl  Wed Aug  3 08:35:24 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 03 Aug 2011 06:35:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23172 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: syntax trans
Message-ID: <20110803063524.1FCE22B8005@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  3 06:35:22 2011
New Revision: 23172
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23172&sc=1

Log:
fatal errors for refactorings

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Tue Aug  2 19:17:53 2011	(r23171)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Wed Aug  3 06:35:22 2011	(r23172)
@@ -95,11 +95,14 @@
 
     "file" PathName -> Input {cons("file")}
 
-    INT "error"       -> Result    {cons("Error")}
-    INT "errors"      -> Result    {cons("Errors")}
+    INT "error"         -> Result    {cons("Error")}
+    INT "errors"        -> Result    {cons("Errors")}
 
-    INT "warning"     -> Result    {cons("Warning")}
-    INT "warnings"    -> Result    {cons("Warnings")}
+    INT "warning"       -> Result    {cons("Warning")}
+    INT "warnings"      -> Result    {cons("Warnings")}
+
+    INT "fatal" "error" -> Result    {cons("Fatal")}
+    INT "fatal" "errors"-> Result    {cons("Fatals")}
 
     "resolve" OptNumbered                     -> Result {cons("Resolve")}
     "resolve" Numbered "to" Numbered          -> Result {cons("ResolveTo")}

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Tue Aug  2 19:17:53 2011	(r23171)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Wed Aug  3 06:35:22 2011	(r23172)
@@ -147,10 +147,8 @@
       <?(_, _, errors, _)> result
     ; not(<eq> (<length> errors, <string-to-int> n))
 
-  /* //TODO
-  check-refactor-issues-expectation(|result) :
+  check-refactor-expectation(|result) :
     Fatals(n) -> $[[n] refactor fatal-error(s) expected: [<write-to-string> fatals]]
     where
       <?(_, fatals, _, _)> result
     ; not(<eq> (<length> fatals, <string-to-int> n))
-  */

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Tue Aug  2 19:17:53 2011	(r23171)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Wed Aug  3 06:35:22 2011	(r23172)
@@ -25,6 +25,9 @@
   spt-desugar:
     Warning(n) -> Warnings(n)
 
+  spt-desugar:
+    Fatal(n) -> Fatals(n)
+
   spt-desugar-refactoring-conditions =
     at-suffix-rev(spt-desugar-refactor-expectations)
 
@@ -32,7 +35,7 @@
   	[Refactor(strategy, arg, expected-ast)|expectations] -> 
   	[Refactor(strategy, arg, (expected-ast, refactor-expectations))]
   	where
-  		zeros := [Errors("0"), Warnings("0")]; //TODO Fatals(0)
+  		zeros := [Fatals("0"), Errors("0"), Warnings("0")]; //TODO Fatals(0)
   		refactor-expectations := 
   			<union(?(Errors(_), Errors(_)) <+ ?(Warnings(_), Warnings(_)))> (zeros, expectations)
 

From M.A.Akhter at student.tudelft.nl  Wed Aug  3 10:19:06 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 03 Aug 2011 08:19:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23173 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans:
	codegen codegen/esv context utils
Message-ID: <20110803081906.D3781108C002@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug  3 08:19:06 2011
New Revision: 23173
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23173&sc=1

Log:
* resolving external lib import during *.main.packed.esv code generation.
* changes in build infrastructure  for new wizard

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Wed Aug  3 06:35:22 2011	(r23172)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Wed Aug  3 08:19:06 2011	(r23173)
@@ -18,10 +18,10 @@
 		with 
  			 project-path             := <ProjectPath>
  		with 
-			 main-ant-output-file-name    := "build.spx.packages"
+			 main-ant-output-file-name    := "build.spx.main.generated"
 			;autogen-ant-output-file-name := "build.spx.packages.generated"
-		  ;autogen-ant-output-path      := <concat-strings>[project-path  , "/" ,  autogen-ant-output-file-name , ".xml"]
-			;main-ant-output-path         := <concat-strings>[project-path  , "/" ,  main-ant-output-file-name    , ".xml"]
+		  ;autogen-ant-output-path      := <concat-strings>[project-path  , "/build/" ,  autogen-ant-output-file-name , ".xml"]
+			;main-ant-output-path         := <concat-strings>[project-path  , "/build/" ,  main-ant-output-file-name    , ".xml"]
 		where
 			 <dirname; ensure-directory-exists>autogen-ant-output-path  
 			;<save-to-file>(autogen-ant-output-path  , <get-ant-autogeneratedscript>())
@@ -35,32 +35,11 @@
 		packages-specific-ant: (pakage-qname*, main-ant-output-file-name ,autogen-ant-output-file-name)  ->
 $[<?xml version="1.0" encoding="UTF-8" ?>
 		
-		<project name="[main-ant-output-file-name]" default="build-spx-packages">
+<project name="[main-ant-output-file-name]" default="build-spx-packages">
     <!-- autogenerated artifacts relative directory path -->	
 		<property name="packages.root" location="[packages-root]"/>
 		
-		<!-- prject directories -->
-    <property name="trans" location="trans"/>
-    <property name="src-gen" location="editor/java"/>
-    <property name="include" location="include"/>
-    <property name="lib" location="lib"/>
-    <property name="build" location="bin"/> 
-    <property name="dist" location="bin/dist"/>
-    
-		<!-- Environment configuration for command-line builds -->
-    <property name="build.sdf.imports" value= "-I &quot;${basedir}&quot; "/>
-    <property name="build.stratego.args" value="
-                    --library
-                    -I &quot;${packages.root}&quot;
-                    -I &quot;${basedir}&quot;
-                    -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm  -la strc -la stratego-sdf"/>
-
-		<condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
-        <isset property="eclipse.spoofaximp.nativeprefix"/>
-    </condition>
-    <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
-	  
-	  <import file="[autogen-ant-output-file-name].xml"/>
+		<import file="[autogen-ant-output-file-name].xml"/>
 	  [<map(emit-package-specific-ant)>pakage-qname*]
 		
 		<!-- Main target -->
@@ -99,7 +78,7 @@
 	</target>	
 	]
 	where 
-		relative-autogen-path        := <qname-to-path>package-untyped-qname
+		relative-autogen-path         :=  <qname-to-path>package-untyped-qname
 		;package-directory		        := $[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
  		;language-name						 	  := <get-language-name>p
  		;language-id-directory			  := <get-language-id; language-id-to-file-path>p

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str	Wed Aug  3 06:35:22 2011	(r23172)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str	Wed Aug  3 08:19:06 2011	(r23173)
@@ -32,36 +32,38 @@
 	* OPTIMIZATION : If we allow arbitary order of different sections of ESV ,
 	*								then we can avoid store-esv-definitions .
 	*/
-	generate-esv-main: module-qname* -> <id>
+	generate-esv-main: module-qname'* -> <id>
 		with
  			 project-path             := <ProjectPath>;
  			 Package(package-qname)   := <GetEnclosingPackageName>
  		where
-			<debug-compiler>$[codegen | ESV | Generate-esv-main  : [<pp-aterm>package-qname]]
+			<debug-compiler>$[CodeGen | ESV | Generate-esv-main  : [<pp-aterm>package-qname]]
 		with
  			 relative-autogen-path := <qname-to-path>package-qname
  			;package-esv-main-name := $[[<get-main-file-name>()].main.packed]
  			;autogen-dir           := $[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
  			;root-directory 			 := $[[project-path]/[<Autogenerated-Artifacts-Dir>]]
  		where
+ 			// During Esv generation, imported packages is also packed.
+ 			// Note: transitive imports is not supported.
+ 			<get-all-imported-modules>Package(package-qname) => imported-modules*;
+ 			<conc;make-set>( module-qname'* , imported-modules*) => module-qname*; 
  			{|  //TODO : consider removing DR and use collect instead
  					Declared-Language-Description,Declared-Builders-Description,Declared-Colorer-Description,
  					Declared-Folding-Description,Declared-Outliner-Description,Declared-References-Description,
  					Declared-Completions-Description:
-
- 						<map(get-original-module-declaration;store-esv-defintions)>module-qname*
+ 						<map(store-module-esv-definition)>module-qname*
  						;sections := <conc>
- 						 					(
- 						 					 <inject-package-ctree><get-main-file-name>(),   // adding ctree import by default
- 						 					 <inject-table-definition><get-main-file-name>(),   // default table definition
- 						 					 <all-keys-Declared-Language-Description>,
- 			 								 <all-keys-Declared-Builders-Description> ,
- 			 								 <all-keys-Declared-Colorer-Description> ,
- 			 								 <all-keys-Declared-Folding-Description>,
- 			 								 <all-keys-Declared-Outliner-Description>,
- 			 								 <all-keys-Declared-References-Description>,
- 			 								 <all-keys-Declared-Completions-Description>,
- 			 								 <map(get-original-module-declaration; template-module-to-esv)> module-qname*
+ 						 					(	 <inject-package-ctree><get-main-file-name>(),   // adding ctree import by default
+	 						 					 <inject-table-definition><get-main-file-name>(),   // default table definition
+	 						 					 <all-keys-Declared-Language-Description>,
+	 			 								 <all-keys-Declared-Builders-Description> ,
+	 			 								 <all-keys-Declared-Colorer-Description> ,
+	 			 								 <all-keys-Declared-Folding-Description>,
+	 			 								 <all-keys-Declared-Outliner-Description>,
+	 			 								 <all-keys-Declared-References-Description>,
+	 			 								 <all-keys-Declared-Completions-Description>,
+	 			 								 <map(get-original-module-declaration; template-module-to-esv)> module-qname*
  			 							   )
  			|}
  			;esv-aterm := Module(package-esv-main-name, Import([]), sections)
@@ -69,7 +71,14 @@
 		where
 			<debug-compiler>$[ Codegen | ESV | Finished generation of packed esv for [<pp-aterm>package-qname].]
 
-
+	store-module-esv-definition : Module(QName(untyped-module-qname)) -> <id>
+	where
+		<debug> $[CodeGen | ESV |  Packing following module : [<pp-aterm>QName(untyped-module-qname)]] 
+	where 
+		get-original-module-declaration;
+ 		store-esv-defintions
+ 		
+	
 	//Adding package ctree as the default semantic provider0
 	inject-package-ctree :
 		lang-name -> [Builders("",[SemanticProvider(lang-output-ctree)])]

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Wed Aug  3 06:35:22 2011	(r23172)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Wed Aug  3 08:19:06 2011	(r23173)
@@ -114,6 +114,17 @@
 	// Returns a list of package/modules that <id> is depeding on. 
 	// Requires the <ID> to be untyped QName to look it up in the symbol tree.
 	// Otherwise, it throws <illegal argument exception>
+	get-all-imported-modules = 
+		where(?Package(_)); 
+		debug(!"1 : ") ; 
+		get-all-usings ; 
+		debug(!"2 : ");  
+		filter( ?Package(_)) ; 
+		debug(!"3 : "); 
+		mapconcat( get-enclosed-modules )
+	  
+	get-all-usings =  ?Package(<id>); debug(!"4 : ") ; get-all-usings 
+	
 	get-all-usings =  where(?QName(_));	?package-untyped-qname; all-keys-Using;	filter(?(package-untyped-qname, _)); mapconcat(bagof-Using)	
 	
 	get-all-usings : (package-untyped-qname , module-untyped-qname) -> lstUsings*

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str	Wed Aug  3 06:35:22 2011	(r23172)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str	Wed Aug  3 08:19:06 2011	(r23173)
@@ -89,6 +89,14 @@
 		end 
 		
 rules
+	ensure-exists =  
+		?(autogen-root-path, QName(qname-parts*))
+		;<ensure-directory-exists>autogen-root-path 
+		;if not(<eq>(<length>qname-parts*,0)) then 
+				<map(create-folder)>qname-parts*  //Creating sub-directories from the qname parts 
+		 end
+		;create-folder(|autogen-root-path)  // restoring current folder to the project-path 
+	
 	//ensures whether a particular directory exists. If it does not , then creates a new one with the same name. 	
 	ensure-directory-exists = ?dirpath ; ((file-exists ; filemode ; isdir) <+ mkdir); chdir	
 
@@ -100,15 +108,7 @@
 				<map(create-folder)> dir*  //Creating sub-directories if they does not exists
 		 end
 		;create-folder(|project-path)  // restoring current folder to the project-path 
-		 
 	
-	ensure-exists =  
-		?(autogen-root-path, QName(qname-parts*))
-		;<ensure-directory-exists>autogen-root-path 
-		;if not(<eq>(<length>qname-parts*,0)) then 
-				<map(create-folder)>qname-parts*  //Creating sub-directories from the qname parts 
-		 end
-		;create-folder(|autogen-root-path)  // restoring current folder to the project-path 
 	
 	create-folder(|directory-to-create) = <file-exists<+mkdir(|"w")> directory-to-create;<chdir>directory-to-create  
 	

From M.A.Akhter at student.tudelft.nl  Wed Aug  3 10:22:17 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 03 Aug 2011 08:22:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23174 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test
Message-ID: <20110803082217.B7330CC486@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug  3 08:22:17 2011
New Revision: 23174
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23174&sc=1

Log:
spx entity lang

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-common.generated.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-services.generated.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-services.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-adapters.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-definitions.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-descriptors.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-lexicalconstructs.spx
Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/Common.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/Lawoco-Test.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entity-lang.spx
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/test-without-package.spx

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-common.generated.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-common.generated.spx	Wed Aug  3 08:22:17 2011	(r23174)
@@ -0,0 +1,256 @@
+package languages.entitylang.generated 
+
+module common-strategies 
+
+imports
+  libstratego-sglr
+  libstratego-gpp 
+  
+strategies
+
+  parse-file = parse-test-file
+  parse-test-file =
+    parse-file(
+      strsglr-perror, strsglr-report-parse-error
+    | <import-term(include/Test.tbl)>
+    )
+
+  parse-string = parse-test-string 
+  parse-test-string = 
+    parse-string( 
+      strsglr-report-parse-error
+    | <import-term(include/Test.tbl)>
+    )
+  
+  parse-stream = parse-test-stream
+  parse-test-stream =
+    parse-stream(
+      strsglr-report-parse-error
+    | <import-term(include/Test.tbl)>
+    )
+
+  pp-test-string =
+    ast2abox(|[<import-term(include/Test.generated.pp.af)>,
+               <import-term(include/Test.pp.af)>]); 
+    box2text-string(|100)
+
+strategies
+  
+  /**
+   * Processes an import during semantic analysis.
+   * Ensures proper caching of files and prevents
+   * processing duplicate imports more than once.
+   *
+   * @param resolve-path  Resolves the filesystem path of this import
+   * @param parse-file    Parses a file (optionally removing definition bodies
+   *                      so only signatures are stored in the cache)
+   * @param record-declarations
+   *                      Performs semantic analysis on a tree
+   */
+  open-import(resolve-path, parse-file, record-declarations):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path       := <resolve-path> import;
+        cache-path := <import-cache-path> path;
+        if not(<IsImported> path) then
+          rules(
+            IsImported: path
+          );
+          ( <is-newer> (cache-path, path);
+            file := <ReadFromFile> cache-path
+          <+
+            file := <parse-file> path;
+            if <file-exists> path then
+              // Only cache if on filesystem (e.g., ignore libstratego-lib)
+              <WriteToBinaryFile> (cache-path, file)
+            end        
+          ); 
+          {| CurrentFile:
+            rules(CurrentFile := path)
+          	;<record-declarations> file    
+          |}
+        end
+      end  
+
+  open-wildcard-import(resolve-path, parse-file, record-declarations, is-source-file):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path := <resolve-path> import;
+        readdir;
+        list-loop(
+          if is-source-file then
+            <open-import(id, parse-file, record-declarations)>
+              $[[path]/[<id>]]
+          <+
+            try(?one-failed)
+          end
+        );
+        not(!one-failed)
+      end
+  
+  import-cache-path:
+    full-path -> cache-path
+    with
+      project-path := <project-path>;
+      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.cache];
+      full-path'   := <string-replace(|"/", "+"); string-replace(|"\\", "+"); string-replace(|":", "+")> full-path;
+      cache-path   := $[[cache-dir]/[full-path'].sig]
+
+  project-path = prim("SSL_EXT_projectpath")
+  
+  plugin-path = prim("SSL_EXT_pluginpath")
+  
+  candidate-sorts = prim("SSL_EXT_candidatesorts")
+
+  is-newer:
+    (file1, file2) -> <id>
+    where
+      <gt> (<file-exists; modification-time> file1, <file-exists; modification-time> file2) 
+
+strategies
+  
+  editor-init =
+    // Ensure all dynamic rules are properly scoped
+    try(dr-scope-all-end);
+    dr-scope-all-start
+  
+  refresh-workspace-file:
+    path -> <prim("SSL_EXT_refreshresource", path)>
+  
+  string-starts-with-capital =
+    explode-string; Hd; is-upper 
+
+strategies
+  
+  origin-term      = prim("SSL_EXT_origin_term", <id>)
+  origin-text      = prim("SSL_EXT_origin_text", <id>)
+  origin-location  = prim("SSL_EXT_origin_location", <id>)
+  origin-line      = origin-location => (<id>, _, _, _)
+  origin-column    = origin-location => (_, <id>, _, _)
+  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
+  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
+  
+  origin-surrounding-comments =
+    prim("SSL_EXT_origin_surrounding_comments", "Test", <id>)
+    
+  origin-documentation-comment =
+    origin-surrounding-comments;
+    filter(string-as-chars(documentation-comment-chars));
+    concat-strings
+  
+  documentation-comment-chars:
+    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*
+  
+  origin-track-forced(s) =
+    ![<id>]; all(s); ?[<id>]
+
+strategies
+
+  desugar-position(desugar|ast): 
+    position -> position'
+    where
+      ast'  := <at-position(!<id>{MARKER()}|position)> ast;
+      ast'' := <topdown(repeat(preserve-annos({?x; desugar; not(?x)})))> ast';
+      position' := <position-of-term({?_{a*}; <one(?MARKER())> a*})> ast''
+   
+  at-position(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+
+  at-position(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t
+
+  position-of-term(is-term):
+    t -> []
+    where
+      is-term
+  
+  position-of-term(is-term):
+    _#(t*) -> <position-of-term(is-term|0)> t*
+  
+  position-of-term(is-term|start-index):
+    [t | t*] -> position  
+    where
+      if i* := <position-of-term(is-term)> t then
+        position := [start-index | i*]
+      else
+        position := <position-of-term(is-term | <inc> start-index)> t*
+      end
+
+  term-at-position(|position):
+    t -> t'
+    where 
+      at-position(?t'|position) 
+
+  parent-at-position(|position):
+    t -> t'
+    where
+      !position => [i, _];
+      t' := <subterm-at(|i)> t
+  
+  parent-at-position(|position):
+    t -> <parent-at-position(|position')> t'
+    where
+      !position => [i | position' @ [_, _ | _]];
+      t' := <subterm-at(|i)> t
+
+  subterm-at(|index):
+    _#(t*) -> <index(|<inc> index)> t*
+  
+
+strategies
+  
+  // Set markers for a given file. Use when checking files from a queued strategy.
+  // Current term: (ast-desugared, errors, warnings, notes) tuple
+  // ast: the root node of the file to set markers on 
+  set-markers(|ast) = prim("SSL_EXT_set_markers", ast)
+
+  // Indicate that one or more files need analysis. 
+  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
+  queue-analysis = 
+       (is-list; list-loop(queue-analysis))
+    <+ prim("SSL_EXT_queue_analysis") 
+
+  // Set the total number of work units to complete. Can be called multiple times. 
+  // Current term: number of work units (int).
+  set-total-work-units = prim("SSL_EXT_set_total_work_units")
+  
+  // Complete one work unit and update progress monitors.
+  // Current term: ignored
+  complete-work-unit = prim("SSL_EXT_complete_work_unit")
+  
+  // Queue a strategy for background processing with a progress indicator.
+  // Current term: the term to pass to the background strategy
+  // s: the strategy, as string
+  // description: name of the task (will be shown in progress view)
+  queue-strategy(|s,description) = prim("SSL_EXT_queue_strategy", s, description)
+  
+  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
+  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
+  set-analysis-backgrounded = !"BACKGROUNDED"
+
+signature constructors
+
+  COMPLETION : String -> Term
+  NOCONTEXT  : Term   -> Term
+  MARKER     : Term
+
+  // Below are copies of the signatures of the terms used in example
+  // trans/test.str file. These definitions should also be automatically 
+  // generated in the imported include/Test.str module. However,
+  // to ensure that the example transformation doesn't break when the
+  // syntax is changed, we also hard-coded them here.
+          
+  Module   : ID * List(Entity)   -> Module
+  Entity   : ID * List(Property) -> Entity
+  Property : ID * Type           -> Property
+  Type     : ID                  -> Type   
+   

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-services.generated.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-services.generated.spx	Wed Aug  3 08:22:17 2011	(r23174)
@@ -0,0 +1,217 @@
+package languages.entitylang.generated 
+
+module builders-generated
+
+	builders                                                                                                         
+  // Building and analysis is defined in Stratego program or programs:                                     
+  //                                                                                                       
+  //   provider : stratego-program.ctree                                                                   
+  //   provider : stratego-library.jar                                                                     
+  //                                                                                                       
+  // Analysis is carried out by a Stratego rule that can be selected as follows:                           
+  //                                                                                                       
+  //   observer : analysis-rule                                                                            
+  //                                                                                                       
+  // Any dynamic rules set in the analysis may be used by other semantic services,                         
+  // such as reference resolving or the builders.                                                          
+  //                                                                                                       
+  // Builders may carry out custom transformations on a file or selection.                                 
+  // (At run-time, they can be accessed using the toolbar button with the star icon.)                      
+  // Builders can be specified as follows:                                                                 
+  //                                                                                                       
+  //   builder : "Generate Java code" = generate-java (openeditor) (persistent) (realtime)                 
+  //                                                                                                       
+  // In this example, the caption "Generate Java code" is used in the build button dropdown menu,          
+  // and the generate-java rule is used to carry out the tranformation.                                    
+  // Builder definitions can also specify any combination of the following annotations:                    
+  //                                                                                                       
+  //   (cursor)      The builder should always transform the tree node at the cursor.                      
+  //   (meta)        Indicates the builder should only be available to meta-programmers                    
+  //                 (i.e., not when the plugin is deployed to end-users).                                 
+  //   (openeditor)  Indicates an editor should be opened with the result.                                 
+  //   (persistent)  Indicates that the resulting file should be saved to disk.                            
+  //   (realtime)    Indicates that the resulting editor should be updated in real-time                    
+  //                 as the source file is edited.                                                         
+  //   (source)      Always apply this builder to the source AST, not to the AST                           
+  //                 after it has been analyzed/desugared by the observer.                                 
+  //                                                                                                       
+  // Refactorings are used for transformations that modify the original source code;                       
+  // the original layout is preserved for unchanged fragments,                                             
+  // while newly inserted nodes are pretty printed using a custom pretty-print strategy,                   
+  // or the layout definitions in the pp-table.                                                            
+  //   pp-table: get-pp-table                                                                              
+  //   pretty-print: prettyprint                                                                           
+  //                                                                                                       
+  // Refactorings can be specified as shown below, whereby Property* indicates on which constructs the     
+  // refactoring is specified (<sort>.<constructor>).                                                      
+  //                                                                                                       
+  //   refactoring Property*: "Extract Entity" =  extract-entity (source)                                  
+  //                                                                                                       
+  // The 'on save' handler can be used  to generate code as files are saved:                               
+  //                                                                                                       
+  //   on save : generate-java           
+  
+module references-generated
+
+	references
+	  // Reference resolving rules can specify the syntax constructors for which              
+	  // a reference resolving function is available:                                         
+	  //                                                                                      
+	  //   reference FunctionCall : resolve-function-call                                     
+	  //                                                                                      
+	  // This defines that for each FunctionCall, resolve-function-call                       
+	  // will retrieve the AST node that declares it.                                         
+	  //                                                                                      
+	  // Likewise, hover help can be specified as follows:                                    
+	  //                                                                                      
+	  //   hover FunctionCall : hover-help-function-call                                      
+	  //                                                                                      
+	  // Reference resolving uses the semantic provider defined in YourLanguage-Builders.esv  
+	  // All semantic services may make use of the dynamic rules created by the observer.    
+
+
+module codecompletions-generated
+	
+	completions 
+	                                                                                          
+	  // Syntactic content completion can be defined as follows:                              
+	  //                                                                                      
+	  //   completion keyword  : "keyword"                                                    
+	  //   completion template : "if " <e> " then\n\t" <s> "\nend"                            
+	  //                                                                                      
+	  // This defines keyword completion for "keyword" and                                    
+	  // a template completion for the "if" keyword (note the use of \n, \t, and spaces).     
+	  // In this template, the text selection expands to the "e" placeholder identifier       
+	  // enclosed in <> brackets.                                                             
+	  //                                                                                      
+	  // Use the (blank) annotation if you want a template completion only to                 
+	  // appear on blank lines:                                                               
+	  //                                                                                      
+	  //   completion template: "section " <title> "\n\t" (blank)                             
+	  //                                                                                      
+	  // You can specify a specific SDF sort for which a completion                           
+	  // rule should trigger as follows:                                                      
+	  //                                                                                      
+	  //   completion template Section :                                                      
+	  //     "section " <title> "\n\t" (blank)                                                
+	  //                                                                                      
+	  // Finally, you can override the prefix of the completion:                              
+	  //                                                                                      
+	  //   completion template Statement : "assignment" =                                     
+	  //     <x> " = " <y> (blank)                                                            
+	  //                                                                                      
+	  // Semantic content completion can be defined as follows:                               
+	  //                                                                                      
+	  //   completion proposer : completion-function-call                                     
+	  //   completion trigger  : "\."                                                         
+	  //                                                                                      
+	  // This sets completion-function-call as the completion strategy,                       
+	  // and declares that [A-Za-z0-9_]+ may be used as a lexical pattern                     
+	  // to parse identifiers (used to set the text selection with suggestions).              
+	  // The completion trigger uses a regular expression to specify that                     
+	  // completions should be proposed as the user types ".".                                
+	  //                                                                                      
+	  // Completions make use of the identifier lexical defined in YourLanguage-Syntax.esv    
+	  // to select identifiers in completion suggestions.                                     
+	  //                                                                                      
+	  // Semantic completion uses the semantic provider defined in YourLanguage-Builders.esv  
+	  // All semantic services may make use of the dynamic rules created by the observer.     
+	
+	completions
+	                                     
+	  // Derived completions may follow  
+	  
+  
+  
+ module folding-generated
+	
+	folding Default folding definitions
+	  
+	  // Folding rules indicate which syntactic constructs can be folded,
+	  // and take one of the following forms:
+	  //
+	  //   <sort>.<constructor>
+	  //
+	  //   <sort>._
+	  //
+	  //   _.<constructor>
+	  //
+	  // To indicate that an element should always be folded, add
+	  // a (folded) annotation:
+	  //
+	  //   _.Imports (folded)
+	  //
+	  // To disable a folding rule defined elsewhere, add a (disabled) annotation:
+	  //
+	  //   Definition._ (disabled)
+	  
+	  //Start.Module
+	  
+
+module outliner-generated
+	
+	outliner Default outliner        
+	  // Outliner rules indicate which syntactic constructs should be shown in the outline
+	  // and quick outline views, and take one of the following forms:
+	  //
+	  //   <sort>.<constructor>
+	  //
+	  //   <sort>._
+	  //
+	  //   _.<constructor>
+
+module syntax-generated
+	
+	language Syntax properties (static defaults)
+	                                           
+	  // Comment constructs:                   
+	  line comment                           : "//"
+	  block comment                          : "/*" * "*/"
+	                                           
+	  // Fences (used for matching,            
+	  // inserting, indenting brackets):       
+	  fences                                 : [ ]
+	                                           ( )
+	                                           { }
+	                                           
+	  // Automatic indent hints                
+	  // (indent after these tokens):          
+	  indent after                           : "="
+	                                           ":"
+	                                           
+	  // Regular expression for identifiers:   
+	  identifier lexical                     : "[A-Za-z0-9_]+"
+
+
+module colorer-generated 
+
+	colorer Default, token-based highlighting
+	                                  
+	  keyword    : 127 0 85 bold      
+	  identifier : default            
+	  string     : blue               
+	  number     : darkgreen          
+	  var        : 255 0 100 italic   
+	  operator   : 0 0 128            
+	  layout     : 63 127 95    
+
+	colorer System colors
+	                            
+	  darkred   = 128 0 0       
+	  red       = 255 0 0       
+	  darkgreen = 0 128 0       
+	  green     = 0 255 0       
+	  darkblue  = 0 0 128       
+	  blue      = 0 0 255       
+	  cyan      = 0 255 255     
+	  magenta   = 255 0 255     
+	  yellow    = 255 255 0     
+	  white     = 255 255 255   
+	  black     = 0 0 0         
+	  gray      = 128 128 128   
+	  grey      = gray          
+	  orange    = 255 165 0     
+	  pink      = 255 105 180   
+	  brown     = 139 69 19     
+	  default   = _    
+

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-services.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/editor-services.spx	Wed Aug  3 08:22:17 2011	(r23174)
@@ -0,0 +1,49 @@
+package languages.entitylang  
+
+module Outliner
+	outliner
+		// This module can be used for custom outliner rules.
+		//
+		// See the editorservices-generated.spx file for a brief introduction and examples.
+	 	Start.Module
+		Definition.Entity
+  
+module Colorer 
+	colorer 
+	// This module can be used for custom colorer rules.
+	//
+	// See the editorservices-generated.spx file for a brief introduction and examples.
+	colorer 
+		Type  : 66 92 217 bold
+		
+
+module Folding 
+	folding
+	// This module can be used for custom folding rules.
+	//
+	// See the imported file for a brief introduction and examples.
+
+
+module Common-Syntax
+	language
+	// This module can be used for custom syntax rules.                
+	//                                                               
+	// See the editorservices-generated.spx file for a brief introduction and examples.  
+                                                                   
+module Syntax-Completions
+	completions
+  // This module is used to define content completion.               
+  //                                                               
+  // See the editorservices-generated.spx file for a brief introduction and examples.
+	completions
+  // completion:                      
+	  completion template Start :
+	    "module " <m> (blank)  
+	                                             
+	  completion template Definition :
+	    "entity " <e> " {" (cursor) "}" (blank)  
+	                                             
+	  completion template Property : "prop" =
+	    <x> " : " <T> (blank)  
+	                                             
+  
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-adapters.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-adapters.spx	Wed Aug  3 08:22:17 2011	(r23174)
@@ -0,0 +1,73 @@
+package languages.entitylang 
+	
+// This module acts as a facade and specify transformation rules for different types
+// of editor services. See editor-services-generated for a brief introduction on the 
+// available editor services.
+module Entitylang-Adapters
+		                                                                                                           
+ 	builders
+		observer : editor-analyze         	                                                                          
+	  
+	  builder  : "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)
+	 	builder  : "Generate Java code (for selection)"   = generate-java (openeditor) (realtime)
+	 	builder  : "Pretty-printing (for selection)"      = prettyprint-entitylang(openeditor) (realtime)
+
+	// Content completion proposer and trigger is specified in the following section.
+	completions
+	  completion proposer                  : editor-complete
+	  completion trigger                   : ":"
+	
+	// Reference resolving and hover help
+	references
+	  reference _ : editor-resolve
+	  hover _     : editor-hover
+
+
+module Builders  
+	 	
+	rules 
+		// Transforms a selection to Java
+		generate-java:
+			(selected, position, ast, path, project-path) -> (filename, result)
+  		with
+	  		filename := <guarantee-extension(|"java")> path;
+    		result   := <to-java> selected
+ 		
+ 		// Prints the abstract syntax ATerm of a selection.
+		generate-aterm:
+			(selected, position, ast, path, project-path) -> (filename, result)
+			with
+  			filename := <guarantee-extension(|"aterm")> path;
+  			result   := selected // we just return the input term
+
+		// Prints the abstract syntax ATerm of a selection.
+		prettyprint-entitylang:
+			(selected, position, ast, path, project-path) -> (filename, result)
+			with
+  			filename := <guarantee-extension(|"pp.spo")> path;
+  			result   := <pp-entitylang>selected // we just return the input term
+
+module Reference-Resolver  
+	
+	rules
+		  // Resolves a reference when the user control-clicks or presses F3 in the editor.
+  	editor-resolve:
+	  	(node, position, ast, path, project-path) -> elem
+     	where 
+	  		<id> node => elem
+	    		 
+    // Returns "hover help" information for a particular node in the editor.
+	  // For references, this rule is invoked using the resolved term.
+	  editor-hover:
+	    (target, position, ast, path, project-path) -> $[Hover help: [<write-to-string> target]]
+		
+		
+	 
+
+module Code-Completion-Proposer
+
+rules
+	 // Completes an identifier when the user presses control-space
+	  // (the completion identifier in the AST provides additional context information)
+	  editor-complete:
+	    (node, position, ast, path, project-path) ->[]

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-definitions.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-definitions.spx	Wed Aug  3 08:22:17 2011	(r23174)
@@ -0,0 +1,157 @@
+package languages.entitylang     
+
+// Following module define the main langauge constructs for this language
+module Language-Constructs-Main
+	imports languages.entitylang.generated 
+	
+	context-free syntax    
+    "module" ID Definition*       	-> Start      {"Module"} 
+   	"entity" ID "{" Property* "}" 	-> Definition {"Entity"}
+    ID  ":" Type               			-> Property   {"Property"} 
+	
+	rules 
+		// Semantic analyses
+		// Reports an error if an entity is defined more than once.
+		// This constraint is implemented by testing if the "bag" of
+		// all entities x is not a singleton list.
+		constraint-error:
+		  Entity(x, _) -> (x, $[Duplicate entity name])
+		  where
+		    not(<bagof-GetEntity> x => [_])
+		
+		constraint-warning:
+		  Entity(x, _) -> (x, $[Entity names must start with a capital])
+		  where
+		    not(<string-starts-with-capital> x)
+	  
+	 	constraint-note:
+    	Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
+	                                      (this note is defined in trans/check.str) ])
+	 
+	rules
+		// generate java codes from entitylang
+		to-java: Module(x, d*) ->
+    $[ package [x];
+       
+       [d'*]
+     ]
+    with
+      d'* := <to-java> d*
+  
+  	to-java: Entity(x, p*) ->
+    $[ class [x] {
+           [p'*]
+       }
+     ]
+    with
+      p'* := <to-java> p*
+
+  	to-java: Property(x, type) -> $[
+      private [<to-java>type] [x];
+      
+      public [<to-java>type] get_[x] {
+          return [x];
+      }
+      
+      public void set_[x] ([<to-java>type] [x]) {
+          this.[x] = [x];    
+      }
+  	 ]     
+  	
+		to-java: t* -> <map(to-java)> t*
+		
+	rules
+		// pretty-printing to entity lang 
+		pp-entitylang: Module(x, d*) ->
+		$[ module [x]
+       [d'*]
+     ]
+    with
+      d'* := <pp-entitylang> d*
+  
+  	pp-entitylang: Entity(x, p*) ->
+    $[ entity [x] {
+           [p'*]
+       }
+     ]
+    with
+      p'* := <pp-entitylang> p*
+
+  	pp-entitylang: Property(x, type) -> 
+  	$[[x] : [<pp-entitylang>type] 
+     ]     
+  	
+  	pp-entitylang: t* -> <map(pp-entitylang)> t*
+		
+		
+// Following module defines the type system for  entitylang language				
+module Type-System
+	
+	context-free syntax
+		ID                              -> Type {"Type"}
+		"Int"														-> Type {"IntegerType", prefer}
+		"String"												-> Type {"StringType" , prefer}
+
+	rules 
+		// Semantic analysis of types
+		// Reports an error if a property type is undefined.
+	  // This error is reported on the type name 'type'.
+	  constraint-error:
+	    Type(type) -> (type, $[Type [type] is not defined])
+	    where
+	      not(<GetEntity> type) // no entity for this type 
+	
+	rules
+		// Transforming entitylang types to java types  
+		to-java: Type(t) -> t
+ 
+  	to-java: IntegerType() -> "int"
+    
+  	to-java: StringType() -> "string"  
+
+	rules
+		// Pretty-printing entitylang types 
+		pp-entitylang : Type(t) -> t
+		
+		pp-entitylang : IntegerType() -> "Int"
+    
+    pp-entitylang : StringType() -> "String"  
+
+	
+
+
+// Following module performs semantic analyses for entity-lang language
+module Semantic-Analyzer
+
+imports languages.entitylang.generated
+	
+	rules
+	  // Analysis: does a topdown traversal of the tree,
+	  // and tries to apply the record-entity rule.
+	  analyze:
+	    t -> t
+	    with
+	      <topdown(try(record-entity))> t
+	
+	  // Records the definition of an entity in a dynamic rule GetEntity.
+	  record-entity:
+	    Entity(x, body) -> Entity(x, body)
+	    with
+	      // For a name 'x', GetEntity will return the original 'x' tree node
+	      rules(
+	        GetEntity :+ x -> x 
+	      )
+ 	
+	rules 
+		// Analyzes the current program, returning a tuple with errors, warnings, and notes;
+		// each a list of (term, message) tuples or simply (message) terms.
+		editor-analyze:
+		  (ast, path, project-path) -> (ast, errors, warnings, notes)
+		  with
+		    editor-init;
+		    analyze;
+		    errors   := <collect-all(constraint-error, conc)> ast;
+		    warnings := <collect-all(constraint-warning, conc)> ast;
+		    notes    := <collect-all(constraint-note, conc)> ast	
+			 
+	                                      

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-descriptors.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-descriptors.spx	Wed Aug  3 08:22:17 2011	(r23174)
@@ -0,0 +1,18 @@
+package languages.entitylang 
+	  
+module Entitylang-Descriptor
+	imports languages.entitylang.generated 
+	language General properties 
+                  
+	  name          : entitylang
+	  id            : SpoofaxEntityLanguage
+	  extends       : Root
+	                  
+	  description   : "Spoofax/IMP-generated editor for the Test language"
+	  url           : http://strategoxt.org
+	                  
+	  extensions    : spo 
+	  start symbols : Start   
+     
+
+	

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-lexicalconstructs.spx
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test/entitylang-lexicalconstructs.spx	Wed Aug  3 08:22:17 2011	(r23174)
@@ -0,0 +1,67 @@
+package languages.entitylang 
+	
+
+module Identifier
+		lexical syntax
+	  	[a-zA-Z][a-zA-Z0-9]* -> ID
+		
+	
+module Literals
+		lexical syntax 
+			"-"? [0-9]+          -> INT
+	    
+	    "\"" StringChar* "\"" -> STRING
+	    ~[\"\n]               -> StringChar 
+	    "\\\""                -> StringChar
+	    
+	    BackSlashChar         -> StringChar
+	    "\\"                  -> BackSlashChar 
+	    
+		lexical restrictions 
+  
+	    //Ensure greedy matching for lexicals
+	  
+	    CommentChar   -/- [\/]
+	    INT           -/- [0-9]
+	    ID            -/- [a-zA-Z0-9\_]
+	    
+			//Backslash chars in strings may not be followed by " 
+	    
+	    BackSlashChar -/- [\"]
+		
+module Keywords
+	
+	lexical syntax 
+ 		"int"					  			-> RESERVED
+ 		"string"			  			-> RESERVED
+ 		 RESERVED 						-> ID{reject}
+
+	lexical restrictions
+		 //Ensure greedy matching for lexicals
+		"int" 
+		"string"  -/- [A-Za-z0-9\_]
+	    
+	
+module Layout
+    lexical syntax
+	    [\ \t\n\r] -> LAYOUT
+	    
+	    [\*]                             -> CommentChar
+	    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
+	    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT   
+	    
+	    -> EOF
+	  
+	 lexical restrictions 
+      //Ensure greedy matching for lexicals
+	    //EOF may not be followed by any char
+	
+	    EOF           -/- ~[]
+	
+	 context-free restrictions 
+  
+  		  //Ensure greedy matching for comments
+
+		    LAYOUT? -/- [\ \t\n\r]
+		    LAYOUT? -/- [\/].[\/]
+		    LAYOUT? -/- [\/].[\*]
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Wed Aug  3 10:23:55 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 03 Aug 2011 08:23:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23175 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test-lang
Message-ID: <20110803082355.7EF577F801F@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug  3 08:23:55 2011
New Revision: 23175
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23175&sc=1

Log:


Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/test-lang/

From M.A.Akhter at student.tudelft.nl  Wed Aug  3 10:24:17 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 03 Aug 2011 08:24:17 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23176 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax
Message-ID: <20110803082417.55CB1CC18B@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug  3 08:24:17 2011
New Revision: 23176
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23176&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Wed Aug  3 08:23:55 2011	(r23175)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Wed Aug  3 08:24:17 2011	(r23176)
@@ -1,6 +1,6 @@
 Configuration
 	Includes
-		AllDirectories Test
+		AllDirectories test
 			
 	CodeGeneration 
 		OutputDirectory		.shadowdir  

From m.dejonge at tudelft.nl  Wed Aug  3 10:38:31 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 03 Aug 2011 08:38:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23177 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110803083831.7C2572B8002@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  3 08:38:31 2011
New Revision: 23177
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23177&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Wed Aug  3 08:24:17 2011	(r23176)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Wed Aug  3 08:38:31 2011	(r23177)
@@ -104,7 +104,7 @@
   check-builder-expectation(|result) :
     Fragment(_{^[ast | _]}) -> $[Unexpected output: [result']]
     where
-      not(<eq> (ast, result) <+ <equal-in-desugared-form> (ast, result)) //TODO compare-ast
+      not(<eq> (ast, result) <+ <equal-in-desugared-form> (ast, result)) 
     with
       result' := <spt-pp-string> result
     <+
@@ -115,7 +115,7 @@
   	where
       input-observer := (ast, <InputFile>, <project-path>);
       ast-desugared := <plugin-strategy-invoke(|<Language>, <spt-get-observer>); try(?Some(<Fst>))> input-observer;
-      <compare-desugared-asts> (ast-desugared, result) //TODO compare-ast with sugar aware diff function
+      <compare-desugared-asts> (ast-desugared, result) 
   		
   check-builder-expectation(|result) :
     ATerm(p) -> $[Unexpected output: [<write-to-string> result]]

From m.dejonge at tudelft.nl  Wed Aug  3 11:57:38 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 03 Aug 2011 09:57:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23178 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110803095738.8D5717F827C@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  3 09:57:37 2011
New Revision: 23178
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23178&sc=1

Log:
bugfix: running testcases on desugared ast

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str	Wed Aug  3 08:38:31 2011	(r23177)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str	Wed Aug  3 09:57:37 2011	(r23178)
@@ -44,8 +44,10 @@
   run-testsuite :
     file -> (ast, [])
     where 
-      ast  := <parse-spt-file> file 
-    ; testcases := <collect-all(testview-add-testcase(|file, <test-to-description>,<origin-offset>))>ast
+      ast  := <parse-spt-file> file
+    ; editor-init
+    ; ast' := <topdown(repeat(spt-desugar)); alltd(spt-desugar-refactoring-conditions)> ast 
+    ; testcases := <collect-all(testview-add-testcase(|file, <test-to-description>,<origin-offset>))>ast'
     ; <map(run-testcase(|file))>testcases
   
   parse-spt-file = 

From m.dejonge at tudelft.nl  Wed Aug  3 12:02:06 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 03 Aug 2011 10:02:06 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23179 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego:
	lib-refactoring test-refactorings trans trans/refactoring
	trans/refactoring/helpers
Message-ID: <20110803100206.EC3ED2B8002@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  3 10:02:06 2011
New Revision: 23179
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23179&sc=1

Log:
bugfix: name analysis Scope
testcases: rename (transformation)
implementation

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-advanced.spt
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-simple.spt
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/extract.str
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/format.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/builders.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/inline.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/remove-debug.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/rename.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/fetch.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -6,6 +6,19 @@
 rules //strategies for fetching terms in the ast
 
 /**
+ * fetches the AST position by visiting the ancestors 
+ * of a term, bottum up, starting at a certain position.
+ * @param matches ancestor term to be fetched
+ * @param AST
+ * @type List(Int)) ->  List(Int)
+ */ 
+fetch-up-position(match|ast):
+  position -> position'
+  where
+  	term := <term-at-position(|position)> ast;
+  	(term', position') := <fetch-up-with-position(match|ast)> (term, position)
+  	  
+/**
  * fetches an ancestor and its AST position by visiting the ancestors of a term, bottum up
  * @param matches ancestor term to be fetched
  * @param AST

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/lib-refactoring/namebinding-preservation.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -8,14 +8,14 @@
  * @example input:
  * ast-t := <annotate; transform> ast
  * ast-t-reanalyzed := <annotate; transform; re-annotate> ast
- * is-name = ?oldname <+ ?newname
+ * get-refname = ?oldname <+ ?newname
  * @param matches endangered names
  * @type (Term, Term) -> List((Term, String)) 
  */
-namebinding-error-messages(is-name):
+namebinding-error-messages(get-refname):
   (ast-t, ast-t-reanalyzed) -> violation-messages
   where
-    violations := <collect-binding-violations(is-name)> (ast-t, ast-t-reanalyzed);
+    violations := <collect-binding-violations(get-refname)> (ast-t, ast-t-reanalyzed);
     violation-messages := <map(mk-binding-violation-message)> violations
 
 /**
@@ -24,15 +24,15 @@
  * @example input:
  * ast-t := <annotate; transform> ast
  * ast-t-reanalyzed := <annotate; transform; re-annotate> ast
- * is-name = ?oldname <+ ?newname
+ * get-refname = ?oldname <+ ?newname
  * @param matches endangered names
  * @type (Term, Term) -> List((Term, Term)) 
  */
-collect-binding-violations(is-name):
+collect-binding-violations(get-refname):
   (ast-t, ast-t-reanalyzed) -> violations
   where
-    old-names  := <collect-all(where(is-name), conc)> ast-t; 
-    new-names  := <collect-all(where(is-name), conc)> ast-t-reanalyzed;
+    old-names  := <collect-all(get-refname, conc)> ast-t; 
+    new-names  := <collect-all(get-refname, conc)> ast-t-reanalyzed;
     violations := <zip; binding-violations> (old-names, new-names)
   
 binding-violations: 
@@ -52,7 +52,7 @@
 
 is-binding-violation(|x,y):
   (old-refname, new-refname) -> (old-refname, new-refname)
-  where
+  where 
     <(?(_,y) <+ ?(x,_)); not(?(x,y))> (old-refname, new-refname)
 
 mk-binding-violation-message:

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-advanced.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-advanced.spt	Wed Aug  3 10:02:06 2011	(r23179)
@@ -0,0 +1,113 @@
+module test-rename-advanced
+ 
+language Stratego-Sugar
+
+/**
+ * Advanced rename testcases: dynamic rules, lambda rules, scoped rules 
+ * errors do not occur
+ */
+setup [[
+  module test-rename-advanced
+  rules
+]]
+
+test Rename S-Rule
+  [[ 
+      bar(|x) = map((([[x]],y,z) -> (x,y))) 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      bar(|foo) = map(((foo,y,z) -> (foo,y))) 
+  ]]
+
+test Rename Scoped Rule (1)
+  [[ 
+      bar(|x) = map({[[x]]: ((x,y,z) -> (x,y))}) 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      bar(|x) = map({foo: ((foo,y,z) -> (foo,y))}) 
+  ]]
+
+test Rename Scoped Rule (2)
+  [[ 
+      bar(|x) = map({y: (([[x]],y,z) -> (x,y))}) 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      bar(|foo) = map({y: ((foo,y,z) -> (foo,y))}) 
+  ]]
+
+test Rename Lambda-Rule (1)
+  [[ 
+      bar(|x) = map(\(x,y,z) -> ([[x]],y)\) 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      bar(|x) = map(\(foo,y,z) -> (foo,y)\) 
+  ]]
+
+test Rename Lambda-Rule (2)
+  [[ 
+      bar(|x) = map(\([[x]],y,z) -> (x,y)\) 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      bar(|x) = map(\(foo,y,z) -> (foo,y)\) 
+  ]]
+
+test Rename Dynamic-Rule
+  [[ 
+  	rename: x -> x{<[[Declare]]> x}
+  	declare-name = 
+  	  ?(name, ref);
+      rules(Declare: name -> ref)
+  ]] refactor rename-refactoring("Rename") to 
+  [[
+  	rename: x -> x{<Rename> x}
+  	declare-name = 
+  	  ?(name, ref);
+      rules(Rename: name -> ref)
+  ]]
+
+test Rename Dynamic-Rule Scope
+  [[ 
+  	rename: x -> x{<[[Declare]]> x}
+  	declare-name = 
+  	  ?(name, ref);
+  	  {|Declare:
+         rules(Declare: name -> ref)
+      |}
+  ]] refactor rename-refactoring("Rename") to 
+  [[
+  	rename: x -> x{<Rename> x}
+  	declare-name = 
+  	  ?(name, ref);
+  	  {|Rename:
+        rules(Rename: name -> ref)
+      |}
+  ]]
+
+test Rename Dynamic-Rule Bagof (1)
+  [[ 
+  	rename: x -> x{<bagof-Declare> x}
+  	declare-name = 
+  	  ?(name, ref);
+      rules([[Declare]]: name -> ref)
+  ]] refactor rename-refactoring("Rename") to 
+  [[
+  	rename: x -> x{<bagof-Rename> x}
+  	declare-name = 
+  	  ?(name, ref);
+      rules(Rename: name -> ref)
+  ]]
+
+test Rename Dynamic-Rule Bagof (2)
+  [[ 
+  	rename: x -> x{<[[bagof-Declare]]> x}
+  	declare-name = 
+  	  ?(name, ref);
+      rules(Declare: name -> ref)
+  ]] refactor rename-refactoring("Rename") to 
+  [[
+  	rename: x -> x{<bagof-Rename> x}
+  	declare-name = 
+  	  ?(name, ref);
+      rules(Rename: name -> ref)
+  ]]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-simple.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-simple.spt	Wed Aug  3 10:02:06 2011	(r23179)
@@ -0,0 +1,125 @@
+module test-rename-simple
+ 
+language Stratego-Sugar
+
+/**
+ * Basic rename testcases: basic constructs, errors do not occur
+ */
+setup [[
+  module test-rename-simple
+  rules
+]]
+
+test Rename Term-Variabele
+  [[ 
+      bar(|[[t]]) =  <id> t 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      bar(|foo) = <id> foo
+  ]]
+
+test Rename Local-Declared-Variabele
+  [[ 
+      r: (x,y) -> z
+      where 
+      	[[z]] := <subt> (x,y) 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      r: (x,y) -> foo
+      where 
+      	foo := <subt> (x,y) 
+  ]]
+
+test Rename Strategy-Variabele
+  [[ 
+      bar([[s]]) =  id; s 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+      bar(foo) = id ; foo
+  ]]
+
+test Rename Call-To-Strategy-Variabele 
+  [[ 
+  	  s = fail
+      bar(s) =  id; [[s]] 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+  	  s = fail
+      bar(foo) = id ; foo
+  ]]
+
+test Rename Call-To-Strategy-Variabele-Multi-Args 
+  [[ 
+  	  s(s1|t1,t2) = fail
+      bar([[s]]) =  id; s(id|"x", "y") 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+  	  s(s1|t1,t2) = fail
+      bar(foo) = id ; foo(id|"x", "y")
+  ]]
+  
+test Rename Global Strategy 
+  [[ 
+  	  aaa = bar("aaa")
+  	  bar(x): a -> a
+      [[bar]](s) =  id; s 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+  	  aaa = foo("aaa")
+  	  foo(x): a -> a
+      foo(s) = id ; s
+  ]]
+
+test Rename Let (1)
+  [[ 
+  	  bbb(s|n) = <s> n
+      aaa(s) =
+        let [[apply]](|i) = <s> (i, <id>)
+          in bbb(apply | 1)
+        end
+  ]] refactor rename-refactoring("foo") to 
+  [[
+  	  bbb(s|n) = <s> n
+      aaa(s) =
+        let foo(|i) = <s> (i, <id>)
+          in bbb(foo | 1)
+        end
+  ]]
+
+test Rename Let (2)
+  [[ 
+  	  bbb(s|n) = <s> n
+      aaa(s) =
+        let apply(|i) = <s> (i, <id>)
+          in [[bbb]](apply | 1)
+        end
+  ]] refactor rename-refactoring("foo") to 
+  [[
+  	  foo(s|n) = <s> n
+      aaa(s) =
+        let apply(|i) = <s> (i, <id>)
+          in foo(apply | 1)
+        end
+  ]]
+
+test Rename Recursion
+  [[ 
+    mapp(s) = rec [[x]]([] + [s | x])
+  ]] refactor rename-refactoring("foo") to 
+  [[
+    mapp(s) = rec foo([] + [s | foo])
+  ]]
+
+    
+test Rename Signature refactoring 
+  [[ 
+      r : [[Bar]](x,y) -> Bar(y,x) 
+      signature constructors
+        Bar : Id * Id -> Bar
+  ]] refactor rename-refactoring("Foo") to 
+  [[
+      r : [[Foo]](x,y) -> Foo(y,x) 
+      signature constructors
+        Foo : Id * Id -> Bar
+  ]]
+

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/analysis.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -367,14 +367,14 @@
   declare-bodies:
     ScopeDefault(s) -> ScopeDefault(s')
     with
-      s' := <scope-variables(declare-bodies-top | <tvars>)> s
+      (_, s') := <scope-variables(declare-bodies-top)> (<tvars>, s)
 
   declare-bodies:
-    Scope(v*, s) -> Scope(v*, s')
+    Scope(v*, s) -> Scope(v', s')
     with
-      s' := <scope-variables(declare-bodies-top | v*)> s
+      (v', s') := <scope-variables(declare-bodies-top)> (v*, s)
       
-  scope-variables(s | vars): x -> x'
+  scope-variables(s): (vars, x) -> (vars', x')
     with
       // Temporarely undeclare vars for redeclaration errors
       {| OuterCookie:
@@ -384,6 +384,7 @@
           try({cookie: DeclareCookie; ?cookie; rules(OuterCookie : sig -> cookie)});
           rules(DeclareCookie :- sig)})> vars;
         x' := <declare-bodies-top> x;
+        vars' := <map(!Var(<id>); try(declare-bodies); ?Var(<id>))> vars; 
         // Re-declare
         all-keys-OuterCookie; map({cookie: \key -> <OuterCookie; ?cookie; rules(DeclareCookie : key -> cookie)> \})
       |}

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/extract.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/extract.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -0,0 +1,158 @@
+module refactoring/extract
+
+imports
+  libstrc
+  lib-refactoring/namebinding-preservation
+  analysis
+  lib/editor-common.generated
+  lib-refactoring/fetch
+
+//TODO Scope
+//TODO Binding, check vars in parent sdef
+//TODO testset: succeed for correct cases, fails for incorrect, maybe: "do not know" otherwise 
+
+rules //extract refactoring
+
+extract-refactoring :
+  (str-name, selected, position, ast, path, project-path) -> (ast-changes, fatal-errors, errors, warnings)
+  where 
+         (sdeft, callt) := <mk-defs-for-extraction> (str-name, selected); debug(!"Defs: ")
+        ; ast' := <extract(?SDefT(_, _, _, _)|position, callt, sdeft)> ast //TODO insert sdef, TODO origin-tracking at-position in refactoring lib
+        ; ast-changes := [(ast, ast')]
+        ; fatal-errors := []
+        ; warnings := <collect-all(precondition-warning(pp-stratego-string))> sdeft
+        ; errors := []
+
+rules //preconditions
+
+precondition-warning(pp):
+	trm -> (outside-subtrm, $[selection extended to: [<pp> trm]])
+	where
+		outside-subtrm := <origin-term; not(in-selected-fragment)> trm
+	 
+
+rules
+	
+mk-defs-for-extraction =
+  mk-defs-for-selection-in-chain <+
+  mk-defs-for-selection
+	
+mk-defs-for-selection-in-chain:
+	(str-name, selected) -> (sdeft, c#([callt, tail-child]))
+	where
+		c#([selected', tail-child]) := <reorder-associativity-chain> selected;
+		(sdeft, callt) := <mk-defs-for-selection> (str-name, selected')
+
+mk-defs-for-selection:
+	(str-name, selected) -> (sdeft, callt)
+	where
+          sdeft-temp := SDefT(str-name, [], [], selected)
+        ; debug(!"1: ")
+        ; sdeft-reanalyzed := <topdown(strip-annos) ; declare-bodies> SDefT(str-name, [], [], selected)
+        ; debug(!"2: ")
+        ; svaruses := <collect-all(is-unbound-svar)> sdeft-reanalyzed
+        ; debug(!"3: ")
+        ; svardecs := <map(svaruse-to-svardec)> svaruses
+        ; debug(!"4: ")
+        ; tvaruses := <collect-all(is-unbound-tvar)> sdeft-reanalyzed
+        ; debug(!"6: ")
+        ; tvardecs := <map(tvaruse-to-tvardec)> tvaruses
+        ; debug(!"7: ")
+        ; sdeft := SDefT(str-name, svardecs, tvardecs, selected)
+        ; debug(!"8: ")
+        ; callt := CallT(SVar(str-name), svaruses, tvaruses)
+        ; debug(!"9: ")
+
+rules //transformation
+	
+extract(match|position-caller, caller, callee):
+	ast -> ast'
+	where
+		position' := <fetch-up-position(match|ast)> position-caller;
+        ast' := <
+        	insert-at-position(|<at-last(elem-as-list(inc))> position', callee);
+        	at-position(!caller|position-caller)
+        > ast //TODO insert sdef, TODO origin-tracking at-position in refactoring lib
+
+elem-as-list(s) =
+	?[<id>]; s; ![<id>]
+
+insert-at-position(|position, elems):
+	ast -> ast'
+	where
+		list-position := <init> position;
+		elem-position := <last> position; 
+		ast' := <at-position(insert-at-index(|elem-position, elems)|list-position)> ast
+
+insert-at-index(|index, elem):
+	lst -> <insert-at-index(|index, [elem])> lst
+	where
+		<not(is-list)> elem
+	
+insert-at-index(|index, elems):
+	lst -> lst'
+	where
+		(prefix, suffix) := <split-at(|index)> lst;
+		lst' := <concat> [prefix, elems, suffix]
+
+rules //helpers reordering associative chains
+	
+in-selected-fragment = id //prim("SSL_EXT_in_selected_fragment", <id>)
+origin-non-layout-tokens = ![] //prim("SSL_EXT_origin_non_layout_tokens", <id>)
+
+reorder-associativity-chain =
+  origin-track-forced(reorder-right-associativity-chain) //TODO left-chain
+  
+reorder-right-associativity-chain:
+  chain at cons#([l,r]) -> cons#([selected, tail-child])
+  where
+  	selected := <break-right-associativity-chain(|cons)> chain;
+  	tail-child := <broken-child-in-right-associativity-chain(|cons)> chain;
+  	<check-brackets-tail-term> (chain, tail-child) 
+
+/*Hack: fails for wrong selections like [[a + (b + c]] + d) */
+check-brackets-tail-term:
+  (trm,rhs) -> trm
+  where
+    parent-tokens-rev := <origin-non-layout-tokens; reverse> trm; 
+    rhs-tokens-rev := <origin-non-layout-tokens; reverse> rhs;
+    rhs-tokens-rev-brackets := <flatten-list ; reverse> ["(", <origin-non-layout-tokens> rhs, ")"] 
+  where
+    <equal>(<common-prefix> (rhs-tokens-rev, parent-tokens-rev), rhs-tokens-rev) <+
+    <equal>(<common-prefix> (rhs-tokens-rev-brackets, parent-tokens-rev), rhs-tokens-rev-brackets)
+    
+
+break-right-associativity-chain(|cons):
+  cons#([l,rhs at cons#([m,r])]) -> cons#([l, <break-right-associativity-chain(|cons)> rhs])
+  where
+  	<in-selected-fragment> r 
+
+break-right-associativity-chain(|cons):
+  cons#([l,rhs at cons#([m,r])]) -> cons#([l,m])
+  where
+  	<not(in-selected-fragment)> r 
+  	
+broken-child-in-right-associativity-chain(|cons):
+  cons#([l,rhs at cons#([m,r])]) -> <broken-child-in-right-associativity-chain(|cons)> rhs
+  where
+  	<in-selected-fragment> r 
+
+broken-child-in-right-associativity-chain(|cons):
+  cons#([l,rhs at cons#([m,r])]) -> r
+  where
+  	<not(in-selected-fragment)> r 
+  	
+rules //helpers variabele substitution
+
+is-unbound-svar = 
+	where(?CallT(SVar(<id>), _, _); not(has-annos))
+
+is-unbound-tvar = 
+	where(?Var(<id>); not(has-annos))
+	
+svaruse-to-svardec:
+  CallT(SVar(name), _, _) -> VarDec(name, ConstType(SortNoArgs("ATerm")))
+
+tvaruse-to-tvardec:
+  Var(name) -> VarDec(name, ConstType(SortNoArgs("ATerm")))
+

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/format.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/format.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/format.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -3,7 +3,7 @@
 imports
   libstrc
 
-rules //remove debug refactoring
+rules //pretty-prints selected fragment (loosing comments)
 
 format-refactoring:
   (_, selected, position, ast, path, project-path) -> 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/builders.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/builders.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -3,30 +3,41 @@
 imports
   refactoring/rename
   refactoring/inline
+  refactoring/extract
   refactoring/remove-debug
   lib-refactoring/fetch
   //lib-reconstruction/construct-text
   libstratego-gpp
   //lib-reconstruction/stratego-parenthesize
   libstrc
+  include/Stratego-Sugar-parenthesize
 
 rules 
 
+//surround-with (preserve-annos, ...)
+
 rename-builder:
-  (selected, position, ast, path, project-path) -> ("x.str", result)
+  (selected, position, ast, path, project-path) -> ("x.aterm", result)
   where 
   	<oncetd(oldname := <is-string; has-annos>)> selected;
     refactoring-result := <rename-refactoring> ("NEWNAME", oldname, position, ast, path, project-path);
     result := <process-refactoring-result> refactoring-result
 
 inline-builder:
-  (selected, position, ast, path, project-path) -> ("x.str", result)
+  (selected, position, ast, path, project-path) -> ("x.aterm", result)
   where
     refactoring-result := <inline-refactoring> (None(), selected, position, ast, path, project-path);
     result := <process-refactoring-result> refactoring-result
 
+extract-builder:
+  (selected, position, ast, path, project-path) -> ("x.aterm", result)
+  where
+    refactoring-result := <extract-refactoring> ("MyStrategy", selected, position, ast, path, project-path);
+    result := <process-refactoring-result> refactoring-result
+
+
 remove-debug-builder:
-  (selected, position, ast, path, project-path) -> ("x.str", result)
+  (selected, position, ast, path, project-path) -> ("x.aterm", result)
   where
     refactoring-result := <remove-debug-refactoring> (None(), selected, position, ast, path, project-path);
     result := <process-refactoring-result> refactoring-result
@@ -36,8 +47,8 @@
   where
     result := <
     	Hd;
-    	Snd; debug; 
-    	pp-stratego-string
+    	Snd; debug
+    	//pp-stratego-string
     	//map(!(<Fst>, <Snd; parenthesize-Stratego>)); 
     	//construct-textual-change(pp-stratego-string); 
     	//Hd; 
@@ -59,3 +70,9 @@
   (selected, position, ast, path, project-path) -> ("x.str", result)
   where 
     result := <debug(!"pp: "); pp-stratego-string> selected
+
+test-builder:
+  (selected, position, ast, path, project-path) -> ("x.str", result)
+  where 
+    //result := <debug(!"pp: "); parenthesize-Stratego-Sugar> selected
+    result := <reorder-right-associativity-chain> selected 
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/inline.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/inline.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/inline.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -8,7 +8,7 @@
 inline-refactoring:
   (_, selected, position, ast, path, project-path) -> 
   (ast-changes, fatal-errors, [], warnings)
-    where
+    where //TODO: multi-file
       declaration := <?(<?SDefT(_, _, _, _)>, _) <+ declaration-of-call> (selected, ast);
       warnings := <warnings-multiple-declarations> (declaration, ast);
       fatal-errors := <errors-recursion> declaration;
@@ -17,12 +17,18 @@
       else
         ast-changes := []
     end
-    
+ 
+
+rules //resolve declaration 
+	
 declaration-of-call:
   (CallT(SVar(name{ref}), _, _), ast) -> declaration
   where
     <oncetd(declaration := <?SDefT(name{ref}, _, _, _)>)> ast
 
+
+rules //precondition errors, warnings
+
 errors-recursion:
   decl at SDefT(name{ref}, _, _, _) -> errors
   where
@@ -42,17 +48,21 @@
   where
     all-defs := <collect-all(?SDefT(name{ref}, _, _, _))> ast;
     if <?[_,_|_]> all-defs then
-      warnings := <map(!(<id>, "multiple declarations found"))> all-defs
+      warnings := 
+      	<map(!(<id>, "multiple declarations found, refactoring may change behaviour by introducing determinism"))> all-defs
     else
       warnings := []
     end
-    
+
+
+rules //transformation
+	
 inline:
   (decl at SDefT(name{ref}, _, _, _), ast) -> ast-inlined
   where
     ast-inlined := <
       topdown(try(inline-call(|decl)));
-      delete-elements(?decl)
+      delete-elements(?decl) //TODO: remove all declarations, make clear in error message?
     > ast 
   
 inline-call(|decl):
@@ -68,6 +78,12 @@
       scope-free-vars
     > body
 
+
+rules //helpers scoping
+	
+rule-to-lambda-rule:
+  rule at Rule(_, _, _) -> LRule(rule)
+
 scope-free-vars =
   try(!Scope(<collect-vars; not(?[])>, <id>))
   //TODO: warning, programmar may not be happy with the result?
@@ -82,15 +98,24 @@
 collect-vars-scope:
 	Scope(scoped-vars, body) -> <diff>(<collect-vars> body, scoped-vars)
 
-rule-to-lambda-rule:
-  rule at Rule(_, _, _) -> LRule(rule)
+collect-vars-scope: //TODO: resugar rule for pretty-printing?
+    LRule(rule at Rule(lhs, _, _)) -> <diff>(<collect-vars> rule, lhs-vars)
+    where 
+    	lhs-vars := <collect-all(?Var(<id>))> lhs 
+
 
+rules //helpers variabele substitution
+	
 svardec-to-svaruse:
   VarDec(name{ref}, _) -> CallT(SVar(name{ref}), [], [])
 
 tvardec-to-tvaruse:
   VarDec(name{ref}, _) -> Var(name{ref})
 
+
+rules //helpers variabele substitution, generic 
+
+//TODO: more efficient one-pass implementation
 substitute-multiple(|vars, values):
   body -> new-body
   where
@@ -112,6 +137,9 @@
   where
     new-body := <topdown(try(?var; !value))> body
 
+
+rules //helper transformation, generic
+	
 delete-elements(is-deletion-elem):
   ast -> ast-t
   where

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/remove-debug.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/remove-debug.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/remove-debug.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -5,6 +5,8 @@
 
 rules //remove debug refactoring
 
+//TODO: optional: replace <debug> x by !x or not(fail)
+//TODO: optional: in workspace/ in file/ in selection, only visable if selection empty?
 remove-debug-refactoring:
   (_, selected, position, ast, path, project-path) -> 
   (ast-changes, [], <conc> (pre-condition-errors, semantic-errors), warnings)
@@ -35,6 +37,22 @@
 remove-debug:
   GuardedLChoice(s1, s2, <debug-call>) -> GuardedLChoice(s1, s2, Id())
 
+remove-debug:
+  Rule(lhs, App(<debug-call>, rhs), conds) -> Rule(lhs, rhs, conds)
+
+remove-debug:
+  Rule(lhs, rhs, <debug-call>) -> Rule(lhs, rhs, [])
+
+remove-debug:
+  Rule(lhs, rhs, conds) -> Rule(lhs, rhs, conds')
+  where
+  	conds' := <filter(not(is-debug-clause))> conds
+  	
+is-debug-clause =
+  where(
+    ?WhereClause(<debug-call>) <+
+    ?WithClause(<debug-call>)
+  )
 
 //TODO: support some common patterns
 //<debug> term ... result not used ???
@@ -48,7 +66,17 @@
   where(?Where(BA(<debug-call>, NoAnnoList(_))))
 
 debug-call =
+  where(?With(BA(<debug-call>, Var(_))))
+
+debug-call =
+  where(?With(BA(<debug-call>, NoAnnoList(_))))
+
+debug-call =
   ?CallT(SVar("debug"{_}), _, [])
 
 debug-call =
-  ?Where(CallT(SVar("debug"{_}), _, []))
\ No newline at end of file
+  ?Where(CallT(SVar("debug"{_}), _, []))
+  
+debug-call =
+  ?With(CallT(SVar("debug"{_}), _, []))
+  

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/rename.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/rename.str	Wed Aug  3 09:57:37 2011	(r23178)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/rename.str	Wed Aug  3 10:02:06 2011	(r23179)
@@ -16,7 +16,11 @@
   (ast-changes, [], <make-set> errors, <make-set> warnings)
   where 
     renamings := <get-dependend-renamings> (name{ref}, newname);
-    (asts, parse-errors) := <get-asts-affected-by-renaming>(ref, renamings, ast-analyzed);
+    if <not(has-extension(|"spt"))> path then
+      (asts, parse-errors) := <get-asts-affected-by-renaming>(ref, renamings, ast-analyzed)
+    else //testing language
+      (asts, parse-errors) := ([ast-analyzed], [])
+    end;
     (ast-changes, semantic-errors, warnings) := <apply-rename-refactoring(
       re-analyse-names, 
       collect-semantic-issues |
@@ -91,4 +95,4 @@
 
 is-editable = 
   not(string-ends-with(|".generated.str"));
-  not(dirname; string-ends-with(|"include"))
+  not(dirname; string-ends-with(|"include"))
\ No newline at end of file

From m.dejonge at tudelft.nl  Wed Aug  3 13:08:34 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 03 Aug 2011 11:08:34 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23180 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego
Message-ID: <20110803110834.E904C2B800A@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  3 11:08:34 2011
New Revision: 23180
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23180&sc=1

Log:
parenthesize

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml	Wed Aug  3 10:02:06 2011	(r23179)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/build.generated.xml	Wed Aug  3 11:08:34 2011	(r23180)
@@ -7,7 +7,7 @@
         <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.jar.helper,sdf2imp,refresh"/>
     
         <!-- Initialization -->
-        <available file="${build}/org/strategoxt/imp/editors/stratego/strategies/Main.class" property="java.jar.enabled"/>
+        <available file="${src-gen}/org/strategoxt/imp/editors/stratego/strategies/Main.java" property="java.jar.enabled"/>
         <condition property="java.jar.import" value="-la org.strategoxt.imp.editors.stratego.strategies" else="">
             <isset property="java.jar.enabled"/>
         </condition>
@@ -19,9 +19,12 @@
         <condition property="externaldefimport" value="-I &quot;${externaldefdir}&quot;" else="">
             <isset property="externaldef"/>
         </condition>
-        <condition property="externaljarimport" value=":${externaljar}" else="">
+        <condition property="externaljarimport1" value=":${externaljar}" else="">
             <isset property="externaljar"/>
         </condition>
+        <condition property="externaljarimport2" value=":${externaljarx}" else="">
+            <isset property="externaljarx"/>
+        </condition>
         <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
             <isset property="eclipse.running"/>
         </condition>
@@ -43,7 +46,7 @@
         <mkdir dir="${lib}"/>
         <mkdir dir="${syntax}"/>
 
-        <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone"/>
+        <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone,sdf2parenthesize"/>
         
         <target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">
             <java classname="org.strategoxt.imp.metatooling.building.AntDescriptorBuilder" failonerror="true">
@@ -247,6 +250,37 @@
             </java>
         </target>
         
+        <target name="sdf2parenthesize" depends="pack-sdf,copy-sdf">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${include}/${sdfmodule}-parenthesize.str"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}-parenthesize.str" property="sdf2parenthesize.available"/>
+            <antcall target="sdf2parenthesize.helper"/>
+        </target>
+
+        <target name="sdf2parenthesize.helper" unless="sdf2parenthesize.available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-sdf2parenthesize"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-m"/>
+                <arg value="${sdfmodule}"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}-parenthesize.str"/>
+                <arg value="--omod"/>
+                <arg value="include/${sdfmodule}-parenthesize"/>
+                <arg value="--main-strategy"/>
+                <arg value="io-${sdfmodule}-parenthesize"/>
+                <arg value="--lang"/>
+                <arg value="${sdfmodule}"/>
+                <arg value="--rule-prefix"/>
+                <arg value="${sdfmodule}"/>
+                <arg value="--sig-module"/>
+                <arg value="include/${sdfmodule}"/>
+            </java>
+        </target>
+        
         <target name="ppgen" if="build.stratego.enabled" depends="pack-sdf">
             <dependset>
                 <srcfileset file="${include}/${sdfmodule}.def"/>
@@ -378,7 +412,7 @@
                 <param name="build.stratego.outputfile" value="${src-gen}/trans/Main.java"/>
                 <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
             </antcall>
-            <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
+            <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
             <!-- copy imported terms -->
             <copy todir="${build}/trans">
                 <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
@@ -418,145 +452,145 @@
                 
         <!-- begin: targets used for adding debugging instrumentation to stratego -->
         
-		<!-- 
-			if "debug.the.debug.transformer" is set, debug the debug instrumentation, do not output rtree-files, but str-files
-			Only used by stratego.jvm.helper.debug 
-		-->
-		<condition property="transformer-output" value="" else="--output-rtree">
-			<isset property="debug.the.debug.transformer"/>
-		</condition>
-		
-		<!-- 
-			if debug.the.debug.transformer is set then the debug.transformer outputs str files, so the strj-compiler should accept a str-file.
-			if debug.the.debug.transformer is NOT set then the debug.transformer outputs rtree files (much faster generated), so the strj-compiler should accept a rtree-file
-			Only used by stratego.jvm.helper.debug
-		-->
-		<condition property="strj.input.file.type" value="str" else="rtree">
-			<isset property="debug.the.debug.transformer"/>
-		</condition>
+        <!-- 
+            if "debug.the.debug.transformer" is set, debug the debug instrumentation, do not output rtree-files, but str-files
+            Only used by stratego.jvm.helper.debug 
+        -->
+        <condition property="transformer-output" value="" else="--output-rtree">
+            <isset property="debug.the.debug.transformer"/>
+        </condition>
+        
+        <!-- 
+            if debug.the.debug.transformer is set then the debug.transformer outputs str files, so the strj-compiler should accept a str-file.
+            if debug.the.debug.transformer is NOT set then the debug.transformer outputs rtree files (much faster generated), so the strj-compiler should accept a rtree-file
+            Only used by stratego.jvm.helper.debug
+        -->
+        <condition property="strj.input.file.type" value="str" else="rtree">
+            <isset property="debug.the.debug.transformer"/>
+        </condition>
         
         <!-- value determines which target will be executed.
-        	If the file ".debugmode" can be found in the project root call stratego.jar.debug
-        	else call stratego.jar
+            If the file ".debugmode" can be found in the project root call stratego.jar.debug
+            else call stratego.jar
         -->
         <condition property="stratego.jar.target" value="call.stratego.jar.debug" else="call.stratego.jar">
             <available file=".debugmode"/>
         </condition>
-		
-		<!-- will save the stratego files with debug info in this folder -->
-		<property name="trans-debug" location="trans-debug"/>
-		
-		<!-- this helper target determines what target to call, based on debug.build.enabled -->
-		<target name="stratego.jar.helper">
-			<antcall target="${stratego.jar.target}"/>
-		</target>
-		
-		<!-- call stratego.jar unless debug.build.enabled property is set --> 
-		<target name="call.stratego.jar" depends="stratego.jar">
-			<echo message="call.stratego.jar - ${stratego.jar.target}"/>
-		</target>
-		
-		<!-- call stratego.jar.debug when debug.build.enabled property is set -->
-		<target name="call.stratego.jar.debug" depends="stratego.jar.debug">
-			<echo message="call.stratego.jar.debug - ${stratego.jar.target}"/>
-		</target>
-		
-		<!-- copy stratego runtime jars to utils folder -->
-		<target name="utils-files-debug" depends="utils-files">
-			<copy file="${eclipse.spoofaximp.stratego-debug-runtime-jar}" todir="utils" failonerror="false"/>
-			<copy file="${eclipse.spoofaximp.stratego-debug-runtime-java-jar}" todir="utils" failonerror="false"/>
-		</target>
-		
-	    <!-- Stratego to Java compiler with debugging capabilities -->
-	    <target name="stratego.jar.debug" depends="rtg2sig,utils-files-debug">
-	        <dependset>
-	            <srcfileset dir="${basedir}">
-	                <include name="**/*.str"/>
-	                <include name="**/*.astr"/>
-	                <exclude name="lib/editor-common.generated.str"/>
-	            </srcfileset>
-	            <targetfileset file="${src-gen}/trans/Main.java"/>
-	        </dependset>
-	        <available file="${src-gen}/trans/Main.java" property="strc-java.available"/>
-	        <antcall target="copy-jar"/>
-	        <antcall target="stratego.jar.deletehelper"/>
-	    	<!-- compile stratego to java -->
-	        <antcall target="stratego.jvm.helper.debug">
-	            <param name="build.stratego.outputfile" value="${src-gen}/trans/Main.java"/>
-	            <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
-	        </antcall>
-	    	<!-- compile java to class -->
-	        <javac destdir="${build}" source="1.5" target="1.5" debug="on">
-	    		<!-- attribute in javac: srcdir="${src-gen}" -->
-	    		<src path="${src-gen}"/>
-	        	<!-- attribute in javac: classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}"  -->
-	        	<classpath>
-	        		<pathelement path="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}"/> <!-- the path attribute accepts colon- or semicolon-separated lists of locations -->
-	        		<pathelement location="utils/stratego-debug-runtime.jar"/> <!-- The location attribute specifies a single file or directory relative to the project's base directory (or an absolute filename) -->
-	        		<pathelement location="utils/stratego-debug-runtime-java.jar"/>
-	        	</classpath>
-	        	<!-- attribute in javac: includes="trans/**"  -->
-	        	<include name="trans/**"/>
-	    	</javac>
-	        <!-- copy imported terms -->
-	        <copy todir="${build}/trans">
-	            <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
-	        </copy>
-	    	<!-- create a jar from the class files -->
-	        <jar basedir="${build}" includes="trans/**" destfile="${include}/${strmodule}.tmp.jar"/>
-	        <move file="${include}/${strmodule}.tmp.jar" tofile="${include}/${strmodule}.jar"/>
-	        <delete><fileset dir="${build}" includes="trans/**"/></delete>
-	    </target>
-		
-		<!-- instrument the stratego program and compile it to java -->
-	    <target name="stratego.jvm.helper.debug" unless="strc-java.available" if="build.stratego.enabled">
-	    	<echo message="generate stratego with debug information"/>
-	    	<echo message="${basedir}"/>
-	    	<available classname="org.strategoxt.imp.debug.stratego.transformer.trans.Main" property="transformer.available"/>
-	    	<!-- add debug information -->
-	  		<java classname="org.strategoxt.imp.debug.stratego.transformer.trans.Main" failonerror="true" fork="true">
-	  		     <classpath>
-					<pathelement location="${eclipse.spoofaximp.stratego-transformer-jar}"/>
-	  		     	<pathelement location="${eclipse.spoofaximp.stratego-transformer-java-jar}"/>
-	  		     	<pathelement location="${eclipse.spoofaximp.strategojar}"/>
-	  		     </classpath>
-	  			<arg value="-i"/>
-	  			<arg value="${trans}/${strmodule}.str"/>
-	  			<arg value="--gen-dir"/>
-	  			<arg value="${trans-debug}"/>
-	  			<arg value="--base-dir"/> <!-- set the basedir to the project dir -->
-	  			<arg value="${basedir}"/>
-	  			<!-- "arg line='val'" val should contain space-separated arguments --> 
-	  			<arg line="--charoffset-converter --fail-catch ${transformer-output}"/>
-	  			
-	  			<!-- arguments should start with two '-'-characters -->
-	  			<!-- <arg value="-charoffset-converter"/> --> <!-- create charoffset table -->
-	  			<!-- <arg value="-fail-catch"/>  --> <!-- catch failures in where/with-clauses in rules -->
-	  			<!-- <arg value="-output-rtree"/> --> 
-	    	</java>
-	    	<!-- now compile instrumented stratego to java -->
-	        <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
-	        <java classname="org.strategoxt.strj.Main" failonerror="true">
-	            <arg value="-i"/>
-	            <arg value="${trans-debug}/trans/${strmodule}.{strj.input.file.type}"/>
-	            <arg value="-o"/>
-	            <arg value="${build.stratego.outputfile}"/>
-	            <arg value="-p"/>
-	            <arg value="trans"/>
-	            <arg value="--library"/>
-	            <arg value="--clean"/>
-	            <arg line="${build.stratego.args}"/>
-	            <arg line="${build.stratego.extraargs}"/>
-	            <arg line="${externaljarflags}"/>
-	            <arg line="${externaldefimport}"/>
-	            <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
-	        	<!-- put strategodebuglib.rtree on the include path -->
-	        	<arg line="-I &quot;${eclipse.spoofaximp.strategodebuglib-folder}&quot;"/>
-	        	<arg line="-la org.strategoxt.imp.debug.stratego.runtime.trans"/>
-	        </java>
-	        <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
-	        <mkdir dir="${build}/trans"/>
-	    </target>
+        
+        <!-- will save the stratego files with debug info in this folder -->
+        <property name="trans-debug" location="trans-debug"/>
+        
+        <!-- this helper target determines what target to call, based on debug.build.enabled -->
+        <target name="stratego.jar.helper">
+            <antcall target="${stratego.jar.target}"/>
+        </target>
+        
+        <!-- call stratego.jar unless debug.build.enabled property is set --> 
+        <target name="call.stratego.jar" depends="stratego.jar">
+            <echo message="call.stratego.jar - ${stratego.jar.target}"/>
+        </target>
+        
+        <!-- call stratego.jar.debug when debug.build.enabled property is set -->
+        <target name="call.stratego.jar.debug" depends="stratego.jar.debug">
+            <echo message="call.stratego.jar.debug - ${stratego.jar.target}"/>
+        </target>
+        
+        <!-- copy stratego runtime jars to utils folder -->
+        <target name="utils-files-debug" depends="utils-files">
+            <copy file="${eclipse.spoofaximp.stratego-debug-runtime-jar}" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.stratego-debug-runtime-java-jar}" todir="utils" failonerror="false"/>
+        </target>
+        
+        <!-- Stratego to Java compiler with debugging capabilities -->
+        <target name="stratego.jar.debug" depends="rtg2sig,utils-files-debug">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.str"/>
+                    <include name="**/*.astr"/>
+                    <exclude name="lib/editor-common.generated.str"/>
+                </srcfileset>
+                <targetfileset file="${src-gen}/trans/Main.java"/>
+            </dependset>
+            <available file="${src-gen}/trans/Main.java" property="strc-java.available"/>
+            <antcall target="copy-jar"/>
+            <antcall target="stratego.jar.deletehelper"/>
+            <!-- compile stratego to java -->
+            <antcall target="stratego.jvm.helper.debug">
+                <param name="build.stratego.outputfile" value="${src-gen}/trans/Main.java"/>
+                <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
+            </antcall>
+            <!-- compile java to class -->
+            <javac destdir="${build}" source="1.5" target="1.5" debug="on">
+                <!-- attribute in javac: srcdir="${src-gen}" -->
+                <src path="${src-gen}"/>
+                <!-- attribute in javac: classpath="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}"  -->
+                <classpath>
+                    <pathelement path="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}"/> <!-- the path attribute accepts colon- or semicolon-separated lists of locations -->
+                    <pathelement location="utils/stratego-debug-runtime.jar"/> <!-- The location attribute specifies a single file or directory relative to the project's base directory (or an absolute filename) -->
+                    <pathelement location="utils/stratego-debug-runtime-java.jar"/>
+                </classpath>
+                <!-- attribute in javac: includes="trans/**"  -->
+                <include name="trans/**"/>
+            </javac>
+            <!-- copy imported terms -->
+            <copy todir="${build}/trans">
+                <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
+            </copy>
+            <!-- create a jar from the class files -->
+            <jar basedir="${build}" includes="trans/**" destfile="${include}/${strmodule}.tmp.jar"/>
+            <move file="${include}/${strmodule}.tmp.jar" tofile="${include}/${strmodule}.jar"/>
+            <delete><fileset dir="${build}" includes="trans/**"/></delete>
+        </target>
+        
+        <!-- instrument the stratego program and compile it to java -->
+        <target name="stratego.jvm.helper.debug" unless="strc-java.available" if="build.stratego.enabled">
+            <echo message="generate stratego with debug information"/>
+            <echo message="${basedir}"/>
+            <available classname="org.strategoxt.imp.debug.stratego.transformer.trans.Main" property="transformer.available"/>
+            <!-- add debug information -->
+              <java classname="org.strategoxt.imp.debug.stratego.transformer.trans.Main" failonerror="true" fork="true">
+                   <classpath>
+                    <pathelement location="${eclipse.spoofaximp.stratego-transformer-jar}"/>
+                       <pathelement location="${eclipse.spoofaximp.stratego-transformer-java-jar}"/>
+                       <pathelement location="${eclipse.spoofaximp.strategojar}"/>
+                   </classpath>
+                  <arg value="-i"/>
+                  <arg value="${trans}/${strmodule}.str"/>
+                  <arg value="--gen-dir"/>
+                  <arg value="${trans-debug}"/>
+                  <arg value="--base-dir"/> <!-- set the basedir to the project dir -->
+                  <arg value="${basedir}"/>
+                  <!-- "arg line='val'" val should contain space-separated arguments --> 
+                  <arg line="--charoffset-converter --fail-catch ${transformer-output}"/>
+                  
+                  <!-- arguments should start with two '-'-characters -->
+                  <!-- <arg value="-charoffset-converter"/> --> <!-- create charoffset table -->
+                  <!-- <arg value="-fail-catch"/>  --> <!-- catch failures in where/with-clauses in rules -->
+                  <!-- <arg value="-output-rtree"/> --> 
+            </java>
+            <!-- now compile instrumented stratego to java -->
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+            <java classname="org.strategoxt.strj.Main" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${trans-debug}/trans/${strmodule}.${strj.input.file.type}"/>
+                <arg value="-o"/>
+                <arg value="${build.stratego.outputfile}"/>
+                <arg value="-p"/>
+                <arg value="trans"/>
+                <arg value="--library"/>
+                <arg value="--clean"/>
+                <arg line="${build.stratego.args}"/>
+                <arg line="${build.stratego.extraargs}"/>
+                <arg line="${externaljarflags}"/>
+                <arg line="${externaldefimport}"/>
+                <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+                <!-- put strategodebuglib.rtree on the include path -->
+                <arg line="-I &quot;${eclipse.spoofaximp.strategodebuglib-folder}&quot;"/>
+                <arg line="-la org.strategoxt.imp.debug.stratego.runtime.trans"/>
+            </java>
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+            <mkdir dir="${build}/trans"/>
+        </target>
         
         
         <!-- end: targets used for adding debugging instrumentation to stratego -->

From m.dejonge at tudelft.nl  Wed Aug  3 14:00:18 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 03 Aug 2011 12:00:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23181 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings
Message-ID: <20110803120018.A932FCC0B3@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  3 12:00:18 2011
New Revision: 23181
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23181&sc=1

Log:
some semantic checks

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-semantic-issues.spt

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-semantic-issues.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-semantic-issues.spt	Wed Aug  3 12:00:18 2011	(r23181)
@@ -0,0 +1,70 @@
+module test-rename-samantic-issues
+ 
+language Stratego-Sugar
+
+/**
+ * Basic rename testcases: basic constructs, errors do not occur
+ */
+setup [[
+  module test-rename-semantic-issues
+  rules
+]]
+
+test Rename Unintended-Strategy-Overloading (1)
+  [[ 
+  	  aaa = fail
+      [[bbb]] =  id 
+  ]] refactor rename-refactoring("aaa") to 
+  [[
+  	  aaa = fail
+      aaa = id 
+  ]]
+  1 error
+  
+test Rename Unintended-Strategy-Overloading (2)
+  [[ 
+  	  aaa(s) = s; fail
+      [[bbb]] =  id 
+  ]] refactor rename-refactoring("aaa") to 
+  [[
+  	  aaa(s) = s; fail
+      aaa = id 
+  ]]
+  0 error
+  
+test Rename Shadow-Global-Strategy (1)
+  [[ 
+  	  aaa = debug; fail
+  	  b(foo) = aaa; [[foo]]
+  ]] refactor rename-refactoring("aaa") to 
+  [[
+  	  aaa = debug; fail
+  	  b(aaa) = aaa; aaa
+  ]]
+  1 error
+
+test Rename Shadow-Global-Strategy (2)
+  [[ 
+  	  aaa(s|t) = s; fail
+  	  b(foo) = [[aaa]](id|[]); foo
+  ]] refactor rename-refactoring("foo") to 
+  [[
+  	  foo(s|t) = s; fail
+  	  b(foo) = [[foo]](id|[]); foo
+  ]]
+  1 error
+
+test Rename Duplicate-Local-Declaration
+  [[
+  	  aaa = 
+  	  	[[b]] := "";
+  	  	c := "" 
+  ]] refactor rename-refactoring("c") to 
+  [[
+  	  aaa = 
+  	  	c := "";
+  	  	c := "" 
+  ]]
+  1 error
+  1 warning
+

From m.dejonge at tudelft.nl  Wed Aug  3 15:32:24 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 03 Aug 2011 13:32:24 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23182 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110803133224.7CBB07F8017@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug  3 13:32:23 2011
New Revision: 23182
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23182&sc=1

Log:
bugfix: warning when refactoring fails because of selection can not be resolved

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Wed Aug  3 12:00:18 2011	(r23181)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Wed Aug  3 13:32:23 2011	(r23182)
@@ -56,14 +56,15 @@
       then 
       	output := <execute-service(|input)> builder
       else 
-      	output := Error("Selection is not matched with expected sort/constructor")
+      	input := None();
+      	output := Error("Selection is not matched with expected sort or constructor")
       end
     where
       error := <check-builder> (output, input, expected, condition)
 	
   check-builder:
 	(output, input, expected, condition) -> error
-    where
+    where 
       switch !output
         case ?Some(output'):
           with(result := <fetch-builder-result(|input, output')> condition);

From m.dejonge at tudelft.nl  Thu Aug  4 09:21:48 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 04 Aug 2011 07:21:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23183 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/syntax
Message-ID: <20110804072148.A9A74108C01A@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug  4 07:21:46 2011
New Revision: 23183
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23183&sc=1

Log:
bugfix: fails ambiguity

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Wed Aug  3 13:32:23 2011	(r23182)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Thu Aug  4 07:21:46 2011	(r23183)
@@ -120,7 +120,7 @@
     "to" "file" PathName -> OptPattern {cons("File")}
     "to" Output          -> OptPattern {cons("Fragment")}
     "to" ATerm           -> OptPattern {cons("ATerm")}
-    "fails"              -> OptPattern {cons("Fails")}
+    %%"fails"              -> OptPattern {cons("Fails")}
 
     RegexExp          -> Result
 
@@ -274,4 +274,3 @@
   lexical syntax
     ShortCom    -> LAYOUT
     LongCom     -> LAYOUT
-

From m.dejonge at tudelft.nl  Thu Aug  4 10:48:03 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 04 Aug 2011 08:48:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23184 - in
	spoofax-imp/trunk/org.strategoxt.imp.testing: editor trans
Message-ID: <20110804084803.E2FE72B805D@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug  4 08:48:02 2011
New Revision: 23184
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23184&sc=1

Log:
run testsuite (current file)

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Builders.esv
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Builders.esv	Thu Aug  4 07:21:46 2011	(r23183)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/editor/Spoofax-Testing-Builders.esv	Thu Aug  4 08:48:02 2011	(r23184)
@@ -19,5 +19,6 @@
   builder  : "Show abstract syntax (for selection)"          = generate-aterm (openeditor) (realtime) (source) // (meta) 
   builder  : "Generate missing output file with current AST" = generate-ast-file (cursor)              
   builder  : "Run testsuites" = test-runner
+  builder  : "Run testsuite (current file)" = test-runner-file
                                                                                                                                
   //on save : generate-java                                                                                                    
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str	Thu Aug  4 07:21:46 2011	(r23183)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str	Thu Aug  4 08:48:02 2011	(r23184)
@@ -29,10 +29,18 @@
   
   test-runner =
     testview-init 
-  ; find-all-testsuites-in-project 
-  ; map(testview-add-testsuite(|<get-testsuite-name-from-file>,<id>))
-  ; map(try(run-testsuite))
+  ; find-all-testsuites-in-project ;debug(!"1: ")
+  ; map(testview-add-testsuite(|<get-testsuite-name-from-file>,<id>)) ;debug(!"2: ")
+  ; map(try(run-testsuite)) ;debug(!"3: ")
   ; !None()
+
+  test-runner-file:
+    (selected, position, ast, path, project-path) -> None()
+    with
+      testview-init 
+    ; !path
+    ; testview-add-testsuite(|<get-testsuite-name-from-file>,<id>)
+    ; try(run-testsuite)
   
   find-all-testsuites-in-project =
     <find(has-extension(|"spt"))> "." 

From m.dejonge at tudelft.nl  Thu Aug  4 11:05:59 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 04 Aug 2011 09:05:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23185 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego:
	test-refactorings trans/refactoring/helpers
Message-ID: <20110804090559.1CB6E2B804C@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug  4 09:05:58 2011
New Revision: 23185
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23185&sc=1

Log:
bugfix: take into account global vars of editor-common.generated

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-semantic-issues.spt
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/multi-file-support.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-semantic-issues.spt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-semantic-issues.spt	Thu Aug  4 08:48:02 2011	(r23184)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-semantic-issues.spt	Thu Aug  4 09:05:58 2011	(r23185)
@@ -6,7 +6,8 @@
  * Basic rename testcases: basic constructs, errors do not occur
  */
 setup [[
-  module test-rename-semantic-issues
+  module test-rename-semantic-issues  
+  imports lib/editor-common.generated
   rules
 ]]
 
@@ -68,3 +69,117 @@
   1 error
   1 warning
 
+test Rename Duplicate-Signature (1)
+  [[ 
+      r : [[Bar]](x,y) -> Bar(y,x) 
+      signature constructors
+        Bar : Id * Id -> Bar
+        Foo : Id * Id -> X
+  ]] refactor rename-refactoring("Foo") to 
+  [[
+      r : [[Foo]](x,y) -> Foo(y,x) 
+      signature constructors
+        Foo : Id * Id -> Bar
+        Foo : Id * Id -> X
+  ]]
+  2 errors
+
+test Rename Duplicate-Signature (1)
+  [[ 
+      r : [[Bar]](x,y) -> Bar(y,x) 
+      signature constructors
+        Bar : Id * Id -> Bar
+        Foo : Id -> X
+  ]] refactor rename-refactoring("Foo") to 
+  [[
+      r : [[Foo]](x,y) -> Foo(y,x) 
+      signature constructors
+        Foo : Id * Id -> Bar
+        Foo : Id -> X
+  ]]
+  0 error
+  
+test Rename Shadowing Let (1)
+  [[ 
+  	  foo(|i) = !i
+  	  bbb(s|n) = <s> n
+      aaa(s) =
+        let [[apply]](|i) = <s> (i, <id>)
+          in bbb(apply | 1); foo(|0)
+        end
+  ]] 
+  refactor rename-refactoring("foo") to 
+  [[
+  	  foo(|i) = !i
+  	  bbb(s|n) = <s> n
+      aaa(s) =
+        let foo(|i) = <s> (i, <id>)
+          in bbb(foo | 1); foo(|0)
+        end
+  ]]
+  1 error
+
+test Rename Shadowing Let (2)
+  [[ 
+  	  foo(|i) = <id> i
+      aaa(s) =
+        let [[apply]](|i) = <s> (i, <id>)
+          in map(apply)
+        end
+  ]] 
+  refactor rename-refactoring("foo") to 
+  [[
+  	  foo(|i) = <id> i
+      aaa(s) =
+        let foo(|i) = <s> (i, <id>)
+          in map(foo)
+        end
+  ]]
+  0 error
+  
+test Rename From-External-Definition
+  [[ 
+  	  aaa = [[map]](id) 
+  ]] refactor rename-refactoring("foo") to 
+  [[
+  	  aaa = foo(id) 
+  ]]
+  2 errors
+  
+test Rename From-To-External-Definition
+  [[ 
+  	  aaa = [[map]](id) 
+  ]] refactor rename-refactoring("filter") to 
+  [[
+  	  aaa = filter(id) 
+  ]]
+  1 errors
+
+test Rename To-External-Definition
+  [[ 
+  	  [[aaa]](s) = map(s) 
+  ]] refactor rename-refactoring("filter") to 
+  [[
+  	  filter(s) = map(s) 
+  ]]
+  1 errors
+
+/** Requires multifile support
+test Rename To-Generated-Definition
+  [[ 
+  	  [[aaa]] = id 
+  ]] refactor rename-refactoring("origin-term") to 
+  [[
+  	  origin-term = id 
+  ]]
+  1 errors
+*/
+
+test Rename From-Generated-Definition
+  [[ 
+  	  [[origin-term]] = id 
+  ]] refactor rename-refactoring("aaa") to 
+  [[
+  	  aaa = id 
+  ]]
+  1 errors

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/multi-file-support.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/multi-file-support.str	Thu Aug  4 08:48:02 2011	(r23184)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/refactoring/helpers/multi-file-support.str	Thu Aug  4 09:05:58 2011	(r23185)
@@ -12,7 +12,7 @@
 	
 get-affected-stratego-asts(is-affected) =
       	<get-affected-asts(
-      		has-extension(|"str"); not(string-ends-with(|".generated.str")), //is-source-file
+      		has-extension(|"str"), //; not(string-ends-with(|".generated.str"))
       		not(is-spoofax-dir) <+ equal(|$[[<project-path>]/trans]), //is-source-dir
       		is-affected, //is-affected 
       		get-cache-path

From m.dejonge at tudelft.nl  Thu Aug  4 11:43:33 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 04 Aug 2011 09:43:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23186 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110804094333.DF169CC649@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug  4 09:43:33 2011
New Revision: 23186
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23186&sc=1

Log:
bugfix

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str	Thu Aug  4 09:05:58 2011	(r23185)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/test-runner.str	Thu Aug  4 09:43:33 2011	(r23186)
@@ -53,7 +53,6 @@
     file -> (ast, [])
     where 
       ast  := <parse-spt-file> file
-    ; editor-init
     ; ast' := <topdown(repeat(spt-desugar)); alltd(spt-desugar-refactoring-conditions)> ast 
     ; testcases := <collect-all(testview-add-testcase(|file, <test-to-description>,<origin-offset>))>ast'
     ; <map(run-testcase(|file))>testcases

From m.dejonge at tudelft.nl  Thu Aug  4 12:41:00 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 04 Aug 2011 10:41:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23187 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/syntax
Message-ID: <20110804104100.6F3457F8002@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug  4 10:41:00 2011
New Revision: 23187
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23187&sc=1

Log:
disambiguation fails

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Thu Aug  4 09:43:33 2011	(r23186)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Thu Aug  4 10:41:00 2011	(r23187)
@@ -88,7 +88,7 @@
     "fails" "parsing"    -> Result {cons("FailsParsing"), deprecated("Use 'parse fails' instead")}
     "succeeds" "parsing" -> Result {cons("SuccessParsing"), deprecated("Use 'parse succeeds' instead")}
 
-    "fails"              -> Result {cons("Fails")}
+    %%"fails"              -> Result {cons("Fails")}
     "parse" "fails"      -> Result {cons("FailsParsing")}
     "succeeds"           -> Result {cons("Success")}
     "parse" "succeeds"   -> Result {cons("SuccessParsing")}
@@ -120,7 +120,7 @@
     "to" "file" PathName -> OptPattern {cons("File")}
     "to" Output          -> OptPattern {cons("Fragment")}
     "to" ATerm           -> OptPattern {cons("ATerm")}
-    %%"fails"              -> OptPattern {cons("Fails")}
+    "fails"              -> OptPattern {cons("Fails"), prefer}
 
     RegexExp          -> Result
 

From m.dejonge at tudelft.nl  Thu Aug  4 14:26:38 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 04 Aug 2011 12:26:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23188 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110804122638.2F1A4108C01C@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug  4 12:26:36 2011
New Revision: 23188
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23188&sc=1

Log:
handle expected output: fails

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Thu Aug  4 10:41:00 2011	(r23187)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check-builders.str	Thu Aug  4 12:26:36 2011	(r23188)
@@ -69,15 +69,22 @@
         case ?Some(output'):
           with(result := <fetch-builder-result(|input, output')> condition);
           error       := <check-builder-expectation(|result)> expected
-        case ?Error(m):
-          if not(!condition => Fails()) then
+        case ?Error(m): 
+          if <not(is-expected-failure)> (condition, expected) then
             error := $[Unexpected error: [m]]
           end
-        case ?Fail(m):
+        case ?Fail(m): 
           error  := $[Unexpected error: [m]]
         otherwise: with(fail)
       end
   
+  is-expected-failure:
+  	(condition, expected) -> (condition, expected)
+  	where
+  	  !condition => Fails() <+ 
+  	  !expected => Fails() <+
+  	  <?(Fails(),_)> expected
+  
   fetch-builder-result(|input, output):
     Run(_, _, _) -> output
   
@@ -97,7 +104,7 @@
       !output => refactor-result
    
   check-builder-expectation(|result) :
-    Fails() -> $[Builder was expected to fail, but produced: [result]]
+    Fails() -> $[Builder was expected to fail, but produced: [<write-to-string> result]]
    
   check-builder-expectation(|result) :
     File(_) -> $[Builder comparison to file is not implemented] // TODO

From srabbelier at gmail.com  Thu Aug  4 16:56:59 2011
From: srabbelier at gmail.com (Sverre Rabbelier)
Date: Thu, 04 Aug 2011 14:56:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23189 -
	strategoxt/trunk/stratego-libraries/xtc/lib
Message-ID: <20110804145659.87F61CC1FC@mx4.tudelft.nl>

Author: SverreRabbelier
Date: Thu Aug  4 14:56:59 2011
New Revision: 23189
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23189&sc=1

Log:
Generate libstratego-xtc.ctree

Modified:
   strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am

Modified: strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am
==============================================================================
--- strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am	Thu Aug  4 12:26:36 2011	(r23188)
+++ strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am	Thu Aug  4 14:56:59 2011	(r23189)
@@ -4,7 +4,7 @@
 
 pkgdatadir = $(datadir)/xtc
 
-nobase_pkgdata_DATA =  stratego-xtc.str $(fullstrategoxtc:.str=.rtree)
+nobase_pkgdata_DATA =  stratego-xtc.str libstratego-xtc.ctree $(fullstrategoxtc:.str=.rtree)
 data_DATA = libstratego-xtc.rtree
 lib_LTLIBRARIES = libstratego-xtc.la
 
@@ -45,6 +45,9 @@
 libstratego-xtc.rtree : lib$(stratego_xtc_module).rtree
 	cp $< $@
 
+libstratego-xtc.ctree : libstratego-xtc-posix-xsi.rtree
+	$(STRC_UNINSTALLED) -F --library -i $< -o $@ $(STRCFLAGS)
+
 stratego-xtc.str : Makefile
 	echo "module stratego-xtc imports $(stratego_xtc_module)" > $@
 

From m.dejonge at tudelft.nl  Sun Aug  7 15:19:56 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 13:19:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23190 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/syntax
Message-ID: <20110807131956.5B34C108C01B@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 13:19:54 2011
New Revision: 23190
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23190&sc=1

Log:
prefer fragment [[...]] above ATerm [[ ...]]

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Thu Aug  4 14:56:59 2011	(r23189)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/syntax/Spoofax-Testing.sdf	Sun Aug  7 13:19:54 2011	(r23190)
@@ -119,7 +119,7 @@
                          -> OptPattern {cons("wildcard")}
     "to" "file" PathName -> OptPattern {cons("File")}
     "to" Output          -> OptPattern {cons("Fragment")}
-    "to" ATerm           -> OptPattern {cons("ATerm")}
+    "to" ATerm           -> OptPattern {cons("ATerm"), avoid}
     "fails"              -> OptPattern {cons("Fails"), prefer}
 
     RegexExp          -> Result

From m.dejonge at tudelft.nl  Sun Aug  7 15:33:07 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 13:33:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23191 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings
Message-ID: <20110807133307.A10247F8052@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 13:33:07 2011
New Revision: 23191
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23191&sc=1

Log:
testcases for pp-stratego refactoring

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-prettyprint.spt

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-prettyprint.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-prettyprint.spt	Sun Aug  7 13:33:07 2011	(r23191)
@@ -0,0 +1,17 @@
+module test-prettyprint
+ 
+language Stratego-Sugar
+
+/**
+ * Testcases Pretty-Print
+*/
+test Pretty-Print
+  [[ 
+    [[module test-prettyprint
+    rules
+      bar(x) = map(x)]] 
+  ]] refactor format-refactoring to
+  "module test-prettyprint
+    rules
+      bar(|x) = map(x)"
+ 

From m.dejonge at tudelft.nl  Sun Aug  7 17:04:11 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 15:04:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23192 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110807150411.C9123108C011@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 15:04:11 2011
New Revision: 23192
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23192&sc=1

Log:
bugfix: support mix of sugared/desugared terms in refactoring output

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str	Sun Aug  7 13:33:07 2011	(r23191)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str	Sun Aug  7 15:04:11 2011	(r23192)
@@ -30,9 +30,19 @@
   	//<is-origin-term-desugared> expected;
   	<not(is-origin-term)> expected;
   	<not(same-signature)> (expected, result);
-  	<compare-ast> (<origin-term> expected, result) 
+  	sugared-c#(sugared-args) := <origin-term> expected;
+  	desugared-args := <get-arguments> expected;
+  	mixed-args := <map(try(lookup-desugared(|desugared-args)))> sugared-args;
+  	<compare-ast> (sugared-c#(mixed-args), result) 
   	//TODO: we assume that 'expected' is a desugared origin. 
- 
+
+lookup-desugared(|desugared*):
+	elem -> desugared-elem
+	where
+		desugared-elem := 
+		  <fetch-elem(where(origin-term; equal(|elem)))> desugared*
+		
+
 same-signature:
   (expected, result) -> (expected, result)
   where

From m.dejonge at tudelft.nl  Sun Aug  7 18:57:47 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 16:57:47 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23193 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans
Message-ID: <20110807165747.67D362B8016@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 16:57:47 2011
New Revision: 23193
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23193&sc=1

Log:
desugar single where clause

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/desugar.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/desugar.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/desugar.str	Sun Aug  7 15:04:11 2011	(r23192)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/trans/desugar.str	Sun Aug  7 16:57:47 2011	(r23193)
@@ -45,6 +45,11 @@
     RDefNoArgs(x, s) -> SDefT(x, [], [], SRule(s))
 
   basic-desugar:
+    Rule(x, y, z) -> Rule(x, y, [WhereClause(z)])
+    where
+    	<not(is-list)> z
+
+  basic-desugar:
     OverlayNoArgs(x, o) -> Overlay(x, [], o)
 
   basic-desugar:

From m.dejonge at tudelft.nl  Sun Aug  7 18:58:49 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 16:58:49 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23194 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110807165850.012C1108C008@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 16:58:49 2011
New Revision: 23194
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23194&sc=1

Log:
more tolerant fetching of desugared term

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str	Sun Aug  7 16:57:47 2011	(r23193)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/ast-compare.str	Sun Aug  7 16:58:49 2011	(r23194)
@@ -31,16 +31,16 @@
   	<not(is-origin-term)> expected;
   	<not(same-signature)> (expected, result);
   	sugared-c#(sugared-args) := <origin-term> expected;
-  	desugared-args := <get-arguments> expected;
-  	mixed-args := <map(try(lookup-desugared(|desugared-args)))> sugared-args;
+  	mixed-args := <map(try(lookup-desugared(|expected)))> sugared-args; 
   	<compare-ast> (sugared-c#(mixed-args), result) 
   	//TODO: we assume that 'expected' is a desugared origin. 
 
-lookup-desugared(|desugared*):
-	elem -> desugared-elem
+lookup-desugared(|desugared-term):
+	subtrm -> desugared-subtrm
 	where
-		desugared-elem := 
-		  <fetch-elem(where(origin-term; equal(|elem)))> desugared*
+		  <oncetd(
+		  	desugared-subtrm := <where(origin-term; equal(|subtrm))>
+		  )> desugared-term
 		
 
 same-signature:

From m.dejonge at tudelft.nl  Sun Aug  7 19:08:16 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 17:08:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23195 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings
Message-ID: <20110807170816.B72B02B8003@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 17:08:16 2011
New Revision: 23195
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23195&sc=1

Log:
testsuite remove debug

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-remove-debug.spt
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-advanced.spt

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-remove-debug.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-remove-debug.spt	Sun Aug  7 17:08:16 2011	(r23195)
@@ -0,0 +1,131 @@
+module test-remove-debug
+ 
+language Stratego-Sugar
+
+/**
+ * Testcases Remove Debug
+*/
+
+setup [[
+  module test-remove-debug
+  rules
+    aaa = fail
+    bbb = fail
+    ccc = fail
+]]
+
+test Remove Debug Seq (1)
+  [[ 
+      bar(x) = debug; map(x)
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar(x) = map(x)
+  ]] 
+ 
+test Remove Debug Seq (2)
+  [[ 
+      bar(x) = map(x); debug
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar(x) = map(x)
+  ]] 
+
+test Remove Debug Seq (3)
+  [[ 
+      bar(x) = debug; map(x); debug(!"1: "); debug
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar(x) = map(x)
+  ]] 
+
+test Remove Debug GuardedLChoice (1)
+  [[ 
+      bar(x) = debug < aaa + bbb
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar(x) = aaa
+  ]] 
+
+test Remove Debug GuardedLChoice (2)
+  [[ 
+      bar(x) = aaa < debug + bbb
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar(x) = aaa <+ bbb
+  ]] 
+
+test Remove Debug GuardedLChoice (3)
+  [[ 
+      bar(x) = aaa < bbb + debug
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar(x) = aaa < bbb + id
+  ]] 
+
+test Remove Debug GuardedLChoice (IfThen)
+  [[ 
+      bar(x) = where(aaa) < bbb + debug
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar(x) = if aaa then bbb end
+  ]] 
+
+test Remove Debug Rule (rhs)
+  [[ 
+      bar: a -> <debug> (a,a)
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar: a -> (a,a)
+  ]] 
+
+test Remove Debug Rule (single condition)
+  [[ 
+      bar: a -> (a,a)
+      where
+        debug
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar: a -> (a,a)
+  ]] 
+
+test Remove Debug Rule (conditions)
+  [[ 
+      bar: a -> (a,a)
+      where
+        debug;
+        aaa
+      where
+        bbb
+      with
+        debug
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar: a -> (a,a)
+      where
+        aaa
+      where
+        bbb
+  ]] 
+
+test Remove Debug Appl in Where
+  [[ 
+      bar =
+      	?(x,y);
+        where (<debug> x) 
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar =
+      	?(x,y)
+  ]] 
+
+test Remove Debug Appl in With
+  [[ 
+      bar =
+      	?(x,y);
+        with (<debug> x) 
+  ]] refactor remove-debug-refactoring to
+  [[ 
+      bar =
+      	?(x,y)
+  ]] 
+

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-advanced.spt
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-advanced.spt	Sun Aug  7 16:58:49 2011	(r23194)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-rename-advanced.spt	Sun Aug  7 17:08:16 2011	(r23195)
@@ -111,3 +111,4 @@
       rules(Rename: name -> ref)
   ]]
 
+

From m.dejonge at tudelft.nl  Sun Aug  7 21:35:27 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 19:35:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23196 -
	spoofax-imp/trunk/org.strategoxt.imp.testing/trans
Message-ID: <20110807193527.16A4B108C003@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 19:35:26 2011
New Revision: 23196
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23196&sc=1

Log:
bugfix: fatal errors expected

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Sun Aug  7 17:08:16 2011	(r23195)
+++ spoofax-imp/trunk/org.strategoxt.imp.testing/trans/check.str	Sun Aug  7 19:35:26 2011	(r23196)
@@ -37,7 +37,7 @@
   	where
   		zeros := [Fatals("0"), Errors("0"), Warnings("0")]; //TODO Fatals(0)
   		refactor-expectations := 
-  			<union(?(Errors(_), Errors(_)) <+ ?(Warnings(_), Warnings(_)))> (zeros, expectations)
+  			<union(?(Errors(_), Errors(_)) <+ ?(Warnings(_), Warnings(_)) <+ ?(Fatals(_), Fatals(_)))> (zeros, expectations)
 
   check-note = fail
   

From m.dejonge at tudelft.nl  Sun Aug  7 21:53:32 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 19:53:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23197 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings
Message-ID: <20110807195332.8521F108C01A@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 19:53:32 2011
New Revision: 23197
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23197&sc=1

Log:
inline tests

Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-inline-semantic-issues.spt
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-inline.spt

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-inline-semantic-issues.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-inline-semantic-issues.spt	Sun Aug  7 19:53:32 2011	(r23197)
@@ -0,0 +1,33 @@
+module test-inline-semantic-issues
+ 
+language Stratego-Sugar
+
+/**
+ * Inline testcases for errors, warnings
+ */
+setup [[
+  module test-inline-semantic-issues
+  rules
+    aaa = fail
+    bbb = fail
+]]
+
+test Inline Multiple Definitions
+  [[ 
+  	  bar = foo
+  	  [[foo = aaa]] 
+  	  foo = bbb 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar = aaa
+  	  foo = bbb 
+  ]]  
+  2 warning
+
+test Inline Recursion
+  [[ 
+  	  bar = aaa; [[bar]]
+  ]] refactor inline-refactoring
+  1 fatal errors
+
+//TODO: name collision (or solve collisions?)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-inline.spt
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/test-refactorings/test-inline.spt	Sun Aug  7 19:53:32 2011	(r23197)
@@ -0,0 +1,80 @@
+module test-inline
+ 
+language Stratego-Sugar
+
+/**
+ * Basic inline testcases: errors do not occur
+ */
+setup [[
+  module test-inline
+  rules
+    aaa = fail
+    bbb = fail
+]]
+
+test Inline Call Selected
+  [[ 
+  	  bar = [[foo]]
+  	  foo = aaa 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar = aaa
+  ]]  
+
+test Inline Multiple Calls
+  [[ 
+  	  bar1 = [[foo]]
+  	  bar2 = [[foo]]
+  	  foo = aaa 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar1 = aaa
+  	  bar2 = aaa
+  ]]  
+
+test Inline Definition Selected
+  [[ 
+  	  bar = foo
+  	  [[foo = aaa]] 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar = aaa
+  ]]  
+
+//TODO: more tolerant with selection
+test Inline Definition-Name Selected
+  [[ 
+  	  bar = foo
+  	  [[foo]] = aaa 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar = aaa
+  ]]  
+
+test Inline Simple Rule
+  [[ 
+  	  bar = <map(foo)> [1,2,3]
+  	  [[foo: a -> (a,a)]] 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar = <map(\a -> (a,a)\)> [1,2,3]
+  ]]  
+
+test Inline Conditional Rule with Variabeles
+  [[ 
+  	  bar = <map(foo)> [1,2,3]
+  	  [[foo: a -> (a,b) where b := <aaa> a ]] 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar = <map({b,a: (a -> (a,b) where b := <aaa> a)})> [1,2,3]
+  ]]  
+
+test Inline Strategy with Variabeles
+  [[ 
+  	  bar = <map(foo)> [1,2,3]
+  	  [[foo = ?a; !(a,a)]] 
+  ]] refactor inline-refactoring to
+  [[ 
+  	  bar = <map({a: ?a; !(a,a)})> [1,2,3]
+  ]]  
+

From m.dejonge at tudelft.nl  Sun Aug  7 21:57:33 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 07 Aug 2011 19:57:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23198 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor
Message-ID: <20110807195733.C19E47F80C9@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug  7 19:57:33 2011
New Revision: 23198
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23198&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Sun Aug  7 19:53:32 2011	(r23197)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.stratego/editor/Stratego-Sugar-Builders.esv	Sun Aug  7 19:57:33 2011	(r23198)
@@ -17,6 +17,8 @@
   
   builder: "Inline strategy" = inline-builder (meta)
 
+  builder: "Extract strategy" = extract-builder (meta)
+
   builder: "Remove debug calls" = remove-debug-builder (meta)
 
   builder : "Show analysed AST" =
@@ -31,19 +33,24 @@
   builder : "PP Stratego String" =
     pp-builder (source) (meta) 
 
-  builder : "PP Stratego String (analyzed)" =
-    pp-builder (meta) 
+  //builder : "Test" =
+    //test-builder //(meta) 
 
-refactorings
-  
+    
+refactorings 
+   
   pretty-print: pp-stratego-string
    
-  refactoring Id: "Rename" = rename-refactoring //(shortcut)
+  refactoring Id: "Rename" = rename-refactoring
+  shortcut: "org.eclipse.jdt.ui.edit.text.java.rename.element"
   input
     identifier : "New Name"
   	
-  refactoring: "Pretty-Print (Warning: Looses Comments in Selection!)" = format-refactoring (source) //(preview) (shortcut)
+  refactoring: "Pretty-Print (Warning: Looses Comments in Selection!)" = format-refactoring (source) 
+  shortcut: "org.eclipse.jdt.ui.edit.text.java.format"
+  
+  refactoring: "Remove debug" = remove-debug-refactoring
 
-  refactoring: "Remove debug" = remove-debug-refactoring (meta) //(preview)
+  refactoring: "Inline" = inline-refactoring (meta)
 
- 
\ No newline at end of file
+  refactoring: "Extract" = extract-refactoring (meta)

From M.A.Akhter at student.tudelft.nl  Mon Aug  8 10:40:04 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 08 Aug 2011 08:40:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23199 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans: .
	codegen codegen/esv context context/esv utils
Message-ID: <20110808084004.5C3097F8016@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug  8 08:40:03 2011
New Revision: 23199
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23199&sc=1

Log:
* changes in the buildscript for the new wizard
* optional Language ID . If missing,it will be derived from the package name. 
* ESV generation is refactored - 
	** getting rid of empty descriptor from packed.esv
	** adding derived language id if missing in language descriptor

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/common.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Sun Aug  7 19:57:33 2011	(r23198)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Mon Aug  8 08:40:03 2011	(r23199)
@@ -22,15 +22,16 @@
 			;autogen-ant-output-file-name := "build.spx.packages.generated"
 		  ;autogen-ant-output-path      := <concat-strings>[project-path  , "/build/" ,  autogen-ant-output-file-name , ".xml"]
 			;main-ant-output-path         := <concat-strings>[project-path  , "/build/" ,  main-ant-output-file-name    , ".xml"]
-		where
+		with
 			 <dirname; ensure-directory-exists>autogen-ant-output-path  
 			;<save-to-file>(autogen-ant-output-path  , <get-ant-autogeneratedscript>())
 			;<refresh-file>autogen-ant-output-path   
-		where
+		with
 			packages-specific-ant-string := <packages-specific-ant>(package-qnames*, main-ant-output-file-name ,autogen-ant-output-file-name);
 			<dirname; ensure-directory-exists>main-ant-output-path;  
 			<save-to-file>(main-ant-output-path,packages-specific-ant-string);
 			<refresh-file>main-ant-output-path
+			 
 	
 		packages-specific-ant: (pakage-qname*, main-ant-output-file-name ,autogen-ant-output-file-name)  ->
 $[<?xml version="1.0" encoding="UTF-8" ?>
@@ -77,13 +78,13 @@
 		</antcall>
 	</target>	
 	]
-	where 
+	with 
 		relative-autogen-path         :=  <qname-to-path>package-untyped-qname
 		;package-directory		        := $[[<Autogenerated-Artifacts-Dir>]/[relative-autogen-path]]
  		;language-name						 	  := <get-language-name>p
  		;language-id-directory			  := <get-language-id; language-id-to-file-path>p
  		;package-target-name				  := <get-package-target-name>package-untyped-qname  
- 		;package-qname-string				  :=  <convert-qname(|".");string-replace(|"-", ".")>package-untyped-qname
+ 		;package-qname-string				  :=  <package-qname-to-string>p
  		;language-sdf-specific-params := <get-idef-args>p 
  		;language-str-specific-params := ""	 
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str	Sun Aug  7 19:57:33 2011	(r23198)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/esv/to-esv.str	Mon Aug  8 08:40:03 2011	(r23199)
@@ -56,6 +56,7 @@
  						;sections := <conc>
  						 					(	 <inject-package-ctree><get-main-file-name>(),   // adding ctree import by default
 	 						 					 <inject-table-definition><get-main-file-name>(),   // default table definition
+	 						 					 //<inject-language-id><get-language-id> Package(package-qname),
 	 						 					 <all-keys-Declared-Language-Description>,
 	 			 								 <all-keys-Declared-Builders-Description> ,
 	 			 								 <all-keys-Declared-Colorer-Description> ,
@@ -65,11 +66,18 @@
 	 			 								 <all-keys-Declared-Completions-Description>,
 	 			 								 <map(get-original-module-declaration; template-module-to-esv)> module-qname*
  			 							   )
- 			|}
- 			;esv-aterm := Module(package-esv-main-name, Import([]), sections)
+ 			|};
+ 			// Adding language Id if not already added with language description
+ 			if <oncetd(?LanguageId(langid))>sections then
+ 				sections' := <filter(not(?[]))>sections 
+ 			else
+ 				sections' := <conc;filter(not(?[]))>(sections , <inject-language-id><get-language-id> Package(package-qname))
+ 			end
+ 			;esv-aterm := Module(package-esv-main-name, Import([]), sections')
+ 			;<debug-compiler> $[$[$ Codegen | Packed ESV |$]$ [<pp-aterm>esv-aterm]]  
  			;<save-artifact(WriteToBinaryFile | package-qname , root-directory , <get-main-output-path(|$[[<get-main-file-name>()].main], "esv")>(root-directory , package-qname))>esv-aterm
 		where
-			<debug-compiler>$[ Codegen | ESV | Finished generation of packed esv for [<pp-aterm>package-qname].]
+			<debug-compiler>$[$[$Codegen | ESV |$]$ Finished generation of packed esv for [<pp-aterm>package-qname].]
 
 	store-module-esv-definition : Module(QName(untyped-module-qname)) -> <id>
 	where
@@ -78,7 +86,9 @@
 		get-original-module-declaration;
  		store-esv-defintions
  		
-	
+	inject-language-id : 
+		lang-id -> [Language("Language Id Definition" , [LanguageId(lang-id)])]
+		
 	//Adding package ctree as the default semantic provider0
 	inject-package-ctree :
 		lang-name -> [Builders("",[SemanticProvider(lang-output-ctree)])]
@@ -88,7 +98,7 @@
 
 	// Injects the default table definition in ESV definition.
 	inject-table-definition :
-		lang-name -> [Language("Default Table Specifiactio" , [default-table-def])]
+		lang-name -> [Language("Default Table Specifiaction" , [default-table-def])]
 		where
 			default-table-def := Table($[include/[lang-name].tbl])
 
@@ -126,7 +136,7 @@
 
  	// Storing Esv Definitions that specifies Langauge
  	store-esv-def :
- 		l at Language(_,properties*) -> l
+ 		l at Language(_,_) -> l
  		with
  			rules ( Declared-Language-Description :+ l -> l)
 
@@ -136,7 +146,8 @@
  	* Storing Esv Definitions that specifies the builders for the
  	* language definition.
  	*/
- 	store-esv-def : b at Builders(_,_) -> b
+ 	store-esv-def: 
+ 		b at Builders(_,_) -> b
  		with
  			rules ( Declared-Builders-Description :+ b -> b)
 
@@ -144,7 +155,7 @@
  	* Storing Esv Definitions that specifies the colorer for the
  	* language definition.
  	*/
- 	store-esv-def : c at Colorer(_,_) -> c
+ 	store-esv-def : c at Colorer(_,[_|_]) -> c
  		with
  			rules ( Declared-Colorer-Description :+ c -> c)
 
@@ -152,7 +163,8 @@
  	* Storing Esv Definitions that specifies the folding semantics for the
  	* language definition.
  	*/
- 	store-esv-def : f at Folding(_,_) -> f
+ 	store-esv-def: 
+ 		f at Folding(_,_) -> f
  		with
  			rules ( Declared-Folding-Description :+ f -> f)
 
@@ -160,14 +172,16 @@
  	* Storing Esv Definitions that specifies the outliner for the
  	* language definition.
  	*/
- 	store-esv-def : o at Outliner(_,_) -> o
+ 	store-esv-def : 
+ 		o at Outliner(_,_) -> o
  		with
  			rules ( Declared-Outliner-Description :+ o -> o)
  	/**
  	* Storing Esv Definitions that specifies the code completion
  	* for the language definition.
  	*/
- 	store-esv-def : c at Completions(_,_) -> c
+ 	store-esv-def : 
+ 		c at Completions(_,_) -> c
  		with
  			rules ( Declared-Completions-Description:+ c -> c)
 
@@ -175,7 +189,8 @@
  	* Storing Esv Definitions that specifies the refencen resolving constructs
  	* for the language definition.
  	*/
- 	store-esv-def : r at References(_,_) -> r
+ 	store-esv-def : 
+ 		r at References(_,_) -> r
  		with
  			rules ( Declared-References-Description :+ r -> r)
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/common.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/common.str	Sun Aug  7 19:57:33 2011	(r23198)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/common.str	Mon Aug  8 08:40:03 2011	(r23199)
@@ -12,7 +12,7 @@
   lib/sdf-parenthesize
 imports 
 	include/SpoofaxLang
-
+	normalize/signatures
 imports 
 	utils/debug
 	utils/path
@@ -23,7 +23,8 @@
 rules 
 	get-project-path = (ProjectPath <+ project-path)
 
-
+	package-qname-to-string : Package(untyped-qname) ->  <convert-qname(|".");string-replace(|"-", ".")> 	untyped-qname
+	
 strategies 
 	//pretty printing aterm 
 	pp-aterm = disable-pp-aterm < !"N/A" + pp-aterm-forced

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str	Sun Aug  7 19:57:33 2011	(r23198)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/esv/declare.str	Mon Aug  8 08:40:03 2011	(r23199)
@@ -5,6 +5,7 @@
 	context/-
 	context/sdf/-
 	utils/debug
+	utils/path
 	common
 
 rules 
@@ -18,7 +19,11 @@
 
 rules
 	declare-esv-globals-top = 
-		alltd(declare-esv-definition)
+		alltd(declare-esv-definition);
+		if <not(get-language-id)>  <GetEnclosingPackageName> then
+			<declare-esv-definition>LanguageId(<package-qname-to-string> <GetEnclosingPackageName>)   
+		end
+			 
 		
 	declare-esv-definition : 
 		LanguageName(name)  -> <id>

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Sun Aug  7 19:57:33 2011	(r23198)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/resolve-declarations.str	Mon Aug  8 08:40:03 2011	(r23199)
@@ -116,11 +116,8 @@
 	// Otherwise, it throws <illegal argument exception>
 	get-all-imported-modules = 
 		where(?Package(_)); 
-		debug(!"1 : ") ; 
 		get-all-usings ; 
-		debug(!"2 : ");  
 		filter( ?Package(_)) ; 
-		debug(!"3 : "); 
 		mapconcat( get-enclosed-modules )
 	  
 	get-all-usings =  ?Package(<id>); debug(!"4 : ") ; get-all-usings 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str	Sun Aug  7 19:57:33 2011	(r23198)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/utils/path.str	Mon Aug  8 08:40:03 2011	(r23199)
@@ -34,7 +34,8 @@
 	convert-qname(|seperator) =
 		?QName(qname-parts*)
 		;<separate-by(|seperator);concat-strings>qname-parts*
-		
+	
+	
 rules
 	get-output-path(|prefix, extension)= 
 		?(dir-path, QName(qname-parts*))

From M.A.Akhter at student.tudelft.nl  Tue Aug  9 00:55:02 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 08 Aug 2011 22:55:02 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23200 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans: .
	codegen
Message-ID: <20110808225502.607A8108C012@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug  8 22:55:01 2011
New Revision: 23200
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23200&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Mon Aug  8 08:40:03 2011	(r23199)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Mon Aug  8 22:55:01 2011	(r23200)
@@ -28,6 +28,10 @@
 			
 		
 strategies 
+	build-spoofaxlang = build-all(generate-artifacts-all)
+	
+	build-spoofaxlang-incrementally = build-all(generate-artifacts-incrementally)
+		 
 	build-all(gen-code) = 
 		?current-term
 		;new-compile-session(

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str	Mon Aug  8 08:40:03 2011	(r23199)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str	Mon Aug  8 22:55:01 2011	(r23200)
@@ -24,7 +24,7 @@
 	libstratego-xtc 
 rules 
 		
-	build-spoofax-main:
+	build-spoofax-console:
 		arg  -> "" // local directory path is specified 
 		where 
 			xtc-io-wrap(
@@ -39,21 +39,46 @@
 				//<override-configured-source-directories><abspath>arg;
 				enable-command-line-mode;  
 				<show-configuration;debug>();     //show configuration for this spx project
-				<build-all>();                     //building all the spx files in the sources directory
+				<build-spoofaxlang>();                     //building all the spx files in the sources directory
 				<debug>$[".................Build-all succeeds................."];
 				!FILE($[[input]/.shadowdir/Globals/Signatures.str])	 //HACK : just to ensure this strategy is not failing ...
 			<+
 				prim("SSL_stacktrace_get_all_frame_names") ; report-failure
 		)
-	
 		
-	test-build-spoofax-main:
-		(selected, position, ast, path, project-path) -> None()
-	where 
-		<build-spoofax-main> "test"		
+  build-spoofaxlang-jvm:
+    current-project-location -> <id>
+    with 
+    	<debug(!"current-project-directory : ")>current-project-location 
+    with	
+	  	editor-init; 						         // cleaning up and initializing editors
+			rules(NoDebugInfo: _);           // HACK: disable origin use for now
+			rules(
+				ProjectPath := current-project-location
+				previous-working-dir := <getcwd>
+			);
+			<chdir>current-project-location				// setting current directory to the project location
+		<+
+			prim("SSL_stacktrace_get_all_frame_names") ; report-failure
 	
+		with	
+			<debug>$[Activating Project Configuration];
+			initialize-configuration;        	// initializes configuration and setting up enviroment variables
+			enable-command-line-mode;  
+			<show-configuration;debug>()     //show configuration for this spx project
+		<+
+			prim("SSL_stacktrace_get_all_frame_names") ; report-failure
+
+		with
+			<debug>$[Init Build];
+			<build-spoofaxlang>(); //building all the spx files in the sources directory
+			<chdir><previous-working-dir> ; 			// resetting working directory
+			<debug>$[Build Successful]
+		<+
+			prim("SSL_stacktrace_get_all_frame_names") ; report-failure
 
-	build-all:
+	  
+	build-all-service:
 		(selected, position, ast, path, project-path) -> None()
 		where
 			 <debug>$[.................starting compile + build all ..........................]
@@ -64,10 +89,11 @@
 		with
 	  	 enable-compiler-debugging
 	  	;<cache-currently-analyzing-ast>(<concat-strings>[project-path, "/" ,path] , ast)	 
-	  	;<build-all(generate-artifacts-all)>()
+	  	;<build-spoofaxlang>()
 	  	;disable-compiler-debugging
 	
-	build-incrementally:
+	
+	build-incrementally-service:
 		(selected, position, ast, path, project-path) -> None()
 		where
 			 <debug>$[.................starting compile + build all ..........................]
@@ -78,9 +104,10 @@
 		with
 	  	 enable-compiler-debugging
 	  	;<cache-currently-analyzing-ast>(<concat-strings>[project-path, "/" ,path] , ast)	 
-	  	;<build-all(generate-artifacts-incrementally)>()
+	  	;<build-spoofaxlang-incrementally>()
 	  	;disable-compiler-debugging
-	
+
+		
 		
 rules
 	//Intregation Test of the compile-all is working as expected 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Mon Aug  8 08:40:03 2011	(r23199)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/spoofaxlang.str	Mon Aug  8 22:55:01 2011	(r23200)
@@ -23,6 +23,8 @@
 	codegen/sdf/to-sdf
 	codegen/sdf/to-name-analysis
   codegen/sdf/to-signature
+  codegen/main
+  
 imports
 	normalize/main
 	normalize/signatures

From M.A.Akhter at student.tudelft.nl  Tue Aug  9 10:02:57 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 09 Aug 2011 08:02:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23201 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen
Message-ID: <20110809080257.489E2108C016@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Aug  9 08:02:56 2011
New Revision: 23201
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23201&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Mon Aug  8 22:55:01 2011	(r23200)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Tue Aug  9 08:02:56 2011	(r23201)
@@ -20,8 +20,8 @@
  		with 
 			 main-ant-output-file-name    := "build.spx.main.generated"
 			;autogen-ant-output-file-name := "build.spx.packages.generated"
-		  ;autogen-ant-output-path      := <concat-strings>[project-path  , "/build/" ,  autogen-ant-output-file-name , ".xml"]
-			;main-ant-output-path         := <concat-strings>[project-path  , "/build/" ,  main-ant-output-file-name    , ".xml"]
+		  ;autogen-ant-output-path      := <concat-strings>[project-path  , "/.build/" ,  autogen-ant-output-file-name , ".xml"]
+			;main-ant-output-path         := <concat-strings>[project-path  , "/.build/" ,  main-ant-output-file-name    , ".xml"]
 		with
 			 <dirname; ensure-directory-exists>autogen-ant-output-path  
 			;<save-to-file>(autogen-ant-output-path  , <get-ant-autogeneratedscript>())

From M.A.Akhter at student.tudelft.nl  Tue Aug  9 10:04:23 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 09 Aug 2011 08:04:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23202 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: . META-INF
Message-ID: <20110809080423.43760108C039@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Aug  9 08:04:23 2011
New Revision: 23202
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23202&sc=1

Log:
- added packagename org.strategoxt.imp.spoofax.trans 
- exporting it so that it can be referenced from metatooling project

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF	Tue Aug  9 08:02:56 2011	(r23201)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF	Tue Aug  9 08:04:23 2011	(r23202)
@@ -20,4 +20,4 @@
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Bundle-ActivationPolicy: lazy
 Export-Package: org.strategoxt.imp.editors.spoofax,
- trans
+ org.strategoxt.imp.editors.spoofax.trans

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml	Tue Aug  9 08:02:56 2011	(r23201)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml	Tue Aug  9 08:04:23 2011	(r23202)
@@ -7,8 +7,9 @@
         <property name="metasdfmodule" value="Stratego-SpoofaxLang"/>
         <property name="esvmodule" value="SpoofaxLang"/>
         <property name="strmodule" value="spoofaxlang"/>
-
-        <!-- Project directories -->
+				<property name="str.package-name" value="org.strategoxt.imp.editors.spoofax.trans"/>
+        
+				<!-- Project directories -->
         <property name="trans" location="trans"/>
         <property name="src-gen" location="editor/java"/>
         <property name="syntax" location="syntax"/>
@@ -42,9 +43,15 @@
 
         <import file="build.generated.xml"/>
 
-        <!-- Main target -->
+        <!-- Main target 
         <target name="all" depends="meta-sdf2table-stratego-sdf2,meta-sdf2table-stratego-esv,meta-sdf2table-strategostratego,spoofaximp.default.jar"/>
-
+				-->
+				
+				<target name="spoofaximp.edited.jar" depends="meta-sdf2table-stratego-sdf2,meta-sdf2table-stratego-esv,meta-sdf2table-strategostratego,check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,spx.stratego.jar,sdf2imp,refresh"/>
+	
+				<target name="all" depends = "spoofaximp.edited.jar"/>
+					
+	
         <!-- Target to create -Permissive grammar and parse table for Stratego-Sdf2.def -->
         <available file="include/Stratego-Sdf2.tbl" property="stratego-sdf2.available"/>
         <target name="meta-sdf2table-stratego-sdf2" unless="stratego-sdf2.available">
@@ -92,4 +99,79 @@
           </antcall>
           <antcall target="meta-sdf2table.helper" />
         </target>
+	
+  			<!-- Target Stratego to Java compiler -->
+        <target name="spx.stratego.jar" depends="rtg2sig,utils-files">
+        	<mkdir dir= "${src-gen}/org/strategoxt/imp/editors/spoofax/trans" />
+      		<property name="src-gen2" location="${src-gen}/org/strategoxt/imp/editors/spoofax/trans"/>
+                	
+      		<available file="${src-gen2}/Main.java" property="strc-java.available"/>
+        	<dependset>
+  	        <srcfileset dir="${basedir}">
+	            <include name="**/*.str"/>
+              <include name="**/*.astr"/>
+              <exclude name="lib/*.generated.str"/>
+            </srcfileset>
+            <targetfileset file="${src-gen2}/${strmodule}.java"/>
+	        </dependset>
+          
+        		
+          <antcall target="copy-jar"/>
+          <antcall target="spx.stratego.jar.deletehelper"/>
+          <antcall target="spx.stratego.jvm.helper">
+	          <param name="build.stratego.outputfile" value="${src-gen2}/${strmodule}.java"/>
+            <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
+          </antcall>
+        
+	    		<javac 
+	        	classpath="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}" 
+	        	srcdir="${src-gen}" 
+	        	includes="org/strategoxt/imp/editors/spoofax/trans/**" 
+	        	destdir="${build}" 
+	        	source="1.5" 
+	        	target="1.5" 
+	        	debug="on"/>
+        	
+          <!-- copy imported terms -->
+          <copy todir="${build}/org/strategoxt/imp/editors/spoofax/trans/">
+  	        <fileset dir="${src-gen2}" excludes="**/*.java"/>
+          </copy>
+          
+      		<jar basedir="${build}" includes="org/strategoxt/imp/editors/spoofax/trans/**" destfile="${include}/${strmodule}.tmp.jar"/>
+        	
+      	  <move file="${include}/${strmodule}.tmp.jar" tofile="${include}/${strmodule}.jar"/>
+          <delete><fileset dir="${build}" includes="trans/**"/></delete>
+        </target>
+	 			
+				
+				<target name="spx.stratego.jar.deletehelper">
+  	      <delete>
+	          <fileset dir="${src-gen2}" includes="**"/>
+            <fileset dir="${build}" includes="trans/**"/>
+	        </delete>
+        </target>
+	
+				<target name="spx.stratego.jvm.helper" unless="strc-java.available" if="build.stratego.enabled">
+  	      <echo> Main Class  : ${build.stratego.outputfile}</echo>
+					<echo> PackageName : ${str.package-name}</echo>
+					
+					<delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+          <java classname="org.strategoxt.strj.Main" failonerror="true">
+            <arg value="-i"/>
+            <arg value="${trans}/${strmodule}.str"/>
+            <arg value="-o"/>
+            <arg value="${build.stratego.outputfile}"/>
+            <arg value="-p"/>
+            <arg value="${str.package-name}"/> <!-- Added package Name. TODO: Consider to persist this changes for all the Spoofax projects -->
+            <arg value="--library"/>
+            <arg value="--clean"/>
+            <arg line="${build.stratego.args}"/>
+            <arg line="${build.stratego.extraargs}"/>
+            <arg line="${externaljarflags}"/>
+            <arg line="${externaldefimport}"/>
+            <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+          </java>
+          <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+          <mkdir dir="${build}/trans"/>
+        </target>
 </project>

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 11:45:49 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 09:45:49 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23203 - in
	spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator: .
	.externalToolBuilders .settings META-INF icons lib
	lib/asfix-tools lib/asfix-tools/trans lib/java-fron...
Message-ID: <20110810094549.258D2108C042@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 09:45:48 2011
New Revision: 23203
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23203&sc=1

Log:
org.strategoxt.imp.spoofax.generator project

Added:
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.classpath
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.disable-global-analysis
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.externalToolBuilders/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.externalToolBuilders/SpoofaxGenerator build.main.xml.launch
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.project
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.settings/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.settings/org.eclipse.jdt.core.prefs
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/META-INF/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/META-INF/MANIFEST.MF
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.main.helper.xml
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.main.xml
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.properties
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/Thumbs.db   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/file.gif   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/file_error.gif   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/file_warning.gif   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/outline_item.gif   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/sample.gif   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/StrategoMix.def
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/trans/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/trans/AsFix.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/trans/asfix-extra.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/aster.jar   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/Stratego-Java-15.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/Stratego-Java-EBlock.def
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/JavaMix.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/arrays/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/arrays/ArrayInitializers.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/arrays/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/ClassDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/ConstructorDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/EnumDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/FieldDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/InstanceInitializers.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/MethodDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/StaticInitializers.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ArrayAccess.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ArrayCreation.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/AssignmentOperators.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/BinaryOperators.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ClassInstanceCreation.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/FieldAccess.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/MethodInvocation.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Postfix.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Primary.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Priorities.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Restrictions.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/UnaryOperators.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/AbstractMethodDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/AnnotationTypes.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/Annotations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/ConstantDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/InterfaceDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Comments.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Identifiers.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Keywords.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/LineTerminators.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Modifiers.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/UnicodeEscapes.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/WhiteSpace.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/BooleanLiterals.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/CharacterLiterals.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/EscapeSequences.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/FloatingPointLiterals.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/IntegerLiterals.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/NullLiteral.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/StringLiterals.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/names/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/names/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/CompilationUnits.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/ImportDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/PackageDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/TypeDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Blocks.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/LocalVariableDeclarations.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Statements.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/ParameterizedTypes.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/PrimitiveTypes.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/ReferenceTypes.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/TypeVariables.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/EmbeddedJava.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/EmbeddedJavaMix.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/ConcatIds.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/JavaEBlockMix.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/Main.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/make_permissive.jar   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/pgen/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/pgen/Sdf2.baf   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/sdf-front/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/sdf-front/trans/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/sdf-front/trans/Sdf2.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/sdf2imp.jar   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/spoofaxgenerator.jar   (contents, props changed)
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/pp/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/pp/Stratego-Sugar-pretty.pp.af
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/syntax/StrategoRenamed.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Atoms.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Base.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Disambiguation.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Layout.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Literal.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Operators.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Stratego-Box.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/trans/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/trans/Box.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/spec/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/spec/collection/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/spec/collection/list/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/spec/collection/list/cons.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/ssl-compat/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/ssl-compat/list-cons.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/Stratego-rtg.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/regexp.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-identifier.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-layout.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-nonterm.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-term.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rtg.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/Stratego-xml-info.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/Stratego-xml.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-attribute.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-comments.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-document.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-external.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-lexical.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-names.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-pi.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-prolog.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-text.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-whitespace.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc2abox.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc2abox.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/tools/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/tools/strategoxt-xtc-tools.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/xtc.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/SpoofaxGenerator.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/RTG.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/asfix-abstractions.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/core-sdf-grammar2rtg.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/core-sdf-grammar2rtg.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/debug.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/multi-options.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/pack-sdf-options.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/pack-sdf.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf-desugar.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf-options.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf2rtg.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/xml-doc2abox.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/xml-doc2abox.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/main.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/main.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/options.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/copy-def-file.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/copy-jars.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-activator.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-activator.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-properties.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-xml.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-builder-xml.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-classpath.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-common-trans.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-example-file.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-example-trans.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-grammar.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-java-strategy.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-jdt-prefs.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-manifest.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-packed-descriptor-file.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-controller.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-controller.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-table.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-plugin-xml.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-pp-table.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-project-file.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-adapters.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-common-trans.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-definitions.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-lexicalconstructs.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-validator.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-validator.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/ast-form-heuristic.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/ast-form-heuristic.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/check-validity.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/common.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/common.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/configure-main-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-builders-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-builders-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-colorer-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-colorer-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-completions-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-completions-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-folding-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-folding-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-references-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-references-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-editorservices.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-language-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-syntax-descriptor.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-syntax-descriptor.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/class-naming.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/construct-text.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/ide-support.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/input.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/origin-tracking.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/output.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/pp.meta
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/pp.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/BuildersService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/ColorerService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Comments.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Common.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/CompletionsService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService-pretty.pp
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService.generated.pp
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/FoldingService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/LanguageDescription.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/OutlinerService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/RefactoringsService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/ReferencesService.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/SemanticServices.sdf
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Stratego-Java-EditorService.generated.pp
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Stratego-Java-EditorService.sdf

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.classpath
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.classpath	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="lib" path="lib/aster.jar"/>
+	<classpathentry exported="true" kind="lib" path="lib/spoofaxgenerator.jar" sourcepath="src-gen"/>
+	<classpathentry exported="true" kind="lib" path="lib/make_permissive.jar" sourcepath="/permissive-grammars/trans/make-permissive/bin"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.disable-global-analysis
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.disable-global-analysis	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.externalToolBuilders/SpoofaxGenerator build.main.xml.launch
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.externalToolBuilders/SpoofaxGenerator build.main.xml.launch	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ui.externaltools.ProgramBuilderLaunchConfigurationType">
+<stringAttribute key="org.eclipse.debug.core.ATTR_REFRESH_SCOPE" value="${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot; factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; label=&quot;working set&quot; name=&quot;working set&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/org.strategoxt.imp.spoofax.generator/lib&quot; type=&quot;2&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/org.strategoxt.imp.spoofax.generator/src-gen&quot; type=&quot;2&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
+<listEntry value="/org.strategoxt.imp.spoofax.generator"/>
+</listAttribute>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
+<listEntry value="4"/>
+</listAttribute>
+<booleanAttribute key="org.eclipse.debug.core.appendEnvironmentVariables" value="true"/>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="true"/>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value="org.strategoxt.imp.spoofax.generator"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="all,"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_BUILD_SCOPE" value="${working_set:&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;launchConfigurationWorkingSet editPageId=&quot;org.eclipse.ui.resourceWorkingSetPage&quot; factoryID=&quot;org.eclipse.ui.internal.WorkingSetFactory&quot; label=&quot;str in metatooling&quot; name=&quot;str in metatooling&quot;&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/org.strategoxt.imp.spoofax.generator/src/syntax&quot; type=&quot;2&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/org.strategoxt.imp.spoofax.generator/src/spoofaxgenerator.str&quot; type=&quot;1&quot;/&gt;&#10;&lt;item factoryID=&quot;org.eclipse.ui.internal.model.ResourceFactory&quot; path=&quot;/org.strategoxt.imp.spoofax.generator/src/spoofaxgenerator&quot; type=&quot;2&quot;/&gt;&#10;&lt;/launchConfigurationWorkingSet&gt;}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/org.strategoxt.imp.spoofax.generator/build.main.xml}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_RUN_BUILD_KINDS" value="full,incremental,"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_TOOL_ARGUMENTS" value="jar"/>
+<booleanAttribute key="org.eclipse.ui.externaltools.ATTR_TRIGGERS_CONFIGURED" value="true"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/org.strategoxt.imp.spoofax.generator}"/>
+</launchConfiguration>
+
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.project
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.project	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.strategoxt.imp.spoofax.generator</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>
+			<triggers>full,incremental,</triggers>
+			<arguments>
+				<dictionary>
+					<key>LaunchConfigHandle</key>
+					<value>&lt;project&gt;/.externalToolBuilders/SpoofaxGenerator build.main.xml.launch</value>
+				</dictionary>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.settings/org.eclipse.jdt.core.prefs
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/.settings/org.eclipse.jdt.core.prefs	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,62 @@
+#Thu Nov 13 14:48:06 CET 2008
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=ignore
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=disabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=ignore
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=ignore
+org.eclipse.jdt.core.compiler.problem.fieldHiding=ignore
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=ignore
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=ignore
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=ignore
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nullReference=ignore
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=ignore
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=ignore
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=ignore
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=ignore
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=ignore
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.source=1.5

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/META-INF/MANIFEST.MF
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/META-INF/MANIFEST.MF	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,25 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: Spoofax/IMP Metatooling
+Bundle-SymbolicName: org.strategoxt.imp.spoofax.generator;singleton:=true
+Bundle-Version: 0.1.2.qualifier
+Bundle-ClassPath: lib/make_permissive.jar,
+ lib/sdf2imp.jar,
+ lib/aster.jar,
+ lib/spoofaxgenerator.jar
+Require-Bundle: org.spoofax.jsglr,
+ org.spoofax.interpreter.core,
+ org.spoofax.interpreter.library.jsglr,
+ org.eclipse.core.runtime,
+ org.eclipse.core.resources,
+ org.junit,
+ org.eclipse.swt,
+ org.spoofax.compiler,
+ org.strategoxt.strj,
+ org.eclipse.ant.core
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-ActivationPolicy: lazy
+Bundle-Vendor: Spoofax.org
+Export-Package: org.strategoxt.aster,
+ org.strategoxt.imp.spoofax.generator,
+ org.strategoxt.permissivegrammars

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.main.helper.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.main.helper.xml	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,619 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<project name="build.spx.imp.generator.helper">
+
+       
+       <!--
+        <target name="spoofaximp.default" depends="spoofaximp.default.ctree"/>
+		<target name="spoofaximp.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.ctree,sdf2imp,refresh"/>
+        <target name="spoofaximp.default.jar" depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,stratego.jar.helper,sdf2imp,refresh"/>
+    -->
+        <!-- Initialization -->
+        <available file="${build}/org/strategoxt/imp/spoofax/generator/Main.class" property="java.jar.enabled"/>
+        <condition property="java.jar.import" value="" else="">
+            <isset property="java.jar.enabled"/>
+        </condition>
+        <condition property="java.jar.classpath" value=":${include}/${strmodule}-java.jar" else="">
+            <isset property="java.jar.enabled"/>
+        </condition>
+        <available file="${trans}/${strmodule}.str" property="build.stratego.enabled"/>
+        <dirname property="externaldefdir" file="${externaldef}"/>
+        <condition property="externaldefimport" value="-I &quot;${externaldefdir}&quot;" else="">
+            <isset property="externaldef"/>
+        </condition>
+        <condition property="externaljarimport1" value=":${externaljar}" else="">
+            <isset property="externaljar"/>
+        </condition>
+        <condition property="externaljarimport2" value=":${externaljarx}" else="">
+            <isset property="externaljarx"/>
+        </condition>
+        <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
+            <isset property="eclipse.running"/>
+        </condition>
+        <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
+            <available classname="org.eclipse.jdt.core.JDTCompilerAdapter"/>
+        </condition>
+        <condition property="externaljarflags" value="${externaljarflags}" else="">
+            <isset property="externaljarflags"/>
+        </condition>
+        <condition property="metasdfmodule.available" value="1">
+            <available file="${syntax}/${metasdfmodule}.sdf"/>
+        </condition>
+        
+        <fail unless="build" message="Please use build.main.xml to build this project or configure the required properties manually"/>
+        <mkdir dir="${build}"/>
+        <mkdir dir="${src-gen}"/>
+        <mkdir dir="${dist}"/>
+        <mkdir dir="${include}"/>
+        <mkdir dir="${lib}"/>
+        <mkdir dir="${syntax}"/>
+
+        <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone"/>
+        
+	<target name="sdf2imp.eclipse" if="eclipse.running" depends="sdf2rtg">
+    	<java classname="org.strategoxt.imp.metatooling.building.AntDescriptorBuilder" failonerror="true">
+	        <arg value="${include}/${esvmodule}.packed.esv"/>
+        </java>
+    </target>
+        
+    <target name="refresh" if="eclipse.running">
+            <eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
+            <eclipse.convertPath fileSystemPath="${syntax}" property="syntaxdir"/>
+            <eclipse.convertPath fileSystemPath="${lib}" property="libdir"/>
+        	<eclipse.convertPath fileSystemPath="${src-gen}" property="eclipse.path.src-gen"/>
+            	
+            <eclipse.refreshLocal resource="${libdir}" depth="infinite"/>
+        	<eclipse.refreshLocal resource="${libdir}/java-front" depth="infinite"/>
+        	
+        	<eclipse.refreshLocal resource="${projectdir}/build.generated.xml" depth="infinite"/>
+			<eclipse.refreshLocal resource="${projectdir}/src/syntax" depth="infinite"/>
+        	<eclipse.refreshLocal resource="${projectdir}/src/sdf2imp" depth="infinite"/>
+        	            
+        	<eclipse.refreshLocal resource="${syntaxdir}/${editorservice}.pp.generated" depth="infinite"/>
+        	
+        	<eclipse.refreshLocal resource="${eclipse.path.src-gen}" depth="infinite"/>
+            <eclipse.convertPath fileSystemPath="${build}" property="eclipse.path.build"/>
+            <eclipse.refreshLocal resource="${eclipse.path.build}" depth="infinite"/>
+            
+        </target>
+        
+    <target name="sdf2imp.standalone" unless="eclipse.running" depends="sdf2rtg">
+        <java classname="org.strategoxt.imp.generator.sdf2imp" failonerror="true">
+            <arg value="-i"/>
+            <arg value="${basedir}/editor/${esvmodule}.main.esv"/>
+            <arg value="-p"/>
+            <arg value="${include}/${sdfmodule}.tbl"/>
+        </java>
+    </target>
+
+	<target name="sdf2table-main" depends="make-permissive-main">
+		
+		<antcall target="sdf2table">
+			<param name="sdfmodule" value = "${editorservice}"/>
+		</antcall>
+		
+		<antcall target="sdf2table">
+			<param name="sdfmodule" value = "${str-java-editorservice}"/>
+		</antcall>
+		
+		<!-- Generating *.TBL from the *.DEF specified in LIB-->	
+		<antcall target="sdf2table">
+			<param name="sdfmodule" value = "Stratego-xml"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+		<antcall target="sdf2table">
+			<param name="sdfmodule" value = "Stratego-rtg"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+		<antcall target="sdf2table">
+			<param name="sdfmodule" value = "Stratego-Box"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+		<antcall target="sdf2table">
+			<param name="sdfmodule" value = "Stratego-Java-15"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+	</target>	
+	
+	<target name = "make-permissive-main" depends= "pack-sdf-main"> 
+		<antcall target="make-permissive">
+			<param name="sdfmodule" value = "${editorservice}"/>
+		</antcall>
+		<antcall target="make-permissive">
+			<param name="sdfmodule" value = "${str-java-editorservice}"/>
+		</antcall>
+		<antcall target="make-permissive">
+			<param name="sdfmodule" value = "Stratego-xml"/>
+		</antcall>
+		<antcall target="make-permissive">
+			<param name="sdfmodule" value = "Stratego-rtg"/>
+		</antcall>
+		<antcall target="make-permissive">
+			<param name="sdfmodule" value = "Stratego-Box"/>
+		</antcall>
+		
+		<antcall target="make-permissive">
+			<param name="sdfmodule" value = "Stratego-Java-15"/>
+		</antcall>
+		
+		<antcall target="meta-sdf2table.helper" />
+	</target>
+	
+	<target name="pack-sdf-main" > 
+		<antcall target="pack-sdf">
+			<param name = "sdfmodule" value = "${editorservice}"/>
+			<param name = "build.sdf.imports" value=""/>
+		</antcall>
+		
+		<antcall target="pack-sdf">
+			<param name="sdfmodule"         value = "${str-java-editorservice}"/>
+			<param name="build.sdf.imports" value="-Idef ${java-front}/Stratego-Java-EBlock.def -Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+		<antcall target="pack-sdf">
+			<param name="syntax" value = "${xml-front}\syntax"/>
+			<param name="sdfmodule" value = "Stratego-xml"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${lib}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+		<antcall target="pack-sdf">
+			<param name="syntax" value = "${lib}\stratego-rtg\syntax"/>
+			<param name="sdfmodule" value = "Stratego-rtg"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${lib}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+		<antcall target="pack-sdf">
+			<param name="syntax" value = "${lib}\stratego-gpp\syntax"/>
+			<param name="sdfmodule" value = "Stratego-Box"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${lib}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+		
+		<antcall target="pack-sdf">
+			<param name="syntax" value = "${java-front}"/>
+			<param name="sdfmodule" value = "Stratego-Java-15"/>
+			<param name="build.sdf.imports" value="-Idef &quot;${lib}/StrategoMix.def&quot; ${build.sdf.imports}" />
+		</antcall>
+	</target>
+	
+	<!-- Generating Signature files from RTG Definitions -->
+	<target name = "rtg2sig-main" if="build.stratego.enabled" depends="sdf2rtg-main">
+		<antcall target="rtg2sig">
+			<param name="sdfmodule" value = "${editorservice}"/>
+		</antcall>	
+		
+		<antcall target="rtg2sig">
+			<param name="sdfmodule" value = "${str-java-editorservice}"/>
+		</antcall>
+	</target>	
+	
+	<target name="sdf2rtg-main" depends="pack-sdf-main" >
+			<antcall target="sdf2rtg">
+				<param name="sdfmodule" value = "${editorservice}"/>
+			</antcall>
+			<antcall target="sdf2rtg">
+				<param name="sdfmodule" value = "${str-java-editorservice}"/>
+			</antcall>
+	</target>
+		
+	 
+	
+    <target name="check-classpath">
+        <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
+        <antcall target="check-classpath.helper"/>  
+    </target>
+    
+    <target name="init" if="eclipse.running">
+        <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+        <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+            <arg value="${include}"/>
+        </java>
+    </target>
+  
+    <target name="check-classpath.helper" unless="check-classpath.available">
+        <echo level="error" message="Could not load the Spoofax plugin loading classes."/>
+        <echo level="error" message="Make sure it is on the class path."/>
+        <echo level="error" message=""/>               
+        <echo level="error" message="In Eclipse, make sure the Ant builder is configured properly:"/>
+        <echo level="error" message="right-click on build.main.xml, go to Run as, Ant build..., JRE tab,"/>
+        <echo level="error" message="and ensure Run in the same JRE as the workspace is selected"/>
+        <echo level="error" message="alternatively, build the project using Build Project in the Project menu"/>
+        <fail/>
+    </target>
+    
+	<target name="sdf2table">
+        <apply executable="${build.strategoxt.sdf}sdf2table" dest="${include}" failonerror="true">
+            <arg value="-i"/>
+            <srcfile/>
+            <arg value="-o"/>
+            <targetfile/>
+            <arg value="-m"/>
+            <arg value="${sdfmodule}"/>
+            
+            <fileset file="${include}/${sdfmodule}-Permissive.def"/>
+            <mapper type="glob" from="*-Permissive.def" to="*.tbl"/>
+        </apply>
+    </target>
+	
+    <target name="make-permissive">
+        <dependset>
+            <srcfileset file="${include}/${sdfmodule}.def"/>
+            <targetfileset file="${include}/${sdfmodule}-Permissive.def"/>
+        </dependset>
+        <available file="${include}/${sdfmodule}-Permissive.def" property="permissive-grammar.available"/>
+        <antcall target="make-permissive.helper"/>
+    </target>
+
+    <target name="make-permissive.helper" unless="permissive-grammar.available">
+        <java classname="org.strategoxt.permissivegrammars.make_permissive" failonerror="true">
+            <arg value="-i"/>
+            <arg value="${include}/${sdfmodule}.def"/>
+            <arg value="-o"/>
+            <arg value="${include}/${sdfmodule}-Permissive.def"/>
+            <arg line="--optimize on"/>
+        </java>
+    </target>
+	
+    <target name="meta-sdf2table" if="metasdfmodule.available">
+        <fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def"/>
+        <antcall target="sdf2table">
+            <param name="sdfmodule" value="${metasdfmodule}"/>
+            <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}"/>
+        </antcall>
+        <antcall target="meta-sdf2table.helper"/>
+    </target>
+        
+    <target name="meta-sdf2table.helper" if="eclipse.running">
+       <eclipse.convertPath fileSystemPath="${include}" property="includeresource"/>
+       <eclipse.refreshLocal resource="${includeresource}/${metasdfmodule}.tbl" depth="infinite"/>
+    </target>
+ 
+    <target name="utils-files"> <!-- only useful for builds outside of Eclipse -->
+            <mkdir dir="utils"/>
+            <copy file="${eclipse.spoofaximp.jars}/make_permissive.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/sdf2imp.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.jars}/aster.jar" todir="utils" failonerror="false"/>
+            <copy file="${eclipse.spoofaximp.strategojar}" todir="utils" failonerror="false"/>
+        </target>
+		
+	<target name="pack-sdf" unless="externaldef">
+        <dependset>
+            <srcfileset dir="${syntax}">
+                <include name="**/*.sdf"/>
+            </srcfileset>
+            <srcfileset dir="${lib}">
+                <include name="**/*.def"/>
+            </srcfileset>
+            <targetfileset file="${include}/${sdfmodule}.def"/>
+        </dependset>
+  
+    	<available file="${include}/${sdfmodule}.def" property="pack-sdf.available"/>
+    	
+		<antcall target = "pack-sdf.helper">
+    		<param name = "sdfmodule"  value = "${sdfmodule}"/>
+    		<param name = "build.sdf.imports" value="${build.sdf.imports}"/>
+    	</antcall>		
+    </target>
+    
+    <target name="pack-sdf.helper" unless="pack-sdf.available">
+        <condition property="utils-include" value="-I ${utils}" else="">
+            <available file="${utils}"/>
+        </condition>
+        <java classname="run" failonerror="true">
+            <arg value="org.strategoxt.tools.main-pack-sdf"/>
+            <arg value="-i"/>
+            <arg value="${syntax}/${sdfmodule}.sdf"/>
+            <arg value="-o"/>
+            <arg value="${include}/${sdfmodule}.def"/>
+            <arg value="-I"/>
+            <arg value="${syntax}"/>
+            <arg value="-I"/>
+            <arg value="${lib}"/>
+            <arg line="${utils-include}"/>
+            <arg line="${build.sdf.imports}"/>
+        </java>
+    </target>
+    
+    <target name="copy-sdf" if="externaldef">
+        <copy file="${externaldef}" tofile="${include}/${sdfmodule}.def" preservelastmodified="true"/>
+    </target>
+
+    <target name="copy-jar" if="externaljar">
+        <copy file="${externaljar}" todir="${include}" preservelastmodified="true"/>
+    </target>
+	
+	   <target name="sdf2rtg">
+        <dependset>
+            <srcfileset file="${include}/${sdfmodule}.def"/>
+            <targetfileset file="${include}/${sdfmodule}.rtg"/>
+        </dependset>
+        <available file="${include}/${sdfmodule}.rtg" property="sdf2rtg.available"/>
+        <antcall target="sdf2rtg.helper"/>
+    </target>
+	
+    <target name="sdf2rtg.helper" unless="sdf2rtg.available">
+        <java classname="run" failonerror="true">
+            <arg value="org.strategoxt.tools.main-sdf2rtg"/>
+            <arg value="-i"/>
+            <arg value="${include}/${sdfmodule}.def"/>
+            <arg value="-m"/>
+            <arg value="${sdfmodule}"/>
+            <arg value="-o"/>
+            <arg value="${include}/${sdfmodule}.rtg"/>
+            <arg value="--ignore-missing-cons"/>
+            <arg value="-Xnativepath"/>
+            <arg value="${build.strategoxt.sdf}"/>
+        </java>
+    </target>
+		
+	<target name="rtg2sig" if="build.stratego.enabled">
+        <dependset>
+            <srcfileset file="${include}/${sdfmodule}.rtg"/>
+            <targetfileset file="${include}/${sdfmodule}.str"/>
+        </dependset>
+        <available file="${include}/${sdfmodule}.str" property="rtg2sig.available"/>
+        <antcall target="rtg2sig.helper"/>
+    </target>
+    
+    <target name="rtg2sig.helper" unless="rtg2sig.available">
+        <java classname="run" failonerror="true">
+            <arg value="org.strategoxt.tools.main-rtg2sig"/>
+            <arg value="-i"/>
+            <arg value="${include}/${sdfmodule}.rtg"/>
+            <arg value="-o"/>
+            <arg value="${include}/${sdfmodule}.str"/>
+            <arg value="--module"/>
+            <arg value="${sdfmodule}"/>
+        </java>
+    </target>
+        	
+		<target name="ppgen-main"  depends="pack-sdf-main"> 
+			<antcall target="ppgen">
+				<param name="sdfmodule" value = "${editorservice}"/>
+			</antcall>
+			<antcall target="ppgen">
+				<param name="sdfmodule" value = "${str-java-editorservice}"/>
+			</antcall>
+		</target>
+	 	
+		<target name="pppack-main" depends="pack-sdf-main"> 
+			<antcall target="pppack">
+				<param name="sdfmodule" value = "${editorservice}-pretty"/>
+			</antcall>
+			<antcall target="pppack">
+				<param name="sdfmodule" value = "${str-java-editorservice}"/>
+			</antcall>
+		</target>
+	
+	
+        <target name="ppgen" if="build.stratego.enabled">
+            <dependset>
+                <srcfileset file="${include}/${sdfmodule}.def"/>
+                <targetfileset file="${syntax}/${sdfmodule}.generated.pp"/>
+                <targetfileset file="${include}/${sdfmodule}.generated.pp.af"/>
+            </dependset>
+            <available file="${include}/${sdfmodule}.generated.pp.af" property="ppgen.available"/>
+            <antcall target="ppgen.helper"/>
+            <available file="${include}/${sdfmodule}.generated.pp.af" property="ppgen.available"/>
+            <antcall target="ppgen.helper.fallback"/>
+        </target>
+    
+        <target name="ppgen.helper" unless="ppgen.available">
+            <!-- Any failures here are ignored; they are only a problem when imported from Stratego -->
+            <java classname="run" failonerror="false">
+                <arg value="org.strategoxt.tools.main-ppgen"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.def"/>
+                <arg value="-t"/>
+                <arg value="-b"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.generated.pp.af"/>
+            </java>
+            <java classname="run" failonerror="false">
+                <arg value="org.strategoxt.tools.main-pp-pp-table"/>
+                <arg value="-i"/>
+                <arg value="${include}/${sdfmodule}.generated.pp.af"/>
+                <arg value="-o"/>
+                <arg value="${syntax}/${sdfmodule}.generated.pp"/>
+            </java>
+        </target>
+    
+        <target name="ppgen.helper.fallback" unless="ppgen.available">
+            <echo file="${include}/${sdfmodule}.generated.pp.af" message="PP-Table([])"/>
+        </target>
+        
+        <target name="pppack" if="build.stratego.enabled" >
+            <dependset>
+                <srcfileset file="${syntax}/${sdfmodule}.pp"/>
+                <targetfileset file="${include}/${sdfmodule}.pp.af"/>
+            </dependset>
+            <available file="${syntax}/${sdfmodule}.pp" property="pppack.source-available"/>
+            <antcall target="pppack.helper"/>
+            <available file="${include}/${sdfmodule}.pp.af" property="pppack.available"/>
+            <antcall target="pppack.helper.fallback"/>
+        </target>
+    
+        <target name="pppack.helper" unless="pppack.available" if="pppack.source-available">
+            <java classname="run" failonerror="true">
+                <arg value="org.strategoxt.tools.main-parse-pp-table"/>
+                <arg value="-i"/>
+                <arg value="${syntax}/${sdfmodule}.pp"/>
+                <arg value="-o"/>
+                <arg value="${include}/${sdfmodule}.pp.af"/>
+            </java>
+        </target>
+    
+        <target name="pppack.helper.fallback" unless="pppack.available">
+            <echo file="${include}/${sdfmodule}.pp.af" message="PP-Table([])"/>
+        </target>
+    
+        <!-- Aster to Stratego -->
+        <target name="stratego.aster">
+            <available file="${trans}/${strmodule}.rtree" property="aster-output.available"/>
+            <fileset dir="${basedir}" id="aster-input-set">
+              <include name="**/*.astr"/>
+            </fileset>
+            <pathconvert pathsep=" " setonempty="false" property="aster-input" refid="aster-input-set"/>
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.astr"/>
+                </srcfileset>
+                <targetfileset file="${trans}/${strmodule}.rtree"/>
+            </dependset>
+            <condition property="aster-output.uptodate">
+                <and>
+                    <isset property="aster-output.available"/>
+                    <available file="${trans}/${strmodule}.rtree"/>
+                </and>
+            </condition>
+            <available file="${trans}/${strmodule}.rtree" property="aster-output.uptodate"/>
+            <antcall target="stratego.aster.helper"/>
+        </target>
+    
+        <target name="stratego.aster.helper" if="aster-input" unless="aster-output.uptodate">
+            <java classname="org.strategoxt.aster.Main" failonerror="true">
+                <arg value="-i"/>
+                <arg line="${aster-input}"/>
+            </java>
+        </target>
+        
+        <target name="java.jar" if="java.jar.enabled">
+            <jar basedir="${build}" excludes="trans/**" update="true" destfile="${include}/${strmodule}-java.jar"/>
+        </target>
+    
+        <!-- Stratego to Java interpreter -->
+        <target name="stratego.ctree" depends="rtg2sig-main">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.str"/>
+                    <include name="**/*.astr"/>
+                    <exclude name="lib/*.generated.str"/>
+                </srcfileset>
+                <targetfileset file="${include}/${strmodule}.ctree"/>
+            </dependset>
+            <available file="${include}/${strmodule}.ctree" property="strc-java.available"/>
+            <antcall target="copy-jar"/>
+            <antcall target="stratego.jvm.helper">
+                <param name="build.stratego.outputfile" value="${include}/${strmodule}.ctree"/>
+                <param name="build.stratego.extraargs" value="-F"/>
+            </antcall>
+        </target>
+    
+        <!-- Stratego to Java compiler -->
+        <target name="stratego.jar" depends="sdf2table-main,rtg2sig-main,utils-files">
+            <dependset>
+                <srcfileset dir="${basedir}">
+                    <include name="**/*.str"/>
+                    <include name="**/*.astr"/>
+                    <exclude name="lib/*.generated.str"/>
+                </srcfileset>
+                <targetfileset file="${src-gen}/trans/Main.java"/>
+            </dependset>
+            <available file="${src-gen}/trans/Main.java" property="strc-java.available"/>
+            <antcall target="copy-jar"/>
+            <antcall target="stratego.jar.deletehelper"/>
+            
+          <property name="build.stratego.packagename" value="org.strategoxt.imp.spoofax.generator"/>
+        	<antcall target="stratego.jvm.helper">
+              <param name="build.stratego.outputfile" value="${src-gen}/${strmodule}.java"/>
+              <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
+          </antcall>
+        	
+        	<javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport1}${externaljarimport2}${java.jar.classpath}" 
+        	        		   srcdir="${src-gen}" 
+        	        		   destdir="${build}" 
+        	        		   source="1.5" 
+        	        		   target="1.5" 
+        	        		   debug="on">	
+    				<compilerarg line = "-J-Xmx256m -J-Xms100m -J-server -J-XX:+UseParallelGC -nowarn "/>
+        	</javac>
+
+  		<!-- copy imported terms -->
+      <copy todir="${build}/org/strategoxt/imp/spoofax/generator">
+        <fileset dir="${src-gen}" excludes="**/*.java"/>
+      </copy>
+      
+    	<!-- creating MENIFEST FILE  -->
+    	<mkdir dir = "${build}/META-INF"/>
+			<property name="build.stratego.manifestfile.path" value="${build}/META-INF/MANIFEST.MF"/>
+    
+    	<antcall target="create-manifest.stratego.jar">
+	    	<param name="sdf2imp.Class-Path" value = "strategoxt.jar"/>
+				<param name="sdf2imp.Main-Class" value = "${build.stratego.packagename}.${strmodule}"/>
+			</antcall>	
+          
+    	<jar 
+      	basedir="${build}" 
+      	includes="org/strategoxt/imp/spoofax/generator/**" 
+        destfile="${include}/${outputjar}.tmp.jar"
+        manifest="${build.stratego.manifestfile.path}"
+      />
+    	    
+      <move file="${include}/${outputjar}.tmp.jar" tofile="${include}/${outputjar}.jar" failonerror="true"/>
+  		<copy file="${include}/${outputjar}.jar" todir="${lib}" failonerror="true"/>
+      <delete>
+      	<fileset dir="${build}" includes="org/strategoxt/imp/spoofax/generator/**"/>
+      	<fileset dir="${build}" includes="META-INF/**"/>
+      </delete>
+    </target>
+		
+	<tstamp>
+        <format property="timestamp.isoformat"  pattern="yyyy-mm-dd'T'HH:mm:ss" locale="en"/>
+    </tstamp>
+            		
+		
+    <!-- Creates Menifest files  for STRATEGO jar -->            			
+    <target name="create-manifest.stratego.jar" description="Create menifast file for *jar" >
+        <manifest file="${build.stratego.manifestfile.path}">
+            <attribute name="Built-On" value="${timestamp.isoformat}"/>
+            <attribute name="Class-Path" value="${sdf2imp.Class-Path}"/>
+            <attribute name="Main-Class" value="${sdf2imp.Main-Class}"/>
+        </manifest>
+    </target>
+
+		<target name="stratego.jar.deletehelper" unless="strc-java.available">
+            <delete>
+                <fileset dir="${src-gen}" includes="trans/**"/>
+                <fileset dir="${build}" includes="trans/**"/>
+            </delete>
+        </target>
+            
+        <target name="stratego.jvm.helper" unless="strc-java.available" if="build.stratego.enabled">
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+        	
+        	<java classname="org.strategoxt.strj.Main" failonerror="true">
+                <arg value="-i"/>
+                <arg value="${trans}/${strmodule}.str"/>
+                <arg value="-o"/>
+                <arg value="${build.stratego.outputfile}"/>
+            		<arg value="-p"/>
+                <arg value="${build.stratego.packagename}"/>
+                <arg value="-m"/>
+                <arg value="main-${strmodule}"/>
+                <arg value="--library"/>
+                <arg value="--clean"/>
+                <arg line="${build.stratego.args}"/>
+                <arg line="${build.stratego.extraargs}"/>
+                <arg line="${externaljarflags}"/>
+                <arg line="${externaldefimport}"/>
+                <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+            </java>
+            <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
+        	<mkdir dir="${build}/org/strategoxt/imp/generator"/>
+        </target>
+                
+    
+        
+        <target name="clean" description="clean up">
+            <delete dir="${build}"/>
+            <delete file="${include}/${editorservice}.def"/>
+        		<delete file="${include}/${str-java-editorservice}.def"/>
+        		<delete>
+        		    <fileset dir="${src-gen}" includes="**/*"/>
+      		  </delete>
+        </target>
+	
+    </project>
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.main.xml
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.main.xml	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<project name="SpoofaxGenerator.build" default="all">
+        
+        <!-- Key input modules -->
+    <property name="editorservice" value="EditorService"/>
+    <property name="str-java-editorservice" value="Stratego-Java-EditorService"/>
+        
+    <property name="metasdfmodule" value="Stratego-sdf2imp"/>
+    <property name="strmodule" value="SpoofaxGenerator"/>
+    <property name="outputjar" value="spoofaxgenerator"/>
+    
+    <!-- Project directories -->
+    <property name="trans" location="src"/>
+		<property name="sdf-imp-trans" location="src/sdf2imp/"/>
+		<property name="src-gen" location="src-gen/org/strategoxt/imp/spoofax/generator"/>
+    <property name="syntax"  location="src/syntax/"/>
+    <property name="include" location="include/"/>
+		<property name="lib" location="lib"/>
+    <property name="build" location="bin"/>
+    <property name="dist" location="bin/dist"/>
+    <property name="java-front" location = "${lib}/java-front/syntax"/> 
+		<property name="xml-front" location = "${lib}/xml-front"/> 
+		
+	 	<property name="build.sdf.imports" value="-I &quot;${lib}/stratego-front/syntax/&quot;" />
+		<property name="build.stratego.args" value="
+			-la stratego-lib 
+			-la stratego-sglr 
+			-la stratego-gpp 
+			-la stratego-xtc 
+			-la stratego-aterm
+			-la stratego-rtg
+			-la stratego-sdf
+			-la stratego-tool-doc
+			-I &quot;${sdf-imp-trans}&quot;
+			-I &quot;${trans}&quot;
+      -I &quot;${lib}&quot;
+	  	-I &quot;${include}&quot;
+			-I &quot;${lib}/xml-front/trans&quot; 
+			-I &quot;${lib}/stratego-gpp/trans&quot; 
+			-I &quot;${lib}/sdf-front/trans&quot;
+			-I &quot;${lib}/asfix-tools/trans&quot;
+			-I &quot;${lib}/xtc/tools&quot;
+			-I &quot;${lib}/xtc&quot;
+			-I &quot;${lib}/stratego-libraries/lib/ssl-compat&quot;
+			-I &quot;${lib}/stratego-libraries/lib/spec&quot;
+			-I &quot;${lib}/pgen&quot;
+			-I &quot;${lib}/stratego-front/pp&quot;
+			-I &quot;${basedir}&quot;
+			"/>
+
+		<!-- Environment configuration for command-line builds -->
+    <condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
+        <isset property="eclipse.spoofaximp.nativeprefix"/>
+    </condition>
+    <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
+		
+		<import file="build.main.helper.xml"/>
+	 
+		<!-- Main target -->
+    <target name="all" depends="check-classpath,init,pack-sdf-main,ppgen-main,pppack-main,sdf2table-main,stratego.jar,refresh"/>
+  </project>
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.properties
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/build.properties	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,14 @@
+output.org.strategoxt.imp.metatooling/ = bin/
+source.includes = src,\
+                  src-gen/,\
+                  include/
+
+bin.includes = META-INF/,\
+               includes,\
+               lib/make_permissive.jar,\
+               lib/spoofaxgenerator.jar,\
+               lib/aster.jar,\
+               lib/StrategoMix.def
+
+src.includes = src/,\
+               lib/

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/Thumbs.db
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/file.gif
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/file_error.gif
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/file_warning.gif
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/outline_item.gif
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/icons/sample.gif
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/StrategoMix.def
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/StrategoMix.def	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,930 @@
+definition
+module Stratego-Sugar-Overlays
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Terms
+
+exports
+  sorts Overlay
+  context-free syntax
+    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
+    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}
+
+module Stratego-Sugar-DynamicRules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+
+exports
+ 
+  sorts ScopeLabels
+  context-free syntax
+
+    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}
+
+    {DynRuleScopeId ","}*   -> ScopeLabels
+    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}
+
+  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
+  context-free syntax
+
+    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}
+
+    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
+    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
+    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
+    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
+    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}
+
+    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
+    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}
+
+    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}
+
+    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
+    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
+    RuleDec                     -> DynRuleId {cons("DynRuleId")}
+
+    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
+    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}
+
+  context-free syntax
+
+    Id                          -> RuleDec {cons("RDecNoArgs")}
+    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}
+
+  sorts RuleNames
+  context-free syntax
+    {Id ","}*				  -> RuleNames
+    "~" Term				  -> RuleNames {cons("RuleNames")}
+
+    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+
+  syntax
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+
+  context-free syntax
+    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+
+    Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+
+  priorities
+    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
+  > {
+
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    }
+  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}
+
+  context-free priorities
+    StrategyAngle Term 		          -> Strategy {cons("BA")}
+  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+  > Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+
+module Stratego-Sugar-Rules
+imports Stratego-Sugar-Strategies
+exports
+
+  sorts RuleDef
+  context-free syntax
+    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
+    
+    Anno+ RuleDef               -> Def {cons("AnnoDef")}
+
+    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
+
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}
+
+  sorts Rule RuleCond
+  context-free syntax
+    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
+    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
+    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}
+
+    "where" Strategy -> RuleCond {cons("WhereClause")}
+    "with"  Strategy -> RuleCond {cons("WithClause")}
+
+module Stratego-Sugar-Strategies
+imports
+  Stratego-Core-Strategies
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Constants
+  Stratego-Sugar-Signatures
+
+exports
+  context-free syntax
+    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
+    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
+
+  context-free syntax
+    ID 				  	  -> Typedid {cons("DefaultVarDec")}
+
+  sorts Rule
+
+  sorts StrategyParen StrategyCurly StrategyAngle
+  context-free syntax
+
+    %% Abstraction
+
+    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
+
+    %% Match and build
+
+    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
+
+     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
+     StrategyAngle Term 		  -> Strategy {cons("BA")}
+     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}
+
+    %% Combinators
+
+    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
+
+    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}
+
+    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
+    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
+    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
+    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}
+
+    %% Primitives
+
+    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
+    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
+
+    %% Congruence operators
+
+    String 				  -> Strategy {cons("StrCong")}
+    Int 				  -> Strategy {cons("IntCong")}
+    Real 				  -> Strategy {cons("RealCong")}
+    Char 			 	  -> Strategy {cons("CharCong")}
+
+    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}
+
+    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}
+
+    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
+    
+    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}
+
+    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
+   "(" Strategy  ")" 		          -> Strategy {bracket}
+    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}
+
+%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
+%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
+%%    Id "^" Id				  -> Mod {cons("Mod")}
+    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
+    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}
+
+%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
+%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
+    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}
+
+  %% Syntactic sugar sugar
+
+  sorts SwitchCase
+  context-free syntax
+
+    SVar  		  		  -> Strategy {cons("CallNoArgs")}
+    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
+    "(" Rule ")" 			  -> Strategy {cons("SRule")}
+    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
+    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
+
+    "proceed"                          -> Strategy {cons("ProceedNoArgs"), prefer}
+    "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}
+
+    "if" Strategy "then" Strategy 
+                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
+    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}
+
+    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
+    "switch" Strategy SwitchCase*
+         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}
+
+    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}
+
+    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+
+    Term ":=" Term			  -> Strategy {cons("Assign")}
+
+  %% Priorities
+
+  context-free priorities
+    { Strategy StrategyCurly		  -> Strategy
+      Strategy "#" StrategyParen          -> Strategy
+    }
+  > { "!" Term 				  -> Strategy
+      "?" Term 				  -> Strategy
+    }
+  > StrategyAngle Term 		          -> Strategy
+  > Strategy "=>" Term 		  	  -> Strategy
+  > Strategy ";" Strategy 		  -> Strategy
+  > {right: 
+     Strategy "+" Strategy 		  -> Strategy
+     Strategy "<+" Strategy 		  -> Strategy
+     Strategy "+>" Strategy 		  -> Strategy
+     
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy
+    }
+
+  context-free priorities
+    Strategy 				  -> StrategyMid
+  > Strategy "+" Strategy 		  -> Strategy
+
+  context-free priorities
+    { Strategy StrategyCurly      -> Strategy
+      Strategy "#" StrategyParen  -> Strategy
+    }
+    .> Term ":=" Term -> Strategy
+
+
+module Stratego-Sugar-Terms
+imports
+  Stratego-Core-Terms
+  Stratego-Sugar-Strategies
+
+exports
+  sorts LID
+  context-free syntax
+    LId 			-> LID  {cons("ListVar")}
+    LID				-> Var  {cons("Var")}
+    LID				-> ID
+
+  context-free syntax
+    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
+    "_" Term 			 -> Term {cons("BuildDefault"),prefer}
+
+    Char 			 -> PreTerm {cons("Char")}
+
+    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+    PreTerm                      -> Term {cons("NoAnnoList")}
+
+    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
+    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}
+
+    StrategyAngle		 -> PreTerm {cons("RootApp")}
+    StrategyAngle		 -> Term {cons("RootApp"),prefer}
+
+    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
+    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
+    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Sugar-Signatures
+imports
+  Stratego-Core-Signatures
+  Stratego-Sugar-Constants
+
+exports
+
+  sorts Sort
+  context-free syntax
+    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
+    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
+    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}
+
+  sorts Kind
+  context-free syntax
+    "*" 			-> Kind {cons("Star")}
+    "**" 			-> Kind {cons("StarStar")}
+
+module Stratego-Core-Signatures
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+exports
+  sorts Sdecl
+  context-free syntax
+    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
+    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}
+
+  sorts Sort
+  context-free syntax
+    LCID 			 -> Sort {cons("SortVar")}
+    UCID 			 -> Sort {cons("SortNoArgs")}
+    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}
+
+  sorts Opdecl
+  context-free syntax
+    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
+    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
+           ":" Type 		-> Opdecl {cons("OpDeclInj")}
+
+  context-free syntax
+    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
+    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
+    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}
+
+  sorts Type ArgType ConstType FunType RetType
+  context-free syntax
+    Sort	                -> ConstType {cons("ConstType")}
+    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
+    "(" Type ")"                -> ArgType {bracket}
+    ConstType			-> ArgType
+    Type	                -> RetType
+    FunType			-> RetType {reject}
+
+    FunType			-> Type
+    ConstType			-> Type
+
+  %%%
+   %% Restriction is required for the Sort* in Sdecl: List(a) is
+   %% ambiguous.
+   %%%
+  context-free restrictions
+    Sort -/- [\(]
+
+module Stratego-Core-Terms
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+
+exports
+  sorts ID Var Wld
+  context-free syntax
+    Id 				-> Var  {cons("Var")}
+    Id				-> ID
+    %% ":" Var                  -> Var  {cons("SeqVar")}
+
+  sorts Term PreTerm
+  context-free syntax
+    Var 			 -> PreTerm 
+    Var 			 -> Term {prefer}
+
+    "_" 			 -> Wld {cons("Wld")}
+    Wld 			 -> PreTerm
+    Wld 			 -> Term {prefer}
+
+    Int 			 -> PreTerm {cons("Int")}
+    Real 			 -> PreTerm {cons("Real")}
+    String 			 -> PreTerm {cons("Str")}
+
+    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
+    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+
+    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}
+
+    Var "@" Term 		 -> Term {cons("As"),prefer}
+    Var "@" PreTerm 		 -> PreTerm {cons("As")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Core-Strategies
+imports
+  Stratego-Core-Terms
+  Stratego-Core-Constants
+  Stratego-Core-Signatures
+
+exports
+  sorts Def
+  context-free syntax
+    StrategyDef					 -> Def 
+    Id						 -> SVar {cons("SVar")}
+    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
+    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}
+
+    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}
+
+
+  sorts StrategyDef
+  context-free syntax
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}
+
+    Anno+ StrategyDef -> Def {cons("AnnoDef")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+    "external"
+    EmptyId "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+
+  sorts EmptyId
+  lexical syntax
+  
+    -> EmptyId
+
+  sorts Anno
+  context-free syntax
+    "extend"      -> Anno {cons("Extend")}
+    "override"    -> Anno {cons("Override")}
+    "internal"    -> Anno {cons("Internal")}
+%%  "sealed"      -> Anno {cons("Sealed")}
+%%  "extensible"  -> Anno {cons("Extensible")}
+%%  "overridable" -> Anno {cons("Overridable")}
+
+  lexical syntax
+    
+    "extend"      -> Keyword
+    "override"    -> Keyword
+    "internal"    -> Keyword
+    "sealed"      -> Keyword
+    "extensible"  -> Keyword
+    "overridable" -> Keyword
+
+  lexical restrictions
+  
+    "extend"
+    "override"
+    "internal"
+    "sealed"
+    "extensible"
+    "overridable" -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Typedid
+  context-free syntax
+    ID ":" Type 			  -> Typedid {cons("VarDec")}
+
+
+  sorts Strategy SVar StrategyParen StrategyMid 
+  context-free syntax
+    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}
+
+    "fail" 				  -> Strategy {cons("Fail")}
+    "id" 				  -> Strategy {cons("Id")}
+
+    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("ProceedT"), prefer}
+    "proceed"                                         -> Strategy {cons("ProceedNoArgs"), prefer}
+
+    %% Match and build
+
+    "?" Term 				  -> Strategy {cons("Match")}
+    "!" Term 				  -> Strategy {cons("Build")}
+    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}
+
+    %% Combinators
+
+    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+    Strategy "<" StrategyMid 
+             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    Strategy 				  -> StrategyMid
+
+    %% Primitives
+
+    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}
+
+    %% Traversal
+
+    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
+    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
+    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
+
+  %% Priorities
+
+  context-free priorities
+    { "!" Term 				  -> Strategy {cons("Build")}
+      "?" Term 				  -> Strategy {cons("Match")}
+    }
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+  > {right: 
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    }
+
+  context-free syntax
+    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}
+
+module Stratego-Core-Modules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Strategies
+  Stratego-Core-Signatures
+
+exports 
+  sorts Module
+  context-free syntax
+    "module" ModName Decl* 	 -> Module {cons("Module")}
+    "specification" Decl*	 -> Module {cons("Specification")}
+
+  sorts Decl 
+  context-free syntax
+    "imports" ImportModName* 	-> Decl {cons("Imports")}
+    "strategies" Def* 		-> Decl {cons("Strategies")}
+    "signature" Sdecl*  	-> Decl {cons("Signature")}
+
+  sorts ImportModName
+  context-free syntax
+    ModName              -> ImportModName {cons("Import")}
+  syntax
+    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}
+
+module Stratego-Sugar-Modules
+imports
+  Stratego-Core-Modules
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Overlays
+  Stratego-Sugar-Rules
+
+exports 
+
+  sorts Decl Def
+  context-free syntax
+    "rules" Def* 		-> Decl {cons("Rules")}
+    "overlays" Overlay* 	-> Decl {cons("Overlays")}
+
+    RuleDef 			-> Def 
+
+
+module Stratego-Sugar-StringQuotations
+exports
+
+  sorts
+    StringQuotation
+    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
+    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
+    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
+    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4  Dollar4
+    Padding
+
+  context-free syntax
+
+    StringQuotation -> PreTerm
+
+  syntax
+
+    StringQuotation -> <PreTerm-CF>
+
+    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
+     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
+    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
+    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
+    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
+    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
+    [\[\]]                                                  -> <QuotedBracket1-LEX>
+    "$"                                                     -> <Dollar1-LEX>
+
+    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
+     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
+    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
+    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
+    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
+    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
+    [\{\}]                                                  -> <QuotedBracket2-LEX>
+    "$"                                                     -> <Dollar2-LEX>
+
+    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
+    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
+    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
+    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
+    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
+    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
+    [\(\)]                                                  -> <QuotedBracket3-LEX>
+    "$"                                                     -> <Dollar3-LEX>
+
+    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
+    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
+    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
+    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
+    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
+    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
+    [\<\>]                                                  -> <QuotedBracket4-LEX>
+    "$"                                                     -> <Dollar4-LEX>
+   
+    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
+    <Padding-LEX>                                           -> Padding
+                                                            -> <Padding-LEX> {indentpadding}
+
+  lexical restrictions
+
+    StringQuotedChars1 -/- ~[\[\]\$]   
+    StringQuotedChars2 -/- ~[\{\}\$]    
+    StringQuotedChars3 -/- ~[\(\)\$]    
+    StringQuotedChars4 -/- ~[\<\>\$]
+    Dollar1            -/- [\[\]] . [\$]
+    Dollar2            -/- [\{\}] . [\$]
+    Dollar3            -/- [\(\)] . [\$]
+    Dollar4            -/- [\<\>] . [\$]
+
+module Stratego-Core-Constants
+exports
+  sorts Int Real String StrChar
+  lexical syntax
+    [\-]? [0-9]+ 		-> Int
+    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
+    "\"" StrChar* "\"" 		-> String
+    ~[\"\\] 			-> StrChar
+    [\\] [\"tnr\\] 		-> StrChar
+
+
+module Stratego-Sugar-Constants
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+  Stratego-Sugar-StringQuotations
+exports
+  sorts Char CharChar
+  lexical syntax
+    "'" CharChar "'"		-> Char
+    ~[\']			-> CharChar
+    [\\] [\'ntr\ ]		-> CharChar
+    Char		 	-> Id {reject}
+
+module Stratego-Core-Identifiers
+exports
+  sorts ModName ModNamePart
+  lexical syntax
+    {ModNamePart "/"}+ -> ModName
+    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
+  lexical restrictions
+    ModName -/- [a-zA-Z0-9\'\.\-\_]
+  lexical syntax
+    "imports" 		-> ModName {reject}
+    "overlays" 		-> ModName {reject}
+    "rules" 		-> ModName {reject}
+    "signature" 	-> ModName {reject}
+    "strategies" 	-> ModName {reject}
+
+  sorts Id LId LCID UCID Wld
+  lexical syntax
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
+    [\'] [a-z]+                       -> Id
+
+    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
+    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
+
+  lexical restrictions
+    Id   -/- [a-zA-Z0-9\'\-\_\*]
+    LId  -/- [a-zA-Z0-9\'\-\_]
+    LCID -/- [a-zA-Z0-9\'\-\_]
+    UCID -/- [a-zA-Z0-9\'\-\_]
+
+  lexical syntax
+    "_"     -> Id {reject}
+    "'"     -> Id {reject}
+
+    Keyword -> Id   {reject}
+    Keyword -> LId  {reject}
+    Keyword -> LCID {reject}
+    Keyword -> UCID {reject}
+
+  lexical restrictions
+    "all"
+    "case" %% not reserved kw
+    "constructors"
+    "else" %% not reserved kw
+    "end" %% not reserved kw
+    "external" %% not reserved kw
+    "fail"
+    "id"
+    "if" %% not reserved kw
+    "in"
+    "imports" %% not reserved kw
+    "let"
+    "module"
+    "not"
+    "one"
+    "overlays"
+    "otherwise" %% not reserved kw
+    "prim"
+    "rec" %% not reserved kw
+    "rules"
+    "script"
+    "signature"
+    "some"
+    "sorts"
+    "strategies"
+    "stratego"
+    "switch" %% not reserved kw
+    "test"
+    "then" %% not reserved kw
+    "where"
+    "import-term"
+      -/- [a-zA-Z0-9\'\-\_]
+  
+  context-free restrictions
+    Wld -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Keyword
+  lexical syntax
+    "all"               -> Keyword
+    "constructors" 	-> Keyword
+    "fail" 		-> Keyword
+    "id" 		-> Keyword
+    "in" 		-> Keyword
+    "let" 		-> Keyword
+    "module" 		-> Keyword
+    "not" 		-> Keyword
+    "one" 		-> Keyword
+    "overlays" 		-> Keyword
+    "prim" 		-> Keyword
+    "rules" 		-> Keyword
+    "script" 		-> Keyword
+    "signature" 	-> Keyword
+    "some" 		-> Keyword
+    "sorts" 		-> Keyword
+    "strategies" 	-> Keyword
+    "stratego" 		-> Keyword
+    "test" 		-> Keyword
+    "where" 		-> Keyword
+    "import-term"	-> Keyword
+
+
+module Stratego-Core-Layout
+exports
+  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
+  lexical syntax
+    [\t\ \n\r]			-> Ws
+
+    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
+    "/*" CommChar* "*/"	-> LongCom
+				-> Eof  
+
+    ~[\*]     -> CommChar
+
+    "*"       -> Asterisk
+    Asterisk  -> CommChar
+
+  lexical restrictions
+    Asterisk -/- [\/]
+    Eof      -/- ~[]
+
+  lexical syntax
+    ShortCom 	-> LAYOUT
+    LongCom 	-> LAYOUT
+    Ws 		-> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\*]
+    LAYOUT? -/- [\/].[\/]
+
+module Stratego-Sugar-Layout
+imports Stratego-Core-Layout
+%%exports
+%%  sorts VeryLongCom Eof VLCchar Backslash
+%%  lexical syntax
+%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
+%%    "\\begin{code}" 			   -> VeryLongCom
+%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
+%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
+%%    ~[\\] 				   -> VLCchar
+%%    Backslash 				   -> VLCchar
+%%    [\\] 				   -> Backslash
+
+%%  lexical restrictions
+%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
+%%    Eof -/- ~[]
+
+%%  lexical syntax
+%%    VeryLongCom -> LAYOUT
+
+
+
+module Stratego-Sugar
+imports
+  Stratego-Sugar-Layout
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Constants 
+  Stratego-Sugar-Modules
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+  Stratego-Sugar-DynamicRules
+  Stratego-Sugar-Overlays
+
+hiddens
+  context-free start-symbols Module
+
+module Stratego
+imports Stratego-Sugar
+hiddens
+  context-free start-symbols Module
+
+module StrategoMix[Ctx0]
+imports Stratego
+          [ RuleNames          => RuleNames[[Ctx0]]
+            RuleDec            => RuleDec[[Ctx0]]
+            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
+            DynRuleId          => DynRuleId[[Ctx0]]
+            DynRuleDef         => DynRuleDef[[Ctx0]]
+            ScopeLabels        => ScopeLabels[[Ctx0]]
+            RuleCond           => RuleCond[[Ctx0]]
+            Rule               => Rule[[Ctx0]]
+            RuleDef            => RuleDef[[Ctx0]]
+            Overlay            => Overlay[[Ctx0]]
+            SwitchCase         => SwitchCase[[Ctx0]]
+            StrategyCurly      => StrategyCurly[[Ctx0]]
+            StrategyAngle      => StrategyAngle[[Ctx0]]
+            Kind               => Kind[[Ctx0]]
+            LID                => LID[[Ctx0]]
+            ImportModName      => ImportModName[[Ctx0]]
+            Decl               => Decl[[Ctx0]]
+            Module             => Module[[Ctx0]]
+            StrategyParen      => StrategyParen[[Ctx0]]
+            Typedid            => Typedid[[Ctx0]]
+            Anno               => Anno[[Ctx0]]
+            EmptyId            => EmptyId[[Ctx0]]
+            StrategyDef        => StrategyDef[[Ctx0]]
+            SVar               => SVar[[Ctx0]]
+            Def                => Def[[Ctx0]]
+            Type               => Type[[Ctx0]]
+            RetType            => RetType[[Ctx0]]
+            ArgType            => ArgType[[Ctx0]]
+            FunType            => FunType[[Ctx0]]
+            ConstType          => ConstType[[Ctx0]]
+            Opdecl             => Opdecl[[Ctx0]]
+            Sort               => Sort[[Ctx0]]
+            Sdecl              => Sdecl[[Ctx0]]
+            Wld                => Wld[[Ctx0]]
+            ID                 => ID[[Ctx0]]
+            Var                => Var[[Ctx0]]
+            CharChar           => CharChar[[Ctx0]]
+            Char               => Char[[Ctx0]]
+            Padding            => Padding[[Ctx0]]
+            Dollar4            => Dollar4[[Ctx0]]
+            QuotedBracket4     => QuotedBracket4[[Ctx0]]
+            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
+            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
+            Dollar3            => Dollar3[[Ctx0]]
+            QuotedBracket3     => QuotedBracket3[[Ctx0]]
+            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
+            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
+            Dollar2            => Dollar2[[Ctx0]]
+            QuotedBracket2     => QuotedBracket2[[Ctx0]]
+            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
+            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
+            Dollar1            => Dollar1[[Ctx0]]
+            QuotedBracket1     => QuotedBracket1[[Ctx0]]
+            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
+            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
+            StringQuotation    => StringQuotation[[Ctx0]]
+            StrChar            => StrChar[[Ctx0]]
+            String             => String[[Ctx0]]
+            Real               => Real[[Ctx0]]
+            Int                => Int[[Ctx0]]
+            Keyword            => Keyword[[Ctx0]]
+            UCID               => UCID[[Ctx0]]
+            LCID               => LCID[[Ctx0]]
+            LId                => LId[[Ctx0]]
+            Id                 => Id[[Ctx0]]
+            ModNamePart        => ModNamePart[[Ctx0]]
+            ModName            => ModName[[Ctx0]]
+            PreTerm            => PreTerm[[Ctx0]]
+            Term               => Term[[Ctx0]]
+            StrategyMid        => StrategyMid[[Ctx0]]
+            Strategy           => Strategy[[Ctx0]] ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/trans/AsFix.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/trans/AsFix.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,52 @@
+module AsFix
+imports list-cons
+signature
+  constructors
+    parsetree             : Tree * NatCon -> ParseTree
+
+    amb                   : List(Tree) -> Tree
+    lit                   : String -> Tree
+    char                  : NatCon -> Tree
+    appl                  : Production * Args -> Tree
+
+    list                  : Symbol -> Production
+    prod                  : List(Symbol) * Symbol * Attributes -> Production
+    attrs                 : List(Attr) -> Attributes
+    no-attrs              : Attributes
+
+    avoid                 : Attr
+    prefer                : Attr
+    reject                : Attr
+    bracket               : Attr
+    term                  : ATerm -> Attr
+    'id                   : String -> Attr
+    assoc                 : Associativity -> Attr
+    cons                  : String -> ATerm
+
+    non-assoc             : Associativity
+    assoc                 : Associativity
+    right                 : Associativity
+    left                  : Associativity
+
+    range                 : NatCon * NatCon -> CharRange
+    character             : NatCon -> CharRange
+
+    parametrized-sort     : String * List(Symbol) -> Symbol
+    strategy              : Symbol * Symbol -> Symbol
+    char-class            : List(CharRange) -> Symbol
+    layout                : Symbol
+    varsym                : Symbol -> Symbol
+    func                  : Symbols * Symbol -> Symbol
+    iter-star-sep         : Symbol * Symbol -> Symbol
+    iter-sep              : Symbol * Symbol -> Symbol
+    iter-star             : Symbol -> Symbol
+    iter                  : Symbol -> Symbol
+    sort                  : String -> Symbol
+    tuple                 : Symbol * Symbols -> Symbol
+    seq                   : Symbol * Symbol -> Symbol
+    alt                   : Symbol * Symbol -> Symbol
+    opt                   : Symbol -> Symbol
+    lex                   : Symbol -> Symbol
+    cf                    : Symbol -> Symbol
+    lit                   : String -> Symbol
+    empty                 : Symbol

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/trans/asfix-extra.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/asfix-tools/trans/asfix-extra.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,16 @@
+module asfix-extra
+signature
+  constructors
+
+    /**
+     * No idea what this is. Some tools need it.
+     */
+    flatlex : Sort * String -> AsFixTerm
+
+    /**
+     * Used by many asfix tools but it is not in AsFix.
+     * 
+     * The tools seem to relate this to a tuple. 
+     * This is however a seq/2 with a head and a tail.
+     */	  
+    seq : List(Symbol) -> Symbol

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/aster.jar
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/Stratego-Java-15.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/Stratego-Java-15.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,7 @@
+module Stratego-Java-15
+imports
+  StrategoMix[StrategoHost]
+  languages/java/EmbeddedJavaMix[JavaObject Term[[StrategoHost]]]
+
+exports
+  context-free start-symbols Module[[StrategoHost]]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/Stratego-Java-EBlock.def
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/Stratego-Java-EBlock.def	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,3473 @@
+definition
+module languages/java/eblock/ConcatIds
+imports
+  languages/java-15/Main
+   
+exports
+  context-free syntax
+  	{ ID "#" }+ -> ID {cons("ConcatIds")}
+
+module languages/java/eblock/Main
+imports
+  languages/java-15/Main
+  languages/java/eblock/ConcatIds
+   
+exports
+  context-free syntax
+    "{|" BlockStm* "|" Expr "|}" -> Expr {cons("PreEBlock")}
+    "{|" Expr "|" BlockStm* "|}" -> Expr {cons("PostEBlock")}
+    "{|" BlockStm* "|}"          -> BlockStm {cons("InnerBlock")}
+
+    "{|" BlockStm* "|" Expr "|" BlockStm* "|}" -> Expr {cons("PrePostEBlock")}
+
+module languages/java/eblock/JavaEBlockMix[Ctx0]
+imports languages/java/eblock/Main
+          [ CompilationUnit       => CompilationUnit[[Ctx0]]
+            TypeDec               => TypeDec[[Ctx0]]
+            ImportDec             => ImportDec[[Ctx0]]
+            PackageDec            => PackageDec[[Ctx0]]
+            ElemVal               => ElemVal[[Ctx0]]
+            ElemValPair           => ElemValPair[[Ctx0]]
+            Anno                  => Anno[[Ctx0]]
+            LHS                   => LHS[[Ctx0]]
+            CondMid               => CondMid[[Ctx0]]
+            ArraySubscript        => ArraySubscript[[Ctx0]]
+            DimExpr               => DimExpr[[Ctx0]]
+            ArrayBaseType         => ArrayBaseType[[Ctx0]]
+            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
+            ClassMemberDec        => ClassMemberDec[[Ctx0]]
+            ClassBodyDec          => ClassBodyDec[[Ctx0]]
+            Interfaces            => Interfaces[[Ctx0]]
+            Super                 => Super[[Ctx0]]
+            ClassMod              => ClassMod[[Ctx0]]
+            ClassDecHead          => ClassDecHead[[Ctx0]]
+            ClassBody             => ClassBody[[Ctx0]]
+            ClassDec              => ClassDec[[Ctx0]]
+            InterfaceMod          => InterfaceMod[[Ctx0]]
+            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
+            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
+            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
+            InterfaceDec          => InterfaceDec[[Ctx0]]
+            DefaultVal            => DefaultVal[[Ctx0]]
+            AnnoElemDec           => AnnoElemDec[[Ctx0]]
+            AnnoDecHead           => AnnoDecHead[[Ctx0]]
+            AnnoDec               => AnnoDec[[Ctx0]]
+            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
+            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
+            ConstantMod           => ConstantMod[[Ctx0]]
+            ConstantDec           => ConstantDec[[Ctx0]]
+            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
+            EnumConstArgs         => EnumConstArgs[[Ctx0]]
+            EnumConst             => EnumConst[[Ctx0]]
+            EnumBody              => EnumBody[[Ctx0]]
+            EnumDecHead           => EnumDecHead[[Ctx0]]
+            EnumDec               => EnumDec[[Ctx0]]
+            ConstrMod             => ConstrMod[[Ctx0]]
+            ConstrInv             => ConstrInv[[Ctx0]]
+            ConstrBody            => ConstrBody[[Ctx0]]
+            ConstrHead            => ConstrHead[[Ctx0]]
+            ConstrDec             => ConstrDec[[Ctx0]]
+            StaticInit            => StaticInit[[Ctx0]]
+            InstanceInit          => InstanceInit[[Ctx0]]
+            MethodBody            => MethodBody[[Ctx0]]
+            ExceptionType         => ExceptionType[[Ctx0]]
+            Throws                => Throws[[Ctx0]]
+            MethodMod             => MethodMod[[Ctx0]]
+            VarMod                => VarMod[[Ctx0]]
+            FormalParam           => FormalParam[[Ctx0]]
+            ResultType            => ResultType[[Ctx0]]
+            MethodDecHead         => MethodDecHead[[Ctx0]]
+            MethodDec             => MethodDec[[Ctx0]]
+            BlockStm              => BlockStm[[Ctx0]]
+            Block                 => Block[[Ctx0]]
+            CatchClause           => CatchClause[[Ctx0]]
+            SwitchLabel           => SwitchLabel[[Ctx0]]
+            SwitchGroup           => SwitchGroup[[Ctx0]]
+            SwitchBlock           => SwitchBlock[[Ctx0]]
+            Stm                   => Stm[[Ctx0]]
+            LocalVarDec           => LocalVarDec[[Ctx0]]
+            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
+            FieldMod              => FieldMod[[Ctx0]]
+            VarInit               => VarInit[[Ctx0]]
+            Dim                   => Dim[[Ctx0]]
+            VarDecId              => VarDecId[[Ctx0]]
+            VarDec                => VarDec[[Ctx0]]
+            FieldDec              => FieldDec[[Ctx0]]
+            ArrayInit             => ArrayInit[[Ctx0]]
+            ClassLiteral          => ClassLiteral[[Ctx0]]
+            Literal               => Literal[[Ctx0]]
+            Type                  => Type[[Ctx0]]
+            ArrayType             => ArrayType[[Ctx0]]
+            TypeVar               => TypeVar[[Ctx0]]
+            TypeDecSpec           => TypeDecSpec[[Ctx0]]
+            InterfaceType         => InterfaceType[[Ctx0]]
+            ClassType             => ClassType[[Ctx0]]
+            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
+            RefType               => RefType[[Ctx0]]
+            TypeVarId             => TypeVarId[[Ctx0]]
+            TypeParams            => TypeParams[[Ctx0]]
+            TypeBound             => TypeBound[[Ctx0]]
+            TypeParam             => TypeParam[[Ctx0]]
+            WildcardBound         => WildcardBound[[Ctx0]]
+            ActualTypeArg         => ActualTypeArg[[Ctx0]]
+            TypeArgs              => TypeArgs[[Ctx0]]
+            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
+            MethodName            => MethodName[[Ctx0]]
+            ExprName              => ExprName[[Ctx0]]
+            TypeName              => TypeName[[Ctx0]]
+            AmbName               => AmbName[[Ctx0]]
+            PackageName           => PackageName[[Ctx0]]
+            FloatType             => FloatType[[Ctx0]]
+            IntType               => IntType[[Ctx0]]
+            NumType               => NumType[[Ctx0]]
+            PrimType              => PrimType[[Ctx0]]
+            NullLiteral           => NullLiteral[[Ctx0]]
+            FooStringChars        => FooStringChars[[Ctx0]]
+            StringChars           => StringChars[[Ctx0]]
+            StringPart            => StringPart[[Ctx0]]
+            StringLiteral         => StringLiteral[[Ctx0]]
+            SingleChar            => SingleChar[[Ctx0]]
+            CharContent           => CharContent[[Ctx0]]
+            CharLiteral           => CharLiteral[[Ctx0]]
+            LastOcta              => LastOcta[[Ctx0]]
+            OctaEscape            => OctaEscape[[Ctx0]]
+            NamedEscape           => NamedEscape[[Ctx0]]
+            EscapeSeq             => EscapeSeq[[Ctx0]]
+            Bool                  => Bool[[Ctx0]]
+            BoolLiteral           => BoolLiteral[[Ctx0]]
+            BinaryExponent        => BinaryExponent[[Ctx0]]
+            HexaSignificand       => HexaSignificand[[Ctx0]]
+            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
+            SignedInteger         => SignedInteger[[Ctx0]]
+            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
+            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
+            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
+            FloatLiteral          => FloatLiteral[[Ctx0]]
+            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
+            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
+            IntLiteral            => IntLiteral[[Ctx0]]
+            OctaNumeral           => OctaNumeral[[Ctx0]]
+            HexaNumeral           => HexaNumeral[[Ctx0]]
+            DeciNumeral           => DeciNumeral[[Ctx0]]
+            OctaLiteral           => OctaLiteral[[Ctx0]]
+            HexaLiteral           => HexaLiteral[[Ctx0]]
+            DeciLiteral           => DeciLiteral[[Ctx0]]
+            Modifier              => Modifier[[Ctx0]]
+            StrictFP              => StrictFP[[Ctx0]]
+            Synchronized          => Synchronized[[Ctx0]]
+            Volatile              => Volatile[[Ctx0]]
+            Transient             => Transient[[Ctx0]]
+            Native                => Native[[Ctx0]]
+            Static                => Static[[Ctx0]]
+            Final                 => Final[[Ctx0]]
+            Abstract              => Abstract[[Ctx0]]
+            Protected             => Protected[[Ctx0]]
+            Private               => Private[[Ctx0]]
+            Public                => Public[[Ctx0]]
+            Id                    => Id[[Ctx0]]
+            ID                    => ID[[Ctx0]]
+            Keyword               => Keyword[[Ctx0]]
+            ArrayAccess           => ArrayAccess[[Ctx0]]
+            FieldAccess           => FieldAccess[[Ctx0]]
+            MethodSpec            => MethodSpec[[Ctx0]]
+            Expr                  => Expr[[Ctx0]] ]
+
+
+module languages/java-15/expressions/Priorities
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/expressions/Main
+
+exports
+  context-free priorities
+      Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
+    > {right:
+        Expr "++" -> Expr
+        Expr "--" -> Expr
+      } 
+
+  context-free priorities
+      {right:
+        Expr "++" -> Expr
+        Expr "--" -> Expr
+      }
+    > { "(" PrimType ")" Expr -> Expr    
+        "(" RefType  ")" Expr -> Expr
+      }
+
+  context-free priorities
+      "(" PrimType ")" Expr -> Expr
+    > {left:
+        Expr "*" Expr -> Expr
+        Expr "/" Expr -> Expr
+        Expr "%" Expr -> Expr
+      } 
+
+  context-free priorities
+      "(" RefType ")" Expr -> Expr 
+    > {
+        "++" Expr -> Expr
+        "--" Expr -> Expr
+        "+"  Expr -> Expr
+        "-"  Expr -> Expr
+      }
+
+  context-free priorities
+    {
+      Expr ArraySubscript -> ArrayAccess
+      Expr "." Id -> FieldAccess
+      Expr "." TypeArgs? Id -> MethodSpec
+    }
+  > {right:
+      Expr "++" -> Expr
+      Expr "--" -> Expr
+    }
+  > {
+      "++" Expr -> Expr
+      "--" Expr -> Expr
+      "+"  Expr -> Expr
+      "-"  Expr -> Expr
+      "~"  Expr -> Expr
+      "!"  Expr -> Expr
+    }
+  > {left:
+      Expr "*" Expr -> Expr
+      Expr "/" Expr -> Expr
+      Expr "%" Expr -> Expr
+    } 
+  > {left:
+      Expr "+" Expr -> Expr
+      Expr "-" Expr -> Expr
+    }
+  > {left:
+      Expr "<<"  Expr -> Expr
+      Expr ">>"  Expr -> Expr
+      Expr ">>>" Expr -> Expr
+    }
+  > {left:
+      Expr "instanceof" RefType -> Expr
+      Expr "<"   Expr -> Expr
+      Expr ">"   Expr -> Expr
+      Expr "<="  Expr -> Expr
+      Expr ">="  Expr -> Expr
+    }
+  > {left:
+      Expr "=="  Expr -> Expr
+      Expr "!="  Expr -> Expr
+    }
+  >   Expr "&"   Expr -> Expr
+  >   Expr "^"   Expr -> Expr
+  >   Expr "|"   Expr -> Expr
+  >   Expr "&&"  Expr -> Expr
+  >   Expr "||"  Expr -> Expr
+  >   Expr CondMid Expr -> Expr
+  > {right:
+      LHS "="    Expr -> Expr
+      LHS "*="   Expr -> Expr
+      LHS "/="   Expr -> Expr
+      LHS "%="   Expr -> Expr
+      LHS "+="   Expr -> Expr
+      LHS "-="   Expr -> Expr
+      LHS "<<="  Expr -> Expr
+      LHS ">>="  Expr -> Expr
+      LHS ">>>=" Expr -> Expr
+      LHS "&="   Expr -> Expr
+      LHS "^="   Expr -> Expr
+      LHS "|="   Expr -> Expr
+    }
+
+module languages/java-15/expressions/Restrictions
+exports
+  lexical restrictions
+    "+" -/- [\+]
+    "-" -/- [\-]
+    "/" -/- [\/]
+
+module languages/java-15/expressions/AssignmentOperators
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts LHS
+  context-free syntax
+    LHS "="    Expr -> Expr {cons("Assign")}
+    LHS "*="   Expr -> Expr {cons("AssignMul")}
+    LHS "/="   Expr -> Expr {cons("AssignDiv")}
+    LHS "%="   Expr -> Expr {cons("AssignRemain")}
+    LHS "+="   Expr -> Expr {cons("AssignPlus")}
+    LHS "-="   Expr -> Expr {cons("AssignMinus")}
+    LHS "<<="  Expr -> Expr {cons("AssignLeftShift")}
+    LHS ">>="  Expr -> Expr {cons("AssignRightShift")}
+    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
+    LHS "&="   Expr -> Expr {cons("AssignAnd")}
+    LHS "^="   Expr -> Expr {cons("AssignExcOr")}
+    LHS "|="   Expr -> Expr {cons("AssignOr")}
+
+    ExprName    -> LHS
+    FieldAccess -> LHS
+    ArrayAccess -> LHS
+
+
+
+
+module languages/java-15/expressions/BinaryOperators
+imports
+  languages/java-15/expressions/Main
+  languages/java-15/types/Main
+
+exports
+  sorts CondMid
+  context-free syntax
+    Expr "instanceof" RefType -> Expr {cons("InstanceOf")}
+
+    Expr "*"   Expr -> Expr  {left, cons("Mul")}
+    Expr "/"   Expr -> Expr  {left, cons("Div")}
+    Expr "%"   Expr -> Expr  {left, cons("Remain")}
+
+    Expr "+"   Expr -> Expr  {left, cons("Plus")}
+    Expr "-"   Expr -> Expr  {left, cons("Minus")}
+
+    Expr "<<"  Expr -> Expr  {left, cons("LeftShift")}
+    Expr ">>"  Expr -> Expr  {left, cons("RightShift")}
+    Expr ">>>" Expr -> Expr  {left, cons("URightShift")}
+
+    Expr "<"   Expr -> Expr  {left, cons("Lt")}
+    Expr ">"   Expr -> Expr  {left, cons("Gt")}
+    Expr "<="  Expr -> Expr  {left, cons("LtEq")}
+    Expr ">="  Expr -> Expr  {left, cons("GtEq")}
+    Expr "=="  Expr -> Expr  {left, cons("Eq")}
+    Expr "!="  Expr -> Expr  {left, cons("NotEq")}
+
+    Expr "&&"  Expr -> Expr  {left, cons("LazyAnd")}
+    Expr "||"  Expr -> Expr  {left, cons("LazyOr")}
+
+    Expr "&" Expr -> Expr {left, cons("And")}
+    Expr "^" Expr -> Expr {left, cons("ExcOr")}
+    Expr "|" Expr -> Expr {left, cons("Or")}
+
+    %% todo JFR-30
+    Expr CondMid Expr -> Expr {right, cons("Cond")}
+    "?" Expr ":" -> CondMid {bracket}
+
+module languages/java-15/expressions/UnaryOperators
+imports 
+  languages/java-15/expressions/Main
+exports
+  context-free syntax
+    "+" Expr -> Expr {cons("Plus")}
+    "-" Expr -> Expr {cons("Minus")}
+
+    "++" Expr -> Expr {cons("PreIncr")}
+    "--" Expr -> Expr {cons("PreDecr")}
+
+    "~" Expr -> Expr {cons("Complement")}
+    "!" Expr -> Expr {cons("Not")}
+
+    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
+    "(" RefType  ")" Expr -> Expr {cons("CastRef")}
+
+module languages/java-15/expressions/Postfix
+imports 
+  languages/java-15/expressions/Main
+
+exports
+  context-free syntax
+    ExprName  -> Expr
+    Expr "++" -> Expr {cons("PostIncr")}
+    Expr "--" -> Expr {cons("PostDecr")}
+
+module languages/java-15/expressions/MethodInvocation
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts MethodSpec
+  context-free syntax
+    MethodSpec "(" {Expr ","}* ")" -> Expr {cons("Invoke")}
+
+                               MethodName -> MethodSpec {cons("Method")}
+                    Expr "." TypeArgs? Id -> MethodSpec {cons("Method")}
+                 "super" "." TypeArgs? Id -> MethodSpec {cons("SuperMethod")}
+    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
+                 AmbName "." TypeArgs  Id -> MethodSpec {cons("GenericMethod")}
+
+  %% This priority forbids a Expr "." MethodSpec if the expression is a plain ExprName.
+  %% This solves an ambiguity with the MethodName and AmbName . TypeArgs MethodSpecs.
+  %% foo.bar.fred() results in a MethodName MethodSpec.
+  %% (foo.bar).fred() results in the Expr. MethodSpec
+  %% foo.bar.<T>fred() results in a GenericMethod
+  context-free priorities
+      Expr "." TypeArgs? Id -> MethodSpec
+    > ExprName  -> Expr
+
+
+
+
+module languages/java-15/expressions/ArrayAccess
+imports
+  languages/java-15/expressions/Main
+exports
+  sorts
+    ArrayAccess
+    ArraySubscript
+
+  context-free syntax
+    ArrayAccess -> Expr
+
+    %% todo: JFR-29
+    Expr ArraySubscript -> ArrayAccess {cons("ArrayAccess")}
+    "[" Expr "]" -> ArraySubscript {bracket}
+
+    ArrayCreationExpr ArraySubscript -> ArrayAccess {reject}
+
+module languages/java-15/expressions/FieldAccess
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts FieldAccess
+  context-free syntax
+    FieldAccess -> Expr
+
+  context-free syntax
+
+                    Expr "." Id -> FieldAccess {cons("Field")}
+                ExprName "." Id -> FieldAccess {reject}
+                 "super" "." Id -> FieldAccess {cons("SuperField")}
+    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}
+
+module languages/java-15/expressions/ArrayCreation
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    ArrayCreationExpr
+    ArrayBaseType
+    Dim
+    DimExpr
+
+  context-free syntax
+    ArrayCreationExpr     -> Expr
+
+    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
+    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}
+
+    PrimType -> ArrayBaseType
+    TypeName -> ArrayBaseType
+    TypeName "<" "?" ">" -> ArrayBaseType {cons("UnboundWld")}
+
+    "[" Expr "]" -> DimExpr {cons("Dim")}
+    "[" "]"      -> Dim     {cons("Dim")}
+
+module languages/java-15/expressions/ClassInstanceCreation
+imports
+  languages/java-15/expressions/Main
+  languages/java-15/classes/ClassDeclarations
+
+exports
+  context-free syntax
+
+             "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? -> Expr {cons("NewInstance")}
+    Expr "." "new" TypeArgs? Id         TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}
+
+module languages/java-15/expressions/Primary
+imports
+  languages/java-15/lexical/literals/Main
+  languages/java-15/names/Main
+  languages/java-15/expressions/Main
+
+exports
+  %%%
+   %% Section 15.8.1: Lexical Literals
+   %%%
+  sorts Literal
+  context-free syntax
+    Literal -> Expr {cons("Lit")}
+
+    IntLiteral    -> Literal
+    FloatLiteral  -> Literal
+    BoolLiteral   -> Literal 
+    CharLiteral   -> Literal
+    StringLiteral -> Literal
+    NullLiteral   -> Literal
+
+  %%%
+   %% Section 15.8.2: Class Literals
+   %%%
+  sorts ClassLiteral
+  context-free syntax
+    ClassLiteral -> Literal
+    Type   "." "class" -> ClassLiteral {cons("Class")}
+    "void" "." "class" -> ClassLiteral {cons("VoidClass")}
+
+  %%%
+   %% Section 15.8.3/4: (Qualified this)
+   %%%
+  context-free syntax
+                 "this" -> Expr {cons("This")}
+    TypeName "." "this" -> Expr {cons("QThis")}
+
+  %%%
+   %% Section 15.8.5: Parenthesized Expression
+   %%%
+  context-free syntax
+    "(" Expr ")"          -> Expr {bracket}
+
+module languages/java-15/expressions/Main
+imports
+  languages/java-15/expressions/Primary
+  languages/java-15/expressions/ClassInstanceCreation
+  languages/java-15/expressions/ArrayCreation
+  languages/java-15/expressions/FieldAccess
+  languages/java-15/expressions/ArrayAccess
+  languages/java-15/expressions/MethodInvocation
+  languages/java-15/expressions/Postfix
+  languages/java-15/expressions/UnaryOperators
+  languages/java-15/expressions/BinaryOperators
+  languages/java-15/expressions/AssignmentOperators
+  languages/java-15/expressions/Restrictions
+  languages/java-15/expressions/Priorities
+
+exports
+  sorts
+    Expr
+
+module languages/java-15/statements/Main
+imports
+  languages/java-15/statements/Blocks
+  languages/java-15/statements/LocalVariableDeclarations
+  languages/java-15/statements/Statements
+
+
+
+
+module languages/java-15/arrays/Main
+imports
+  languages/java-15/arrays/ArrayInitializers
+
+
+
+
+module languages/java-15/interfaces/Main
+imports
+  languages/java-15/interfaces/InterfaceDeclarations
+  languages/java-15/interfaces/AbstractMethodDeclarations
+  languages/java-15/interfaces/AnnotationTypes
+  languages/java-15/interfaces/Annotations
+
+
+
+
+module languages/java-15/classes/Main
+imports
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/classes/EnumDeclarations
+
+
+
+
+module languages/java-15/packages/PackageDeclarations
+imports
+  languages/java-15/names/Main
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    PackageDec
+
+  context-free syntax
+    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}
+
+module languages/java-15/packages/ImportDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/names/Main
+
+exports
+  sorts
+    ImportDec
+
+  context-free syntax
+    "import" TypeName                  ";"  -> ImportDec {cons("TypeImportDec")}
+    "import" PackageName       "." "*" ";"  -> ImportDec {cons("TypeImportOnDemandDec")}
+    "import" "static" TypeName "." Id  ";"  -> ImportDec {cons("StaticImportDec")}
+    "import" "static" TypeName "." "*" ";"  -> ImportDec {cons("StaticImportOnDemandDec")}
+
+module languages/java-15/interfaces/AnnotationTypes
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/classes/EnumDeclarations
+  languages/java-15/interfaces/InterfaceDeclarations
+  languages/java-15/interfaces/AbstractMethodDeclarations
+  languages/java-15/interfaces/ConstantDeclarations
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    AnnoDec
+    AnnoDecHead
+
+  context-free syntax
+    AnnoDecHead "{" AnnoElemDec* "}" -> AnnoDec {cons("AnnoDec")}
+    (Anno | InterfaceMod)* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}
+
+  sorts
+    AnnoElemDec
+    DefaultVal
+
+  context-free syntax
+    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}
+
+    ConstantDec  -> AnnoElemDec
+    ClassDec     -> AnnoElemDec
+    InterfaceDec -> AnnoElemDec
+    EnumDec      -> AnnoElemDec
+    AnnoDec      -> AnnoElemDec
+    ";"          -> AnnoElemDec {cons("Semicolon")}
+
+    "default" ElemVal -> DefaultVal {cons("DefaultVal")}
+
+module languages/java-15/interfaces/AbstractMethodDeclarations
+imports
+  languages/java-15/lexical/Modifiers
+  languages/java-15/names/Main
+  languages/java-15/types/Main
+  languages/java-15/classes/MethodDeclarations
+
+exports
+  sorts
+    AbstractMethodDec
+    AbstractMethodMod
+
+  context-free syntax
+    (Anno | AbstractMethodMod)* TypeParams? ResultType
+      Id "(" {FormalParam ","}* ")" Throws? ";" -> AbstractMethodDec {cons("AbstractMethodDec")}
+
+    (Anno | AbstractMethodMod)* TypeParams? ResultType
+      Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}
+
+    Public   -> AbstractMethodMod
+    Abstract -> AbstractMethodMod
+
+
+
+
+
+module languages/java-15/interfaces/ConstantDeclarations
+imports
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/Main
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    ConstantDec
+    ConstantMod
+
+  context-free syntax
+    (Anno | ConstantMod)* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}
+
+    Public -> ConstantMod
+    Static -> ConstantMod
+    Final  -> ConstantMod
+
+
+
+
+module languages/java-15/interfaces/InterfaceDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/names/Main
+  languages/java-15/types/Main
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/interfaces/ConstantDeclarations
+  languages/java-15/interfaces/AbstractMethodDeclarations
+  languages/java-15/interfaces/AnnotationTypes
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    InterfaceDec
+    InterfaceDecHead
+    ExtendsInterfaces
+    InterfaceMemberDec
+    InterfaceMod
+
+  context-free syntax
+    AnnoDec -> InterfaceDec
+
+    InterfaceDecHead "{" InterfaceMemberDec* "}" -> InterfaceDec {cons("InterfaceDec")}
+
+    (Anno | InterfaceMod)* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead {cons("InterfaceDecHead")}
+    "extends" {InterfaceType ","}+ -> ExtendsInterfaces {cons("ExtendsInterfaces")}
+
+  context-free syntax
+    ConstantDec       -> InterfaceMemberDec
+    AbstractMethodDec -> InterfaceMemberDec
+    ClassDec          -> InterfaceMemberDec
+    InterfaceDec      -> InterfaceMemberDec
+    ";"               -> InterfaceMemberDec {cons("Semicolon")}
+
+  context-free syntax
+    Public         -> InterfaceMod
+    Protected      -> InterfaceMod
+    Private        -> InterfaceMod
+    Abstract       -> InterfaceMod
+    Static         -> InterfaceMod
+    StrictFP       -> InterfaceMod
+
+
+
+
+module languages/java-15/classes/EnumDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/classes/ClassDeclarations
+
+exports
+  sorts
+    EnumDec
+    EnumDecHead
+    EnumBody
+    EnumConst
+    EnumConstArgs
+    EnumBodyDecs
+
+  context-free syntax
+    EnumDecHead EnumBody -> EnumDec {cons("EnumDec")}
+
+    (Anno | ClassMod)* "enum" Id Interfaces? -> EnumDecHead {cons("EnumDecHead")}
+
+    "{" {EnumConst ","}*     EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
+    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
+
+    Id EnumConstArgs? ClassBody?  -> EnumConst {cons("EnumConst")}
+    "(" {Expr ","}* ")"  -> EnumConstArgs {bracket}
+
+    ";" ClassBodyDec* -> EnumBodyDecs {cons("EnumBodyDecs")}
+
+module languages/java-15/classes/ConstructorDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/interfaces/Annotations
+  languages/java-15/statements/Main
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    ConstrDec
+    ConstrBody
+    ConstrHead
+    ConstrInv
+
+  context-free syntax
+    ConstrHead ConstrBody ->  ConstrDec {cons("ConstrDec")}
+    (Anno | ConstrMod)* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}
+
+
+    "{" ConstrInv? BlockStm* "}" -> ConstrBody {cons("ConstrBody")}
+
+             TypeArgs? "this"  "(" {Expr ","}* ")" ";" -> ConstrInv {cons("AltConstrInv")}
+             TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("SuperConstrInv")}
+    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("QSuperConstrInv")}
+
+  sorts ConstrMod
+  context-free syntax  
+    Public    -> ConstrMod
+    Protected -> ConstrMod
+    Private   -> ConstrMod
+
+
+
+
+module languages/java-15/classes/StaticInitializers
+imports
+  languages/java-15/statements/Blocks
+
+exports
+  sorts
+    StaticInit
+
+  context-free syntax
+    "static" Block -> StaticInit   {cons("StaticInit")}
+
+module languages/java-15/classes/InstanceInitializers
+imports
+  languages/java-15/statements/Blocks
+
+exports
+  sorts
+    InstanceInit
+
+  context-free syntax
+    Block -> InstanceInit {cons("InstanceInit")}
+
+module languages/java-15/statements/Statements
+imports
+  languages/java-15/statements/LocalVariableDeclarations
+  languages/java-15/statements/Blocks
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    Stm
+
+  context-free syntax
+    Block      -> Stm
+
+  %%%
+   %% Section 14.6: The Empty Statement
+   %%%
+  context-free syntax
+    ";"        -> Stm {cons("Empty")}
+
+  %%%
+   %% Section 14.7: Labeled Statements
+   %%%
+  context-free syntax
+    Id ":" Stm -> Stm {cons("Labeled")}
+
+  %%%
+   %% Section 14.8: Expressions Statements
+   %%%
+  context-free syntax
+    Expr ";"   -> Stm {cons("ExprStm")}
+
+  %%%
+   %% Section 14.9: The If Statement
+   %%%
+  context-free syntax
+    "if" "(" Expr ")" Stm             -> Stm {prefer, cons("If")}
+    "if" "(" Expr ")" Stm  "else" Stm -> Stm {cons("If")}
+
+  %%%
+   %% Section 14.10: The Assert Statement
+   %%%
+  context-free syntax
+    "assert" Expr          ";" -> Stm  {cons("AssertStm")}
+    "assert" Expr ":" Expr ";" -> Stm  {cons("AssertStm")}
+
+
+  %%%
+   %% Section 14.11: The Switch Statement
+   %%%
+  sorts SwitchBlock SwitchGroup SwitchLabel
+  context-free syntax
+    "switch" "(" Expr ")" SwitchBlock -> Stm {cons("Switch")}
+    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
+    SwitchLabel+ BlockStm+ -> SwitchGroup  {cons("SwitchGroup")}
+
+    "case" Expr ":" -> SwitchLabel {cons("Case")}
+    "default"   ":" -> SwitchLabel {cons("Default")}
+
+  %%%
+   %% Section 14.12: The While Statement
+   %%%
+  context-free syntax
+    "while" "(" Expr ")" Stm -> Stm {cons("While")}
+
+  %%%
+   %% Section 14.13: The Do Statement
+   %%%
+  context-free syntax
+  "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}
+
+
+  %%%
+   %% Section 14.14: The For Statement
+   %%%
+  context-free syntax
+    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+
+    "for" "(" FormalParam ":" Expr ")" Stm -> Stm {cons("ForEach")}
+
+  %%%
+   %% Section 14.15: The Break Statement
+   %%%
+  context-free syntax
+    "break"    Id? ";"   -> Stm {cons("Break")}
+
+  %%%
+   %% Section 14.16: The Continue Statement
+   %%%
+  context-free syntax
+    "continue" Id? ";"   -> Stm {cons("Continue")}
+
+  %%%
+   %% Section 14.17: The Return Statement
+   %%%
+  context-free syntax
+    "return"   Expr? ";" -> Stm {cons("Return")}
+
+  %%%
+   %% Section 14.18: The Throw Statement
+   %%%
+  context-free syntax
+    "throw"    Expr  ";" -> Stm {cons("Throw")}
+
+  %%%
+   %% Section 14.19: The Synchronized Statement
+   %%%
+  context-free syntax
+    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}
+
+  %%%
+   %% Section 14.20: The Try Statement
+   %%%
+  sorts CatchClause
+  context-free syntax
+    "try" Block CatchClause+ -> Stm {cons("Try")}
+    "try" Block CatchClause* "finally" Block -> Stm {cons("Try")}
+    "catch" "(" FormalParam ")" Block -> CatchClause {cons("Catch")}
+
+module languages/java-15/statements/LocalVariableDeclarations
+imports
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts
+    LocalVarDecStm
+    LocalVarDec
+
+  context-free syntax
+    LocalVarDec ";" -> LocalVarDecStm {prefer, cons("LocalVarDecStm")}
+    (Anno | VarMod)* Type {VarDec ","}+ -> LocalVarDec {prefer, cons("LocalVarDec")}
+
+module languages/java-15/statements/Blocks
+imports
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/statements/LocalVariableDeclarations
+  languages/java-15/statements/Statements
+
+exports
+  sorts
+    BlockStm
+    Block
+
+  context-free syntax
+    "{" BlockStm* "}" -> Block {cons("Block")}
+
+    LocalVarDecStm  -> BlockStm 
+    ClassDec        -> BlockStm {cons("ClassDecStm")}
+    Stm             -> BlockStm
+
+
+
+
+module languages/java-15/classes/MethodDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/Main
+  languages/java-15/classes/FieldDeclarations
+  languages/java-15/interfaces/Annotations
+  languages/java-15/statements/Blocks
+
+exports
+  sorts
+    MethodDec
+    MethodDecHead
+    ResultType
+
+  context-free syntax
+    MethodDecHead MethodBody -> MethodDec {cons("MethodDec")}
+
+    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
+    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}
+
+    Type   -> ResultType
+    "void" -> ResultType {cons("Void")}
+
+  sorts FormalParam
+  context-free syntax
+    (Anno | VarMod)* Type       VarDecId -> FormalParam {cons("Param")}
+    (Anno | VarMod)* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}
+
+  sorts VarMod
+  context-free syntax
+    Final -> VarMod
+
+  sorts MethodMod
+  context-free syntax
+    Public         -> MethodMod
+    Protected      -> MethodMod
+    Private        -> MethodMod
+
+    Abstract       -> MethodMod
+    Static         -> MethodMod
+    Final          -> MethodMod
+    Synchronized   -> MethodMod
+    Native         -> MethodMod
+    StrictFP       -> MethodMod
+
+  %%%
+   %% Section 8.4.6: Method Throws
+   %%%
+  sorts
+    Throws
+    ExceptionType
+
+  context-free syntax
+    "throws" {ExceptionType ","}+ -> Throws {cons("ThrowsDec")}
+    ClassType -> ExceptionType
+    %% TypeVar -> ExceptionType
+
+  %%%
+   %% Section 8.4.7: Method Body
+   %%% 
+  sorts MethodBody
+  context-free syntax
+    Block -> MethodBody
+    ";"   -> MethodBody {cons("NoMethodBody")}
+
+module languages/java-15/arrays/ArrayInitializers
+imports
+  languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts ArrayInit
+  context-free syntax
+    "{" {VarInit ","}*     "}" -> ArrayInit {cons("ArrayInit")}
+    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}
+
+module languages/java-15/interfaces/Annotations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/names/Main
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    Anno
+    ElemVal
+    ElemValPair
+
+  context-free syntax
+    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
+    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
+    "@" TypeName                            -> Anno {cons("MarkerAnno")}
+
+  context-free syntax  
+    Id "=" ElemVal -> ElemValPair {cons("ElemValPair")}
+
+    Expr -> ElemVal
+    Anno -> ElemVal
+
+    "{" {ElemVal ","}*     "}" -> ElemVal {cons("ElemValArrayInit")}
+    "{" {ElemVal ","}* "," "}" -> ElemVal {cons("ElemValArrayInit")}
+
+    %% Assignments are not allowed as element values.
+    LHS "=" Expr -> ElemVal {reject}
+
+module languages/java-15/classes/FieldDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/Main
+  languages/java-15/interfaces/Annotations
+  languages/java-15/arrays/ArrayInitializers
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    FieldDec
+    VarDec
+    VarDecId
+    Dim
+    VarInit
+
+  context-free syntax
+    (Anno | FieldMod)* Type { VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}
+
+    VarDecId             -> VarDec {cons("VarDec")}
+    VarDecId "=" VarInit -> VarDec {cons("VarDec")}
+
+    Id      -> VarDecId
+    Id Dim+ -> VarDecId {cons("ArrayVarDecId")}
+
+    "[" "]" -> Dim {cons("Dim")}
+
+    Expr      -> VarInit
+    ArrayInit -> VarInit
+
+  sorts FieldMod
+  context-free syntax
+    Public    -> FieldMod
+    Protected -> FieldMod
+    Private   -> FieldMod
+
+    Static    -> FieldMod
+    Final     -> FieldMod
+    Transient -> FieldMod
+    Volatile  -> FieldMod
+
+
+
+
+module languages/java-15/classes/ClassDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/ReferenceTypes
+  languages/java-15/types/TypeVariables
+  languages/java-15/classes/FieldDeclarations
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/classes/InstanceInitializers
+  languages/java-15/classes/StaticInitializers
+  languages/java-15/classes/ConstructorDeclarations
+  languages/java-15/classes/EnumDeclarations
+  languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts
+    ClassDec
+    ClassBody
+    ClassDecHead
+
+  context-free syntax
+    EnumDec -> ClassDec
+
+    ClassDecHead ClassBody -> ClassDec {cons("ClassDec")}
+    "{" ClassBodyDec* "}" -> ClassBody {cons("ClassBody")}
+
+    (Anno | ClassMod)* "class" Id  TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}
+
+  %% 8.1.1: Class Modifiers
+  sorts ClassMod
+  context-free syntax
+    Abstract  -> ClassMod
+    Public    -> ClassMod
+    Protected -> ClassMod
+    Private   -> ClassMod
+    Static    -> ClassMod
+    Final     -> ClassMod
+    StrictFP  -> ClassMod
+
+  %% 8.1.4: Superclasses and Subclasses
+  sorts Super
+  context-free syntax
+
+    "extends" ClassType -> Super {cons("SuperDec")}
+
+  %% 8.1.5: Superinterfaces
+  sorts Interfaces
+  context-free syntax
+    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}
+
+
+  %% 8.1.6: Class Body and Member Declarations
+  sorts
+    ClassBodyDec
+    ClassMemberDec
+
+  context-free syntax
+    ClassMemberDec -> ClassBodyDec
+    InstanceInit   -> ClassBodyDec
+    StaticInit     -> ClassBodyDec
+    ConstrDec      -> ClassBodyDec
+
+  context-free syntax
+    FieldDec     -> ClassMemberDec
+    MethodDec    -> ClassMemberDec
+    ClassDec     -> ClassMemberDec
+    InterfaceDec -> ClassMemberDec
+    ";"          -> ClassMemberDec {cons("Semicolon")}
+
+module languages/java-15/packages/TypeDeclarations
+imports
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts
+    TypeDec
+
+  context-free syntax
+    ClassDec      -> TypeDec
+    InterfaceDec  -> TypeDec
+    ";"           -> TypeDec {cons("Semicolon")}
+
+module languages/java-15/packages/CompilationUnits
+imports
+  languages/java-15/packages/PackageDeclarations
+  languages/java-15/packages/ImportDeclarations
+  languages/java-15/packages/TypeDeclarations
+
+exports
+  sorts
+    CompilationUnit
+
+  context-free syntax
+    PackageDec? ImportDec* TypeDec+ -> CompilationUnit   {cons("CompilationUnit")}
+
+module languages/java-15/packages/Main
+imports
+  languages/java-15/packages/CompilationUnits
+  languages/java-15/packages/ImportDeclarations
+  languages/java-15/packages/PackageDeclarations
+
+
+
+
+module languages/java-15/names/Main
+imports
+  languages/java-15/lexical/Identifiers
+exports
+  sorts PackageName
+  context-free syntax
+    {Id "."}+ -> PackageName {cons("PackageName")}
+
+  sorts
+    TypeName
+    ExprName
+    MethodName
+    PackageOrTypeName
+    AmbName
+
+  context-free syntax
+    Id             -> AmbName {cons("AmbName")}
+    AmbName "." Id -> AmbName {cons("AmbName")}
+
+    Id                       -> TypeName {cons("TypeName")}
+    PackageOrTypeName "." Id -> TypeName {cons("TypeName")}
+
+    Id             -> ExprName {cons("ExprName")}
+    AmbName "." Id -> ExprName {cons("ExprName")}
+
+    Id             -> MethodName  {cons("MethodName")}
+    AmbName "." Id -> MethodName  {cons("MethodName")}
+
+    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
+    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}
+
+module languages/java-15/types/ParameterizedTypes
+imports
+  languages/java-15/types/ReferenceTypes
+
+exports
+  sorts
+    TypeArgs
+    ActualTypeArg
+    WildcardBound
+    
+  context-free syntax
+    "<" {ActualTypeArg ","}+ ">" -> TypeArgs {cons("TypeArgs")}
+
+    Type               -> ActualTypeArg
+    "?" WildcardBound? -> ActualTypeArg {cons("Wildcard")}
+
+    "extends" RefType -> WildcardBound {cons("WildcardUpperBound")}
+    "super"   RefType -> WildcardBound {cons("WildcardLowerBound")}
+
+module languages/java-15/types/TypeVariables
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/types/ReferenceTypes
+
+exports
+  sorts
+    TypeParams
+    TypeParam
+    TypeBound
+    TypeVarId
+  
+  context-free syntax
+    TypeVarId TypeBound? -> TypeParam {cons("TypeParam")}
+    
+    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound {cons("TypeBound")}
+    "<" {TypeParam ","}+ ">" -> TypeParams {cons("TypeParams")}
+
+    Id -> TypeVarId
+    
+
+
+
+module languages/java-15/types/ReferenceTypes
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/names/Main
+  languages/java-15/types/Main  
+  languages/java-15/types/ParameterizedTypes
+  languages/java-15/types/TypeVariables
+
+
+exports
+  sorts
+    RefType
+    ClassOrInterfaceType
+    ClassType
+    InterfaceType
+    TypeDecSpec
+    ArrayType
+    TypeVar
+
+  context-free syntax
+    ClassOrInterfaceType -> RefType
+    ArrayType            -> RefType
+    
+    %% This production rule is highly ambiguous, since every
+    %% TypeVar can be a ClassOrInterfaceType. A later disambiguation
+    %% phase has to find out if a ClassOrInterfaceType is in fact
+    %% a TypeVar.
+    
+    %% TypeVar -> RefType {avoid}
+
+  context-free syntax
+  
+    %% ClassType and InterfaceType are ambiguous. We modify the
+    %% production of ClassOrInterfaceType to make this ambiguity explicit.
+    
+    TypeDecSpec TypeArgs? -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
+    TypeDecSpec TypeArgs? -> ClassType {cons("ClassType")}
+    TypeDecSpec TypeArgs? -> InterfaceType {cons("InterfaceType")}
+
+    TypeName -> TypeDecSpec
+    TypeDecSpec TypeArgs "." Id -> TypeDecSpec {cons("Member")}
+    
+  context-free syntax    
+    TypeVarId -> TypeVar {cons("TypeVar")}
+
+  context-free syntax
+    Type "[" "]" -> ArrayType  {cons("ArrayType")}
+
+module languages/java-15/types/PrimitiveTypes
+exports
+  sorts
+    PrimType
+    NumType
+    IntType  
+    FloatType
+
+  context-free syntax
+    NumType   -> PrimType
+    "boolean" -> PrimType {cons("Boolean")}
+
+    IntType   -> NumType
+    FloatType -> NumType
+
+    "byte"   -> IntType   {cons("Byte")}
+    "short"  -> IntType   {cons("Short")}
+    "int"    -> IntType   {cons("Int")}
+    "long"   -> IntType   {cons("Long")}
+    "char"   -> IntType   {cons("Char")}
+    "float"  -> FloatType {cons("Float")}
+    "double" -> FloatType {cons("Double")}
+
+module languages/java-15/types/Main
+imports
+  languages/java-15/types/PrimitiveTypes
+  languages/java-15/types/ReferenceTypes
+  languages/java-15/types/TypeVariables
+  languages/java-15/types/ParameterizedTypes
+
+exports
+  sorts
+    Type
+
+  context-free syntax
+    PrimType -> Type
+    RefType  -> Type
+
+
+
+
+module languages/java-15/lexical/literals/NullLiteral
+exports
+  sorts NullLiteral
+  context-free syntax
+    "null"  -> NullLiteral {cons("Null")}
+
+module languages/java-15/lexical/literals/StringLiterals
+imports
+  languages/java-15/lexical/literals/EscapeSequences
+  languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts
+    StringLiteral
+    StringPart
+    StringChars
+    FooStringChars
+
+  syntax
+    StringLiteral -> <StringLiteral-CF>
+    
+    "\"" StringPart* "\"" -> StringLiteral {cons("String")}
+    StringChars    -> StringPart {cons("Chars")}
+    UnicodeEscape  -> StringPart
+    EscapeSeq      -> StringPart
+
+    <FooStringChars-LEX> -> StringChars
+    ~[\"\\\n\13]+  -> <FooStringChars-LEX>
+
+  restrictions
+    StringChars -/- ~[\"\\\n\13]
+
+module languages/java-15/lexical/literals/EscapeSequences
+imports
+
+exports
+  sorts
+    EscapeSeq
+    NamedEscape
+    OctaEscape
+    LastOcta
+
+  syntax
+    OctaEscape  -> EscapeSeq
+    NamedEscape -> EscapeSeq
+
+    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
+    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
+    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}
+
+    [0-7] -> LastOcta
+
+  restrictions
+    LastOcta -/- [0-7]
+
+module languages/java-15/lexical/literals/CharacterLiterals
+imports
+  languages/java-15/lexical/literals/EscapeSequences
+  languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts
+    CharLiteral
+    CharContent
+    SingleChar
+
+  syntax
+    CharLiteral   -> <CharLiteral-CF>
+
+    "'" CharContent "'" -> CharLiteral {cons("Char")}
+    SingleChar    -> CharContent {cons("Single")}
+    UnicodeEscape -> CharContent
+    EscapeSeq     -> CharContent
+
+    ~[\r\n\'\\] -> SingleChar
+
+
+
+
+module languages/java-15/lexical/literals/BooleanLiterals
+exports
+  sorts
+    Bool
+    BoolLiteral
+
+  context-free syntax
+    Bool -> BoolLiteral {cons("Bool")}
+    "true"  -> Bool {cons("True")}
+    "false" -> Bool {cons("False")}
+
+module languages/java-15/lexical/literals/FloatingPointLiterals
+exports
+  sorts
+    FloatLiteral
+    DeciFloatLiteral
+    HexaFloatLiteral      
+  
+  context-free syntax
+    DeciFloatLiteral -> FloatLiteral {cons("Float")}
+    HexaFloatLiteral -> FloatLiteral {cons("Float")}
+
+  lexical syntax
+    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral
+    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral
+    
+    %% Reject plain integer literals as decimal float literals.
+    %% A similar rejection for hexadecimal float literals is not
+    %% required, since these always contain an exponent part.
+    [0-9]+ -> DeciFloatLiteral {reject}
+
+  lexical restrictions
+    DeciFloatLiteral -/- [fFdD]
+    HexaFloatLiteral -/- [fFdD]
+
+  %%%
+   %% Decimal Floating Point Numerals
+   %%%
+  sorts
+    DeciFloatNumeral
+    DeciFloatDigits
+    DeciFloatExponentPart
+
+  lexical syntax
+    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral
+
+    [0-9]* "." [0-9]* -> DeciFloatDigits
+           "."        -> DeciFloatDigits {reject}
+    [0-9]+            -> DeciFloatDigits
+
+    [eE] SignedInteger -> DeciFloatExponentPart
+    
+    [\+\-]? [0-9]+ -> SignedInteger    
+
+  lexical restrictions
+    DeciFloatDigits  -/- [0-9]
+    DeciFloatExponentPart -/- [0-9]
+
+  %%%
+   %% Hexadecimal Floating Point Literals
+   %%%
+  sorts
+    HexaFloatNumeral
+    HexaSignificand
+    BinaryExponent
+    SignedInteger
+    
+  lexical syntax
+    HexaSignificand BinaryExponent -> HexaFloatNumeral
+
+    [0][xX] [0-9a-fA-F]+                  -> HexaSignificand
+    [0][xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand
+    [0][xX]              "."              -> HexaSignificand {reject}
+
+    [pP] SignedInteger -> BinaryExponent
+  lexical restrictions
+    HexaSignificand -/- [0-9a-fA-F]
+    SignedInteger   -/- [0-9]
+
+module languages/java-15/lexical/literals/IntegerLiterals
+exports
+  sorts
+    IntLiteral
+    DeciLiteral
+    HexaLiteral
+    OctaLiteral
+    DeciNumeral
+    HexaNumeral
+    OctaNumeral
+
+  context-free syntax
+    DeciLiteral -> IntLiteral {cons("Deci")}
+    HexaLiteral -> IntLiteral {cons("Hexa")}
+    OctaLiteral -> IntLiteral {cons("Octa")}
+
+  lexical syntax
+    DeciNumeral [lL]? -> DeciLiteral
+    HexaNumeral [lL]? -> HexaLiteral
+    OctaNumeral [lL]? -> OctaLiteral
+
+    "0" -> DeciNumeral
+    [1-9][0-9]*  -> DeciNumeral
+    [0][xX] [0-9a-fA-F]+ -> HexaNumeral
+    [0]     [0-7]+       -> OctaNumeral
+
+  lexical restrictions
+    DeciNumeral -/- [0-9\.fFdD]
+    HexaNumeral -/- [0-9a-fA-F]
+    OctaNumeral -/- [0-7]
+
+    DeciLiteral -/- [lL]
+    HexaLiteral -/- [lL]
+    OctaLiteral -/- [lL]
+
+module languages/java-15/lexical/literals/Main
+imports
+  languages/java-15/lexical/literals/IntegerLiterals
+  languages/java-15/lexical/literals/FloatingPointLiterals
+  languages/java-15/lexical/literals/BooleanLiterals  
+  languages/java-15/lexical/literals/CharacterLiterals  
+  languages/java-15/lexical/literals/StringLiterals
+  languages/java-15/lexical/literals/NullLiteral
+
+
+
+
+module languages/java-15/lexical/Modifiers
+exports
+  sorts
+    Public
+    Private
+    Protected
+    Abstract
+    Final
+    Static
+    Native
+    Transient
+    Volatile
+    Synchronized
+    StrictFP
+    Modifier
+
+  context-free syntax
+    "public"       -> Public       {cons("Public")}
+    "private"      -> Private      {cons("Private")}
+    "protected"    -> Protected    {cons("Protected")}
+
+    "abstract"     -> Abstract     {cons("Abstract")}
+    "final"        -> Final        {cons("Final")}
+    "static"       -> Static       {cons("Static")}
+    "native"       -> Native       {cons("Native")}
+    "transient"    -> Transient    {cons("Transient")}
+    "volatile"     -> Volatile     {cons("Volatile")}
+    "synchronized" -> Synchronized {cons("Synchronized")}
+    "strictfp"     -> StrictFP     {cons("StrictFP")}
+
+    Public       -> Modifier
+    Private      -> Modifier
+    Protected    -> Modifier
+    Abstract     -> Modifier
+    Final        -> Modifier
+    Static       -> Modifier
+    Native       -> Modifier
+    Transient    -> Modifier
+    Volatile     -> Modifier
+    Synchronized -> Modifier
+    StrictFP     -> Modifier
+
+
+
+
+module languages/java-15/lexical/Keywords
+exports
+  sorts Keyword
+  lexical syntax
+    "abstract"      -> Keyword
+    "assert"        -> Keyword
+    "boolean"       -> Keyword
+    "break"         -> Keyword
+    "byte"          -> Keyword
+    "case"          -> Keyword
+    "catch"         -> Keyword
+    "char"          -> Keyword
+    "class"         -> Keyword
+    "const"         -> Keyword
+    "continue"      -> Keyword
+    "default"       -> Keyword
+    "do"            -> Keyword
+    "double"        -> Keyword
+    "else"          -> Keyword
+    "enum"          -> Keyword
+    "extends"       -> Keyword
+    "final"         -> Keyword
+    "finally"       -> Keyword
+    "float"         -> Keyword
+    "for"           -> Keyword
+    "goto"          -> Keyword
+    "if"            -> Keyword
+    "implements"    -> Keyword
+    "import"        -> Keyword
+    "instanceof"    -> Keyword
+    "int"           -> Keyword
+    "interface"     -> Keyword
+    "long"          -> Keyword
+    "native"        -> Keyword
+    "new"           -> Keyword
+    "package"       -> Keyword
+    "private"       -> Keyword
+    "protected"     -> Keyword
+    "public"        -> Keyword
+    "return"        -> Keyword
+    "short"         -> Keyword
+    "static"        -> Keyword
+    "strictfp"      -> Keyword
+    "super"         -> Keyword
+    "switch"        -> Keyword
+    "synchronized"  -> Keyword
+    "this"          -> Keyword
+    "throw"         -> Keyword
+    "throws"        -> Keyword
+    "transient"     -> Keyword
+    "try"           -> Keyword
+    "void"          -> Keyword
+    "volatile"      -> Keyword
+    "while"         -> Keyword
+
+  lexical restrictions
+
+    "abstract"
+    "assert"
+    "boolean" 
+    "break"   
+    "byte"    
+    "case"    
+    "catch"   
+    "char"     
+    "class"
+    "const"    
+    "continue" 
+    "default"  
+    "do"       
+    "double"   
+    "else"     
+    "enum"
+    "extends"  
+    "final"     
+    "finally"   
+    "float"     
+    "for"       
+    "goto"       
+    "if"         
+    "implements" 
+    "import"     
+    "instanceof" 
+    "int"        
+    "interface"  
+    "long"       
+    "native"     
+    "new"        
+    "package"    
+    "private"    
+    "protected"   
+    "public"       
+    "return"       
+    "short"        
+    "static"     
+    "strictfp"
+    "super"        
+    "switch"       
+    "synchronized" 
+    "this"         
+    "throw"        
+    "throws"       
+    "transient"    
+    "try"          
+    "void"         
+    "volatile"     
+    "while"       -/- [A-Za-z0-9\_\$]
+
+module languages/java-15/lexical/Identifiers
+imports
+  languages/java-15/lexical/Keywords
+exports
+  sorts
+    Id
+    ID
+
+  context-free syntax
+    ID -> Id {cons("Id")}
+
+  lexical syntax
+    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> ID
+    
+    Keyword -> ID {reject}
+    "true"  -> ID {reject}
+    "false" -> ID {reject}
+    "null"  -> ID {reject}
+
+  lexical restrictions
+    ID -/- [a-zA-Z0-9\_\$]
+
+module languages/java-15/lexical/Comments
+imports
+  languages/java-15/lexical/LineTerminators
+exports
+  sorts
+    Comment
+    EOLCommentChars
+    CommentPart
+    UnicodeEscape
+    BlockCommentChars
+    Asterisk
+    EscEscChar
+    EscChar
+
+  lexical syntax
+    Comment -> LAYOUT
+
+    "//" EOLCommentChars LineTerminator -> Comment
+    ~[\n\r]* -> EOLCommentChars
+
+    "/*"  CommentPart* "*/" -> Comment
+    "/**" CommentPart* "*/" -> Comment
+    "/**/"                  -> Comment %% Strange javadoc comment
+
+    BlockCommentChars -> CommentPart
+    EscChar           -> CommentPart
+    EscEscChar        -> CommentPart
+    Asterisk          -> CommentPart
+    UnicodeEscape     -> CommentPart
+
+    ~[\*\\]+ -> BlockCommentChars
+
+    "*"    -> Asterisk
+    "\\\\" -> EscEscChar
+    "\\"   -> EscChar
+
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape
+
+  lexical restrictions
+    "/**"    -/- [\/]
+    "/*"     -/- [\*]
+    Asterisk -/- [\/]
+    EscChar  -/- [\\u]
+
+    BlockCommentChars -/- ~[\*\\]
+    EOLCommentChars   -/- ~[\n\13]
+
+  context-free restrictions
+    LAYOUT?  -/- [\/].[\*]
+    LAYOUT?  -/- [\/].[\/]
+
+module languages/java-15/lexical/WhiteSpace
+exports
+  lexical syntax
+    [\ \t\12\r\n] -> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\12\n\r]
+
+module languages/java-15/lexical/LineTerminators
+exports
+  sorts
+    LineTerminator CarriageReturn EndOfFile
+
+  lexical syntax
+    [\n]           -> LineTerminator
+    [\r][\n]       -> LineTerminator
+    CarriageReturn -> LineTerminator
+    EndOfFile      -> LineTerminator
+
+    [\r] -> CarriageReturn
+
+  lexical restrictions
+    CarriageReturn -/- [\n]
+
+  %% End of file is empty.
+  lexical syntax    
+    -> EndOfFile
+
+  lexical restrictions
+    EndOfFile -/- ~[]
+
+module languages/java-15/lexical/UnicodeEscapes
+exports
+  sorts
+    UnicodeEscape
+
+  syntax
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}
+
+module languages/java-15/lexical/Main
+imports
+  languages/java-15/lexical/UnicodeEscapes
+  languages/java-15/lexical/LineTerminators
+  languages/java-15/lexical/WhiteSpace
+  languages/java-15/lexical/Comments
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Keywords
+  languages/java-15/lexical/Modifiers
+  languages/java-15/lexical/literals/Main
+
+
+
+module languages/java-15/Main
+imports
+  languages/java-15/lexical/Main
+  languages/java-15/types/Main
+  languages/java-15/names/Main
+  languages/java-15/packages/Main
+  languages/java-15/classes/Main
+  languages/java-15/interfaces/Main
+  languages/java-15/arrays/Main
+  languages/java-15/statements/Main
+  languages/java-15/expressions/Main
+
+
+
+
+module languages/java/EmbeddedJava[E]
+imports
+  languages/java-15/Main
+
+exports
+  variables
+    [ij]  [0-9\']*            -> DeciLiteral {prefer}
+    [ij]  [\_] [a-zA-Z0-9\']* -> DeciLiteral {prefer}
+    [xyz] [0-9\']*            -> ID          {prefer}
+    [xyz] [\_] [a-zA-Z0-9\']* -> ID          {prefer}
+
+  context-free restrictions
+    ID -/- [\_a-zA-Z0-9\']
+
+%%%
+ %% Expressions
+ %%%
+exports
+
+  %%%
+   %% Variables for Expressions
+   %%%
+  variables
+    "e"    [0-9\']*         -> Expr           {prefer}
+    "e_" [a-zA-Z0-9\']*     -> Expr           {prefer}
+    "e"    [0-9\']* "*"     -> {VarInit ","}* {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {VarInit ","}* {prefer}
+    "e"    [0-9\']* "*"     -> {Expr ","}*    {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {Expr ","}*    {prefer}
+
+  lexical syntax
+    "e" [0-9\']*            -> ID {reject}
+    "e_" [a-zA-Z0-9\']*     -> ID {reject}
+
+  %%%
+   %% Quotations for Expressions
+   %%%
+  context-free syntax
+            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+
+    "var-init" "|[" VarInit "]|" -> E {cons("ToMetaExpr")}
+
+%%%
+ %% Statements
+ %%%
+exports
+
+  %%%
+   %% Variables for Statements
+   %%%
+  variables
+    "stm"  [0-9\']*             -> Stm         {prefer}
+    "stm_" [a-zA-Z0-9\']*       -> Stm         {prefer}
+    "bstm" [0-9\']*             -> BlockStm    {prefer}
+    "bstm_" [a-zA-Z0-9\']*      -> BlockStm    {prefer}
+    "bstm" [0-9\']* "*"         -> BlockStm*   {prefer}    
+    "bstm_" [a-zA-Z0-9\']* "*"  -> BlockStm*   {prefer}
+
+  %%%
+   %% Quotations for Statements
+   %%%
+  context-free syntax
+    "java:bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+         "bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+    "java"       "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+                 "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+
+    "java:bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+         "bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+
+    "java:block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+         "block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+    "java"            "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+                      "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+
+    "java:block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+         "block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+
+
+    "java:stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
+         "stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
+         
+         "switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}         
+    "java:switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}
+    
+  %%%
+   %% Anti Quotations for Statements
+   %%%
+  context-free syntax
+    "~"       E  -> BlockStm  {cons("FromMetaExpr")}
+    "~bstm:"  E  -> BlockStm  {cons("FromMetaExpr")}
+    "~*"      E  -> BlockStm* {cons("FromMetaExpr")}
+    "~bstm*:" E  -> BlockStm* {cons("FromMetaExpr")}
+
+    "~stm:"   E  -> Stm {cons("FromMetaExpr"), prefer}
+    "~"       E  -> Stm {cons("FromMetaExpr")}
+
+    "~*"              E -> SwitchGroup* {cons("FromMetaExpr")}    
+    "~switch-group*:" E -> SwitchGroup* {cons("FromMetaExpr")}    
+
+    "~"               E -> SwitchGroup {cons("FromMetaExpr")}
+    "~switch-group:"  E -> SwitchGroup {cons("FromMetaExpr")}
+
+%%%
+ %% Variable Declarations
+ %%%
+
+  %%%
+   %% Variables for Variable Declarations
+   %%%
+  variables
+    "lvdec" [0-9]*            -> LocalVarDec    {prefer}
+    "lvdec_" [a-zA-Z0-9]*     -> LocalVarDec    {prefer}
+     "vdec" [0-9]*            -> VarDec         {prefer}
+     "vdec_" [a-zA-Z0-9]*     -> VarDec         {prefer}
+     "vdec"  [0-9]* "*"       -> {VarDec ","}+  {prefer}
+     "vdec_" [a-zA-Z0-9]* "*" -> {VarDec ","}+  {prefer}
+
+  lexical syntax
+    "lvdec"               -> ID {reject}
+    "lvdec_" [a-zA-Z0-9]* -> ID {reject}
+     "vdec"               -> ID {reject}
+     "vdec_" [a-zA-Z0-9]* -> ID {reject}
+
+  %%%
+   %% Quotations for Local Variable Declarations
+   %%%
+  context-free syntax
+    "java:lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
+         "lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
+
+    "java:vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}
+         "vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti Quotations for Local Variable Declarations
+   %%%
+  context-free syntax
+
+%%%
+ %% LeftHandSide of Assignment
+ %%%
+exports
+
+  %%%
+   %% Variables for LeftHandSide of Assignment
+   %%%
+  variables
+    "lhs" [0-9\']* -> LHS {prefer}
+    "e"   [0-9\']* -> LHS {prefer}
+
+  lexical syntax
+    "lhs" [0-9\']* -> ID {reject}
+
+%%%
+ %% Types
+ %%%
+exports
+
+  %%%
+   %% Variables for Types
+   %%%
+  variables
+    MetaTypeVar     -> Type     {prefer}
+    MetaPrimTypeVar -> PrimType {prefer}
+    MetaRefTypeVar  -> RefType  {prefer}
+
+  lexical syntax
+    "t"  [0-9\']*        -> MetaTypeVar
+    "t_" [a-zA-Z0-9\']*  -> MetaTypeVar
+    "ty" [0-9]*          -> MetaTypeVar
+    "ty_" [a-zA-Z0-9\']* -> MetaTypeVar
+
+    "primt"  [0-9]*        -> MetaPrimTypeVar
+    "primt_" [a-zA-Z0-9]*  -> MetaPrimTypeVar
+    "primty" [0-9]*        -> MetaPrimTypeVar
+    "primty_" [a-zA-Z0-9]* -> MetaPrimTypeVar
+    "reft"   [0-9]*        -> MetaRefTypeVar
+    "reft_" [a-zA-Z0-9]*   -> MetaRefTypeVar
+    "refty"  [0-9]*        -> MetaRefTypeVar
+    "refty_" [a-zA-Z0-9]*  -> MetaRefTypeVar
+
+    "t"  [0-9\']*          -> ID {reject}
+    "t_" [a-zA-Z0-9]*      -> ID {reject}
+    "ty" [0-9]*            -> ID {reject}
+    "ty_" [a-zA-Z0-9]*     -> ID {reject}
+    "primt"  [0-9]*        -> ID {reject}
+    "primt_" [a-zA-Z0-9]*  -> ID  {reject}
+    "primty" [0-9]*        -> ID {reject}
+    "primty_" [a-zA-Z0-9]* -> ID {reject}
+    "reft"   [0-9]*        -> ID {reject}
+    "reft_" [a-zA-Z0-9]*   -> ID {reject}    
+    "refty"  [0-9]*        -> ID {reject}
+    "refty_" [a-zA-Z0-9]*  -> ID {reject}
+
+  lexical restrictions
+    MetaTypeVar -/- [a-zA-Z0-9\_\$\']
+
+  %%%
+   %% Quotation for Types
+   %%%
+  context-free syntax
+            "t" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+           "ty" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+
+    "java:type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+         "type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+    "java"      "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+                "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti-Quotation for Types
+   %%%
+  context-free syntax
+    "~"       E -> Type {cons("FromMetaExpr")}
+    "~type:"  E -> Type {cons("FromMetaExpr")}
+
+%%%
+ %% Names
+ %%%
+exports
+
+  %%%
+   %% Variables for Names
+   %%%
+  variables
+    "ambname"  [0-9]*        -> AmbName    {prefer}
+    "ambname_" [a-zA-Z0-9]*  -> AmbName    {prefer}
+    "ename"    [0-9]*        -> ExprName   {prefer}
+    "ename_" [a-zA-Z0-9]*    -> ExprName   {prefer}
+    "fname"    [0-9]*        -> MethodName {prefer}
+    "fname_" [a-zA-Z0-9]*    -> MethodName {prefer}
+    "tname"    [0-9]*        -> TypeName   {prefer}
+    "tname_" [a-zA-Z0-9]*    -> TypeName   {prefer}
+    "pkgtname" [0-9]*        -> PackageOrTypeName  {prefer}
+    "pkgtname_" [a-zA-Z0-9]* -> PackageOrTypeName  {prefer}
+    "pkgname" [0-9]*         -> PackageName  {prefer}
+    "pkgname_" [a-zA-Z0-9]*  -> PackageName  {prefer}
+
+  %%%
+   %% Quotations for Names
+   %%%
+  context-free syntax
+    "ambname"  "|[" AmbName    "]|" -> E {cons("ToMetaExpr")}
+    "ename"    "|[" ExprName   "]|" -> E {cons("ToMetaExpr")}
+    "fname"    "|[" MethodName "]|" -> E {cons("ToMetaExpr")}
+    "tname"    "|[" TypeName   "]|" -> E {cons("ToMetaExpr")}
+    "pkgtname" "|[" PackageOrTypeName "]|" -> E {cons("ToMetaExpr")}
+
+%%%
+ %% Modifiers
+ %%%
+exports
+
+  %%%
+   %% Variables for Modifiers
+   %%%
+  variables
+     "mod" [0-9]*            -> MethodMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> MethodMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | MethodMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | MethodMod)* {prefer}
+     
+     "mod" [0-9]*            -> ClassMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> ClassMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | ClassMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ClassMod)* {prefer}
+     
+     "mod" [0-9]*            -> ConstrMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> ConstrMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | ConstrMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ConstrMod)* {prefer}
+     
+     "mod" [0-9]*            -> VarMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> VarMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | VarMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | VarMod)* {prefer}
+
+     "mod" [0-9]*            -> FieldMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> FieldMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | FieldMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | FieldMod)* {prefer}
+
+  %%%
+   %% Quotations for Modifiers
+   %%%
+  context-free syntax
+           "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
+    "mod"  "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
+
+    "anno" "|[" Anno "]|" -> E {cons("ToMetaExpr")}
+
+
+%%%
+ %% Formal Parameters
+ %%%
+exports
+
+  %%%
+   %% Variables for Formal Parameters
+   %%%
+  variables
+     "param" [0-9]*            -> FormalParam  {prefer}
+     "param_" [a-zA-Z0-9]*     -> FormalParam  {prefer}
+     "param" [0-9]* "*"        -> {FormalParam ","}*  {prefer}
+     "param_" [a-zA-Z0-9]* "*" -> {FormalParam ","}* {prefer}
+
+  %%%
+   %% Quotations for Formal Parameters
+   %%%
+  context-free syntax
+
+         "param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+    "java:param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+
+         "param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+    "java:param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+
+    "java:formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+         "formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+    "java"              "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+                        "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+
+    "java:formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+         "formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+    "java"               "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+                         "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti Quotations for Formal Parameters
+   %%%
+  context-free syntax
+    "~"  E  ->  FormalParam       {cons("FromMetaExpr")}
+    "~*" E  -> {FormalParam ","}* {cons("FromMetaExpr")}
+
+%%%
+ %% Package Declarations
+ %%%
+exports
+
+  %%%
+   %% Quotations
+   %%%
+  context-free syntax
+    "java:package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
+         "package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
+                       "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
+         "package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti Quotations
+   %%%
+  context-free syntax
+    "~package-dec:"  E -> PackageDec {cons("FromMetaExpr")}
+    "~package-dec?:" E -> PackageDec? {cons("FromMetaExpr")}
+
+%%%
+ %% Import Declarations
+ %%%
+exports
+
+  %%%
+   %% Quotations for Import Declarations
+   %%%
+  context-free syntax
+
+    "java:import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
+         "import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
+                       "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
+         "import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
+
+  %%%
+   %% Anti Quotations for Import Declarations
+   %%%
+  context-free syntax
+
+    "~import-dec:"  E  -> ImportDec  {cons("FromMetaExpr")}
+    "~import-dec*:" E  -> ImportDec* {cons("FromMetaExpr")}
+
+%%%
+ %% Must be cleaned up
+ %%%
+exports
+  context-free syntax
+            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+
+    "java:compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+         "compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+    "java"                  "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+                            "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+
+    "java:importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
+         "importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
+    "java"            "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
+
+    "java:type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+         "type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+    "java"          "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+                    "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+
+    "java:class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+         "class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+    "java"                "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+                          "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}
+         "interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}
+         "constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
+         "class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
+    "java"                 "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
+                           "|[" ClassBodyDec* "]|" -> E {cons("ToMetaListExpr")}
+
+    "java:stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}
+         "stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}
+
+    "java:imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+         "imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+    "java"             "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+                       "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+         "imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+    "java"              "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+                        "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+
+  %% Anti-quotation
+  context-free syntax
+
+    "~"      E -> Name {cons("FromMetaExpr")}
+    "~name:" E -> Name {cons("FromMetaExpr")}
+    "~*:"    E -> Name {cons("FromMetaExpr")}
+
+    "~"     E     -> Id   {cons("FromMetaExpr")}
+    "~id:"  E     -> Id   {cons("FromMetaExpr")}
+    "~idd:" E ":" -> Id   {cons("FromMetaExpr")}
+
+    "~x:" E -> ID {cons("FromMetaExpr")}
+
+    "~"  E -> TypeParam        {cons("FromMetaExpr")}
+    "~*" E -> {TypeParam ","}+ {cons("FromMetaExpr")}
+
+    "~*" E -> {ExceptionType ","}* {cons("FromMetaExpr")}
+
+    "~"      E  ->  Expr {cons("FromMetaExpr")}
+    "~e:"    E  ->  Expr {prefer, cons("FromMetaExpr")}
+    "~expr:" E  ->  Expr {prefer, cons("FromMetaExpr")}
+
+    "~*" E      -> {Expr ","}*    {cons("FromMetaExpr")}
+    "~*" E      -> {VarInit ","}* {cons("FromMetaExpr")}
+
+    "~"  E  -> TypeDec  {cons("FromMetaExpr")}
+    "~*" E  -> TypeDec* {cons("FromMetaExpr")}
+
+    "~"  E  -> ClassBodyDec  {cons("FromMetaExpr")}
+    "~*" E  -> ClassBodyDec* {cons("FromMetaExpr")}
+
+    "~"  E  -> InterfaceMemberDec  {cons("FromMetaExpr")}
+    "~*" E  -> InterfaceMemberDec* {cons("FromMetaExpr")}
+
+    "~i:"      E -> DeciLiteral   {cons("FromMetaExpr")}
+    "~deci:"   E -> DeciLiteral   {cons("FromMetaExpr")}
+    "~hexa:"   E -> HexaLiteral   {cons("FromMetaExpr")}
+    "~octa:"   E -> OctaLiteral   {cons("FromMetaExpr")}
+    "~float:"  E -> FloatLiteral  {cons("FromMetaExpr")}
+    "~string:" E -> StringLiteral {cons("FromMetaExpr")}
+    "~char:"   E -> CharLiteral   {cons("FromMetaExpr")}
+
+  syntax
+    "~" <E-CF> -> StringChars {cons("FromMetaExpr"), prefer}
+    "~" <E-CF> <LAYOUT?-CF> -> SingleChar  {cons("FromMetaExpr"), prefer}
+
+module languages/java/EmbeddedJavaMix[Ctx0 E]
+imports languages/java/EmbeddedJava[E]
+          [ Name                  => Name[[Ctx0]]
+            MetaRefTypeVar        => MetaRefTypeVar[[Ctx0]]
+            MetaPrimTypeVar       => MetaPrimTypeVar[[Ctx0]]
+            MetaTypeVar           => MetaTypeVar[[Ctx0]]
+            CompilationUnit       => CompilationUnit[[Ctx0]]
+            TypeDec               => TypeDec[[Ctx0]]
+            ImportDec             => ImportDec[[Ctx0]]
+            PackageDec            => PackageDec[[Ctx0]]
+            ElemVal               => ElemVal[[Ctx0]]
+            ElemValPair           => ElemValPair[[Ctx0]]
+            Anno                  => Anno[[Ctx0]]
+            LHS                   => LHS[[Ctx0]]
+            CondMid               => CondMid[[Ctx0]]
+            ArraySubscript        => ArraySubscript[[Ctx0]]
+            DimExpr               => DimExpr[[Ctx0]]
+            ArrayBaseType         => ArrayBaseType[[Ctx0]]
+            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
+            ClassMemberDec        => ClassMemberDec[[Ctx0]]
+            ClassBodyDec          => ClassBodyDec[[Ctx0]]
+            Interfaces            => Interfaces[[Ctx0]]
+            Super                 => Super[[Ctx0]]
+            ClassMod              => ClassMod[[Ctx0]]
+            ClassDecHead          => ClassDecHead[[Ctx0]]
+            ClassBody             => ClassBody[[Ctx0]]
+            ClassDec              => ClassDec[[Ctx0]]
+            InterfaceMod          => InterfaceMod[[Ctx0]]
+            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
+            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
+            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
+            InterfaceDec          => InterfaceDec[[Ctx0]]
+            DefaultVal            => DefaultVal[[Ctx0]]
+            AnnoElemDec           => AnnoElemDec[[Ctx0]]
+            AnnoDecHead           => AnnoDecHead[[Ctx0]]
+            AnnoDec               => AnnoDec[[Ctx0]]
+            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
+            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
+            ConstantMod           => ConstantMod[[Ctx0]]
+            ConstantDec           => ConstantDec[[Ctx0]]
+            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
+            EnumConstArgs         => EnumConstArgs[[Ctx0]]
+            EnumConst             => EnumConst[[Ctx0]]
+            EnumBody              => EnumBody[[Ctx0]]
+            EnumDecHead           => EnumDecHead[[Ctx0]]
+            EnumDec               => EnumDec[[Ctx0]]
+            ConstrMod             => ConstrMod[[Ctx0]]
+            ConstrInv             => ConstrInv[[Ctx0]]
+            ConstrBody            => ConstrBody[[Ctx0]]
+            ConstrHead            => ConstrHead[[Ctx0]]
+            ConstrDec             => ConstrDec[[Ctx0]]
+            StaticInit            => StaticInit[[Ctx0]]
+            InstanceInit          => InstanceInit[[Ctx0]]
+            MethodBody            => MethodBody[[Ctx0]]
+            ExceptionType         => ExceptionType[[Ctx0]]
+            Throws                => Throws[[Ctx0]]
+            MethodMod             => MethodMod[[Ctx0]]
+            VarMod                => VarMod[[Ctx0]]
+            FormalParam           => FormalParam[[Ctx0]]
+            ResultType            => ResultType[[Ctx0]]
+            MethodDecHead         => MethodDecHead[[Ctx0]]
+            MethodDec             => MethodDec[[Ctx0]]
+            BlockStm              => BlockStm[[Ctx0]]
+            Block                 => Block[[Ctx0]]
+            CatchClause           => CatchClause[[Ctx0]]
+            SwitchLabel           => SwitchLabel[[Ctx0]]
+            SwitchGroup           => SwitchGroup[[Ctx0]]
+            SwitchBlock           => SwitchBlock[[Ctx0]]
+            Stm                   => Stm[[Ctx0]]
+            LocalVarDec           => LocalVarDec[[Ctx0]]
+            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
+            FieldMod              => FieldMod[[Ctx0]]
+            VarInit               => VarInit[[Ctx0]]
+            Dim                   => Dim[[Ctx0]]
+            VarDecId              => VarDecId[[Ctx0]]
+            VarDec                => VarDec[[Ctx0]]
+            FieldDec              => FieldDec[[Ctx0]]
+            ArrayInit             => ArrayInit[[Ctx0]]
+            ClassLiteral          => ClassLiteral[[Ctx0]]
+            Literal               => Literal[[Ctx0]]
+            Type                  => Type[[Ctx0]]
+            ArrayType             => ArrayType[[Ctx0]]
+            TypeVar               => TypeVar[[Ctx0]]
+            TypeDecSpec           => TypeDecSpec[[Ctx0]]
+            InterfaceType         => InterfaceType[[Ctx0]]
+            ClassType             => ClassType[[Ctx0]]
+            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
+            RefType               => RefType[[Ctx0]]
+            TypeVarId             => TypeVarId[[Ctx0]]
+            TypeParams            => TypeParams[[Ctx0]]
+            TypeBound             => TypeBound[[Ctx0]]
+            TypeParam             => TypeParam[[Ctx0]]
+            WildcardBound         => WildcardBound[[Ctx0]]
+            ActualTypeArg         => ActualTypeArg[[Ctx0]]
+            TypeArgs              => TypeArgs[[Ctx0]]
+            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
+            MethodName            => MethodName[[Ctx0]]
+            ExprName              => ExprName[[Ctx0]]
+            TypeName              => TypeName[[Ctx0]]
+            AmbName               => AmbName[[Ctx0]]
+            PackageName           => PackageName[[Ctx0]]
+            FloatType             => FloatType[[Ctx0]]
+            IntType               => IntType[[Ctx0]]
+            NumType               => NumType[[Ctx0]]
+            PrimType              => PrimType[[Ctx0]]
+            NullLiteral           => NullLiteral[[Ctx0]]
+            FooStringChars        => FooStringChars[[Ctx0]]
+            StringChars           => StringChars[[Ctx0]]
+            StringPart            => StringPart[[Ctx0]]
+            StringLiteral         => StringLiteral[[Ctx0]]
+            SingleChar            => SingleChar[[Ctx0]]
+            CharContent           => CharContent[[Ctx0]]
+            CharLiteral           => CharLiteral[[Ctx0]]
+            LastOcta              => LastOcta[[Ctx0]]
+            OctaEscape            => OctaEscape[[Ctx0]]
+            NamedEscape           => NamedEscape[[Ctx0]]
+            EscapeSeq             => EscapeSeq[[Ctx0]]
+            Bool                  => Bool[[Ctx0]]
+            BoolLiteral           => BoolLiteral[[Ctx0]]
+            BinaryExponent        => BinaryExponent[[Ctx0]]
+            HexaSignificand       => HexaSignificand[[Ctx0]]
+            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
+            SignedInteger         => SignedInteger[[Ctx0]]
+            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
+            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
+            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
+            FloatLiteral          => FloatLiteral[[Ctx0]]
+            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
+            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
+            IntLiteral            => IntLiteral[[Ctx0]]
+            OctaNumeral           => OctaNumeral[[Ctx0]]
+            HexaNumeral           => HexaNumeral[[Ctx0]]
+            DeciNumeral           => DeciNumeral[[Ctx0]]
+            OctaLiteral           => OctaLiteral[[Ctx0]]
+            HexaLiteral           => HexaLiteral[[Ctx0]]
+            DeciLiteral           => DeciLiteral[[Ctx0]]
+            Modifier              => Modifier[[Ctx0]]
+            StrictFP              => StrictFP[[Ctx0]]
+            Synchronized          => Synchronized[[Ctx0]]
+            Volatile              => Volatile[[Ctx0]]
+            Transient             => Transient[[Ctx0]]
+            Native                => Native[[Ctx0]]
+            Static                => Static[[Ctx0]]
+            Final                 => Final[[Ctx0]]
+            Abstract              => Abstract[[Ctx0]]
+            Protected             => Protected[[Ctx0]]
+            Private               => Private[[Ctx0]]
+            Public                => Public[[Ctx0]]
+            Id                    => Id[[Ctx0]]
+            ID                    => ID[[Ctx0]]
+            Keyword               => Keyword[[Ctx0]]
+            ArrayAccess           => ArrayAccess[[Ctx0]]
+            FieldAccess           => FieldAccess[[Ctx0]]
+            MethodSpec            => MethodSpec[[Ctx0]]
+            Expr                  => Expr[[Ctx0]] ]
+
+
+module Stratego-Sugar-Overlays
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Terms
+
+exports
+  sorts Overlay
+  context-free syntax
+    Id 			 "=" Term 	-> Overlay {cons("OverlayNoArgs")}
+    Id "(" {Id ","}* ")" "=" Term 	-> Overlay {cons("Overlay")}
+
+module Stratego-Sugar-DynamicRules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+
+exports
+ 
+  sorts ScopeLabels
+  context-free syntax
+
+    "{|" ScopeLabels ":" Strategy "|}" -> Strategy {cons("DynRuleScope")}
+
+    {DynRuleScopeId ","}*   -> ScopeLabels
+    "~" Term		    -> ScopeLabels {cons("ScopeLabels")}
+
+  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
+  context-free syntax
+
+    "rules" "(" DynRuleDef* ")" -> Strategy {cons("GenDynRules")}
+
+    Id "+" Term                 -> DynRuleDef {cons("AddScopeLabel")} 
+    DynRuleId ":-"  Term        -> DynRuleDef {cons("UndefineDynRule")}
+    DynRuleId ":"   Rule        -> DynRuleDef {cons("SetDynRule")}
+    DynRuleId ":+"  Rule        -> DynRuleDef {cons("AddDynRule")}
+    DynRuleId ":"   Term        -> DynRuleDef {cons("SetDynRuleMatch")}
+
+    DynRuleId ":="  Term        -> DynRuleDef {cons("DynRuleAssign")}
+    DynRuleId ":+="  Term       -> DynRuleDef {cons("DynRuleAssignAdd")}
+
+    DynRuleId ":"   Rule "depends" "on" Term -> DynRuleDef {cons("SetDynRuleDepends")}
+
+    RuleDec "." Term            -> DynRuleId {cons("LabeledDynRuleId")}
+    RuleDec "+" Term            -> DynRuleId {cons("AddLabelDynRuleId")}
+    RuleDec                     -> DynRuleId {cons("DynRuleId")}
+
+    Id "." Term                 -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
+    Id                          -> DynRuleScopeId {cons("DynRuleScopeId")}
+
+  context-free syntax
+
+    Id                          -> RuleDec {cons("RDecNoArgs")}
+    Id "(" {Typedid ","}* ")"   -> RuleDec {cons("RDec")}
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"   -> RuleDec {cons("RDecT")}
+
+  sorts RuleNames
+  context-free syntax
+    {Id ","}*				  -> RuleNames
+    "~" Term				  -> RuleNames {cons("RuleNames")}
+
+    "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+
+  syntax
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+
+  context-free syntax
+    Strategy "/" RuleNames"\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+    Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+
+    Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+
+  priorities
+    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")}
+  > {
+
+    %% no space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% 1 space after RuleNames
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleUnionFix")}
+
+    %% no space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    %% 1 space after RuleNames
+    "/"  <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\"
+        <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+    }
+  > <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("AM")}
+
+  context-free priorities
+    StrategyAngle Term 		          -> Strategy {cons("BA")}
+  > "/" RuleNames "\\*" Strategy          -> Strategy {cons("DynRuleIntersectFix")}
+  > Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+  > Strategy "/" RuleNames "\\" Strategy  -> Strategy {cons("DynRuleIntersect"),right}
+  > Strategy "\\" RuleNames "/" Strategy  -> Strategy {cons("DynRuleUnion"),right}
+  > Strategy "/" RuleNames "\\" 
+                 RuleNames "/"  Strategy  -> Strategy {cons("DynRuleIntersectUnion"),right}
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+
+module Stratego-Sugar-Rules
+imports Stratego-Sugar-Strategies
+exports
+
+  sorts RuleDef
+  context-free syntax
+    Id ":" Rule 				-> RuleDef {cons("RDefNoArgs")}
+    
+    Anno+ RuleDef               -> Def {cons("AnnoDef")}
+
+    Id "(" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDef")}
+
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" ":" Rule 		-> RuleDef {cons("RDefT")}
+
+  sorts Rule RuleCond
+  context-free syntax
+    Term "->" Term           	    -> Rule {cons("RuleNoCond")} %% backward comp.
+    Term "->" Term "where" Strategy -> Rule {cons("Rule")}       %% backward comp.
+    Term "->" Term RuleCond+	    -> Rule {cons("Rule"), avoid}
+
+    "where" Strategy -> RuleCond {cons("WhereClause")}
+    "with"  Strategy -> RuleCond {cons("WithClause")}
+
+module Stratego-Sugar-Strategies
+imports
+  Stratego-Core-Strategies
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Constants
+  Stratego-Sugar-Signatures
+
+exports
+  context-free syntax
+    Id  		      "=" Strategy -> StrategyDef {cons("SDefNoArgs")}
+    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
+
+  context-free syntax
+    ID 				  	  -> Typedid {cons("DefaultVarDec")}
+
+  sorts Rule
+
+  sorts StrategyParen StrategyCurly StrategyAngle
+  context-free syntax
+
+    %% Abstraction
+
+    SVar "(" {Strategy ","}* ")" 	  -> Strategy {cons("Call")}
+
+    %% Match and build
+
+    "{" Strategy "}" 			  -> Strategy {cons("ScopeDefault")}
+
+     %%"<" Strategy ">" Term 		  -> Strategy {cons("BA")}
+     StrategyAngle Term 		  -> Strategy {cons("BA")}
+     "<" Strategy ">"			  -> StrategyAngle {bracket} %% {cons("AngleStrat")}
+
+    %% Combinators
+
+    Strategy "<+" Strategy 		  -> Strategy {cons("LChoice"),right}
+
+    "rec" Id "(" Strategy ")" 		  -> Strategy {cons("Rec")}
+
+    "not"   "(" Strategy ")" 		  -> Strategy {cons("Not")}
+    "where" "(" Strategy ")" 		  -> Strategy {cons("Where")}
+    "with"  "(" Strategy ")" 		  -> Strategy {cons("With"), prefer}
+    "test"  "(" Strategy ")" 		  -> Strategy {cons("Test")}
+
+    %% Primitives
+
+    "prim" "(" String ")" 		  -> Strategy {cons("PrimNoArgs")}
+    "prim" "(" String "," {Term ","}* ")" -> Strategy {cons("Prim")}
+
+    %% Congruence operators
+
+    String 				  -> Strategy {cons("StrCong")}
+    Int 				  -> Strategy {cons("IntCong")}
+    Real 				  -> Strategy {cons("RealCong")}
+    Char 			 	  -> Strategy {cons("CharCong")}
+
+    String "(" {Strategy ","}* ")" 	  -> Strategy {cons("CongQ")}
+
+    %%"(" {Strategy ","}* ")" 		  -> Strategy {cons("TupleCong"),avoid}
+
+    Strategy StrategyCurly		  -> Strategy {cons("AnnoCong")}
+    
+    "{" Strategy "}"		  	  -> StrategyCurly {cons("StrategyCurly")}
+
+    "("  ")" 		  		  -> Strategy {cons("EmptyTupleCong")}
+   "(" Strategy  ")" 		          -> Strategy {bracket}
+    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy {cons("TupleCong")}
+
+%%    Mod 	  			  -> Strategy {cons("ModCongNoArgs")}
+%%    Mod "(" {Strategy ","}* ")"	  	  -> Strategy {cons("ModCong")}
+%%    Id "^" Id				  -> Mod {cons("Mod")}
+    "[" {Strategy ","}* "]" 		  -> Strategy {cons("ListCongNoTail")}
+    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy {cons("ListCong")}
+
+%%    Strategy "#" "(" StrategyInj ")" 	  -> Strategy {cons("ExplodeCong")}
+%%    Strategy "#" "(" Strategy ")" 	  -> Strategy {cons("ExplodeCong")}
+    Strategy "#" StrategyParen	  	  -> Strategy {cons("ExplodeCong")}
+
+  %% Syntactic sugar sugar
+
+  sorts SwitchCase
+  context-free syntax
+
+    SVar  		  		  -> Strategy {cons("CallNoArgs")}
+    "\\" Rule "\\" 			  -> Strategy {cons("LRule")}
+    "(" Rule ")" 			  -> Strategy {cons("SRule")}
+    Strategy "+" Strategy 		  -> Strategy {cons("Choice"),right} 
+    Strategy "+>" Strategy 		  -> Strategy {cons("RChoice"),right}
+
+    "proceed" "(" {Strategy "," }+ ")" -> Strategy {cons("Proceed"), prefer}
+
+    "if" Strategy "then" Strategy 
+                  "else" Strategy "end"   -> Strategy {cons("CondChoice")}
+    "if" Strategy "then" Strategy "end"   -> Strategy {cons("IfThen")}
+
+    "switch" Strategy SwitchCase* "end"   -> Strategy {cons("SwitchChoiceNoOtherwise")}
+    "switch" Strategy SwitchCase*
+         "otherwise" ":" Strategy "end"   -> Strategy {cons("SwitchChoice")}
+
+    "case" Strategy ":" Strategy          -> SwitchCase {cons("SwitchCase")}
+
+    Strategy "=>" Term 		  	  -> Strategy {cons("AM")}
+
+    Term ":=" Term			  -> Strategy {cons("Assign")}
+
+  %% Priorities
+
+  context-free priorities
+    { Strategy StrategyCurly		  -> Strategy
+      Strategy "#" StrategyParen          -> Strategy
+    }
+  > { "!" Term 				  -> Strategy
+      "?" Term 				  -> Strategy
+    }
+  > StrategyAngle Term 		          -> Strategy
+  > Strategy "=>" Term 		  	  -> Strategy
+  > Strategy ";" Strategy 		  -> Strategy
+  > {right: 
+     Strategy "+" Strategy 		  -> Strategy
+     Strategy "<+" Strategy 		  -> Strategy
+     Strategy "+>" Strategy 		  -> Strategy
+     
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy
+    }
+
+  context-free priorities
+    Strategy 				  -> StrategyMid
+  > Strategy "+" Strategy 		  -> Strategy
+
+  context-free priorities
+    { Strategy StrategyCurly      -> Strategy
+      Strategy "#" StrategyParen  -> Strategy
+    }
+    .> Term ":=" Term -> Strategy
+
+
+
+
+module Stratego-Sugar-Terms
+imports
+  Stratego-Core-Terms
+  Stratego-Sugar-Strategies
+
+exports
+  sorts LID
+  context-free syntax
+    LId 			-> LID  {cons("ListVar")}
+    LID				-> Var  {cons("Var")}
+    LID				-> ID
+
+  context-free syntax
+    "_" PreTerm 		 -> PreTerm {cons("BuildDefaultPT")}
+    "_" Term 			 -> Term {cons("BuildDefault"),prefer}
+
+    Char 			 -> PreTerm {cons("Char")}
+
+    PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+    PreTerm                      -> Term {cons("NoAnnoList")}
+
+    "<" Strategy ">" Term 	 -> PreTerm {cons("App")}
+    "<" Strategy ">" Term 	 -> Term {cons("App"),prefer}
+
+    StrategyAngle		 -> PreTerm {cons("RootApp")}
+    StrategyAngle		 -> Term {cons("RootApp"),prefer}
+
+    "(" {Term ","}* ")" 	 -> PreTerm {cons("Tuple")}
+    "[" {Term ","}* "]" 	 -> PreTerm {cons("List")}
+    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > PreTerm "{" {Term ","}* "}"	 -> Term {cons("AnnoList")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Sugar-Signatures
+imports
+  Stratego-Core-Signatures
+  Stratego-Sugar-Constants
+
+exports
+
+  sorts Sort
+  context-free syntax
+    "[" {Sort ","}* "]"		 -> Sort {cons("SortList")}
+    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
+    "(" {Sort ","}* ")"		 -> Sort {cons("SortTuple")}
+
+  sorts Kind
+  context-free syntax
+    "*" 			-> Kind {cons("Star")}
+    "**" 			-> Kind {cons("StarStar")}
+
+module Stratego-Core-Signatures
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+exports
+  sorts Sdecl
+  context-free syntax
+    "sorts" Sort* 		-> Sdecl {cons("Sorts")}
+    "constructors" Opdecl* 	-> Sdecl {cons("Constructors")}
+
+  sorts Sort
+  context-free syntax
+    LCID 			 -> Sort {cons("SortVar")}
+    UCID 			 -> Sort {cons("SortNoArgs")}
+    Id "(" {Sort ","}* ")" 	 -> Sort {cons("Sort")}
+
+  sorts Opdecl
+  context-free syntax
+    Id     ":" Type 		-> Opdecl {cons("OpDecl")}
+    String ":" Type 		-> Opdecl {cons("OpDeclQ")}
+           ":" Type 		-> Opdecl {cons("OpDeclInj")}
+
+  context-free syntax
+    "external" Id     ":" Type 	-> Opdecl {cons("ExtOpDecl")}
+    "external" String ":" Type 	-> Opdecl {cons("ExtOpDeclQ")}
+    "external"        ":" Type 	-> Opdecl {cons("ExtOpDeclInj")}
+
+  sorts Type ArgType ConstType FunType RetType
+  context-free syntax
+    Sort	                -> ConstType {cons("ConstType")}
+    {ArgType "*"}+ "->" RetType -> FunType {cons("FunType")}
+    "(" Type ")"                -> ArgType {bracket}
+    ConstType			-> ArgType
+    Type	                -> RetType
+    FunType			-> RetType {reject}
+
+    FunType			-> Type
+    ConstType			-> Type
+
+  %%%
+   %% Restriction is required for the Sort* in Sdecl: List(a) is
+   %% ambiguous.
+   %%%
+  context-free restrictions
+    Sort -/- [\(]
+
+module Stratego-Core-Terms
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+
+exports
+  sorts ID Var Wld
+  context-free syntax
+    Id 				-> Var  {cons("Var")}
+    Id				-> ID
+    %% ":" Var                  -> Var  {cons("SeqVar")}
+
+  sorts Term PreTerm
+  context-free syntax
+    Var 			 -> PreTerm 
+    Var 			 -> Term {prefer}
+
+    "_" 			 -> Wld {cons("Wld")}
+    Wld 			 -> PreTerm
+    Wld 			 -> Term {prefer}
+
+    Int 			 -> PreTerm {cons("Int")}
+    Real 			 -> PreTerm {cons("Real")}
+    String 			 -> PreTerm {cons("Str")}
+
+    Id "(" {Term ","}* ")" 	 -> PreTerm {cons("Op")}
+    String "(" {Term ","}* ")" 	 -> PreTerm {cons("OpQ")}
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+
+    PreTerm "{^" PreTerm "}"	 -> Term {cons("Anno")}
+
+    Var "@" Term 		 -> Term {cons("As"),prefer}
+    Var "@" PreTerm 		 -> PreTerm {cons("As")}
+
+  context-free priorities
+    Term "#" "(" Term ")" 	 -> PreTerm {cons("Explode")}
+  > Var "@" Term 		 -> Term {cons("As")}
+
+module Stratego-Core-Strategies
+imports
+  Stratego-Core-Terms
+  Stratego-Core-Constants
+  Stratego-Core-Signatures
+
+exports
+  sorts Def
+  context-free syntax
+    StrategyDef					 -> Def 
+    Id						 -> SVar {cons("SVar")}
+    "let" Def* "in" Strategy "end"		 -> Strategy {cons("Let")}
+    SVar "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallT")}
+
+    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}
+
+
+  sorts StrategyDef
+  context-free syntax
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDefT")}
+
+    Anno+ StrategyDef -> Def {cons("AnnoDef")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
+
+    "external"
+    Id "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+    "external"
+    EmptyId "(" {Typedid ","}* 
+       "|" {Typedid ","}* ")"		   -> StrategyDef {cons("ExtSDef")}
+
+
+  sorts EmptyId
+  lexical syntax
+  
+    -> EmptyId
+
+  sorts Anno
+  context-free syntax
+    "extend"      -> Anno {cons("Extend")}
+    "override"    -> Anno {cons("Override")}
+    "internal"    -> Anno {cons("Internal")}
+%%  "sealed"      -> Anno {cons("Sealed")}
+%%  "extensible"  -> Anno {cons("Extensible")}
+%%  "overridable" -> Anno {cons("Overridable")}
+
+  lexical syntax
+    
+    "extend"      -> Keyword
+    "override"    -> Keyword
+    "internal"    -> Keyword
+    "sealed"      -> Keyword
+    "extensible"  -> Keyword
+    "overridable" -> Keyword
+
+  lexical restrictions
+  
+    "extend"
+    "override"
+    "internal"
+    "sealed"
+    "extensible"
+    "overridable" -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Typedid
+  context-free syntax
+    ID ":" Type 			  -> Typedid {cons("VarDec")}
+
+
+  sorts Strategy SVar StrategyParen StrategyMid 
+  context-free syntax
+    "(" Strategy ")"			  -> StrategyParen {cons("ParenStrat")}
+
+    "fail" 				  -> Strategy {cons("Fail")}
+    "id" 				  -> Strategy {cons("Id")}
+
+    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("ProceedT"), prefer}
+    "proceed"                                         -> Strategy {cons("ProceedNoArgs"), prefer}
+
+    %% Match and build
+
+    "?" Term 				  -> Strategy {cons("Match")}
+    "!" Term 				  -> Strategy {cons("Build")}
+    "{" {ID ","}* ":" Strategy "}" 	  -> Strategy {cons("Scope")}
+
+    %% Combinators
+
+    Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+    Strategy "<" StrategyMid 
+             "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    Strategy 				  -> StrategyMid
+
+    %% Primitives
+
+    "prim" "(" String "," {Strategy ","}* "|" {Term ","}*")"  -> Strategy {cons("PrimT")}
+
+    %% Traversal
+
+    "some" "(" Strategy ")" 		  -> Strategy {cons("Some")}
+    "one" "(" Strategy ")" 		  -> Strategy {cons("One")}
+    "all" "(" Strategy ")" 		  -> Strategy {cons("All")}
+
+  %% Priorities
+
+  context-free priorities
+    { "!" Term 				  -> Strategy {cons("Build")}
+      "?" Term 				  -> Strategy {cons("Match")}
+    }
+  > Strategy ";" Strategy 		  -> Strategy {cons("Seq"),right}
+  > {right: 
+     Strategy "<" StrategyMid 
+              "+" Strategy 		  -> Strategy {cons("GuardedLChoice"),right}
+    }
+
+  context-free syntax
+    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}
+
+module Stratego-Core-Modules
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Strategies
+  Stratego-Core-Signatures
+
+exports 
+  sorts Module
+  context-free syntax
+    "module" ModName Decl* 	 -> Module {cons("Module")}
+    "specification" Decl*	 -> Module {cons("Specification")}
+
+  sorts Decl 
+  context-free syntax
+    "imports" ImportModName* 	-> Decl {cons("Imports")}
+    "strategies" Def* 		-> Decl {cons("Strategies")}
+    "signature" Sdecl*  	-> Decl {cons("Signature")}
+
+  sorts ImportModName
+  context-free syntax
+    ModName              -> ImportModName {cons("Import")}
+  syntax
+    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}
+
+module Stratego-Sugar-Modules
+imports
+  Stratego-Core-Modules
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Overlays
+  Stratego-Sugar-Rules
+
+exports 
+
+  sorts Decl Def
+  context-free syntax
+    "rules" Def* 		-> Decl {cons("Rules")}
+    "overlays" Overlay* 	-> Decl {cons("Overlays")}
+
+    RuleDef 			-> Def 
+
+
+
+
+module Stratego-Sugar-StringQuotations
+exports
+
+  sorts
+    StringQuotation
+    StringQuotedPart1 StringQuotedChars1 DollarOpen1 DollarClose1 QuotedBracket1 Dollar1
+    StringQuotedPart2 StringQuotedChars2 DollarOpen2 DollarClose2 QuotedBracket2 Dollar2
+    StringQuotedPart3 StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
+    StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4 QuotedBracket4  Dollar4
+    Padding
+
+  context-free syntax
+
+    StringQuotation -> PreTerm
+
+  syntax
+
+    StringQuotation -> <PreTerm-CF>
+
+    "$" "[" Padding StringQuotedPart1*               "]"    -> StringQuotation {cons("StringQuotation1") }
+     Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]"    -> StringQuotedPart1 {cons("StringEscape1")}
+    <StringQuotedChars1-LEX>                                -> StringQuotedPart1 {cons("QStr")}
+    <Dollar1-LEX>                                           -> StringQuotedPart1 {cons("QDollar")}
+    "$" <QuotedBracket1-LEX> "$"                            -> StringQuotedPart1 {cons("QBr")}
+    ~[\[\]\$]+                                              -> <StringQuotedChars1-LEX>
+    [\[\]]                                                  -> <QuotedBracket1-LEX>
+    "$"                                                     -> <Dollar1-LEX>
+
+    "$" "{" Padding StringQuotedPart2*               "}"    -> StringQuotation {cons("StringQuotation2") }
+     Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}"    -> StringQuotedPart2 {cons("StringEscape2")}
+    <StringQuotedChars2-LEX>                                -> StringQuotedPart2 {cons("QStr")}
+    <Dollar2-LEX>                                           -> StringQuotedPart2 {cons("QDollar")}
+    "$" <QuotedBracket2-LEX> "$"                            -> StringQuotedPart2 {cons("QBr")}
+    ~[\{\}\$]+                                              -> <StringQuotedChars2-LEX>
+    [\{\}]                                                  -> <QuotedBracket2-LEX>
+    "$"                                                     -> <Dollar2-LEX>
+
+    "$" "(" Padding StringQuotedPart3*              ")"     -> StringQuotation {cons("StringQuotation3") }
+    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")"     -> StringQuotedPart3 {cons("StringEscape3")}
+    <StringQuotedChars3-LEX>                                -> StringQuotedPart3 {cons("QStr")}
+    <Dollar3-LEX>                                           -> StringQuotedPart3 {cons("QDollar")}
+    "$" <QuotedBracket3-LEX> "$"                            -> StringQuotedPart3 {cons("QBr")}
+    ~[\(\)\$]+                                              -> <StringQuotedChars3-LEX>
+    [\(\)]                                                  -> <QuotedBracket3-LEX>
+    "$"                                                     -> <Dollar3-LEX>
+
+    "$" "<" Padding StringQuotedPart4*               ">"    -> StringQuotation {cons("StringQuotation4") }
+    Padding "<"  <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">"    -> StringQuotedPart4 {cons("StringEscape4")}
+    <StringQuotedChars4-LEX>                                -> StringQuotedPart4 {cons("QStr")}
+    <Dollar4-LEX>                                           -> StringQuotedPart4 {cons("QDollar")}
+    "$" <QuotedBracket4-LEX> "$"                            -> StringQuotedPart4 {cons("QBr")}
+    ~[\<\>\$]+                                              -> <StringQuotedChars4-LEX>
+    [\<\>]                                                  -> <QuotedBracket4-LEX>
+    "$"                                                     -> <Dollar4-LEX>
+   
+    %% Padding is a dummy lexical that will contain the indentation prefix of every quotation
+    <Padding-LEX>                                           -> Padding
+                                                            -> <Padding-LEX> {indentpadding}
+
+  lexical restrictions
+
+    StringQuotedChars1 -/- ~[\[\]\$]   
+    StringQuotedChars2 -/- ~[\{\}\$]    
+    StringQuotedChars3 -/- ~[\(\)\$]    
+    StringQuotedChars4 -/- ~[\<\>\$]
+    Dollar1            -/- [\[\]] . [\$]
+    Dollar2            -/- [\{\}] . [\$]
+    Dollar3            -/- [\(\)] . [\$]
+    Dollar4            -/- [\<\>] . [\$]
+
+module Stratego-Core-Constants
+exports
+  sorts Int Real String StrChar
+  lexical syntax
+    [\-]? [0-9]+ 		-> Int
+    [\-]? [0-9]+ [\.] [0-9]+ 	-> Real
+    "\"" StrChar* "\"" 		-> String
+    ~[\"\\] 			-> StrChar
+    [\\] [\"tnr\\] 		-> StrChar
+
+
+
+
+module Stratego-Sugar-Constants
+imports
+  Stratego-Core-Identifiers
+  Stratego-Core-Constants
+  Stratego-Sugar-StringQuotations
+exports
+  sorts Char CharChar
+  lexical syntax
+    "'" CharChar "'"		-> Char
+    ~[\']			-> CharChar
+    [\\] [\'ntr\ ]		-> CharChar
+    Char		 	-> Id {reject}
+
+module Stratego-Core-Identifiers
+exports
+  sorts ModName ModNamePart
+  lexical syntax
+    {ModNamePart "/"}+ -> ModName
+    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart
+  lexical restrictions
+    ModName -/- [a-zA-Z0-9\'\.\-\_]
+  lexical syntax
+    "imports" 		-> ModName {reject}
+    "overlays" 		-> ModName {reject}
+    "rules" 		-> ModName {reject}
+    "signature" 	-> ModName {reject}
+    "strategies" 	-> ModName {reject}
+
+  sorts Id LId LCID UCID Wld
+  lexical syntax
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId
+    [\'] [a-z]+                       -> Id
+
+    [a-z] [a-zA-Z0-9\'\-\_]*  -> LCID
+    [A-Z] [a-zA-Z0-9\'\-\_]*  -> UCID
+
+  lexical restrictions
+    Id   -/- [a-zA-Z0-9\'\-\_\*]
+    LId  -/- [a-zA-Z0-9\'\-\_]
+    LCID -/- [a-zA-Z0-9\'\-\_]
+    UCID -/- [a-zA-Z0-9\'\-\_]
+
+  lexical syntax
+    "_"     -> Id {reject}
+    "'"     -> Id {reject}
+
+    Keyword -> Id   {reject}
+    Keyword -> LId  {reject}
+    Keyword -> LCID {reject}
+    Keyword -> UCID {reject}
+
+  lexical restrictions
+    "all"
+    "case" %% not reserved kw
+    "constructors"
+    "else" %% not reserved kw
+    "end" %% not reserved kw
+    "external" %% not reserved kw
+    "fail"
+    "id"
+    "if" %% not reserved kw
+    "in"
+    "imports" %% not reserved kw
+    "let"
+    "module"
+    "not"
+    "one"
+    "overlays"
+    "otherwise" %% not reserved kw
+    "prim"
+    "rec" %% not reserved kw
+    "rules"
+    "script"
+    "signature"
+    "some"
+    "sorts"
+    "strategies"
+    "stratego"
+    "switch" %% not reserved kw
+    "test"
+    "then" %% not reserved kw
+    "where"
+    "import-term"
+      -/- [a-zA-Z0-9\'\-\_]
+  
+  context-free restrictions
+    Wld -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Keyword
+  lexical syntax
+    "all"               -> Keyword
+    "constructors" 	-> Keyword
+    "fail" 		-> Keyword
+    "id" 		-> Keyword
+    "in" 		-> Keyword
+    "let" 		-> Keyword
+    "module" 		-> Keyword
+    "not" 		-> Keyword
+    "one" 		-> Keyword
+    "overlays" 		-> Keyword
+    "prim" 		-> Keyword
+    "rules" 		-> Keyword
+    "script" 		-> Keyword
+    "signature" 	-> Keyword
+    "some" 		-> Keyword
+    "sorts" 		-> Keyword
+    "strategies" 	-> Keyword
+    "stratego" 		-> Keyword
+    "test" 		-> Keyword
+    "where" 		-> Keyword
+    "import-term"	-> Keyword
+
+
+
+
+module Stratego-Core-Layout
+exports
+  sorts Ws ShortCom LongCom CommChar Asterisk Eof 
+  lexical syntax
+    [\t\ \n\r]			-> Ws
+
+    "//" ~[\n]* ([\n] | Eof)	-> ShortCom
+    "/*" CommChar* "*/"	-> LongCom
+				-> Eof  
+
+    ~[\*]     -> CommChar
+
+    "*"       -> Asterisk
+    Asterisk  -> CommChar
+
+  lexical restrictions
+    Asterisk -/- [\/]
+    Eof      -/- ~[]
+
+  lexical syntax
+    ShortCom 	-> LAYOUT
+    LongCom 	-> LAYOUT
+    Ws 		-> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\*]
+    LAYOUT? -/- [\/].[\/]
+
+module Stratego-Sugar-Layout
+imports Stratego-Core-Layout
+%%exports
+%%  sorts VeryLongCom Eof VLCchar Backslash
+%%  lexical syntax
+%%    "\\end{code}" VLCchar* "\\begin{code}" -> VeryLongCom
+%%    "\\begin{code}" 			   -> VeryLongCom
+%%    "\\end{code}" VLCchar* Eof 		   -> VeryLongCom
+%%    "\\literate" VLCchar* "\\begin{code}"  -> VeryLongCom
+%%    ~[\\] 				   -> VLCchar
+%%    Backslash 				   -> VLCchar
+%%    [\\] 				   -> Backslash
+
+%%  lexical restrictions
+%%    Backslash -/- [b].[e].[g].[i].[n].[\{].[c].[o].[d].[e].[\}]
+%%    Eof -/- ~[]
+
+%%  lexical syntax
+%%    VeryLongCom -> LAYOUT
+
+
+
+
+
+module Stratego-Sugar
+imports
+  Stratego-Sugar-Layout
+  Stratego-Core-Identifiers
+  Stratego-Sugar-Constants 
+  Stratego-Sugar-Modules
+  Stratego-Sugar-Signatures
+  Stratego-Sugar-Terms
+  Stratego-Sugar-Strategies
+  Stratego-Sugar-Rules
+  Stratego-Sugar-DynamicRules
+  Stratego-Sugar-Overlays
+
+hiddens
+  context-free start-symbols Module
+
+module Stratego
+imports Stratego-Sugar
+hiddens
+  context-free start-symbols Module
+
+module StrategoMix[Ctx0]
+imports Stratego
+          [ RuleNames          => RuleNames[[Ctx0]]
+            RuleDec            => RuleDec[[Ctx0]]
+            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
+            DynRuleId          => DynRuleId[[Ctx0]]
+            DynRuleDef         => DynRuleDef[[Ctx0]]
+            ScopeLabels        => ScopeLabels[[Ctx0]]
+            RuleCond           => RuleCond[[Ctx0]]
+            Rule               => Rule[[Ctx0]]
+            RuleDef            => RuleDef[[Ctx0]]
+            Overlay            => Overlay[[Ctx0]]
+            SwitchCase         => SwitchCase[[Ctx0]]
+            StrategyCurly      => StrategyCurly[[Ctx0]]
+            StrategyAngle      => StrategyAngle[[Ctx0]]
+            Kind               => Kind[[Ctx0]]
+            LID                => LID[[Ctx0]]
+            ImportModName      => ImportModName[[Ctx0]]
+            Decl               => Decl[[Ctx0]]
+            Module             => Module[[Ctx0]]
+            StrategyParen      => StrategyParen[[Ctx0]]
+            Typedid            => Typedid[[Ctx0]]
+            Anno               => Anno[[Ctx0]]
+            EmptyId            => EmptyId[[Ctx0]]
+            StrategyDef        => StrategyDef[[Ctx0]]
+            SVar               => SVar[[Ctx0]]
+            Def                => Def[[Ctx0]]
+            Type               => Type[[Ctx0]]
+            RetType            => RetType[[Ctx0]]
+            ArgType            => ArgType[[Ctx0]]
+            FunType            => FunType[[Ctx0]]
+            ConstType          => ConstType[[Ctx0]]
+            Opdecl             => Opdecl[[Ctx0]]
+            Sort               => Sort[[Ctx0]]
+            Sdecl              => Sdecl[[Ctx0]]
+            Wld                => Wld[[Ctx0]]
+            ID                 => ID[[Ctx0]]
+            Var                => Var[[Ctx0]]
+            CharChar           => CharChar[[Ctx0]]
+            Char               => Char[[Ctx0]]
+            Padding            => Padding[[Ctx0]]
+            Dollar4            => Dollar4[[Ctx0]]
+            QuotedBracket4     => QuotedBracket4[[Ctx0]]
+            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
+            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
+            Dollar3            => Dollar3[[Ctx0]]
+            QuotedBracket3     => QuotedBracket3[[Ctx0]]
+            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
+            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
+            Dollar2            => Dollar2[[Ctx0]]
+            QuotedBracket2     => QuotedBracket2[[Ctx0]]
+            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
+            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
+            Dollar1            => Dollar1[[Ctx0]]
+            QuotedBracket1     => QuotedBracket1[[Ctx0]]
+            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
+            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
+            StringQuotation    => StringQuotation[[Ctx0]]
+            StrChar            => StrChar[[Ctx0]]
+            String             => String[[Ctx0]]
+            Real               => Real[[Ctx0]]
+            Int                => Int[[Ctx0]]
+            Keyword            => Keyword[[Ctx0]]
+            UCID               => UCID[[Ctx0]]
+            LCID               => LCID[[Ctx0]]
+            LId                => LId[[Ctx0]]
+            Id                 => Id[[Ctx0]]
+            ModNamePart        => ModNamePart[[Ctx0]]
+            ModName            => ModName[[Ctx0]]
+            PreTerm            => PreTerm[[Ctx0]]
+            Term               => Term[[Ctx0]]
+            StrategyMid        => StrategyMid[[Ctx0]]
+            Strategy           => Strategy[[Ctx0]] ]
+
+
+module Stratego-Java-EBlock
+imports
+  StrategoMix[StrategoHost]
+  languages/java/EmbeddedJavaMix[JavaObject Term[[StrategoHost]]]
+  languages/java/eblock/JavaEBlockMix[JavaObject]
+
+exports
+  context-free start-symbols Module[[StrategoHost]]
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/JavaMix.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/JavaMix.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,151 @@
+module languages/java-15/JavaMix[Ctx0]
+imports languages/java-15/Main
+          [ CompilationUnit       => CompilationUnit[[Ctx0]]
+            TypeDec               => TypeDec[[Ctx0]]
+            ImportDec             => ImportDec[[Ctx0]]
+            PackageDec            => PackageDec[[Ctx0]]
+            ElemVal               => ElemVal[[Ctx0]]
+            ElemValPair           => ElemValPair[[Ctx0]]
+            Anno                  => Anno[[Ctx0]]
+            LHS                   => LHS[[Ctx0]]
+            CondMid               => CondMid[[Ctx0]]
+            ArraySubscript        => ArraySubscript[[Ctx0]]
+            DimExpr               => DimExpr[[Ctx0]]
+            ArrayBaseType         => ArrayBaseType[[Ctx0]]
+            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
+            ClassMemberDec        => ClassMemberDec[[Ctx0]]
+            ClassBodyDec          => ClassBodyDec[[Ctx0]]
+            Interfaces            => Interfaces[[Ctx0]]
+            Super                 => Super[[Ctx0]]
+            ClassMod              => ClassMod[[Ctx0]]
+            ClassDecHead          => ClassDecHead[[Ctx0]]
+            ClassBody             => ClassBody[[Ctx0]]
+            ClassDec              => ClassDec[[Ctx0]]
+            InterfaceMod          => InterfaceMod[[Ctx0]]
+            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
+            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
+            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
+            InterfaceDec          => InterfaceDec[[Ctx0]]
+            DefaultVal            => DefaultVal[[Ctx0]]
+            AnnoElemDec           => AnnoElemDec[[Ctx0]]
+            AnnoDecHead           => AnnoDecHead[[Ctx0]]
+            AnnoDec               => AnnoDec[[Ctx0]]
+            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
+            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
+            ConstantMod           => ConstantMod[[Ctx0]]
+            ConstantDec           => ConstantDec[[Ctx0]]
+            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
+            EnumConstArgs         => EnumConstArgs[[Ctx0]]
+            EnumConst             => EnumConst[[Ctx0]]
+            EnumBody              => EnumBody[[Ctx0]]
+            EnumDecHead           => EnumDecHead[[Ctx0]]
+            EnumDec               => EnumDec[[Ctx0]]
+            ConstrMod             => ConstrMod[[Ctx0]]
+            ConstrInv             => ConstrInv[[Ctx0]]
+            ConstrBody            => ConstrBody[[Ctx0]]
+            ConstrHead            => ConstrHead[[Ctx0]]
+            ConstrDec             => ConstrDec[[Ctx0]]
+            StaticInit            => StaticInit[[Ctx0]]
+            InstanceInit          => InstanceInit[[Ctx0]]
+            MethodBody            => MethodBody[[Ctx0]]
+            ExceptionType         => ExceptionType[[Ctx0]]
+            Throws                => Throws[[Ctx0]]
+            MethodMod             => MethodMod[[Ctx0]]
+            VarMod                => VarMod[[Ctx0]]
+            FormalParam           => FormalParam[[Ctx0]]
+            ResultType            => ResultType[[Ctx0]]
+            MethodDecHead         => MethodDecHead[[Ctx0]]
+            MethodDec             => MethodDec[[Ctx0]]
+            BlockStm              => BlockStm[[Ctx0]]
+            Block                 => Block[[Ctx0]]
+            CatchClause           => CatchClause[[Ctx0]]
+            SwitchLabel           => SwitchLabel[[Ctx0]]
+            SwitchGroup           => SwitchGroup[[Ctx0]]
+            SwitchBlock           => SwitchBlock[[Ctx0]]
+            Stm                   => Stm[[Ctx0]]
+            LocalVarDec           => LocalVarDec[[Ctx0]]
+            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
+            FieldMod              => FieldMod[[Ctx0]]
+            VarInit               => VarInit[[Ctx0]]
+            Dim                   => Dim[[Ctx0]]
+            VarDecId              => VarDecId[[Ctx0]]
+            VarDec                => VarDec[[Ctx0]]
+            FieldDec              => FieldDec[[Ctx0]]
+            ArrayInit             => ArrayInit[[Ctx0]]
+            ClassLiteral          => ClassLiteral[[Ctx0]]
+            Literal               => Literal[[Ctx0]]
+            Type                  => Type[[Ctx0]]
+            ArrayType             => ArrayType[[Ctx0]]
+            TypeVar               => TypeVar[[Ctx0]]
+            TypeDecSpec           => TypeDecSpec[[Ctx0]]
+            InterfaceType         => InterfaceType[[Ctx0]]
+            ClassType             => ClassType[[Ctx0]]
+            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
+            RefType               => RefType[[Ctx0]]
+            TypeVarId             => TypeVarId[[Ctx0]]
+            TypeParams            => TypeParams[[Ctx0]]
+            TypeBound             => TypeBound[[Ctx0]]
+            TypeParam             => TypeParam[[Ctx0]]
+            WildcardBound         => WildcardBound[[Ctx0]]
+            ActualTypeArg         => ActualTypeArg[[Ctx0]]
+            TypeArgs              => TypeArgs[[Ctx0]]
+            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
+            MethodName            => MethodName[[Ctx0]]
+            ExprName              => ExprName[[Ctx0]]
+            TypeName              => TypeName[[Ctx0]]
+            AmbName               => AmbName[[Ctx0]]
+            PackageName           => PackageName[[Ctx0]]
+            FloatType             => FloatType[[Ctx0]]
+            IntType               => IntType[[Ctx0]]
+            NumType               => NumType[[Ctx0]]
+            PrimType              => PrimType[[Ctx0]]
+            NullLiteral           => NullLiteral[[Ctx0]]
+            FooStringChars        => FooStringChars[[Ctx0]]
+            StringChars           => StringChars[[Ctx0]]
+            StringPart            => StringPart[[Ctx0]]
+            StringLiteral         => StringLiteral[[Ctx0]]
+            SingleChar            => SingleChar[[Ctx0]]
+            CharContent           => CharContent[[Ctx0]]
+            CharLiteral           => CharLiteral[[Ctx0]]
+            LastOcta              => LastOcta[[Ctx0]]
+            OctaEscape            => OctaEscape[[Ctx0]]
+            NamedEscape           => NamedEscape[[Ctx0]]
+            EscapeSeq             => EscapeSeq[[Ctx0]]
+            Bool                  => Bool[[Ctx0]]
+            BoolLiteral           => BoolLiteral[[Ctx0]]
+            BinaryExponent        => BinaryExponent[[Ctx0]]
+            HexaSignificand       => HexaSignificand[[Ctx0]]
+            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
+            SignedInteger         => SignedInteger[[Ctx0]]
+            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
+            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
+            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
+            FloatLiteral          => FloatLiteral[[Ctx0]]
+            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
+            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
+            IntLiteral            => IntLiteral[[Ctx0]]
+            OctaNumeral           => OctaNumeral[[Ctx0]]
+            HexaNumeral           => HexaNumeral[[Ctx0]]
+            DeciNumeral           => DeciNumeral[[Ctx0]]
+            OctaLiteral           => OctaLiteral[[Ctx0]]
+            HexaLiteral           => HexaLiteral[[Ctx0]]
+            DeciLiteral           => DeciLiteral[[Ctx0]]
+            Modifier              => Modifier[[Ctx0]]
+            StrictFP              => StrictFP[[Ctx0]]
+            Synchronized          => Synchronized[[Ctx0]]
+            Volatile              => Volatile[[Ctx0]]
+            Transient             => Transient[[Ctx0]]
+            Native                => Native[[Ctx0]]
+            Static                => Static[[Ctx0]]
+            Final                 => Final[[Ctx0]]
+            Abstract              => Abstract[[Ctx0]]
+            Protected             => Protected[[Ctx0]]
+            Private               => Private[[Ctx0]]
+            Public                => Public[[Ctx0]]
+            Id                    => Id[[Ctx0]]
+            ID                    => ID[[Ctx0]]
+            Keyword               => Keyword[[Ctx0]]
+            ArrayAccess           => ArrayAccess[[Ctx0]]
+            FieldAccess           => FieldAccess[[Ctx0]]
+            MethodSpec            => MethodSpec[[Ctx0]]
+            Expr                  => Expr[[Ctx0]] ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,11 @@
+module languages/java-15/Main
+imports
+  languages/java-15/lexical/Main
+  languages/java-15/types/Main
+  languages/java-15/names/Main
+  languages/java-15/packages/Main
+  languages/java-15/classes/Main
+  languages/java-15/interfaces/Main
+  languages/java-15/arrays/Main
+  languages/java-15/statements/Main
+  languages/java-15/expressions/Main

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/arrays/ArrayInitializers.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/arrays/ArrayInitializers.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,14 @@
+%%%
+ %% Section 10.6: Array Initializers
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/arrays/ArrayInitializers
+imports
+  languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts ArrayInit
+  context-free syntax
+    "{" {VarInit ","}*     "}" -> ArrayInit {cons("ArrayInit")}
+    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/arrays/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/arrays/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,8 @@
+%%%
+ %% Chapter 10: Arrays
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/arrays/Main
+imports
+  languages/java-15/arrays/ArrayInitializers

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/ClassDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/ClassDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,73 @@
+%%%
+ %% Section 8.1: Class Declarations
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/ClassDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/ReferenceTypes
+  languages/java-15/types/TypeVariables
+  languages/java-15/classes/FieldDeclarations
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/classes/InstanceInitializers
+  languages/java-15/classes/StaticInitializers
+  languages/java-15/classes/ConstructorDeclarations
+  languages/java-15/classes/EnumDeclarations
+  languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts
+    ClassDec
+    ClassBody
+    ClassDecHead
+
+  context-free syntax
+    EnumDec -> ClassDec
+
+    ClassDecHead ClassBody -> ClassDec {cons("ClassDec")}
+    "{" ClassBodyDec* "}" -> ClassBody {cons("ClassBody")}
+
+    (Anno | ClassMod)* "class" Id  TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}
+
+  %% 8.1.1: Class Modifiers
+  sorts ClassMod
+  context-free syntax
+    Abstract  -> ClassMod
+    Public    -> ClassMod
+    Protected -> ClassMod
+    Private   -> ClassMod
+    Static    -> ClassMod
+    Final     -> ClassMod
+    StrictFP  -> ClassMod
+
+  %% 8.1.4: Superclasses and Subclasses
+  sorts Super
+  context-free syntax
+
+    "extends" ClassType -> Super {cons("SuperDec")}
+
+  %% 8.1.5: Superinterfaces
+  sorts Interfaces
+  context-free syntax
+    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}
+
+
+  %% 8.1.6: Class Body and Member Declarations
+  sorts
+    ClassBodyDec
+    ClassMemberDec
+
+  context-free syntax
+    ClassMemberDec -> ClassBodyDec
+    InstanceInit   -> ClassBodyDec
+    StaticInit     -> ClassBodyDec
+    ConstrDec      -> ClassBodyDec
+
+  context-free syntax
+    FieldDec     -> ClassMemberDec
+    MethodDec    -> ClassMemberDec
+    ClassDec     -> ClassMemberDec
+    InterfaceDec -> ClassMemberDec
+    ";"          -> ClassMemberDec {cons("Semicolon")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/ConstructorDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/ConstructorDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,36 @@
+%%%
+ %% Section 8.8: Constructor Declarations
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/ConstructorDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/interfaces/Annotations
+  languages/java-15/statements/Main
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    ConstrDec
+    ConstrBody
+    ConstrHead
+    ConstrInv
+
+  context-free syntax
+    ConstrHead ConstrBody ->  ConstrDec {cons("ConstrDec")}
+    (Anno | ConstrMod)* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}
+
+
+    "{" ConstrInv? BlockStm* "}" -> ConstrBody {cons("ConstrBody")}
+
+             TypeArgs? "this"  "(" {Expr ","}* ")" ";" -> ConstrInv {cons("AltConstrInv")}
+             TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("SuperConstrInv")}
+    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";" -> ConstrInv {cons("QSuperConstrInv")}
+
+  sorts ConstrMod
+  context-free syntax  
+    Public    -> ConstrMod
+    Protected -> ConstrMod
+    Private   -> ConstrMod

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/EnumDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/EnumDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,31 @@
+%%%
+ %% Section 8.9: Enums
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/EnumDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/classes/ClassDeclarations
+
+exports
+  sorts
+    EnumDec
+    EnumDecHead
+    EnumBody
+    EnumConst
+    EnumConstArgs
+    EnumBodyDecs
+
+  context-free syntax
+    EnumDecHead EnumBody -> EnumDec {cons("EnumDec")}
+
+    (Anno | ClassMod)* "enum" Id Interfaces? -> EnumDecHead {cons("EnumDecHead")}
+
+    "{" {EnumConst ","}*     EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
+    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody {cons("EnumBody")}
+
+    Id EnumConstArgs? ClassBody?  -> EnumConst {cons("EnumConst")}
+    "(" {Expr ","}* ")"  -> EnumConstArgs {bracket}
+
+    ";" ClassBodyDec* -> EnumBodyDecs {cons("EnumBodyDecs")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/FieldDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/FieldDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,46 @@
+%%%
+ %% Section 8.3: Field Declarations
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/FieldDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/Main
+  languages/java-15/interfaces/Annotations
+  languages/java-15/arrays/ArrayInitializers
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    FieldDec
+    VarDec
+    VarDecId
+    Dim
+    VarInit
+
+  context-free syntax
+    (Anno | FieldMod)* Type { VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}
+
+    VarDecId             -> VarDec {cons("VarDec")}
+    VarDecId "=" VarInit -> VarDec {cons("VarDec")}
+
+    Id      -> VarDecId
+    Id Dim+ -> VarDecId {cons("ArrayVarDecId")}
+
+    "[" "]" -> Dim {cons("Dim")}
+
+    Expr      -> VarInit
+    ArrayInit -> VarInit
+
+  sorts FieldMod
+  context-free syntax
+    Public    -> FieldMod
+    Protected -> FieldMod
+    Private   -> FieldMod
+
+    Static    -> FieldMod
+    Final     -> FieldMod
+    Transient -> FieldMod
+    Volatile  -> FieldMod

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/InstanceInitializers.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/InstanceInitializers.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,15 @@
+%%%
+ %% Section 8.6: Instance Initializers
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/InstanceInitializers
+imports
+  languages/java-15/statements/Blocks
+
+exports
+  sorts
+    InstanceInit
+
+  context-free syntax
+    Block -> InstanceInit {cons("InstanceInit")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,9 @@
+%%%
+ %% Section 8: Classes
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/Main
+imports
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/classes/EnumDeclarations

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/MethodDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/MethodDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,71 @@
+%%%
+ %% Section 8.4: Method Declarations
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/MethodDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/Main
+  languages/java-15/classes/FieldDeclarations
+  languages/java-15/interfaces/Annotations
+  languages/java-15/statements/Blocks
+
+exports
+  sorts
+    MethodDec
+    MethodDecHead
+    ResultType
+
+  context-free syntax
+    MethodDecHead MethodBody -> MethodDec {cons("MethodDec")}
+
+    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
+    (Anno | MethodMod)* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}
+
+    Type   -> ResultType
+    "void" -> ResultType {cons("Void")}
+
+  sorts FormalParam
+  context-free syntax
+    (Anno | VarMod)* Type       VarDecId -> FormalParam {cons("Param")}
+    (Anno | VarMod)* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}
+
+  sorts VarMod
+  context-free syntax
+    Final -> VarMod
+
+  sorts MethodMod
+  context-free syntax
+    Public         -> MethodMod
+    Protected      -> MethodMod
+    Private        -> MethodMod
+
+    Abstract       -> MethodMod
+    Static         -> MethodMod
+    Final          -> MethodMod
+    Synchronized   -> MethodMod
+    Native         -> MethodMod
+    StrictFP       -> MethodMod
+
+  %%%
+   %% Section 8.4.6: Method Throws
+   %%%
+  sorts
+    Throws
+    ExceptionType
+
+  context-free syntax
+    "throws" {ExceptionType ","}+ -> Throws {cons("ThrowsDec")}
+    ClassType -> ExceptionType
+    %% TypeVar -> ExceptionType
+
+  %%%
+   %% Section 8.4.7: Method Body
+   %%% 
+  sorts MethodBody
+  context-free syntax
+    Block -> MethodBody
+    ";"   -> MethodBody {cons("NoMethodBody")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/StaticInitializers.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/classes/StaticInitializers.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,15 @@
+%%%
+ %% Section 8.7: Static Initializers
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/classes/StaticInitializers
+imports
+  languages/java-15/statements/Blocks
+
+exports
+  sorts
+    StaticInit
+
+  context-free syntax
+    "static" Block -> StaticInit   {cons("StaticInit")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ArrayAccess.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ArrayAccess.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,16 @@
+module languages/java-15/expressions/ArrayAccess
+imports
+  languages/java-15/expressions/Main
+exports
+  sorts
+    ArrayAccess
+    ArraySubscript
+
+  context-free syntax
+    ArrayAccess -> Expr
+
+    %% todo: JFR-29
+    Expr ArraySubscript -> ArrayAccess {cons("ArrayAccess")}
+    "[" Expr "]" -> ArraySubscript {bracket}
+
+    ArrayCreationExpr ArraySubscript -> ArrayAccess {reject}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ArrayCreation.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ArrayCreation.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,29 @@
+%%%
+ %% Section 15.10: Array Creation Expressions
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/ArrayCreation
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    ArrayCreationExpr
+    ArrayBaseType
+    Dim
+    DimExpr
+
+  context-free syntax
+    ArrayCreationExpr     -> Expr
+
+    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
+    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}
+
+    PrimType -> ArrayBaseType
+    TypeName -> ArrayBaseType
+    TypeName "<" "?" ">" -> ArrayBaseType {cons("UnboundWld")}
+
+    "[" Expr "]" -> DimExpr {cons("Dim")}
+    "[" "]"      -> Dim     {cons("Dim")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/AssignmentOperators.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/AssignmentOperators.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,28 @@
+%%%
+ %% Section 15.26: Assignment Operators
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/AssignmentOperators
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts LHS
+  context-free syntax
+    LHS "="    Expr -> Expr {cons("Assign")}
+    LHS "*="   Expr -> Expr {cons("AssignMul")}
+    LHS "/="   Expr -> Expr {cons("AssignDiv")}
+    LHS "%="   Expr -> Expr {cons("AssignRemain")}
+    LHS "+="   Expr -> Expr {cons("AssignPlus")}
+    LHS "-="   Expr -> Expr {cons("AssignMinus")}
+    LHS "<<="  Expr -> Expr {cons("AssignLeftShift")}
+    LHS ">>="  Expr -> Expr {cons("AssignRightShift")}
+    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
+    LHS "&="   Expr -> Expr {cons("AssignAnd")}
+    LHS "^="   Expr -> Expr {cons("AssignExcOr")}
+    LHS "|="   Expr -> Expr {cons("AssignOr")}
+
+    ExprName    -> LHS
+    FieldAccess -> LHS
+    ArrayAccess -> LHS

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/BinaryOperators.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/BinaryOperators.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,38 @@
+module languages/java-15/expressions/BinaryOperators
+imports
+  languages/java-15/expressions/Main
+  languages/java-15/types/Main
+
+exports
+  sorts CondMid
+  context-free syntax
+    Expr "instanceof" RefType -> Expr {cons("InstanceOf")}
+
+    Expr "*"   Expr -> Expr  {left, cons("Mul")}
+    Expr "/"   Expr -> Expr  {left, cons("Div")}
+    Expr "%"   Expr -> Expr  {left, cons("Remain")}
+
+    Expr "+"   Expr -> Expr  {left, cons("Plus")}
+    Expr "-"   Expr -> Expr  {left, cons("Minus")}
+
+    Expr "<<"  Expr -> Expr  {left, cons("LeftShift")}
+    Expr ">>"  Expr -> Expr  {left, cons("RightShift")}
+    Expr ">>>" Expr -> Expr  {left, cons("URightShift")}
+
+    Expr "<"   Expr -> Expr  {left, cons("Lt")}
+    Expr ">"   Expr -> Expr  {left, cons("Gt")}
+    Expr "<="  Expr -> Expr  {left, cons("LtEq")}
+    Expr ">="  Expr -> Expr  {left, cons("GtEq")}
+    Expr "=="  Expr -> Expr  {left, cons("Eq")}
+    Expr "!="  Expr -> Expr  {left, cons("NotEq")}
+
+    Expr "&&"  Expr -> Expr  {left, cons("LazyAnd")}
+    Expr "||"  Expr -> Expr  {left, cons("LazyOr")}
+
+    Expr "&" Expr -> Expr {left, cons("And")}
+    Expr "^" Expr -> Expr {left, cons("ExcOr")}
+    Expr "|" Expr -> Expr {left, cons("Or")}
+
+    %% todo JFR-30
+    Expr CondMid Expr -> Expr {right, cons("Cond")}
+    "?" Expr ":" -> CondMid {bracket}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ClassInstanceCreation.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/ClassInstanceCreation.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,16 @@
+%%%
+ %% Section 15.9: Class Instance Creation Expressions
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/ClassInstanceCreation
+imports
+  languages/java-15/expressions/Main
+  languages/java-15/classes/ClassDeclarations
+
+exports
+  context-free syntax
+
+             "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody? -> Expr {cons("NewInstance")}
+    Expr "." "new" TypeArgs? Id         TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/FieldAccess.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/FieldAccess.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,20 @@
+%%%
+ %% Section 15.11: Field Access Expressions
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/FieldAccess
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts FieldAccess
+  context-free syntax
+    FieldAccess -> Expr
+
+  context-free syntax
+
+                    Expr "." Id -> FieldAccess {cons("Field")}
+                ExprName "." Id -> FieldAccess {reject}
+                 "super" "." Id -> FieldAccess {cons("SuperField")}
+    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,23 @@
+%%%
+ %% Chapter 15: Expressions
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/Main
+imports
+  languages/java-15/expressions/Primary
+  languages/java-15/expressions/ClassInstanceCreation
+  languages/java-15/expressions/ArrayCreation
+  languages/java-15/expressions/FieldAccess
+  languages/java-15/expressions/ArrayAccess
+  languages/java-15/expressions/MethodInvocation
+  languages/java-15/expressions/Postfix
+  languages/java-15/expressions/UnaryOperators
+  languages/java-15/expressions/BinaryOperators
+  languages/java-15/expressions/AssignmentOperators
+  languages/java-15/expressions/Restrictions
+  languages/java-15/expressions/Priorities
+
+exports
+  sorts
+    Expr

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/MethodInvocation.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/MethodInvocation.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,28 @@
+%%%
+ %% Section 15.12: Method Invocation Expressions
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/MethodInvocation
+imports
+  languages/java-15/expressions/Main
+
+exports
+  sorts MethodSpec
+  context-free syntax
+    MethodSpec "(" {Expr ","}* ")" -> Expr {cons("Invoke")}
+
+                               MethodName -> MethodSpec {cons("Method")}
+                    Expr "." TypeArgs? Id -> MethodSpec {cons("Method")}
+                 "super" "." TypeArgs? Id -> MethodSpec {cons("SuperMethod")}
+    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
+                 AmbName "." TypeArgs  Id -> MethodSpec {cons("GenericMethod")}
+
+  %% This priority forbids a Expr "." MethodSpec if the expression is a plain ExprName.
+  %% This solves an ambiguity with the MethodName and AmbName . TypeArgs MethodSpecs.
+  %% foo.bar.fred() results in a MethodName MethodSpec.
+  %% (foo.bar).fred() results in the Expr. MethodSpec
+  %% foo.bar.<T>fred() results in a GenericMethod
+  context-free priorities
+      Expr "." TypeArgs? Id -> MethodSpec
+    > ExprName  -> Expr

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Postfix.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Postfix.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,14 @@
+%%%
+ %% Section 15.14: Postfix Expressions
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/Postfix
+imports 
+  languages/java-15/expressions/Main
+
+exports
+  context-free syntax
+    ExprName  -> Expr
+    Expr "++" -> Expr {cons("PostIncr")}
+    Expr "--" -> Expr {cons("PostDecr")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Primary.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Primary.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,48 @@
+%%%
+ %% Section 15.8: Primary Expressions
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/Primary
+imports
+  languages/java-15/lexical/literals/Main
+  languages/java-15/names/Main
+  languages/java-15/expressions/Main
+
+exports
+  %%%
+   %% Section 15.8.1: Lexical Literals
+   %%%
+  sorts Literal
+  context-free syntax
+    Literal -> Expr {cons("Lit")}
+
+    IntLiteral    -> Literal
+    FloatLiteral  -> Literal
+    BoolLiteral   -> Literal 
+    CharLiteral   -> Literal
+    StringLiteral -> Literal
+    NullLiteral   -> Literal
+
+  %%%
+   %% Section 15.8.2: Class Literals
+   %%%
+  sorts ClassLiteral
+  context-free syntax
+    ClassLiteral -> Literal
+    Type   "." "class" -> ClassLiteral {cons("Class")}
+    "void" "." "class" -> ClassLiteral {cons("VoidClass")}
+
+  %%%
+   %% Section 15.8.3/4: (Qualified this)
+   %%%
+  context-free syntax
+                 "this" -> Expr {cons("This")}
+    TypeName "." "this" -> Expr {cons("QThis")}
+
+  %%%
+   %% Section 15.8.5: Parenthesized Expression
+   %%%
+  context-free syntax
+    "(" Expr ")"          -> Expr {bracket}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Priorities.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Priorities.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,102 @@
+module languages/java-15/expressions/Priorities
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/expressions/Main
+
+exports
+  context-free priorities
+      Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
+    > {right:
+        Expr "++" -> Expr
+        Expr "--" -> Expr
+      } 
+
+  context-free priorities
+      {right:
+        Expr "++" -> Expr
+        Expr "--" -> Expr
+      }
+    > { "(" PrimType ")" Expr -> Expr    
+        "(" RefType  ")" Expr -> Expr
+      }
+
+  context-free priorities
+      "(" PrimType ")" Expr -> Expr
+    > {left:
+        Expr "*" Expr -> Expr
+        Expr "/" Expr -> Expr
+        Expr "%" Expr -> Expr
+      } 
+
+  context-free priorities
+      "(" RefType ")" Expr -> Expr 
+    > {
+        "++" Expr -> Expr
+        "--" Expr -> Expr
+        "+"  Expr -> Expr
+        "-"  Expr -> Expr
+      }
+
+  context-free priorities
+    {
+      Expr ArraySubscript -> ArrayAccess
+      Expr "." Id -> FieldAccess
+      Expr "." TypeArgs? Id -> MethodSpec
+    }
+  > {right:
+      Expr "++" -> Expr
+      Expr "--" -> Expr
+    }
+  > {
+      "++" Expr -> Expr
+      "--" Expr -> Expr
+      "+"  Expr -> Expr
+      "-"  Expr -> Expr
+      "~"  Expr -> Expr
+      "!"  Expr -> Expr
+    }
+  > {left:
+      Expr "*" Expr -> Expr
+      Expr "/" Expr -> Expr
+      Expr "%" Expr -> Expr
+    } 
+  > {left:
+      Expr "+" Expr -> Expr
+      Expr "-" Expr -> Expr
+    }
+  > {left:
+      Expr "<<"  Expr -> Expr
+      Expr ">>"  Expr -> Expr
+      Expr ">>>" Expr -> Expr
+    }
+  > {left:
+      Expr "instanceof" RefType -> Expr
+      Expr "<"   Expr -> Expr
+      Expr ">"   Expr -> Expr
+      Expr "<="  Expr -> Expr
+      Expr ">="  Expr -> Expr
+    }
+  > {left:
+      Expr "=="  Expr -> Expr
+      Expr "!="  Expr -> Expr
+    }
+  >   Expr "&"   Expr -> Expr
+  >   Expr "^"   Expr -> Expr
+  >   Expr "|"   Expr -> Expr
+  >   Expr "&&"  Expr -> Expr
+  >   Expr "||"  Expr -> Expr
+  >   Expr CondMid Expr -> Expr
+  > {right:
+      LHS "="    Expr -> Expr
+      LHS "*="   Expr -> Expr
+      LHS "/="   Expr -> Expr
+      LHS "%="   Expr -> Expr
+      LHS "+="   Expr -> Expr
+      LHS "-="   Expr -> Expr
+      LHS "<<="  Expr -> Expr
+      LHS ">>="  Expr -> Expr
+      LHS ">>>=" Expr -> Expr
+      LHS "&="   Expr -> Expr
+      LHS "^="   Expr -> Expr
+      LHS "|="   Expr -> Expr
+    }

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Restrictions.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/Restrictions.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,6 @@
+module languages/java-15/expressions/Restrictions
+exports
+  lexical restrictions
+    "+" -/- [\+]
+    "-" -/- [\-]
+    "/" -/- [\/]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/UnaryOperators.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/expressions/UnaryOperators.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,21 @@
+%%%
+ %% Section 15.15: Unary Operators
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/expressions/UnaryOperators
+imports 
+  languages/java-15/expressions/Main
+exports
+  context-free syntax
+    "+" Expr -> Expr {cons("Plus")}
+    "-" Expr -> Expr {cons("Minus")}
+
+    "++" Expr -> Expr {cons("PreIncr")}
+    "--" Expr -> Expr {cons("PreDecr")}
+
+    "~" Expr -> Expr {cons("Complement")}
+    "!" Expr -> Expr {cons("Not")}
+
+    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
+    "(" RefType  ")" Expr -> Expr {cons("CastRef")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/AbstractMethodDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/AbstractMethodDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,22 @@
+module languages/java-15/interfaces/AbstractMethodDeclarations
+imports
+  languages/java-15/lexical/Modifiers
+  languages/java-15/names/Main
+  languages/java-15/types/Main
+  languages/java-15/classes/MethodDeclarations
+
+exports
+  sorts
+    AbstractMethodDec
+    AbstractMethodMod
+
+  context-free syntax
+    (Anno | AbstractMethodMod)* TypeParams? ResultType
+      Id "(" {FormalParam ","}* ")" Throws? ";" -> AbstractMethodDec {cons("AbstractMethodDec")}
+
+    (Anno | AbstractMethodMod)* TypeParams? ResultType
+      Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}
+
+    Public   -> AbstractMethodMod
+    Abstract -> AbstractMethodMod
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/AnnotationTypes.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/AnnotationTypes.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,39 @@
+%%%
+ %% Section 9.6: Annotation Types
+ %%  
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com
+ %%%
+module languages/java-15/interfaces/AnnotationTypes
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/classes/EnumDeclarations
+  languages/java-15/interfaces/InterfaceDeclarations
+  languages/java-15/interfaces/AbstractMethodDeclarations
+  languages/java-15/interfaces/ConstantDeclarations
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    AnnoDec
+    AnnoDecHead
+
+  context-free syntax
+    AnnoDecHead "{" AnnoElemDec* "}" -> AnnoDec {cons("AnnoDec")}
+    (Anno | InterfaceMod)* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}
+
+  sorts
+    AnnoElemDec
+    DefaultVal
+
+  context-free syntax
+    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}
+
+    ConstantDec  -> AnnoElemDec
+    ClassDec     -> AnnoElemDec
+    InterfaceDec -> AnnoElemDec
+    EnumDec      -> AnnoElemDec
+    AnnoDec      -> AnnoElemDec
+    ";"          -> AnnoElemDec {cons("Semicolon")}
+
+    "default" ElemVal -> DefaultVal {cons("DefaultVal")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/Annotations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/Annotations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,33 @@
+%%%
+ %% Section 9.7: Annotations
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/interfaces/Annotations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/names/Main
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    Anno
+    ElemVal
+    ElemValPair
+
+  context-free syntax
+    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
+    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
+    "@" TypeName                            -> Anno {cons("MarkerAnno")}
+
+  context-free syntax  
+    Id "=" ElemVal -> ElemValPair {cons("ElemValPair")}
+
+    Expr -> ElemVal
+    Anno -> ElemVal
+
+    "{" {ElemVal ","}*     "}" -> ElemVal {cons("ElemValArrayInit")}
+    "{" {ElemVal ","}* "," "}" -> ElemVal {cons("ElemValArrayInit")}
+
+    %% Assignments are not allowed as element values.
+    LHS "=" Expr -> ElemVal {reject}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/ConstantDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/ConstantDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,23 @@
+%%%
+ %% Section 9.3: Field (Constant) Declarations
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/interfaces/ConstantDeclarations
+imports
+  languages/java-15/lexical/Modifiers
+  languages/java-15/types/Main
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    ConstantDec
+    ConstantMod
+
+  context-free syntax
+    (Anno | ConstantMod)* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}
+
+    Public -> ConstantMod
+    Static -> ConstantMod
+    Final  -> ConstantMod

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/InterfaceDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/InterfaceDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,48 @@
+%%%
+ %% Section 9.1: Interface Declarations
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/interfaces/InterfaceDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Modifiers
+  languages/java-15/names/Main
+  languages/java-15/types/Main
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/interfaces/ConstantDeclarations
+  languages/java-15/interfaces/AbstractMethodDeclarations
+  languages/java-15/interfaces/AnnotationTypes
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    InterfaceDec
+    InterfaceDecHead
+    ExtendsInterfaces
+    InterfaceMemberDec
+    InterfaceMod
+
+  context-free syntax
+    AnnoDec -> InterfaceDec
+
+    InterfaceDecHead "{" InterfaceMemberDec* "}" -> InterfaceDec {cons("InterfaceDec")}
+
+    (Anno | InterfaceMod)* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead {cons("InterfaceDecHead")}
+    "extends" {InterfaceType ","}+ -> ExtendsInterfaces {cons("ExtendsInterfaces")}
+
+  context-free syntax
+    ConstantDec       -> InterfaceMemberDec
+    AbstractMethodDec -> InterfaceMemberDec
+    ClassDec          -> InterfaceMemberDec
+    InterfaceDec      -> InterfaceMemberDec
+    ";"               -> InterfaceMemberDec {cons("Semicolon")}
+
+  context-free syntax
+    Public         -> InterfaceMod
+    Protected      -> InterfaceMod
+    Private        -> InterfaceMod
+    Abstract       -> InterfaceMod
+    Static         -> InterfaceMod
+    StrictFP       -> InterfaceMod

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/interfaces/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,11 @@
+%%%
+ %% Chapter 9: Interfaces
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/interfaces/Main
+imports
+  languages/java-15/interfaces/InterfaceDeclarations
+  languages/java-15/interfaces/AbstractMethodDeclarations
+  languages/java-15/interfaces/AnnotationTypes
+  languages/java-15/interfaces/Annotations

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Comments.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Comments.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,55 @@
+%%%
+ %% Section 3.7: Comments
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/Comments
+imports
+  languages/java-15/lexical/LineTerminators
+exports
+  sorts
+    Comment
+    EOLCommentChars
+    CommentPart
+    UnicodeEscape
+    BlockCommentChars
+    Asterisk
+    EscEscChar
+    EscChar
+
+  lexical syntax
+    Comment -> LAYOUT
+
+    "//" EOLCommentChars LineTerminator -> Comment
+    ~[\n\r]* -> EOLCommentChars
+
+    "/*"  CommentPart* "*/" -> Comment
+    "/**" CommentPart* "*/" -> Comment
+    "/**/"                  -> Comment %% Strange javadoc comment
+
+    BlockCommentChars -> CommentPart
+    EscChar           -> CommentPart
+    EscEscChar        -> CommentPart
+    Asterisk          -> CommentPart
+    UnicodeEscape     -> CommentPart
+
+    ~[\*\\]+ -> BlockCommentChars
+
+    "*"    -> Asterisk
+    "\\\\" -> EscEscChar
+    "\\"   -> EscChar
+
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape
+
+  lexical restrictions
+    "/**"    -/- [\/]
+    "/*"     -/- [\*]
+    Asterisk -/- [\/]
+    EscChar  -/- [\\u]
+
+    BlockCommentChars -/- ~[\*\\]
+    EOLCommentChars   -/- ~[\n\13]
+
+  context-free restrictions
+    LAYOUT?  -/- [\/].[\*]
+    LAYOUT?  -/- [\/].[\/]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Identifiers.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Identifiers.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,26 @@
+%%%
+ %% Section 3.8: Identifiers
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/Identifiers
+imports
+  languages/java-15/lexical/Keywords
+exports
+  sorts
+    Id
+    ID
+
+  context-free syntax
+    ID -> Id {cons("Id")}
+
+  lexical syntax
+    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> ID
+    
+    Keyword -> ID {reject}
+    "true"  -> ID {reject}
+    "false" -> ID {reject}
+    "null"  -> ID {reject}
+
+  lexical restrictions
+    ID -/- [a-zA-Z0-9\_\$]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Keywords.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Keywords.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,113 @@
+%%%
+ %% Section 3.7: Comments
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/Keywords
+exports
+  sorts Keyword
+  lexical syntax
+    "abstract"      -> Keyword
+    "assert"        -> Keyword
+    "boolean"       -> Keyword
+    "break"         -> Keyword
+    "byte"          -> Keyword
+    "case"          -> Keyword
+    "catch"         -> Keyword
+    "char"          -> Keyword
+    "class"         -> Keyword
+    "const"         -> Keyword
+    "continue"      -> Keyword
+    "default"       -> Keyword
+    "do"            -> Keyword
+    "double"        -> Keyword
+    "else"          -> Keyword
+    "enum"          -> Keyword
+    "extends"       -> Keyword
+    "final"         -> Keyword
+    "finally"       -> Keyword
+    "float"         -> Keyword
+    "for"           -> Keyword
+    "goto"          -> Keyword
+    "if"            -> Keyword
+    "implements"    -> Keyword
+    "import"        -> Keyword
+    "instanceof"    -> Keyword
+    "int"           -> Keyword
+    "interface"     -> Keyword
+    "long"          -> Keyword
+    "native"        -> Keyword
+    "new"           -> Keyword
+    "package"       -> Keyword
+    "private"       -> Keyword
+    "protected"     -> Keyword
+    "public"        -> Keyword
+    "return"        -> Keyword
+    "short"         -> Keyword
+    "static"        -> Keyword
+    "strictfp"      -> Keyword
+    "super"         -> Keyword
+    "switch"        -> Keyword
+    "synchronized"  -> Keyword
+    "this"          -> Keyword
+    "throw"         -> Keyword
+    "throws"        -> Keyword
+    "transient"     -> Keyword
+    "try"           -> Keyword
+    "void"          -> Keyword
+    "volatile"      -> Keyword
+    "while"         -> Keyword
+
+  lexical restrictions
+
+    "abstract"
+    "assert"
+    "boolean" 
+    "break"   
+    "byte"    
+    "case"    
+    "catch"   
+    "char"     
+    "class"
+    "const"    
+    "continue" 
+    "default"  
+    "do"       
+    "double"   
+    "else"     
+    "enum"
+    "extends"  
+    "final"     
+    "finally"   
+    "float"     
+    "for"       
+    "goto"       
+    "if"         
+    "implements" 
+    "import"     
+    "instanceof" 
+    "int"        
+    "interface"  
+    "long"       
+    "native"     
+    "new"        
+    "package"    
+    "private"    
+    "protected"   
+    "public"       
+    "return"       
+    "short"        
+    "static"     
+    "strictfp"
+    "super"        
+    "switch"       
+    "synchronized" 
+    "this"         
+    "throw"        
+    "throws"       
+    "transient"    
+    "try"          
+    "void"         
+    "volatile"     
+    "while"       -/- [A-Za-z0-9\_\$]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/LineTerminators.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/LineTerminators.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,27 @@
+%%%
+ %% Section 3.4: Line Terminators
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/LineTerminators
+exports
+  sorts
+    LineTerminator CarriageReturn EndOfFile
+
+  lexical syntax
+    [\n]           -> LineTerminator
+    [\r][\n]       -> LineTerminator
+    CarriageReturn -> LineTerminator
+    EndOfFile      -> LineTerminator
+
+    [\r] -> CarriageReturn
+
+  lexical restrictions
+    CarriageReturn -/- [\n]
+
+  %% End of file is empty.
+  lexical syntax    
+    -> EndOfFile
+
+  lexical restrictions
+    EndOfFile -/- ~[]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,15 @@
+%%%
+ %% Chapter 3: Lexical Structure
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/Main
+imports
+  languages/java-15/lexical/UnicodeEscapes
+  languages/java-15/lexical/LineTerminators
+  languages/java-15/lexical/WhiteSpace
+  languages/java-15/lexical/Comments
+  languages/java-15/lexical/Identifiers
+  languages/java-15/lexical/Keywords
+  languages/java-15/lexical/Modifiers
+  languages/java-15/lexical/literals/Main
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Modifiers.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/Modifiers.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,41 @@
+module languages/java-15/lexical/Modifiers
+exports
+  sorts
+    Public
+    Private
+    Protected
+    Abstract
+    Final
+    Static
+    Native
+    Transient
+    Volatile
+    Synchronized
+    StrictFP
+    Modifier
+
+  context-free syntax
+    "public"       -> Public       {cons("Public")}
+    "private"      -> Private      {cons("Private")}
+    "protected"    -> Protected    {cons("Protected")}
+
+    "abstract"     -> Abstract     {cons("Abstract")}
+    "final"        -> Final        {cons("Final")}
+    "static"       -> Static       {cons("Static")}
+    "native"       -> Native       {cons("Native")}
+    "transient"    -> Transient    {cons("Transient")}
+    "volatile"     -> Volatile     {cons("Volatile")}
+    "synchronized" -> Synchronized {cons("Synchronized")}
+    "strictfp"     -> StrictFP     {cons("StrictFP")}
+
+    Public       -> Modifier
+    Private      -> Modifier
+    Protected    -> Modifier
+    Abstract     -> Modifier
+    Final        -> Modifier
+    Static       -> Modifier
+    Native       -> Modifier
+    Transient    -> Modifier
+    Volatile     -> Modifier
+    Synchronized -> Modifier
+    StrictFP     -> Modifier

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/UnicodeEscapes.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/UnicodeEscapes.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,12 @@
+%%%
+ %% Section 3.3: Unicode Escapes
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/UnicodeEscapes
+exports
+  sorts
+    UnicodeEscape
+
+  syntax
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/WhiteSpace.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/WhiteSpace.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,14 @@
+%%%
+ %% Section 3.6: WhiteSpace
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/WhiteSpace
+exports
+  lexical syntax
+    [\ \t\12\r\n] -> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\12\n\r]
+
+  %% \f = 12

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/BooleanLiterals.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/BooleanLiterals.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,15 @@
+%%%
+ %% Section 3.10.3: Boolean Literals
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/BooleanLiterals
+exports
+  sorts
+    Bool
+    BoolLiteral
+
+  context-free syntax
+    Bool -> BoolLiteral {cons("Bool")}
+    "true"  -> Bool {cons("True")}
+    "false" -> Bool {cons("False")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/CharacterLiterals.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/CharacterLiterals.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,25 @@
+%%%
+ %% Section 3.10.4: Character Literals
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/CharacterLiterals
+imports
+  languages/java-15/lexical/literals/EscapeSequences
+  languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts
+    CharLiteral
+    CharContent
+    SingleChar
+
+  syntax
+    CharLiteral   -> <CharLiteral-CF>
+
+    "'" CharContent "'" -> CharLiteral {cons("Char")}
+    SingleChar    -> CharContent {cons("Single")}
+    UnicodeEscape -> CharContent
+    EscapeSeq     -> CharContent
+
+    ~[\r\n\'\\] -> SingleChar

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/EscapeSequences.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/EscapeSequences.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,29 @@
+%%%
+ %% Section 3.10.6: Escape Sequences for Character and String Literals
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/EscapeSequences
+imports
+
+exports
+  sorts
+    EscapeSeq
+    NamedEscape
+    OctaEscape
+    LastOcta
+
+  syntax
+    OctaEscape  -> EscapeSeq
+    NamedEscape -> EscapeSeq
+
+    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
+    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
+    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}
+
+    [0-7] -> LastOcta
+
+  restrictions
+    LastOcta -/- [0-7]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/FloatingPointLiterals.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/FloatingPointLiterals.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,72 @@
+%%%
+ %% Section 3.10.2: Floating Point Literals
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/FloatingPointLiterals
+exports
+  sorts
+    FloatLiteral
+    DeciFloatLiteral
+    HexaFloatLiteral      
+  
+  context-free syntax
+    DeciFloatLiteral -> FloatLiteral {cons("Float")}
+    HexaFloatLiteral -> FloatLiteral {cons("Float")}
+
+  lexical syntax
+    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral
+    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral
+    
+    %% Reject plain integer literals as decimal float literals.
+    %% A similar rejection for hexadecimal float literals is not
+    %% required, since these always contain an exponent part.
+    [0-9]+ -> DeciFloatLiteral {reject}
+
+  lexical restrictions
+    DeciFloatLiteral -/- [fFdD]
+    HexaFloatLiteral -/- [fFdD]
+
+  %%%
+   %% Decimal Floating Point Numerals
+   %%%
+  sorts
+    DeciFloatNumeral
+    DeciFloatDigits
+    DeciFloatExponentPart
+
+  lexical syntax
+    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral
+
+    [0-9]* "." [0-9]* -> DeciFloatDigits
+           "."        -> DeciFloatDigits {reject}
+    [0-9]+            -> DeciFloatDigits
+
+    [eE] SignedInteger -> DeciFloatExponentPart
+    
+    [\+\-]? [0-9]+ -> SignedInteger    
+
+  lexical restrictions
+    DeciFloatDigits  -/- [0-9]
+    DeciFloatExponentPart -/- [0-9]
+
+  %%%
+   %% Hexadecimal Floating Point Literals
+   %%%
+  sorts
+    HexaFloatNumeral
+    HexaSignificand
+    BinaryExponent
+    SignedInteger
+    
+  lexical syntax
+    HexaSignificand BinaryExponent -> HexaFloatNumeral
+
+    [0][xX] [0-9a-fA-F]+                  -> HexaSignificand
+    [0][xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand
+    [0][xX]              "."              -> HexaSignificand {reject}
+
+    [pP] SignedInteger -> BinaryExponent
+  lexical restrictions
+    HexaSignificand -/- [0-9a-fA-F]
+    SignedInteger   -/- [0-9]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/IntegerLiterals.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/IntegerLiterals.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,39 @@
+%%%
+ %% Section 3.10.1: Literals
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/IntegerLiterals
+exports
+  sorts
+    IntLiteral
+    DeciLiteral
+    HexaLiteral
+    OctaLiteral
+    DeciNumeral
+    HexaNumeral
+    OctaNumeral
+
+  context-free syntax
+    DeciLiteral -> IntLiteral {cons("Deci")}
+    HexaLiteral -> IntLiteral {cons("Hexa")}
+    OctaLiteral -> IntLiteral {cons("Octa")}
+
+  lexical syntax
+    DeciNumeral [lL]? -> DeciLiteral
+    HexaNumeral [lL]? -> HexaLiteral
+    OctaNumeral [lL]? -> OctaLiteral
+
+    "0" -> DeciNumeral
+    [1-9][0-9]*  -> DeciNumeral
+    [0][xX] [0-9a-fA-F]+ -> HexaNumeral
+    [0]     [0-7]+       -> OctaNumeral
+
+  lexical restrictions
+    DeciNumeral -/- [0-9\.fFdD]
+    HexaNumeral -/- [0-9a-fA-F]
+    OctaNumeral -/- [0-7]
+
+    DeciLiteral -/- [lL]
+    HexaLiteral -/- [lL]
+    OctaLiteral -/- [lL]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,13 @@
+%%%
+ %% Section 3.10: Literals
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/Main
+imports
+  languages/java-15/lexical/literals/IntegerLiterals
+  languages/java-15/lexical/literals/FloatingPointLiterals
+  languages/java-15/lexical/literals/BooleanLiterals  
+  languages/java-15/lexical/literals/CharacterLiterals  
+  languages/java-15/lexical/literals/StringLiterals
+  languages/java-15/lexical/literals/NullLiteral

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/NullLiteral.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/NullLiteral.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,10 @@
+%%%
+ %% Section 3.10.7: The null Literal
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/NullLiteral
+exports
+  sorts NullLiteral
+  context-free syntax
+    "null"  -> NullLiteral {cons("Null")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/StringLiterals.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/lexical/literals/StringLiterals.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,30 @@
+%%%
+ %% Section 3.10.5: String Literals
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/lexical/literals/StringLiterals
+imports
+  languages/java-15/lexical/literals/EscapeSequences
+  languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts
+    StringLiteral
+    StringPart
+    StringChars
+    FooStringChars
+
+  syntax
+    StringLiteral -> <StringLiteral-CF>
+    
+    "\"" StringPart* "\"" -> StringLiteral {cons("String")}
+    StringChars    -> StringPart {cons("Chars")}
+    UnicodeEscape  -> StringPart
+    EscapeSeq      -> StringPart
+
+    <FooStringChars-LEX> -> StringChars
+    ~[\"\\\n\13]+  -> <FooStringChars-LEX>
+
+  restrictions
+    StringChars -/- ~[\"\\\n\13]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/names/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/names/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,35 @@
+%%%
+ %% Chapter 6: Names
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/names/Main
+imports
+  languages/java-15/lexical/Identifiers
+exports
+  sorts PackageName
+  context-free syntax
+    {Id "."}+ -> PackageName {cons("PackageName")}
+
+  sorts
+    TypeName
+    ExprName
+    MethodName
+    PackageOrTypeName
+    AmbName
+
+  context-free syntax
+    Id             -> AmbName {cons("AmbName")}
+    AmbName "." Id -> AmbName {cons("AmbName")}
+
+    Id                       -> TypeName {cons("TypeName")}
+    PackageOrTypeName "." Id -> TypeName {cons("TypeName")}
+
+    Id             -> ExprName {cons("ExprName")}
+    AmbName "." Id -> ExprName {cons("ExprName")}
+
+    Id             -> MethodName  {cons("MethodName")}
+    AmbName "." Id -> MethodName  {cons("MethodName")}
+
+    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
+    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/CompilationUnits.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/CompilationUnits.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,17 @@
+%%%
+ %% Section 7.3: CompilationUnits
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/packages/CompilationUnits
+imports
+  languages/java-15/packages/PackageDeclarations
+  languages/java-15/packages/ImportDeclarations
+  languages/java-15/packages/TypeDeclarations
+
+exports
+  sorts
+    CompilationUnit
+
+  context-free syntax
+    PackageDec? ImportDec* TypeDec+ -> CompilationUnit   {cons("CompilationUnit")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/ImportDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/ImportDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,19 @@
+%%%
+ %% Section 7.5: Import Declarations
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/packages/ImportDeclarations
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/names/Main
+
+exports
+  sorts
+    ImportDec
+
+  context-free syntax
+    "import" TypeName                  ";"  -> ImportDec {cons("TypeImportDec")}
+    "import" PackageName       "." "*" ";"  -> ImportDec {cons("TypeImportOnDemandDec")}
+    "import" "static" TypeName "." Id  ";"  -> ImportDec {cons("StaticImportDec")}
+    "import" "static" TypeName "." "*" ";"  -> ImportDec {cons("StaticImportOnDemandDec")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,10 @@
+%%%
+ %% Chapter 7: Packages
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/packages/Main
+imports
+  languages/java-15/packages/CompilationUnits
+  languages/java-15/packages/ImportDeclarations
+  languages/java-15/packages/PackageDeclarations

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/PackageDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/PackageDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,16 @@
+%%%
+ %% Section 7.4: Package Declarations
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/packages/PackageDeclarations
+imports
+  languages/java-15/names/Main
+  languages/java-15/interfaces/Annotations
+
+exports
+  sorts
+    PackageDec
+
+  context-free syntax
+    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/TypeDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/packages/TypeDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,18 @@
+%%%
+ %% Section 7.6: Top Level Type Declarations
+ %%
+ %% @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/packages/TypeDeclarations
+imports
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts
+    TypeDec
+
+  context-free syntax
+    ClassDec      -> TypeDec
+    InterfaceDec  -> TypeDec
+    ";"           -> TypeDec {cons("Semicolon")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Blocks.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Blocks.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,22 @@
+%%%
+ %% Section 14.2: Blocks
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/statements/Blocks
+imports
+  languages/java-15/classes/ClassDeclarations
+  languages/java-15/statements/LocalVariableDeclarations
+  languages/java-15/statements/Statements
+
+exports
+  sorts
+    BlockStm
+    Block
+
+  context-free syntax
+    "{" BlockStm* "}" -> Block {cons("Block")}
+
+    LocalVarDecStm  -> BlockStm 
+    ClassDec        -> BlockStm {cons("ClassDecStm")}
+    Stm             -> BlockStm

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/LocalVariableDeclarations.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/LocalVariableDeclarations.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,18 @@
+%%%
+ %% Section 14.4: Local Variable Declaration Statements
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/statements/LocalVariableDeclarations
+imports
+  languages/java-15/classes/MethodDeclarations
+  languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts
+    LocalVarDecStm
+    LocalVarDec
+
+  context-free syntax
+    LocalVarDec ";" -> LocalVarDecStm {prefer, cons("LocalVarDecStm")}
+    (Anno | VarMod)* Type {VarDec ","}+ -> LocalVarDec {prefer, cons("LocalVarDec")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,10 @@
+%%%
+ %% Chapter 14: Blocks and Statements
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/statements/Main
+imports
+  languages/java-15/statements/Blocks
+  languages/java-15/statements/LocalVariableDeclarations
+  languages/java-15/statements/Statements

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Statements.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/statements/Statements.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,123 @@
+%%%
+ %% Section 14.5: Statements
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/statements/Statements
+imports
+  languages/java-15/statements/LocalVariableDeclarations
+  languages/java-15/statements/Blocks
+  languages/java-15/expressions/Main
+
+exports
+  sorts
+    Stm
+
+  context-free syntax
+    Block      -> Stm
+
+  %%%
+   %% Section 14.6: The Empty Statement
+   %%%
+  context-free syntax
+    ";"        -> Stm {cons("Empty")}
+
+  %%%
+   %% Section 14.7: Labeled Statements
+   %%%
+  context-free syntax
+    Id ":" Stm -> Stm {cons("Labeled")}
+
+  %%%
+   %% Section 14.8: Expressions Statements
+   %%%
+  context-free syntax
+    Expr ";"   -> Stm {cons("ExprStm")}
+
+  %%%
+   %% Section 14.9: The If Statement
+   %%%
+  context-free syntax
+    "if" "(" Expr ")" Stm             -> Stm {prefer, cons("If")}
+    "if" "(" Expr ")" Stm  "else" Stm -> Stm {cons("If")}
+
+  %%%
+   %% Section 14.10: The Assert Statement
+   %%%
+  context-free syntax
+    "assert" Expr          ";" -> Stm  {cons("AssertStm")}
+    "assert" Expr ":" Expr ";" -> Stm  {cons("AssertStm")}
+
+
+  %%%
+   %% Section 14.11: The Switch Statement
+   %%%
+  sorts SwitchBlock SwitchGroup SwitchLabel
+  context-free syntax
+    "switch" "(" Expr ")" SwitchBlock -> Stm {cons("Switch")}
+    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
+    SwitchLabel+ BlockStm+ -> SwitchGroup  {cons("SwitchGroup")}
+
+    "case" Expr ":" -> SwitchLabel {cons("Case")}
+    "default"   ":" -> SwitchLabel {cons("Default")}
+
+  %%%
+   %% Section 14.12: The While Statement
+   %%%
+  context-free syntax
+    "while" "(" Expr ")" Stm -> Stm {cons("While")}
+
+  %%%
+   %% Section 14.13: The Do Statement
+   %%%
+  context-free syntax
+  "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}
+
+
+  %%%
+   %% Section 14.14: The For Statement
+   %%%
+  context-free syntax
+    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+
+    "for" "(" FormalParam ":" Expr ")" Stm -> Stm {cons("ForEach")}
+
+  %%%
+   %% Section 14.15: The Break Statement
+   %%%
+  context-free syntax
+    "break"    Id? ";"   -> Stm {cons("Break")}
+
+  %%%
+   %% Section 14.16: The Continue Statement
+   %%%
+  context-free syntax
+    "continue" Id? ";"   -> Stm {cons("Continue")}
+
+  %%%
+   %% Section 14.17: The Return Statement
+   %%%
+  context-free syntax
+    "return"   Expr? ";" -> Stm {cons("Return")}
+
+  %%%
+   %% Section 14.18: The Throw Statement
+   %%%
+  context-free syntax
+    "throw"    Expr  ";" -> Stm {cons("Throw")}
+
+  %%%
+   %% Section 14.19: The Synchronized Statement
+   %%%
+  context-free syntax
+    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}
+
+  %%%
+   %% Section 14.20: The Try Statement
+   %%%
+  sorts CatchClause
+  context-free syntax
+    "try" Block CatchClause+ -> Stm {cons("Try")}
+    "try" Block CatchClause* "finally" Block -> Stm {cons("Try")}
+    "catch" "(" FormalParam ")" Block -> CatchClause {cons("Catch")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,19 @@
+%%%
+ %% Chapter 4: Types, Values, and Variables
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/types/Main
+imports
+  languages/java-15/types/PrimitiveTypes
+  languages/java-15/types/ReferenceTypes
+  languages/java-15/types/TypeVariables
+  languages/java-15/types/ParameterizedTypes
+
+exports
+  sorts
+    Type
+
+  context-free syntax
+    PrimType -> Type
+    RefType  -> Type

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/ParameterizedTypes.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/ParameterizedTypes.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,23 @@
+%%%
+ %% Section 4.5: Parameterized Types
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/types/ParameterizedTypes
+imports
+  languages/java-15/types/ReferenceTypes
+
+exports
+  sorts
+    TypeArgs
+    ActualTypeArg
+    WildcardBound
+    
+  context-free syntax
+    "<" {ActualTypeArg ","}+ ">" -> TypeArgs {cons("TypeArgs")}
+
+    Type               -> ActualTypeArg
+    "?" WildcardBound? -> ActualTypeArg {cons("Wildcard")}
+
+    "extends" RefType -> WildcardBound {cons("WildcardUpperBound")}
+    "super"   RefType -> WildcardBound {cons("WildcardLowerBound")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/PrimitiveTypes.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/PrimitiveTypes.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,27 @@
+%%%
+ %% Section 4.2: Primitive Types and Values
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/types/PrimitiveTypes
+exports
+  sorts
+    PrimType
+    NumType
+    IntType  
+    FloatType
+
+  context-free syntax
+    NumType   -> PrimType
+    "boolean" -> PrimType {cons("Boolean")}
+
+    IntType   -> NumType
+    FloatType -> NumType
+
+    "byte"   -> IntType   {cons("Byte")}
+    "short"  -> IntType   {cons("Short")}
+    "int"    -> IntType   {cons("Int")}
+    "long"   -> IntType   {cons("Long")}
+    "char"   -> IntType   {cons("Char")}
+    "float"  -> FloatType {cons("Float")}
+    "double" -> FloatType {cons("Double")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/ReferenceTypes.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/ReferenceTypes.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,52 @@
+%%%
+ %% Section 4.3: Reference Types and Values
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/types/ReferenceTypes
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/names/Main
+  languages/java-15/types/Main  
+  languages/java-15/types/ParameterizedTypes
+  languages/java-15/types/TypeVariables
+
+
+exports
+  sorts
+    RefType
+    ClassOrInterfaceType
+    ClassType
+    InterfaceType
+    TypeDecSpec
+    ArrayType
+    TypeVar
+
+  context-free syntax
+    ClassOrInterfaceType -> RefType
+    ArrayType            -> RefType
+    
+    %% This production rule is highly ambiguous, since every
+    %% TypeVar can be a ClassOrInterfaceType. A later disambiguation
+    %% phase has to find out if a ClassOrInterfaceType is in fact
+    %% a TypeVar.
+    
+    %% TypeVar -> RefType {avoid}
+
+  context-free syntax
+  
+    %% ClassType and InterfaceType are ambiguous. We modify the
+    %% production of ClassOrInterfaceType to make this ambiguity explicit.
+    
+    TypeDecSpec TypeArgs? -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
+    TypeDecSpec TypeArgs? -> ClassType {cons("ClassType")}
+    TypeDecSpec TypeArgs? -> InterfaceType {cons("InterfaceType")}
+
+    TypeName -> TypeDecSpec
+    TypeDecSpec TypeArgs "." Id -> TypeDecSpec {cons("Member")}
+    
+  context-free syntax    
+    TypeVarId -> TypeVar {cons("TypeVar")}
+
+  context-free syntax
+    Type "[" "]" -> ArrayType  {cons("ArrayType")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/TypeVariables.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java-15/types/TypeVariables.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,25 @@
+%%%
+ %% Section 4.4: Type Variables
+ %%
+ %% @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ %%%
+module languages/java-15/types/TypeVariables
+imports
+  languages/java-15/lexical/Identifiers
+  languages/java-15/types/ReferenceTypes
+
+exports
+  sorts
+    TypeParams
+    TypeParam
+    TypeBound
+    TypeVarId
+  
+  context-free syntax
+    TypeVarId TypeBound? -> TypeParam {cons("TypeParam")}
+    
+    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound {cons("TypeBound")}
+    "<" {TypeParam ","}+ ">" -> TypeParams {cons("TypeParams")}
+
+    Id -> TypeVarId
+    
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/EmbeddedJava.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/EmbeddedJava.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,486 @@
+module languages/java/EmbeddedJava[E]
+imports
+  languages/java-15/Main
+
+exports
+  variables
+    [ij]  [0-9\']*            -> DeciLiteral {prefer}
+    [ij]  [\_] [a-zA-Z0-9\']* -> DeciLiteral {prefer}
+    [xyz] [0-9\']*            -> ID          {prefer}
+    [xyz] [\_] [a-zA-Z0-9\']* -> ID          {prefer}
+
+  context-free restrictions
+    ID -/- [\_a-zA-Z0-9\']
+
+%%%
+ %% Expressions
+ %%%
+exports
+
+  %%%
+   %% Variables for Expressions
+   %%%
+  variables
+    "e"    [0-9\']*         -> Expr           {prefer}
+    "e_" [a-zA-Z0-9\']*     -> Expr           {prefer}
+    "e"    [0-9\']* "*"     -> {VarInit ","}* {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {VarInit ","}* {prefer}
+    "e"    [0-9\']* "*"     -> {Expr ","}*    {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {Expr ","}*    {prefer}
+
+  lexical syntax
+    "e" [0-9\']*            -> ID {reject}
+    "e_" [a-zA-Z0-9\']*     -> ID {reject}
+
+  %%%
+   %% Quotations for Expressions
+   %%%
+  context-free syntax
+            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+
+    "var-init" "|[" VarInit "]|" -> E {cons("ToMetaExpr")}
+
+%%%
+ %% Statements
+ %%%
+exports
+
+  %%%
+   %% Variables for Statements
+   %%%
+  variables
+    "stm"  [0-9\']*             -> Stm         {prefer}
+    "stm_" [a-zA-Z0-9\']*       -> Stm         {prefer}
+    "bstm" [0-9\']*             -> BlockStm    {prefer}
+    "bstm_" [a-zA-Z0-9\']*      -> BlockStm    {prefer}
+    "bstm" [0-9\']* "*"         -> BlockStm*   {prefer}    
+    "bstm_" [a-zA-Z0-9\']* "*"  -> BlockStm*   {prefer}
+
+  %%%
+   %% Quotations for Statements
+   %%%
+  context-free syntax
+    "java:bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+         "bstm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+    "java"       "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+                 "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+
+    "java:bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+         "bstm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+
+    "java:block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+         "block-stm"  "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+    "java"            "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+                      "|[" BlockStm "]|" -> E {cons("ToMetaExpr")}
+
+    "java:block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+         "block-stm*" "|[" BlockStm* "]|" -> E {cons("ToMetaListExpr")}
+
+
+    "java:stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
+         "stm"  "|[" Stm "]|" -> E {cons("ToMetaExpr")}
+         
+         "switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}         
+    "java:switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}
+    
+  %%%
+   %% Anti Quotations for Statements
+   %%%
+  context-free syntax
+    "~"       E  -> BlockStm  {cons("FromMetaExpr")}
+    "~bstm:"  E  -> BlockStm  {cons("FromMetaExpr")}
+    "~*"      E  -> BlockStm* {cons("FromMetaExpr")}
+    "~bstm*:" E  -> BlockStm* {cons("FromMetaExpr")}
+
+    "~stm:"   E  -> Stm {cons("FromMetaExpr"), prefer}
+    "~"       E  -> Stm {cons("FromMetaExpr")}
+
+    "~*"              E -> SwitchGroup* {cons("FromMetaExpr")}    
+    "~switch-group*:" E -> SwitchGroup* {cons("FromMetaExpr")}    
+
+    "~"               E -> SwitchGroup {cons("FromMetaExpr")}
+    "~switch-group:"  E -> SwitchGroup {cons("FromMetaExpr")}
+
+%%%
+ %% Variable Declarations
+ %%%
+
+  %%%
+   %% Variables for Variable Declarations
+   %%%
+  variables
+    "lvdec" [0-9]*            -> LocalVarDec    {prefer}
+    "lvdec_" [a-zA-Z0-9]*     -> LocalVarDec    {prefer}
+     "vdec" [0-9]*            -> VarDec         {prefer}
+     "vdec_" [a-zA-Z0-9]*     -> VarDec         {prefer}
+     "vdec"  [0-9]* "*"       -> {VarDec ","}+  {prefer}
+     "vdec_" [a-zA-Z0-9]* "*" -> {VarDec ","}+  {prefer}
+
+  lexical syntax
+    "lvdec"               -> ID {reject}
+    "lvdec_" [a-zA-Z0-9]* -> ID {reject}
+     "vdec"               -> ID {reject}
+     "vdec_" [a-zA-Z0-9]* -> ID {reject}
+
+  %%%
+   %% Quotations for Local Variable Declarations
+   %%%
+  context-free syntax
+    "java:lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
+         "lvdec"  "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
+
+    "java:vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}
+         "vdec" "|[" VarDec "]|" -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti Quotations for Local Variable Declarations
+   %%%
+  context-free syntax
+
+%%%
+ %% LeftHandSide of Assignment
+ %%%
+exports
+
+  %%%
+   %% Variables for LeftHandSide of Assignment
+   %%%
+  variables
+    "lhs" [0-9\']* -> LHS {prefer}
+    "e"   [0-9\']* -> LHS {prefer}
+
+  lexical syntax
+    "lhs" [0-9\']* -> ID {reject}
+
+%%%
+ %% Types
+ %%%
+exports
+
+  %%%
+   %% Variables for Types
+   %%%
+  variables
+    MetaTypeVar     -> Type     {prefer}
+    MetaPrimTypeVar -> PrimType {prefer}
+    MetaRefTypeVar  -> RefType  {prefer}
+
+  lexical syntax
+    "t"  [0-9\']*        -> MetaTypeVar
+    "t_" [a-zA-Z0-9\']*  -> MetaTypeVar
+    "ty" [0-9]*          -> MetaTypeVar
+    "ty_" [a-zA-Z0-9\']* -> MetaTypeVar
+
+    "primt"  [0-9]*        -> MetaPrimTypeVar
+    "primt_" [a-zA-Z0-9]*  -> MetaPrimTypeVar
+    "primty" [0-9]*        -> MetaPrimTypeVar
+    "primty_" [a-zA-Z0-9]* -> MetaPrimTypeVar
+    "reft"   [0-9]*        -> MetaRefTypeVar
+    "reft_" [a-zA-Z0-9]*   -> MetaRefTypeVar
+    "refty"  [0-9]*        -> MetaRefTypeVar
+    "refty_" [a-zA-Z0-9]*  -> MetaRefTypeVar
+
+    "t"  [0-9\']*          -> ID {reject}
+    "t_" [a-zA-Z0-9]*      -> ID {reject}
+    "ty" [0-9]*            -> ID {reject}
+    "ty_" [a-zA-Z0-9]*     -> ID {reject}
+    "primt"  [0-9]*        -> ID {reject}
+    "primt_" [a-zA-Z0-9]*  -> ID  {reject}
+    "primty" [0-9]*        -> ID {reject}
+    "primty_" [a-zA-Z0-9]* -> ID {reject}
+    "reft"   [0-9]*        -> ID {reject}
+    "reft_" [a-zA-Z0-9]*   -> ID {reject}    
+    "refty"  [0-9]*        -> ID {reject}
+    "refty_" [a-zA-Z0-9]*  -> ID {reject}
+
+  lexical restrictions
+    MetaTypeVar -/- [a-zA-Z0-9\_\$\']
+
+  %%%
+   %% Quotation for Types
+   %%%
+  context-free syntax
+            "t" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+           "ty" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+
+    "java:type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+         "type" "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+    "java"      "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+                "|[" Type "]|"   -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti-Quotation for Types
+   %%%
+  context-free syntax
+    "~"       E -> Type {cons("FromMetaExpr")}
+    "~type:"  E -> Type {cons("FromMetaExpr")}
+
+%%%
+ %% Names
+ %%%
+exports
+
+  %%%
+   %% Variables for Names
+   %%%
+  variables
+    "ambname"  [0-9]*        -> AmbName    {prefer}
+    "ambname_" [a-zA-Z0-9]*  -> AmbName    {prefer}
+    "ename"    [0-9]*        -> ExprName   {prefer}
+    "ename_" [a-zA-Z0-9]*    -> ExprName   {prefer}
+    "fname"    [0-9]*        -> MethodName {prefer}
+    "fname_" [a-zA-Z0-9]*    -> MethodName {prefer}
+    "tname"    [0-9]*        -> TypeName   {prefer}
+    "tname_" [a-zA-Z0-9]*    -> TypeName   {prefer}
+    "pkgtname" [0-9]*        -> PackageOrTypeName  {prefer}
+    "pkgtname_" [a-zA-Z0-9]* -> PackageOrTypeName  {prefer}
+    "pkgname" [0-9]*         -> PackageName  {prefer}
+    "pkgname_" [a-zA-Z0-9]*  -> PackageName  {prefer}
+
+  %%%
+   %% Quotations for Names
+   %%%
+  context-free syntax
+    "ambname"  "|[" AmbName    "]|" -> E {cons("ToMetaExpr")}
+    "ename"    "|[" ExprName   "]|" -> E {cons("ToMetaExpr")}
+    "fname"    "|[" MethodName "]|" -> E {cons("ToMetaExpr")}
+    "tname"    "|[" TypeName   "]|" -> E {cons("ToMetaExpr")}
+    "pkgtname" "|[" PackageOrTypeName "]|" -> E {cons("ToMetaExpr")}
+
+%%%
+ %% Modifiers
+ %%%
+exports
+
+  %%%
+   %% Variables for Modifiers
+   %%%
+  variables
+     "mod" [0-9]*            -> MethodMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> MethodMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | MethodMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | MethodMod)* {prefer}
+     
+     "mod" [0-9]*            -> ClassMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> ClassMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | ClassMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ClassMod)* {prefer}
+     
+     "mod" [0-9]*            -> ConstrMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> ConstrMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | ConstrMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | ConstrMod)* {prefer}
+     
+     "mod" [0-9]*            -> VarMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> VarMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | VarMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | VarMod)* {prefer}
+
+     "mod" [0-9]*            -> FieldMod  {prefer}
+     "mod_" [a-zA-Z0-9]*     -> FieldMod  {prefer}
+     "mod" [0-9]* "*"        -> (Anno | FieldMod)* {prefer}
+     "mod_" [a-zA-Z0-9]* "*" -> (Anno | FieldMod)* {prefer}
+
+  %%%
+   %% Quotations for Modifiers
+   %%%
+  context-free syntax
+           "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
+    "mod"  "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
+
+    "anno" "|[" Anno "]|" -> E {cons("ToMetaExpr")}
+
+
+%%%
+ %% Formal Parameters
+ %%%
+exports
+
+  %%%
+   %% Variables for Formal Parameters
+   %%%
+  variables
+     "param" [0-9]*            -> FormalParam  {prefer}
+     "param_" [a-zA-Z0-9]*     -> FormalParam  {prefer}
+     "param" [0-9]* "*"        -> {FormalParam ","}*  {prefer}
+     "param_" [a-zA-Z0-9]* "*" -> {FormalParam ","}* {prefer}
+
+  %%%
+   %% Quotations for Formal Parameters
+   %%%
+  context-free syntax
+
+         "param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+    "java:param"  "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+
+         "param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+    "java:param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+
+    "java:formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+         "formal-param" "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+    "java"              "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+                        "|[" FormalParam "]|" -> E {cons("ToMetaExpr")}
+
+    "java:formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+         "formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+    "java"               "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+                         "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti Quotations for Formal Parameters
+   %%%
+  context-free syntax
+    "~"  E  ->  FormalParam       {cons("FromMetaExpr")}
+    "~*" E  -> {FormalParam ","}* {cons("FromMetaExpr")}
+
+%%%
+ %% Package Declarations
+ %%%
+exports
+
+  %%%
+   %% Quotations
+   %%%
+  context-free syntax
+    "java:package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
+         "package-dec" "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
+                       "|[" PackageDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
+         "package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
+
+  %%%
+   %% Anti Quotations
+   %%%
+  context-free syntax
+    "~package-dec:"  E -> PackageDec {cons("FromMetaExpr")}
+    "~package-dec?:" E -> PackageDec? {cons("FromMetaExpr")}
+
+%%%
+ %% Import Declarations
+ %%%
+exports
+
+  %%%
+   %% Quotations for Import Declarations
+   %%%
+  context-free syntax
+
+    "java:import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
+         "import-dec"  "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
+                       "|[" ImportDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
+         "import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
+
+  %%%
+   %% Anti Quotations for Import Declarations
+   %%%
+  context-free syntax
+
+    "~import-dec:"  E  -> ImportDec  {cons("FromMetaExpr")}
+    "~import-dec*:" E  -> ImportDec* {cons("FromMetaExpr")}
+
+%%%
+ %% Must be cleaned up
+ %%%
+exports
+  context-free syntax
+            "e" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+         "expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "java"      "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+                "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+
+    "java:compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+         "compilation-unit" "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+    "java"                  "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+                            "|[" CompilationUnit "]|"  -> E {cons("ToMetaExpr")}
+
+    "java:importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
+         "importdecl" "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
+    "java"            "|[" ImportDec "]|"  -> E {cons("ToMetaExpr")}
+
+    "java:type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+         "type-dec" "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+    "java"          "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+                    "|[" TypeDec "]|" -> E {cons("ToMetaExpr")}
+
+    "java:class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+         "class-body-dec" "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+    "java"                "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+                          "|["  ClassBodyDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}
+         "interface-member-dec" "|[" InterfaceMemberDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}
+         "constant-dec" "|[" ConstantDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
+         "class-body-dec*" "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
+    "java"                 "|[" ClassBodyDec* "]|" -> E {cons("ToMetaExpr")}
+                           "|[" ClassBodyDec* "]|" -> E {cons("ToMetaListExpr")}
+
+    "java:stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}
+         "stm" "|["  Stm "]|" -> E {cons("ToMetaExpr")}
+
+    "java:imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+         "imember-dec" "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+    "java"             "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+                       "|["  AbstractMethodDec  "]|" -> E {cons("ToMetaExpr")}
+
+    "java:imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+         "imember-dec*" "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+    "java"              "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+                        "|["  AbstractMethodDec*  "]|" -> E {cons("ToMetaExpr")}
+
+  %% Anti-quotation
+  context-free syntax
+
+    "~"      E -> Name {cons("FromMetaExpr")}
+    "~name:" E -> Name {cons("FromMetaExpr")}
+    "~*:"    E -> Name {cons("FromMetaExpr")}
+
+    "~"     E     -> Id   {cons("FromMetaExpr")}
+    "~id:"  E     -> Id   {cons("FromMetaExpr")}
+    "~idd:" E ":" -> Id   {cons("FromMetaExpr")}
+
+    "~x:" E -> ID {cons("FromMetaExpr")}
+
+    "~"  E -> TypeParam        {cons("FromMetaExpr")}
+    "~*" E -> {TypeParam ","}+ {cons("FromMetaExpr")}
+
+    "~*" E -> {ExceptionType ","}* {cons("FromMetaExpr")}
+
+    "~"      E  ->  Expr {cons("FromMetaExpr")}
+    "~e:"    E  ->  Expr {prefer, cons("FromMetaExpr")}
+    "~expr:" E  ->  Expr {prefer, cons("FromMetaExpr")}
+
+    "~*" E      -> {Expr ","}*    {cons("FromMetaExpr")}
+    "~*" E      -> {VarInit ","}* {cons("FromMetaExpr")}
+
+    "~"  E  -> TypeDec  {cons("FromMetaExpr")}
+    "~*" E  -> TypeDec* {cons("FromMetaExpr")}
+
+    "~"  E  -> ClassBodyDec  {cons("FromMetaExpr")}
+    "~*" E  -> ClassBodyDec* {cons("FromMetaExpr")}
+
+    "~"  E  -> InterfaceMemberDec  {cons("FromMetaExpr")}
+    "~*" E  -> InterfaceMemberDec* {cons("FromMetaExpr")}
+
+    "~i:"      E -> DeciLiteral   {cons("FromMetaExpr")}
+    "~deci:"   E -> DeciLiteral   {cons("FromMetaExpr")}
+    "~hexa:"   E -> HexaLiteral   {cons("FromMetaExpr")}
+    "~octa:"   E -> OctaLiteral   {cons("FromMetaExpr")}
+    "~float:"  E -> FloatLiteral  {cons("FromMetaExpr")}
+    "~string:" E -> StringLiteral {cons("FromMetaExpr")}
+    "~char:"   E -> CharLiteral   {cons("FromMetaExpr")}
+
+  syntax
+    "~" <E-CF> -> StringChars {cons("FromMetaExpr"), prefer}
+    "~" <E-CF> <LAYOUT?-CF> -> SingleChar  {cons("FromMetaExpr"), prefer}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/EmbeddedJavaMix.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/EmbeddedJavaMix.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,155 @@
+module languages/java/EmbeddedJavaMix[Ctx0 E]
+imports languages/java/EmbeddedJava[E]
+          [ Name                  => Name[[Ctx0]]
+            MetaRefTypeVar        => MetaRefTypeVar[[Ctx0]]
+            MetaPrimTypeVar       => MetaPrimTypeVar[[Ctx0]]
+            MetaTypeVar           => MetaTypeVar[[Ctx0]]
+            CompilationUnit       => CompilationUnit[[Ctx0]]
+            TypeDec               => TypeDec[[Ctx0]]
+            ImportDec             => ImportDec[[Ctx0]]
+            PackageDec            => PackageDec[[Ctx0]]
+            ElemVal               => ElemVal[[Ctx0]]
+            ElemValPair           => ElemValPair[[Ctx0]]
+            Anno                  => Anno[[Ctx0]]
+            LHS                   => LHS[[Ctx0]]
+            CondMid               => CondMid[[Ctx0]]
+            ArraySubscript        => ArraySubscript[[Ctx0]]
+            DimExpr               => DimExpr[[Ctx0]]
+            ArrayBaseType         => ArrayBaseType[[Ctx0]]
+            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
+            ClassMemberDec        => ClassMemberDec[[Ctx0]]
+            ClassBodyDec          => ClassBodyDec[[Ctx0]]
+            Interfaces            => Interfaces[[Ctx0]]
+            Super                 => Super[[Ctx0]]
+            ClassMod              => ClassMod[[Ctx0]]
+            ClassDecHead          => ClassDecHead[[Ctx0]]
+            ClassBody             => ClassBody[[Ctx0]]
+            ClassDec              => ClassDec[[Ctx0]]
+            InterfaceMod          => InterfaceMod[[Ctx0]]
+            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
+            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
+            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
+            InterfaceDec          => InterfaceDec[[Ctx0]]
+            DefaultVal            => DefaultVal[[Ctx0]]
+            AnnoElemDec           => AnnoElemDec[[Ctx0]]
+            AnnoDecHead           => AnnoDecHead[[Ctx0]]
+            AnnoDec               => AnnoDec[[Ctx0]]
+            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
+            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
+            ConstantMod           => ConstantMod[[Ctx0]]
+            ConstantDec           => ConstantDec[[Ctx0]]
+            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
+            EnumConstArgs         => EnumConstArgs[[Ctx0]]
+            EnumConst             => EnumConst[[Ctx0]]
+            EnumBody              => EnumBody[[Ctx0]]
+            EnumDecHead           => EnumDecHead[[Ctx0]]
+            EnumDec               => EnumDec[[Ctx0]]
+            ConstrMod             => ConstrMod[[Ctx0]]
+            ConstrInv             => ConstrInv[[Ctx0]]
+            ConstrBody            => ConstrBody[[Ctx0]]
+            ConstrHead            => ConstrHead[[Ctx0]]
+            ConstrDec             => ConstrDec[[Ctx0]]
+            StaticInit            => StaticInit[[Ctx0]]
+            InstanceInit          => InstanceInit[[Ctx0]]
+            MethodBody            => MethodBody[[Ctx0]]
+            ExceptionType         => ExceptionType[[Ctx0]]
+            Throws                => Throws[[Ctx0]]
+            MethodMod             => MethodMod[[Ctx0]]
+            VarMod                => VarMod[[Ctx0]]
+            FormalParam           => FormalParam[[Ctx0]]
+            ResultType            => ResultType[[Ctx0]]
+            MethodDecHead         => MethodDecHead[[Ctx0]]
+            MethodDec             => MethodDec[[Ctx0]]
+            BlockStm              => BlockStm[[Ctx0]]
+            Block                 => Block[[Ctx0]]
+            CatchClause           => CatchClause[[Ctx0]]
+            SwitchLabel           => SwitchLabel[[Ctx0]]
+            SwitchGroup           => SwitchGroup[[Ctx0]]
+            SwitchBlock           => SwitchBlock[[Ctx0]]
+            Stm                   => Stm[[Ctx0]]
+            LocalVarDec           => LocalVarDec[[Ctx0]]
+            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
+            FieldMod              => FieldMod[[Ctx0]]
+            VarInit               => VarInit[[Ctx0]]
+            Dim                   => Dim[[Ctx0]]
+            VarDecId              => VarDecId[[Ctx0]]
+            VarDec                => VarDec[[Ctx0]]
+            FieldDec              => FieldDec[[Ctx0]]
+            ArrayInit             => ArrayInit[[Ctx0]]
+            ClassLiteral          => ClassLiteral[[Ctx0]]
+            Literal               => Literal[[Ctx0]]
+            Type                  => Type[[Ctx0]]
+            ArrayType             => ArrayType[[Ctx0]]
+            TypeVar               => TypeVar[[Ctx0]]
+            TypeDecSpec           => TypeDecSpec[[Ctx0]]
+            InterfaceType         => InterfaceType[[Ctx0]]
+            ClassType             => ClassType[[Ctx0]]
+            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
+            RefType               => RefType[[Ctx0]]
+            TypeVarId             => TypeVarId[[Ctx0]]
+            TypeParams            => TypeParams[[Ctx0]]
+            TypeBound             => TypeBound[[Ctx0]]
+            TypeParam             => TypeParam[[Ctx0]]
+            WildcardBound         => WildcardBound[[Ctx0]]
+            ActualTypeArg         => ActualTypeArg[[Ctx0]]
+            TypeArgs              => TypeArgs[[Ctx0]]
+            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
+            MethodName            => MethodName[[Ctx0]]
+            ExprName              => ExprName[[Ctx0]]
+            TypeName              => TypeName[[Ctx0]]
+            AmbName               => AmbName[[Ctx0]]
+            PackageName           => PackageName[[Ctx0]]
+            FloatType             => FloatType[[Ctx0]]
+            IntType               => IntType[[Ctx0]]
+            NumType               => NumType[[Ctx0]]
+            PrimType              => PrimType[[Ctx0]]
+            NullLiteral           => NullLiteral[[Ctx0]]
+            FooStringChars        => FooStringChars[[Ctx0]]
+            StringChars           => StringChars[[Ctx0]]
+            StringPart            => StringPart[[Ctx0]]
+            StringLiteral         => StringLiteral[[Ctx0]]
+            SingleChar            => SingleChar[[Ctx0]]
+            CharContent           => CharContent[[Ctx0]]
+            CharLiteral           => CharLiteral[[Ctx0]]
+            LastOcta              => LastOcta[[Ctx0]]
+            OctaEscape            => OctaEscape[[Ctx0]]
+            NamedEscape           => NamedEscape[[Ctx0]]
+            EscapeSeq             => EscapeSeq[[Ctx0]]
+            Bool                  => Bool[[Ctx0]]
+            BoolLiteral           => BoolLiteral[[Ctx0]]
+            BinaryExponent        => BinaryExponent[[Ctx0]]
+            HexaSignificand       => HexaSignificand[[Ctx0]]
+            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
+            SignedInteger         => SignedInteger[[Ctx0]]
+            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
+            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
+            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
+            FloatLiteral          => FloatLiteral[[Ctx0]]
+            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
+            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
+            IntLiteral            => IntLiteral[[Ctx0]]
+            OctaNumeral           => OctaNumeral[[Ctx0]]
+            HexaNumeral           => HexaNumeral[[Ctx0]]
+            DeciNumeral           => DeciNumeral[[Ctx0]]
+            OctaLiteral           => OctaLiteral[[Ctx0]]
+            HexaLiteral           => HexaLiteral[[Ctx0]]
+            DeciLiteral           => DeciLiteral[[Ctx0]]
+            Modifier              => Modifier[[Ctx0]]
+            StrictFP              => StrictFP[[Ctx0]]
+            Synchronized          => Synchronized[[Ctx0]]
+            Volatile              => Volatile[[Ctx0]]
+            Transient             => Transient[[Ctx0]]
+            Native                => Native[[Ctx0]]
+            Static                => Static[[Ctx0]]
+            Final                 => Final[[Ctx0]]
+            Abstract              => Abstract[[Ctx0]]
+            Protected             => Protected[[Ctx0]]
+            Private               => Private[[Ctx0]]
+            Public                => Public[[Ctx0]]
+            Id                    => Id[[Ctx0]]
+            ID                    => ID[[Ctx0]]
+            Keyword               => Keyword[[Ctx0]]
+            ArrayAccess           => ArrayAccess[[Ctx0]]
+            FieldAccess           => FieldAccess[[Ctx0]]
+            MethodSpec            => MethodSpec[[Ctx0]]
+            Expr                  => Expr[[Ctx0]] ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/ConcatIds.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/ConcatIds.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,7 @@
+module languages/java/eblock/ConcatIds
+imports
+  languages/java-15/Main
+   
+exports
+  context-free syntax
+  	{ ID "#" }+ -> ID {cons("ConcatIds")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/JavaEBlockMix.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/JavaEBlockMix.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,151 @@
+module languages/java/eblock/JavaEBlockMix[Ctx0]
+imports languages/java/eblock/Main
+          [ CompilationUnit       => CompilationUnit[[Ctx0]]
+            TypeDec               => TypeDec[[Ctx0]]
+            ImportDec             => ImportDec[[Ctx0]]
+            PackageDec            => PackageDec[[Ctx0]]
+            ElemVal               => ElemVal[[Ctx0]]
+            ElemValPair           => ElemValPair[[Ctx0]]
+            Anno                  => Anno[[Ctx0]]
+            LHS                   => LHS[[Ctx0]]
+            CondMid               => CondMid[[Ctx0]]
+            ArraySubscript        => ArraySubscript[[Ctx0]]
+            DimExpr               => DimExpr[[Ctx0]]
+            ArrayBaseType         => ArrayBaseType[[Ctx0]]
+            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
+            ClassMemberDec        => ClassMemberDec[[Ctx0]]
+            ClassBodyDec          => ClassBodyDec[[Ctx0]]
+            Interfaces            => Interfaces[[Ctx0]]
+            Super                 => Super[[Ctx0]]
+            ClassMod              => ClassMod[[Ctx0]]
+            ClassDecHead          => ClassDecHead[[Ctx0]]
+            ClassBody             => ClassBody[[Ctx0]]
+            ClassDec              => ClassDec[[Ctx0]]
+            InterfaceMod          => InterfaceMod[[Ctx0]]
+            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
+            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
+            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
+            InterfaceDec          => InterfaceDec[[Ctx0]]
+            DefaultVal            => DefaultVal[[Ctx0]]
+            AnnoElemDec           => AnnoElemDec[[Ctx0]]
+            AnnoDecHead           => AnnoDecHead[[Ctx0]]
+            AnnoDec               => AnnoDec[[Ctx0]]
+            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
+            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
+            ConstantMod           => ConstantMod[[Ctx0]]
+            ConstantDec           => ConstantDec[[Ctx0]]
+            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
+            EnumConstArgs         => EnumConstArgs[[Ctx0]]
+            EnumConst             => EnumConst[[Ctx0]]
+            EnumBody              => EnumBody[[Ctx0]]
+            EnumDecHead           => EnumDecHead[[Ctx0]]
+            EnumDec               => EnumDec[[Ctx0]]
+            ConstrMod             => ConstrMod[[Ctx0]]
+            ConstrInv             => ConstrInv[[Ctx0]]
+            ConstrBody            => ConstrBody[[Ctx0]]
+            ConstrHead            => ConstrHead[[Ctx0]]
+            ConstrDec             => ConstrDec[[Ctx0]]
+            StaticInit            => StaticInit[[Ctx0]]
+            InstanceInit          => InstanceInit[[Ctx0]]
+            MethodBody            => MethodBody[[Ctx0]]
+            ExceptionType         => ExceptionType[[Ctx0]]
+            Throws                => Throws[[Ctx0]]
+            MethodMod             => MethodMod[[Ctx0]]
+            VarMod                => VarMod[[Ctx0]]
+            FormalParam           => FormalParam[[Ctx0]]
+            ResultType            => ResultType[[Ctx0]]
+            MethodDecHead         => MethodDecHead[[Ctx0]]
+            MethodDec             => MethodDec[[Ctx0]]
+            BlockStm              => BlockStm[[Ctx0]]
+            Block                 => Block[[Ctx0]]
+            CatchClause           => CatchClause[[Ctx0]]
+            SwitchLabel           => SwitchLabel[[Ctx0]]
+            SwitchGroup           => SwitchGroup[[Ctx0]]
+            SwitchBlock           => SwitchBlock[[Ctx0]]
+            Stm                   => Stm[[Ctx0]]
+            LocalVarDec           => LocalVarDec[[Ctx0]]
+            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
+            FieldMod              => FieldMod[[Ctx0]]
+            VarInit               => VarInit[[Ctx0]]
+            Dim                   => Dim[[Ctx0]]
+            VarDecId              => VarDecId[[Ctx0]]
+            VarDec                => VarDec[[Ctx0]]
+            FieldDec              => FieldDec[[Ctx0]]
+            ArrayInit             => ArrayInit[[Ctx0]]
+            ClassLiteral          => ClassLiteral[[Ctx0]]
+            Literal               => Literal[[Ctx0]]
+            Type                  => Type[[Ctx0]]
+            ArrayType             => ArrayType[[Ctx0]]
+            TypeVar               => TypeVar[[Ctx0]]
+            TypeDecSpec           => TypeDecSpec[[Ctx0]]
+            InterfaceType         => InterfaceType[[Ctx0]]
+            ClassType             => ClassType[[Ctx0]]
+            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
+            RefType               => RefType[[Ctx0]]
+            TypeVarId             => TypeVarId[[Ctx0]]
+            TypeParams            => TypeParams[[Ctx0]]
+            TypeBound             => TypeBound[[Ctx0]]
+            TypeParam             => TypeParam[[Ctx0]]
+            WildcardBound         => WildcardBound[[Ctx0]]
+            ActualTypeArg         => ActualTypeArg[[Ctx0]]
+            TypeArgs              => TypeArgs[[Ctx0]]
+            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
+            MethodName            => MethodName[[Ctx0]]
+            ExprName              => ExprName[[Ctx0]]
+            TypeName              => TypeName[[Ctx0]]
+            AmbName               => AmbName[[Ctx0]]
+            PackageName           => PackageName[[Ctx0]]
+            FloatType             => FloatType[[Ctx0]]
+            IntType               => IntType[[Ctx0]]
+            NumType               => NumType[[Ctx0]]
+            PrimType              => PrimType[[Ctx0]]
+            NullLiteral           => NullLiteral[[Ctx0]]
+            FooStringChars        => FooStringChars[[Ctx0]]
+            StringChars           => StringChars[[Ctx0]]
+            StringPart            => StringPart[[Ctx0]]
+            StringLiteral         => StringLiteral[[Ctx0]]
+            SingleChar            => SingleChar[[Ctx0]]
+            CharContent           => CharContent[[Ctx0]]
+            CharLiteral           => CharLiteral[[Ctx0]]
+            LastOcta              => LastOcta[[Ctx0]]
+            OctaEscape            => OctaEscape[[Ctx0]]
+            NamedEscape           => NamedEscape[[Ctx0]]
+            EscapeSeq             => EscapeSeq[[Ctx0]]
+            Bool                  => Bool[[Ctx0]]
+            BoolLiteral           => BoolLiteral[[Ctx0]]
+            BinaryExponent        => BinaryExponent[[Ctx0]]
+            HexaSignificand       => HexaSignificand[[Ctx0]]
+            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
+            SignedInteger         => SignedInteger[[Ctx0]]
+            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
+            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
+            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
+            FloatLiteral          => FloatLiteral[[Ctx0]]
+            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
+            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
+            IntLiteral            => IntLiteral[[Ctx0]]
+            OctaNumeral           => OctaNumeral[[Ctx0]]
+            HexaNumeral           => HexaNumeral[[Ctx0]]
+            DeciNumeral           => DeciNumeral[[Ctx0]]
+            OctaLiteral           => OctaLiteral[[Ctx0]]
+            HexaLiteral           => HexaLiteral[[Ctx0]]
+            DeciLiteral           => DeciLiteral[[Ctx0]]
+            Modifier              => Modifier[[Ctx0]]
+            StrictFP              => StrictFP[[Ctx0]]
+            Synchronized          => Synchronized[[Ctx0]]
+            Volatile              => Volatile[[Ctx0]]
+            Transient             => Transient[[Ctx0]]
+            Native                => Native[[Ctx0]]
+            Static                => Static[[Ctx0]]
+            Final                 => Final[[Ctx0]]
+            Abstract              => Abstract[[Ctx0]]
+            Protected             => Protected[[Ctx0]]
+            Private               => Private[[Ctx0]]
+            Public                => Public[[Ctx0]]
+            Id                    => Id[[Ctx0]]
+            ID                    => ID[[Ctx0]]
+            Keyword               => Keyword[[Ctx0]]
+            ArrayAccess           => ArrayAccess[[Ctx0]]
+            FieldAccess           => FieldAccess[[Ctx0]]
+            MethodSpec            => MethodSpec[[Ctx0]]
+            Expr                  => Expr[[Ctx0]] ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/Main.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/java-front/syntax/languages/java/eblock/Main.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,12 @@
+module languages/java/eblock/Main
+imports
+  languages/java-15/Main
+  languages/java/eblock/ConcatIds
+   
+exports
+  context-free syntax
+    "{|" BlockStm* "|" Expr "|}" -> Expr {cons("PreEBlock")}
+    "{|" Expr "|" BlockStm* "|}" -> Expr {cons("PostEBlock")}
+    "{|" BlockStm* "|}"          -> BlockStm {cons("InnerBlock")}
+
+    "{|" BlockStm* "|" Expr "|" BlockStm* "|}" -> Expr {cons("PrePostEBlock")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/make_permissive.jar
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/pgen/Sdf2.baf
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/sdf-front/trans/Sdf2.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/sdf-front/trans/Sdf2.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,156 @@
+module Sdf2
+
+signature
+  constructors
+    definition                 : Definition -> SDF
+                               : List(Alias) -> Aliases
+    alias                      : Symbol * Symbol -> Alias
+                               : List(Restriction) -> Restrictions
+    follow                     : Symbols * Lookaheads -> Restriction
+    list                       : List(Lookahead) -> Lookaheads
+    alt                        : Lookaheads * Lookaheads -> Lookaheads
+    single                     : Lookahead -> Lookaheads
+    seq                        : CharClass * Lookaheads -> Lookahead
+    char-class                 : CharClass -> Lookahead
+    unquoted                   : IdCon -> Label
+    quoted                     : StrCon -> Label
+    quoted-fun                 : StrCon -> FunctionName
+    unquoted-fun               : IdCon -> FunctionName
+                               : String -> SingleQuotedStrCon
+                               : String -> Sort
+    union                      : CharClass * CharClass -> CharClass
+    isect                      : CharClass * CharClass -> CharClass
+    diff                       : CharClass * CharClass -> CharClass
+    comp                       : CharClass -> CharClass
+    simple-charclass           : OptCharRanges -> CharClass
+    present                    : CharRanges -> OptCharRanges
+    absent                     : OptCharRanges
+    conc                       : CharRanges * CharRanges -> CharRanges
+                               : CharRange -> CharRanges
+    range                      : Character * Character -> CharRange
+                               : Character -> CharRange
+    label_start                : Character
+    bot                        : Character
+    eof                        : Character
+    top                        : Character
+    short                      : ShortChar -> Character
+    numeric                    : NumChar -> Character
+                               : String -> ShortChar
+                               : String -> NumChar
+                               : List(Priority) -> Priorities
+    assoc                      : Group * Associativity * Group -> Priority
+    chain                      : List(Group) -> Priority
+    assoc-group                : Associativity * Productions -> Group
+    prods-group                : Productions -> Group
+    simple-group               : Production -> Group
+    non-transitive             : Group -> Group
+    with-arguments             : Group * ArgumentIndicator -> Group
+    default                    : List(NatCon) -> ArgumentIndicator
+    assoc                      : Associativity
+    non-assoc                  : Associativity
+    right                      : Associativity
+    left                       : Associativity
+    renamed-module             : ModuleName * Renamings -> Import
+    'module                    : ModuleName -> Import
+                               : List(Import) -> Imports
+    imports                    : Imports -> ImpSection
+    parameterized              : ModuleId * Symbols -> ModuleName
+    unparameterized            : ModuleId -> ModuleName
+                               : List(Section) -> Sections
+    hiddens                    : Grammar -> Section
+    exports                    : Grammar -> Section
+    'module                    : ModuleName * List(ImpSection) * Sections -> Module
+                               : List(Module) -> Definition
+                               : String -> ModuleId
+    production                 : Production * Production -> Renaming
+    symbol                     : Symbol * Symbol -> Renaming
+    renamings                  : List(Renaming) -> Renamings
+    file-start                 : Symbol
+    start                      : Symbol
+    label                      : Label * Symbol -> Symbol
+    ci-lit                     : SingleQuotedStrCon -> Symbol
+    lit                        : StrCon -> Symbol
+    parameterized-sort         : Sort * List(Symbol) -> Symbol
+    sort                       : Sort -> Symbol
+    char-class                 : CharClass -> Symbol
+    lifting                    : Symbol -> Symbol
+    strategy                   : Symbol * Symbol -> Symbol
+    alt                        : Symbol * Symbol -> Symbol
+    func                       : Symbols * Symbol -> Symbol
+    tuple                      : Symbol * List(Symbol) -> Symbol
+    iter-star-sep              : Symbol * Symbol -> Symbol
+    iter-sep                   : Symbol * Symbol -> Symbol
+    iter-star                  : Symbol -> Symbol
+    iter                       : Symbol -> Symbol
+    opt                        : Symbol -> Symbol
+    seq                        : Symbol * List(Symbol) -> Symbol
+    empty                      : Symbol
+    layout                     : Symbol
+    varsym                     : Symbol -> Symbol
+    lex                        : Symbol -> Symbol
+    cf                         : Symbol -> Symbol
+                               : List(Production) -> Productions
+    prefix-fun                 : FunctionName * List(Symbol) * Symbol * Attributes -> Production
+    prod                       : Symbols * Symbol * Attributes -> Production
+    no-attrs                   : Attributes
+    attrs                      : List(Attribute) -> Attributes
+    avoid                      : Attribute
+    prefer                     : Attribute
+    reject                     : Attribute
+    assoc                      : Associativity -> Attribute
+    bracket                    : Attribute
+    'id                        : ModuleName -> Attribute
+    term                       : ATermAttribute -> Attribute
+    default                    : ATerm -> ATermAttribute
+    context-free-restrictions  : Restrictions -> Grammar
+    lexical-restrictions       : Restrictions -> Grammar
+    context-free-priorities    : Priorities -> Grammar
+    lexical-priorities         : Priorities -> Grammar
+    aliases                    : Aliases -> Grammar
+    restrictions               : Restrictions -> Grammar
+    context-free-start-symbols : Symbols -> Grammar
+    lexical-start-symbols      : Symbols -> Grammar
+    kernel-start-symbols       : Symbols -> Grammar
+    'sorts                     : Symbols -> Grammar
+    priorities                 : Priorities -> Grammar
+    imp-section                : ImpSection -> Grammar
+    lexical-variables          : Productions -> Grammar
+    variables                  : Productions -> Grammar
+    context-free-syntax        : Productions -> Grammar
+    lexical-syntax             : Productions -> Grammar
+    syntax                     : Productions -> Grammar
+    conc-grammars              : Grammar * Grammar -> Grammar
+    empty-grammar              : Grammar
+                               : List(Symbol) -> Symbols
+    default                    : List(ATerm) -> Annotation
+    annotated                  : ATerm * Annotation -> ATerm
+    list                       : List(ATerm) -> ATerm
+    placeholder                : ATerm -> ATerm
+    appl                       : AFun * List(ATerm) -> ATerm
+    fun                        : AFun -> ATerm
+    real                       : RealCon -> ATerm
+    int                        : IntCon -> ATerm
+    unquoted                   : IdCon -> AFun
+    quoted                     : StrCon -> AFun
+                               : String -> IdCon
+                               : String -> StrCon
+    real-con                   : IntCon * NatCon * OptExp -> RealCon
+    absent                     : OptExp
+    present                    : IntCon -> OptExp
+    negative                   : NatCon -> IntCon
+    positive                   : NatCon -> IntCon
+    natural                    : NatCon -> IntCon
+                               : String -> NatCon
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/sdf2imp.jar
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/spoofaxgenerator.jar
==============================================================================
Binary file. No diff available.

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/pp/Stratego-Sugar-pretty.pp.af
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/pp/Stratego-Sugar-pretty.pp.af	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+PP-Table([PP-Entry(Path1("Comment"),[H([],[Arg("1"),S("\"/*\""),Arg("2"),S("\"*/\"")])]),PP-Entry(Path("Comment",[selector("2","iter-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("Env"),[H([SOpt(HS,"0")],[S("\"{\""),H([],[Arg("1")]),S("\"}\"")])]),PP-Entry(Path("Env",[selector("1","iter-sep")]),[H([SOpt(HS,"0")],[Arg("1"),S("\",\"")])]),PP-Entry(Path1("Assign"),[H([],[Arg("1"),FBOX(KW,S("\":=\"")),Arg("2")])]),PP-Entry(Path1("--saved-entry--TupleCong"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path("--saved-entry--SwitchChoice",[selector("2","iter-star")]),[V([SOpt(IS,"2"),SOpt(VS,"0")],[H([SOpt(HS,"1")],[FBOX(KW,S("\"case\"")),Arg("1"),FBOX(KW,S("\":\""))]),Arg("2")])]),PP-Entry(Path1("--saved-entry--SwitchChoice"),[V([],[V([SOpt(IS,"2"),SOpt(VS,"0")],[H([SOpt(HS,"1")],[FBOX(KW,S("\"switch\"")),Arg("1")]),Arg("2"),V([SOpt(IS,"2"),SOpt(VS,"0")],[H([SOpt(HS,"1")],[FBOX(KW,S("\"otherwise\"")),FBOX(KW,S("\":\""
 ))]),Arg("2")])]),FBOX(KW,S("\"end\""))])]),PP-Entry(Path("--saved-entry--SwitchChoiceNoOtherwise",[selector("2","iter-star")]),[V([SOpt(IS,"2"),SOpt(VS,"0")],[H([SOpt(HS,"1")],[FBOX(KW,S("\"case\"")),Arg("1"),FBOX(KW,S("\":\""))]),Arg("2")])]),PP-Entry(Path1("--saved-entry--BA"),[H([SOpt(HS,"1")],[H([SOpt(HS,"0")],[FBOX(KW,S("\"<\"")),Arg("1"),FBOX(KW,S("\">\""))]),Arg("2")])]),PP-Entry(Path1("--saved-entry--Con4"),[FBOX(KW,S("\"[\"")),Arg("1"),FBOX(KW,S("\"where\"")),Arg("2"),FBOX(KW,S("\"]\"")),FBOX(KW,S("\"(\"")),Arg("3"),FBOX(KW,S("\")\""))]),PP-Entry(Path1("--saved-entry--Con3"),[FBOX(KW,S("\"[\"")),Arg("1"),FBOX(KW,S("\"where\"")),Arg("2"),FBOX(KW,S("\"]\""))]),PP-Entry(Path1("--saved-entry--Con1"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"[\"")),Arg("1"),FBOX(KW,S("\"]\""))])]),PP-Entry(Path1("--saved-entry--Anno"),[Arg("1"),FBOX(KW,S("\"{\"")),Arg("2"),FBOX(KW,S("\"}\""))]),PP-Entry(Path1("--saved-entry--RootApp"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"<\"")),Arg("1"),FBOX(KW,S("\">
 \""))])]),PP-Entry(Path1("--saved-entry--OpDeclInj"),[R([],[S("\"\"") r("2","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("CongQ"),[Arg("1"),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\""))]),PP-Entry(Path1("CharCong"),[Arg("1")]),PP-Entry(Path1("\"stratego-0\""),[Arg("1")]),PP-Entry(Path1("Definition"),[V([],[Arg("1")])]),PP-Entry(Path("Definition",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("ImportTerm"),[FBOX(KW,S("\"import-term\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))]),PP-Entry(Path1("Module"),[V([],[H([],[FBOX(KW,S("\"module\"")),Arg("1")]),Arg("2")])]),PP-Entry(Path("Module",[selector("2","iter-star")]),[Arg("1")]),PP-Entry(Path1("Specification"),[V([SOpt(VS,"1"),SOpt(IS,"2")],[H([],[FBOX(KW,S("\"specification\""))]),Arg("1")])]),PP-Entry(Path("Specification",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("Script"),[V([],[H([],[FBOX(KW,S("\"stratego\"")),FBOX(KW,S("\"script\""))]),Arg("1")])]),PP-Entry(Path("Script",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("Command"),[
 Arg("1")]),PP-Entry(Path1("Dump"),[FBOX(KW,S("\":dump\"")),Arg("1")]),PP-Entry(Path1("Load"),[FBOX(KW,S("\":load\"")),Arg("1")]),PP-Entry(Pa ,[Arg("1")]),PP-Entry(Path1("Sorts"),[V([],[H([],[FBOX(KW,S("\"sorts\""))]),Arg("1")])]),PP-Entry(Path("Sorts",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("Constructors"),[V([SOpt(IS,"2")],[H([],[FBOX(KW,S("\"constructors\""))]),A(AOPTIONS([AL([SOpt(HS,"1")]),AL([SOpt(HS,"1")]),AL([SOpt(HS,"1")])]),[],[Arg("1")])])]),PP-Entry(Path("Constructors",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("SortVar"),[Arg("1")]),PP-Entry(Path1("SortNoArgs"),[Arg("1")]),PP-Entry(Path1("Sort"),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\""))])]),PP-Entry(Path("Sort",[selector("2","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("SortList"),[FBOX(KW,S("\"[\"")),Arg("1"),FBOX(KW,S("\"]\""))]),PP-Entry(Path("SortList",[selector("1","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("SortListTl"),[FBOX(KW,S("\"[\"")),Arg("1"),FBOX(KW,S("\"|\"")),Arg("2"),FBOX(KW,S("\"]\""))]),PP-Entry(Path("SortListTl",[selector("1"
 ,"iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("SortTuple"),[FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))]),PP-Entry(Path("SortTuple",[selector("1","iter-star-sep")]),[Arg("1"),FBOX(KW,S( Path1("FunType"),[Arg("1"),FBOX(KW,S("\"->\"")),Arg("2")]),PP-Entry(Path("FunType",[selector("1","iter-sep")]),[Arg("1"),FBOX(KW,S("\"*\""))]),PP-Entry(Path1("Var"),[Arg("1")]),PP-Entry(Path1("ListVar"),[Arg("1")]),PP-Entry(Path1("SeqVar"),[H([SOpt(HS,"0")],[FBOX(KW,S("\":\"")),Arg("1")])]),PP-Entry(Path1("Int"),[Arg("1")]),PP-Entry(Path1("Real"),[Arg("1")]),PP-Entry(Path1("Str"),[Arg("1")]),PP-Entry(Path1("Char"),[Arg("1")]),PP-Entry(Path1("Wld"),[FBOX(KW,S("\"_\""))]),PP-Entry(Path1("BuildDefault"),[FBOX(KW,S("\"_\"")),Arg("1")]),PP-Entry(Path1("BuildDefaultPT"),[FBOX(KW,S("\"_\"")),Arg("1")]),PP-Entry(Path1("Inj"),[Arg("1")]),PP-Entry(Path1("Op"),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2")]),FBOX(KW,S("\")\""))])]),PP-Entry(Path("Op",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("As"),[Arg("1"),FBOX(KW,S("\"@\"")),Arg("2")]),PP-Entry(Path1("Tuple"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"(\"")),H([SOpt(HS,"0
 ")],[Arg("1")]),FBOX(KW,S("\")\""))])]),PP-Entry(Path("Tuple",[selector("1","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("App"),[H([],[H([SOpt(HS,"0")],[FBOX(KW,S("\"<\"")),Arg("1"),FBOX(KW,S("\">\""))]),Arg("2")])]),PP-Entry(Path1("List"),[ \"}\""))]),PP-Entry(Path1("Con"),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"[\"")),Arg("2"),FBOX(KW,S("\"]\"")),FBOX(KW,S("\"(\"")),Arg("3"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("Con1"),[Arg("1"),FBOX(KW,S("\"[\"")),Arg("2"),FBOX(KW,S("\"]\""))]),PP-Entry(Path1("Con2"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"[\"")),Arg("1"),FBOX(KW,S("\"]\"")),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("Con3"),[Arg("1"),FBOX(KW,S("\"[\"")),Arg("2"),FBOX(KW,S("\"where\"")),Arg("3"),FBOX(KW,S("\"]\""))]),PP-Entry(Path1("Con4"),[Arg("1"),FBOX(KW,S("\"[\"")),Arg("2"),FBOX(KW,S("\"where\"")),Arg("3"),FBOX(KW,S("\"]\"")),FBOX(KW,S("\"(\"")),Arg("4"),FBOX(KW,S("\")\""))]),PP-Entry(Path1("RDefNoArgs"),[V([SOpt(IS,"2")],[H([],[Arg("1"),FBOX(KW,S("\":\""))]),Arg("2")])]),PP-Entry(Path1("RDef"),[V([SOpt(IS,"2")],[H([],[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2")]),FBOX(KW,S("\")\""))]),FBOX(KW,S("\":\""))]),Arg("3")])]),PP-Entry(Path("RDef",[selector("2","iter-star-se
 p")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("RDefT"),[V([SOpt(IS,"2")],[H([],[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2"),FBOX(KW,S("\"|\"")),Arg("3")]),FBOX(KW,S("\")\""))]),FBOX(KW,S("\":\""))]),Arg("4")])]),PP-Entry(Path("RDefT",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\" Path("RDecT",[selector("3","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("DynRuleIntersectFix"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"/\"")),Arg("1"),FBOX(KW,S("\"\\\\*\""))]),Arg("2")]),PP-Entry(Path("DynRuleIntersectFix",[selector("1","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("DynRuleUnionFix"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"\\\\\"")),Arg("1"),FBOX(KW,S("\"/*\""))]),Arg("2")]),PP-Entry(Path("DynRuleUnionFix",[selector("1","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("DynRuleIntersect"),[Arg("1"),H([SOpt(HS,"0")],[FBOX(KW,S("\"/\"")),Arg("2"),FBOX(KW,S("\"\\\\\""))]),Arg("3")]),PP-Entry(Path("DynRuleIntersect",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("DynRuleUnion"),[Arg("1"),H([SOpt(HS,"0")],[FBOX(KW,S("\"\\\\\"")),Arg("2"),FBOX(KW,S("\"/\""))]),Arg("3")]),PP-Entry(Path("DynRuleUnion",[selector("2
 ","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("DynRuleIntersectUnion"),[Arg("1"),H([SOpt(HS,"0")],[FBOX(KW,S("\"/\"")),Arg("2"),FBOX(KW,S("\"\\\\\"")),Arg("3"),FBOX(KW,S("\"/\""))]),Arg("4")]),PP-Entry(Path("DynRuleIntersectUnion",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path("DynRuleIntersectUnion",[selector("3","iter-star-sep opeLabels"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"~\"")),Arg("1")])]),PP-Entry(Path1("SetDynRuleDepends"),[H([],[Arg("1"),FBOX(KW,S("\":\"")),Arg("2"),FBOX(KW,S("\"depends\"")),FBOX(KW,S("\"on\"")),Arg("3")])]),PP-Entry(Path1("SRDefNoArgs"),[Arg("1"),FBOX(KW,S("\"::\"")),Arg("2")]),PP-Entry(Path1("SRDef"),[Arg("1"),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\"")),FBOX(KW,S("\"::\"")),Arg("3")]),PP-Entry(Path("SRDef",[selector("2","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("SRDefT"),[Arg("1"),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\"|\"")),Arg("3"),FBOX(KW,S("\")\"")),FBOX(KW,S("\"::\"")),Arg("4")]),PP-Entry(Path("SRDefT",[selector("2","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path("SRDefT",[selector("3","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("RuleNoCond"),[H([SOpt(HS,"1")],[Arg("1"),FBOX(KW,S("\"->\"")),Arg("2")])]),PP-Entry(Path1("Rule"),[V([],[H([SOpt(HS,"1")],[Arg("1"),FBOX(KW,S("\"->\"")),Arg("2")]),Arg("3")]
 )]),PP-Entry(Path1("WhereClause"),[H([],[FBOX(KW,S("\"where\"")),Arg("1")])]),PP-Entry(Path1("WithClause"),[H([],[FBOX(KW,S("\"with\"")),Arg("1")])]),PP-Entry(Path("Rule",[selector("3","iter")]),[Arg("1")]),PP-Entry(Path1("StratRuleNoCond"),[Arg("1"),FBOX(KW,S("\"-->\"")),Arg("2")]),PP-Entry(Path1("StratRule"),[Arg("1"),FBOX(KW,S("\"-->\"")),Arg("2"),FBOX(KW,S("\"where\"")),Arg("3")]),PP-Entry(Path1("Fail"),[FBOX(KW,S("\"fail\""))]),PP-Entry(Path1("Id"),[FBOX(KW,S("\"id\""))]),PP-Entry(Path ")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("CallNoArgs"),[Arg("1")]),PP-Entry(Path1("Call"),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2")]),FBOX(KW,S("\")\""))])]),PP-Entry(Path("Call",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("CallT"),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2"),FBOX(KW,S("\"|\"")),Arg("3")]),FBOX(KW,S("\")\""))])]),PP-Entry(Path("CallT",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path("CallT",[selector("3","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("Match"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"?\"")),Arg("1")])]),PP-Entry(Path1("Build"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"!\"")),Arg("1")])]),PP-Entry(Path1("ScopeDefault"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"{\"")),Arg("1"),FBOX(KW,S("\"}\""))])]),PP-Entry(Path1("Scope"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"{\"")),V([],[H([],[Arg("1
 "),FBOX(KW,S("\":\""))]),Arg("2")]),FBOX(KW,S("\"}\""))])]),PP-Entry(Path("Scope",[selector("1","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("BA"),[Arg("1"),Arg("2")]),PP-Entry(Path1("AM"),[H([],[Arg("1"),FBOX(KW,S("\"=>\"")),Arg("2")])]),PP-Entry(Path1("AngleStrat"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"<\"")),Arg("1"),FBOX(KW,S("\">\""))])]),PP-Entry(Path1("ParenStrat"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("LRule"),[H([],[FBOX(KW,S("\"\\\\\"")),Arg("1"),FBOX(KW,S("\"\\\\\"") Entry(Path1("GChoice"),[V([],[Arg("1"),H([],[FBOX(KW,S("\"++\"")),Arg("2")])])]),PP-Entry(Path1("LGChoice"),[V([],[Arg("1"),H([],[FBOX(KW,S("\"<++\"")),Arg("2")])])]),PP-Entry(Path1("RGChoice"),[V([],[Arg("1"),H([],[FBOX(KW,S("\"++>\"")),Arg("2")])])]),PP-Entry(Path1("GuardedLChoice"),[V([],[Arg("1"),H([],[FBOX(KW,S("\"<\"")),Arg("2")]),H([],[FBOX(KW,S("\"+\"")),Arg("3")])])]),PP-Entry(Path1("CondChoice"),[V([SOpt(VS,"0")],[H([SOpt(HS,"1")],[FBOX(KW,S("\"if\"")),Arg("1")]),H([SOpt(HS,"1")],[FBOX(KW,S("\"then\"")),Arg("2")]),H([SOpt(HS,"1")],[FBOX(KW,S("\"else\"")),Arg("3")]),FBOX(KW,S("\"end\""))])]),PP-Entry(Path1("SwitchChoiceNoOtherwise"),[V([],[V([SOpt(IS,"2"),SOpt(VS,"0")],[H([SOpt(HS,"1")],[FBOX(KW,S("\"switch\"")),Arg("1")]),Arg("2")]),FBOX(KW,S("\"end\""))])]),PP-Entry(Path("SwitchChoiceNoOtherwise",[selector("2","iter-star")]),[Arg("1")]),PP-Entry(Path1("SwitchChoice"),[FBOX(KW,S("\"switch\"")),Arg("1"),Arg("2"),FBOX(KW,S("\"otherwise\"")),FBOX(KW,S("\":\"")),Arg("3
 "),FBOX(KW,S("\"end\""))]),PP-Entry(Path("SwitchChoice",[selector("2","iter-star")]),[Arg("1")]),PP-Entry(Path1("Rec"),[H([],[FBOX(KW,S("\"rec\"")),Arg("1"),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("Not"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"not\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("Where"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"where\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("With"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"with\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("Test"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"test\"")),FBOX(KW, )),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\",\"")),Arg("2"),FBOX(KW,S("\")\""))])]),PP-Entry(Path("Prim",[selector("2","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("PrimT"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"prim\"")),FBOX(KW,S("\"(\"")),Arg("1"),H([],[FBOX(KW,S("\",\"")),Arg("2"),FBOX(KW,S("\"|\"")),Arg("3")]),FBOX(KW,S("\")\""))])]),PP-Entry(Path("PrimT",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path("PrimT",[selector("3","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("Some"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"some\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("One"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"one\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("All"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"all\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("Thread"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"thread\"")),
 FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("StrCong"),[Arg("1")]),PP-Entry(Path1("IntCong"),[Arg("1")]),PP-Entry(Path1("RealCong"),[Arg("1")]),PP-Entry(Path1("EmptyTupleCong"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"(\"")),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("TupleCong"),[FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\",\"")),Arg("2"),FBOX(KW,S("\")\""))]),PP-Entry(Path("TupleCong",[selector("1","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("ModCongNoArgs"),[Arg("1")]),PP-Entry(Path1("ModCong"),[Arg("1"),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\""))]),PP-Entry(Path("ModCong",[selector("2","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("Mod"),[A X(KW,S("\"|\"")),Arg("2"),FBOX(KW,S("\"]\""))]),PP-Entry(Path("ListCong",[selector("1","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("ExplodeCong"),[Arg("1"),FBOX(KW,S("\"#\"")),Arg("2")]),PP-Entry(Path1("GenDynRules"),[V([],[V([SOpt(IS,"2")],[H([],[FBOX(KW,S("\"rules\"")),FBOX(KW,S("\"(\""))]),Arg("1")]),FBOX(KW,S("\")\""))])]),PP-Entry(Path("GenDynRules",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("AddScopeLabel"),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"+\"")),Arg("2")])]),PP-Entry(Path1("UndefineDynRule"),[V([SOpt(IS,"2")],[H([SOpt(HS,"1")],[Arg("1"),FBOX(KW,S("\":-\""))]),Arg("2")])]),PP-Entry(Path1("SetDynRule"),[V([SOpt(IS,"2")],[H([SOpt(HS,"1")],[Arg("1"),FBOX(KW,S("\":\""))]),Arg("2")])]),PP-Entry(Path1("AddDynRule"),[V([SOpt(IS,"2")],[H([SOpt(HS,"1")],[Arg("1"),FBOX(KW,S("\":+\""))]),Arg("2")])]),PP-Entry(Path1("SetDynRuleMatch"),[V([SOpt(IS,"2")],[H([SOpt(HS,"1")],[Arg("1"),FBOX(KW,S("\":\""))]),Arg("2")])]),PP-Entry(Path1("LabeledD
 ynRuleId"),[H([SOpt(HS,"0")],[Arg("1"),S("\".\""),Arg("2")])]),PP-Entry(Path1("AddLabelDynRuleId"),[H([SOpt(HS,"0")],[Arg("1"),S("\"+\""),Arg("2")])]),PP-Entry(Path1("DynRuleId"),[Arg("1")]),PP-Entry(Path1("LabeledDynRuleScopeId"),[H([SOpt(HS,"0")],[Arg("1"),S("\".\""),Arg("2")])]),PP-Entry(Path1("DynRuleScopeId"),[Arg("1")]),PP-Entry(Path1("OverrideDynamicRules"),[FBOX(KW,S("\"override\"")),FBOX(KW,S("\"rules\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))]),PP-Entry(Path("OverrideDynamicRules",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("ExtendDynamicRules"),[V([],[V([SOpt(IS,"2")],[H([],[FBOX(KW,S("\"extend\"")),FBOX(KW,S("\"rules\"")),FBOX(KW,S("\"(\""))]),Arg("1")]),FBOX(KW,S("\")\""))])]),PP-Entry(Path("ExtendDynamicRules",[selector("1","iter-st tendOverrideDynamicRules",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("DynRuleScope"),[V([],[V([SOpt(IS,"3")],[H([SOpt(HS,"0")],[FBOX(KW,S("\"{|\"")),Arg("1"),FBOX(KW,S("\":\""))]),Arg("2")]),FBOX(KW,S("\"|}\""))])]),PP-Entry(Path("DynRuleScope",[selector("1","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("SDefNoArgs"),[V([SOpt(IS,"2")],[H([],[Arg("1"),FBOX(KW,S("\"=\""))]),Arg("2")])]),PP-Entry(Path1("SDef"),[V([SOpt(IS,"2")],[H([],[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2")]),FBOX(KW,S("\")\""))]),FBOX(KW,S("\"=\""))]),Arg("3")])]),PP-Entry(Path("SDef",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("SDefT"),[V([SOpt(IS,"2")],[H([],[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2")])]),FBOX(KW,S("\"|\"")),H([SOpt(HS,"0")],[H([],[Arg("3")]),FBOX(KW,S("\")\""))]),FBOX(KW,S("\"=\""))]),Arg("4")])]),PP-Entry(Path("SDefT",[selector("2","iter-star-sep")]),[H([SOpt(HS
 ,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path("SDefT",[selector("3","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("Override"),[FBOX(KW,S("\"override\""))]),PP-Entry(Path1("Extend"),[FBOX(KW,S("\"extend\""))]),PP-Entry(Path1("Internal"),[FBOX(KW,S("\"internal\""))]),PP-Entry(Path1("ProceedNoArgs"),[FBOX(KW,S("\"proceed\""))]),PP-Entry(Path1("Proceed"),[FBOX(KW,S("\"proceed\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\")\""))]),PP-Entry(Path("Proceed",[selector("1","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("ProceedT"),[FBOX(KW,S("\"proceed\"")),FBOX(KW,S("\"(\"")),Arg("1"),FBOX(KW,S("\"|\"")),Arg("2"),FBOX(KW,S("\")\""))]),PP-Entry(Path("ProceedT",[selector("1","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path("ProceedT",[selector("1","iter-star-sep")]) )],[FBOX(KW,S("\"$[\"")),Arg("2"),FBOX(KW,S("\"]\""))])]),PP-Entry(Path1("StringQuotation2"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"${\"")),Arg("2"),FBOX(KW,S("\"}\""))])]),PP-Entry(Path1("StringQuotation3"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"$(\"")),Arg("2"),FBOX(KW,S("\")\""))])]),PP-Entry(Path1("StringQuotation4"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"$<\"")),Arg("2"),FBOX(KW,S("\">\""))])]),PP-Entry(Path("StringQuotation1",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path("StringQuotation2",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path("StringQuotation3",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path("StringQuotation4",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("StringEscape1"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"[\"")),Arg("2"),FBOX(KW,S("\"]\""))])]),PP-Entry(Path1("StringEscape2"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"{\"")),Arg("2"),FBOX(KW,S("\"}\""))])]),PP-Entry(Path1("StringEscape3"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\""))])])
 ,PP-Entry(Path1("StringEscape4"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"<\"")),Arg("2"),FBOX(KW,S("\">\""))])]),PP-Entry(Path1("QStr"),[Arg("1")]),PP-Entry(Path1("QDollar"),[Arg("1")]),PP-Entry(Path1("QBr"),[H([SOpt(HS,"0")],[FBOX(KW,S("\"$\"")),Arg("1"),FBOX(KW,S("\"$\""))])]),PP-Entry(Path1("ExtSDefInl"),[V([SOpt(IS,"2")],[H([],[FBOX(KW,S("\"external\"")),H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2")])]),FBOX(KW,S("\"|\"")),H([SOpt(HS,"0")],[H([],[Arg("3")]),FBOX(KW,S("\")\""))]),FBOX(KW,S("\"=\""))]),Arg("4")])]),PP-Entry(Path("ExtSDefInl",[selector("2","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path("ExtSDefInl",[selector("3","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("ExtSDef"),[H([],[FBOX(KW,S("\"external\"")),H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\"(\"")),H([],[Arg("2")])]),FBOX(KW,S("\"|\"")),H([SOpt(HS,"0")],[H([],[Arg("3")]),FBOX(KW,S("\")\""))])])]) ,FBOX(KW,S("\",\""))]),PP-Entry(Path("ExtSDef",[selector("3","iter-star-sep")]),[Arg("1"),FBOX(KW,S("\",\""))]),PP-Entry(Path1("DefaultVarDec"),[Arg("1")]),PP-Entry(Path1("VarDec"),[H([],[Arg("1"),FBOX(KW,S("\":\"")),Arg("2")])]),PP-Entry(Path1("OverlayNoArgs"),[Arg("1"),FBOX(KW,S("\"=\"")),Arg("2")]),PP-Entry(Path1("Overlay"),[V([SOpt(IS,"2")],[H([],[Arg("1"),FBOX(KW,S("\"(\"")),Arg("2"),FBOX(KW,S("\")\"")),FBOX(KW,S("\"=\""))]),Arg("3")])]),PP-Entry(Path("Overlay",[selector("2","iter-star-sep")]),[H([SOpt(HS,"0")],[Arg("1"),FBOX(KW,S("\",\""))])]),PP-Entry(Path1("Mark"),[S("\"@mark@\"")])])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/syntax/StrategoRenamed.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-front/syntax/StrategoRenamed.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,79 @@
+module StrategoRenamed
+imports Stratego
+          [ RuleNames          => StrategoRuleNames
+            RuleDec            => StrategoRuleDec
+            DynRuleScopeId     => StrategoDynRuleScopeId
+            DynRuleId          => StrategoDynRuleId
+            DynRuleDef         => StrategoDynRuleDef
+            ScopeLabels        => StrategoScopeLabels
+            RuleCond           => StrategoRuleCond
+            Rule               => StrategoRule
+            RuleDef            => StrategoRuleDef
+            Overlay            => StrategoOverlay
+            SwitchCase         => StrategoSwitchCase
+            StrategyCurly      => StrategoStrategyCurly
+            StrategyAngle      => StrategoStrategyAngle
+            Kind               => StrategoKind
+            LID                => StrategoLID
+            ImportModName      => StrategoImportModName
+            Decl               => StrategoDecl
+            Module             => StrategoModule
+            StrategyParen      => StrategoStrategyParen
+            Typedid            => StrategoTypedid
+            Anno               => StrategoAnno
+            EmptyId            => StrategoEmptyId
+            StrategyDef        => StrategoStrategyDef
+            SVar               => StrategoSVar
+            Def                => StrategoDef
+            Type               => StrategoType
+            RetType            => StrategoRetType
+            ArgType            => StrategoArgType
+            FunType            => StrategoFunType
+            ConstType          => StrategoConstType
+            Opdecl             => StrategoOpdecl
+            Sort               => StrategoSort
+            Sdecl              => StrategoSdecl
+            Wld                => StrategoWld
+            ID                 => StrategoID
+            Var                => StrategoVar
+            CharChar           => StrategoCharChar
+            Char               => StrategoChar
+            Padding            => StrategoPadding
+            Dollar4            => StrategoDollar4
+            QuotedBracket4     => StrategoQuotedBracket4
+            StringQuotedChars4 => StrategoStringQuotedChars4
+            StringQuotedPart4  => StrategoStringQuotedPart4
+            Dollar3            => StrategoDollar3
+            QuotedBracket3     => StrategoQuotedBracket3
+            StringQuotedChars3 => StrategoStringQuotedChars3
+            StringQuotedPart3  => StrategoStringQuotedPart3
+            Dollar2            => StrategoDollar2
+            QuotedBracket2     => StrategoQuotedBracket2
+            StringQuotedChars2 => StrategoStringQuotedChars2
+            StringQuotedPart2  => StrategoStringQuotedPart2
+            Dollar1            => StrategoDollar1
+            QuotedBracket1     => StrategoQuotedBracket1
+            StringQuotedChars1 => StrategoStringQuotedChars1
+            StringQuotedPart1  => StrategoStringQuotedPart1
+            StringQuotation    => StrategoStringQuotation
+            StrChar            => StrategoStrChar
+            String             => StrategoString
+            Real               => StrategoReal
+            Int                => StrategoInt
+            Keyword            => StrategoKeyword
+            UCID               => StrategoUCID
+            LCID               => StrategoLCID
+            LId                => StrategoLId
+            Id                 => StrategoId
+            ModNamePart        => StrategoModNamePart
+            ModName            => StrategoModName
+            Asterisk           => StrategoAsterisk
+            CommChar           => StrategoCommChar
+            Eof                => StrategoEof
+            LongCom            => StrategoLongCom
+            ShortCom           => StrategoShortCom
+            Ws                 => StrategoWs
+            PreTerm            => StrategoPreTerm
+            Term               => StrategoTerm
+            StrategyMid        => StrategoStrategyMid
+            Strategy           => StrategoStrategy ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Atoms.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Atoms.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,13 @@
+%% The most elementary boxes are strings enclosed in double quotes
+%% (literals) and numbered placeholders. Numbered placeholders refer to a
+%% sub-expression of a BOX term. Currently, referencing sub-terms at a
+%% maximum level of two is supported. For example, \_i.j refers to the jth
+%% element within the ith BOX of a BOX term.
+
+module Box-Atoms
+   exports
+      imports Box-Base Box-Literal
+
+   exports
+      context-free syntax
+         BoxLiteral            -> BOX {cons("S")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Base.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Base.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,5 @@
+%% Base module of the BOX markup language. Here only the sort BOX is
+%% defined.
+module Box-Base
+   exports
+      sorts BOX

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Disambiguation.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Disambiguation.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,4 @@
+module Box-Disambiguation
+exports
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\%]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Layout.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Layout.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,9 @@
+module Box-Layout
+exports
+  lexical syntax
+    "%%" ~[\n]* "\n" -> LAYOUT
+    [\ \t\n\r] -> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\13]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Literal.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Literal.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,26 @@
+module Box-Literal
+exports
+  sorts BoxLiteral
+  lexical syntax
+    "\\" ~[] -> AlphaNumericalEscChar {avoid}
+    "\\" [01] [0-9] [0-9] -> DecimalEscChar
+    "\\" "2" [0-4] [0-9]  -> DecimalEscChar
+    "\\" "2" "5" [0-5]    -> DecimalEscChar
+
+    AlphaNumericalEscChar -> EscChar
+    DecimalEscChar        -> EscChar
+
+    ~[\0-\31\"\\] \/ [\t\n] -> L-Char
+    EscChar                 -> L-Char
+
+    "\"" L-Char* "\""             -> QLiteral
+    [A-Za-z\-\_] [A-Za-z0-9\-\_]* -> UQLiteral
+
+    QLiteral  -> Literal
+    UQLiteral -> Literal
+
+    QLiteral -> BoxLiteral
+
+  sorts NatCon
+  lexical syntax
+    [0-9]+ -> NatCon

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Operators.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box-Operators.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,203 @@
+%% Expressions over the BOX language can be constructed by
+%% \emph{composing} boxes using BOX operators. These operators
+%% specify the relative positioning of boxes. BOX supports several of these
+%% \emph{positional} operators. Examples of positional operators are the
+%% \textsf{H} and \textsf{V} operators which format their sub-boxes
+%% horizontally and vertically, respectively. The exact formatting of the
+%% positional operators can be controlled by means of \emph{space options}.
+%% These options allow for instance, the horizontal and vertical layout
+%% within the \textsf{H} and \textsf{V} operators to be controlled.
+%%
+%% Besides positional operators, BOX also contains
+%% \emph{non-positional} operators. These operators are used to control
+%% how sub-boxes are displayed. These operators include font operators to
+%% specify font parameters (font family, font color, etc.) and operators for
+%% cross referencing.
+%%
+%% \subsection{Space Options}
+%%
+%% Space options are used to adapt the amount of layout between boxes. The
+%% horizontal, vertical, and indentation offset between boxes can be
+%% adapted.
+
+module Box-Operators
+exports
+
+  %% Deprecated, but used by Transformers.
+  context-free syntax
+    BOX* -> BOX-LIST
+
+  exports
+      sorts SPACE-SYMBOL S-OPTION
+
+      context-free syntax
+         SPACE-SYMBOL "=" NatCon -> S-OPTION     {cons("SOpt")}
+         SPACE-SYMBOL "=" BOX    -> S-OPTION     {cons("SOptB")}
+
+%% Below all supported space options are defined. The \textsf{hs} option is
+%% used to define the horizontal layout between boxes. The \textsf{vs}
+%% option defines the amount of vertical layout between boxes (the number of
+%% newlines between boxes in a vertical context). The \textsf{is} option
+%% defines indentation between boxes within a vertical context. Not every
+%% combination of space option and BOX operator makes sense. E.g.\ the
+%% modification of the vertical offset in combination of the \textsf{H}
+%% operator does not make any sense.
+
+      context-free syntax
+         "vs"                    -> SPACE-SYMBOL {cons("VS")}
+         "hs"                    -> SPACE-SYMBOL {cons("HS")}
+         "is"                    -> SPACE-SYMBOL {cons("IS")}
+
+%%\subsection{Positional BOX Operators}
+%% Smaller boxes can be composed to form new boxes using positional BOX
+%% operators that specify the relative ordering of sub boxes.
+%%
+%% The \textsf{H} operator is used to format a list of boxes horizontally.
+%% The operator only supports the \textsf{hs} space option to control the
+%% amount of horizontal layout between its sub-boxes. The \textsf{V}
+%% operator is used to format a list of boxes vertically. The operator
+%% supports the \textsf{vs} and \textsf{is} space options to control the
+%% amount of vertical layout and the amount of indentation between its
+%% sub-boxes, respectively. The \textsf{HV} operator is used to format a
+%% list of boxes horizontally \emph{or} vertically, depending on the
+%% available width. The operator calculates an optimal combination of
+%% \textsf{H} and \textsf{V} operators in such a way that the number of
+%% lines occupied is minimized. Because the \textsf{HV} is a combination of
+%% the \textsf{H} and \textsf{V} operators, it supports all space
+%% options of these operators (\textsf{hs}, \textsf{vs}, and \textsf{is}).
+
+   exports
+      context-free syntax
+         "H" S-OPTION*  "[" BOX* "]"  -> BOX {cons("H")}
+         "V" S-OPTION*  "[" BOX* "]"  -> BOX {cons("V")}
+         "HV" S-OPTION* "[" BOX* "]" -> BOX {cons("HV")}
+
+%% The \textsf{ALT} operator is used to choose between two alternative BOX
+%% expressions depending on the available width. When its first argument
+%% fits on the current line, that BOX expression is used. Otherwise, the
+%% \textsf{ALT} operator chooses the second alternative. No space options
+%% are supported by this operator.
+
+   exports
+      context-free syntax
+         "ALT" "[" BOX BOX "]" -> BOX {cons("ALT")}
+
+%% Alignments are implemented by means of two BOX operators: \textsf{A} and
+%% \textsf{R}. The arguments of the \textsf{A} operator are \textsf{R}
+%% boxes. Each \textsf{R} BOX represents a row, each element of an
+%% \textsf{R} BOX represents an entry in the alignment. The number of
+%% arguments of an
+%% \textsf{R} BOX may not exceed the number of columns of the alignment. For
+%% each column the user can specify whether the alignment should be left,
+%% right, or centered. The number of alignment indications should be equal
+%% to the number of columns. Each alignment indication can be extended with
+%% space options, specifying the horizontal layout between columns. The
+%% \textsf{A} operator supports the \textsf{vs} space option which defines
+%% the vertical layout between individual rows.
+%%
+%% \textsf{R} boxes occurring outside an alignment are formatted as
+%% \text{HV} operator. This behavior enables the use of an alternative
+%% formatting (not based on the \textsf{A} operator) of alignments within an
+%% \textsf{ALT} operator. The \textsf{R} operator therefore supports all
+%% space options of the \textsf{HV} operator.
+
+   exports
+      sorts A-OPTION A-OPTIONS
+
+      context-free syntax
+         "A" A-OPTIONS S-OPTION* "[" BOX* "]" -> BOX       {cons("A")}
+         "R" S-OPTION* "[" BOX* "]"           -> BOX       {cons("R")}
+
+%% Justification of columns and horizontal layout between columns can be
+%% specified using A-OPTIONS. An A-OPTION is composed of an alignment
+%% indicator (\textsf{l} for left, \textsf{r} for right, and \textsf{c} for
+%% centered alignment), and space options (only the \textsf{hs} option is
+%% supported).
+
+         "l" S-OPTION*                            -> A-OPTION  {cons("AL")}
+         "c" S-OPTION*                            -> A-OPTION  {cons("AC")}
+         "r" S-OPTION*                            -> A-OPTION  {cons("AR")}
+         "(" {A-OPTION ","}* ")"                  -> A-OPTIONS {cons("AOPTIONS")}
+
+%%\subsection{Non-Positional BOX Operators}
+%%
+%% There are four different types of non-positional BOX operators: font
+%% operators to change the textual appearance of BOX expressions, cross
+%% reference operators to create links between boxes, the comment operator
+%% to indicate that a BOX expression contains comments, and the line
+%% operator to draw lines of characters of arbitrary length.
+%%
+%%
+%% BOX font operators are used to change the textual appearance of the
+%% argument BOX expression. Fonts can be characterized by the parameters
+%% font name (\textsf{fn}), font family (\textsf{fm}), font series
+%% (\textsf{se}), font shape (\textsf{sh}), font size (\textsf{sz}), and
+%% font color (\textsf{cl}). The most general font operator is \textsf{F}.
+%% By means of font parameters the desired font can be controlled.
+
+   exports
+      sorts FID FONT-PARAM F-OPTION FONT-OPERATOR
+
+      lexical syntax
+         [A-Za-z]+ -> FID
+
+      context-free syntax
+         FONT-PARAM "=" NatCon     -> F-OPTION      {cons("FNAT")}
+         FONT-PARAM "=" FID        -> F-OPTION      {cons("FFID")}
+
+      context-free syntax
+         "F" F-OPTION*             -> FONT-OPERATOR {cons("F")}
+         FONT-OPERATOR "[" BOX "]" -> BOX           {cons("FBOX")}
+         "fn"                      -> FONT-PARAM    {cons("FN")}
+         "fm"                      -> FONT-PARAM    {cons("FM")}
+         "se"                      -> FONT-PARAM    {cons("SE")}
+         "sh"                      -> FONT-PARAM    {cons("SH")}
+         "sz"                      -> FONT-PARAM    {cons("SZ")}
+         "cl"                      -> FONT-PARAM    {cons("CL")}
+
+%% By using the \textsf{F} font operator, fonts are defined statically.
+%% BOX also support fonts to be defined dynamically using special
+%% font operators.  These operators are used to format specific language
+%% constructs like keywords and variables. The mapping from these
+%% operators to fonts is deferred to the back-ends.
+
+   exports
+      context-free syntax
+         "KW"   -> FONT-OPERATOR {cons("KW")}
+         "VAR"  -> FONT-OPERATOR {cons("VAR")}
+         "NUM"  -> FONT-OPERATOR {cons("NUM")}
+         "MATH" -> FONT-OPERATOR {cons("MATH")}
+
+%% The \textsf{LBL} operator is used to label BOX terms. A labeled BOX term
+%% can be refered to using the \textsf{REF} operator.  The first argument of
+%% the \textsf{LBL} and \textsf{REF} operators denote the name of the label.
+%% The second argument of the \textsf{LBL} operator denotes the BOX term to
+%% label. The second argument of the \textsf{REF} operator denotes the BOX
+%% containing the reference. Both operators do not support any space
+%% options.
+
+   exports
+      context-free syntax
+         "LBL" "[" BoxLiteral BOX "]" -> BOX {cons("LBL")}
+         "REF" "[" BoxLiteral BOX "]" -> BOX {cons("REF")}
+
+%% Comments can be formatted using the \textsf{C} operator. The operator
+%% supports the \textsf{is} space option to denote the indentation level of
+%% comments.
+
+   exports
+      context-free syntax
+         "C" S-OPTION* "[" BOX* "]" -> BOX {cons("C")}
+
+%% The \textsf{L} operator  is used to construct horizontal bars of fixed
+%% \emph{or} variable width. A bar of fixed width can be constructed by
+%% specifying its width as a fixed number. A bar of variable width can be
+%% constructed by specifying a BOX expressions as width parameter. The
+%% second argument of the \textsf{L} operator specifies the symbol of which
+%% the bar should be constructed. The \textsf{L} operator does not support
+%% any space options.
+
+   exports
+      context-free syntax
+         "L" "[" BOX BOX "]"    -> BOX {cons("L")}
+         "L" "[" NatCon BOX "]" -> BOX {cons("LNAT")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Box.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,39 @@
+%% This module contains the syntax of the BOX markup language. This version
+%% of the BOX language is heavily based on:
+%%
+%% \begin{center}
+%%                `Box: Language, Laws and Formatters''\\
+%%\ \\
+%%          Copyright (c) Mark van den Brand \& Eelco Visser, 1995\\
+%%\ \\
+%%           Programming Research Group, University of Amsterdam \\
+%%           Kruislaan 403, 1098 SJ Amsterdam, The Netherlands.  \\
+%%        mail:markvdb at fwi.uva.nl http://adam.fwi.uva.nl/~markvdb/  \\
+%%         mail:visser at fwi.uva.nl  http://adam.fwi.uva.nl/~visser/ \\
+%% \end{center}
+%%
+%% We applied several modifications to this original BOX language. On the
+%% one hand these modifications include a redesign of the SDF definition of
+%% the BOX language. On the other hand, we adapted the BOX language itself
+%% (we removed several BOX operators and introduced several new ones). For
+%% more information on the BOX language we refer to the following technical
+%% reports:
+%% \begin{center}
+%%               Mark van den Brand and Merijn de Jonge. \\
+%%          Pretty Printing within the ASF+SDF Meta-Environment:
+%%                         a Generic Approach. \\
+%%                Technical Report SEN-R9904, CWI, 1999. \\
+%%                ftp://ftp.cwi.nl/pub/CWIreports/SEN/SEN-R9904.ps.Z\\
+%% \ \\
+%%                           Merijn de Jonge. \\
+%%    boxenv.sty: A LaTeX Style File for Formatting BOX Expressions.\\
+%%                 Technical Report SEN-R9911, CWI, 1999.\\
+%%                ftp://ftp.cwi.nl/pub/CWIreports/SEN/SEN-R9911.ps.Z
+%% \end{center}
+
+module Box
+  hiddens
+    context-free start-symbols BOX
+  exports
+    imports Box-Atoms Box-Operators Box-Layout Box-Disambiguation
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Stratego-Box.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/syntax/Stratego-Box.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,24 @@
+module Stratego-Box
+imports Box StrategoRenamed
+hiddens
+  context-free start-symbols StrategoModule
+
+exports
+  context-free syntax
+
+                BOX      -> StrategoTerm  {cons("ToTerm"), avoid}
+          "|["  BOX "]|" -> StrategoTerm  {cons("ToTerm"), prefer}
+    "box" "|["  BOX "]|" -> StrategoTerm  {cons("ToTerm")}
+
+           "|["  BOX* "]|" -> StrategoTerm {cons("ToTerm")}
+    "box*" "|["  BOX* "]|" -> StrategoTerm {cons("ToTerm")}
+
+    "~"  StrategoTerm    -> BOX   {cons("FromTerm"), prefer}
+    "~*" StrategoTerm    -> BOX*  {cons("FromTerm"), prefer}
+
+    "~lit:" StrategoTerm -> BoxLiteral {cons("FromTerm"), prefer}
+
+  variables
+    "b" [0-9]*     -> BOX
+    "b" [0-9]* "*" -> BOX*
+    "s" [0-9]*     -> BoxLiteral

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/trans/Box.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-gpp/trans/Box.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,55 @@
+module Box
+
+signature
+  constructors
+    CL       : FONT-PARAM
+    SZ       : FONT-PARAM
+    SH       : FONT-PARAM
+    SE       : FONT-PARAM
+    FM       : FONT-PARAM
+    FN       : FONT-PARAM
+    MATH     : FONT-OPERATOR
+    NUM      : FONT-OPERATOR
+    VAR      : FONT-OPERATOR
+    KW       : FONT-OPERATOR
+    F        : List(F-OPTION) -> FONT-OPERATOR
+    FFID     : FONT-PARAM * FID -> F-OPTION
+    FNAT     : FONT-PARAM * NatCon -> F-OPTION
+             : String -> FID
+    AOPTIONS : List(A-OPTION) -> A-OPTIONS
+    AR       : List(S-OPTION) -> A-OPTION
+    AC       : List(S-OPTION) -> A-OPTION
+    AL       : List(S-OPTION) -> A-OPTION
+    IS       : SPACE-SYMBOL
+    HS       : SPACE-SYMBOL
+    VS       : SPACE-SYMBOL
+    SOptB    : SPACE-SYMBOL * BOX -> S-OPTION
+    SOpt     : SPACE-SYMBOL * NatCon -> S-OPTION
+    LNAT     : NatCon * BOX -> BOX
+    L        : BOX * BOX -> BOX
+    C        : List(S-OPTION) * List(BOX) -> BOX
+    REF      : BoxLiteral * BOX -> BOX
+    LBL      : BoxLiteral * BOX -> BOX
+    FBOX     : FONT-OPERATOR * BOX -> BOX
+    R        : List(S-OPTION) * List(BOX) -> BOX
+    A        : A-OPTIONS * List(S-OPTION) * List(BOX) -> BOX
+    ALT      : BOX * BOX -> BOX
+    HV       : List(S-OPTION) * List(BOX) -> BOX
+    V        : List(S-OPTION) * List(BOX) -> BOX
+    H        : List(S-OPTION) * List(BOX) -> BOX
+    S        : BoxLiteral -> BOX
+             : String -> NatCon
+             : String -> BoxLiteral
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/spec/collection/list/cons.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/spec/collection/list/cons.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,27 @@
+/**
+ * Lists are represented by means of the constructors Nil and Cons. They can
+ * either be written as terms with these constructors, e.g. Cons(0, Cons(1, Nil)),
+ * or using concrete list syntax: [0, 1]
+ *
+ * Stratego pretty-printers and the Stratego Shell will always prefer to display
+ * lists using the concrete syntax.
+ */
+module collection/list/cons
+signature
+  sorts List(a)
+  constructors
+  
+    /**
+     * Empty list.
+     */
+    Nil  : List(a)
+    
+    /**
+     * Element of a list.
+     */
+    Cons : a * List(a) -> List(a)
+    
+    /**
+     * Concatenation of two lists.
+     */
+    Conc : List(a) * List(a) -> List(a)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/ssl-compat/list-cons.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-libraries/lib/ssl-compat/list-cons.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,2 @@
+module list-cons
+imports collection/list/cons

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/Stratego-rtg.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/Stratego-rtg.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,26 @@
+module Stratego-rtg
+imports rtg StrategoRenamed
+
+exports
+  context-free start-symbols StrategoModule
+
+  context-free syntax
+
+    "rtg" "|[" ProdRule   "]|" -> StrategoTerm {cons("ToTerm")}
+    "rtg" "|[" AnnoTreeFN "]|" -> StrategoTerm {cons("ToTerm")}
+    "rtg" "|[" RTG        "]|" -> StrategoTerm {cons("ToTerm")}
+
+                "A" "|[" NonTerm "]|" -> StrategoTerm {cons("ToTerm")}
+    "rtg" "nonterm" "|[" NonTerm "]|" -> StrategoTerm {cons("ToTerm")}
+
+  variables
+    "t"  [0-9\']*     -> TreeFN   {prefer}
+    "at" [0-9\']*     -> AnnoTreeFN
+    "at" [0-9\']* "*" -> {AnnoTreeFN ","}*
+    "t"  [0-9\']* "*" -> {AnnoTreeFN ","}*
+
+    [ABC][0-9\']*     -> NonTerm  {prefer}
+    [ABC][0-9\']* "+" -> NonTerm+
+    [abc][0-9\']*     -> Term
+    [xyz][0-9\']*     -> Id
+    [ij][0-9\']*      -> IntConst

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/regexp.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/regexp.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,25 @@
+module regexp[Symbol]
+
+exports
+  sorts RegExp
+
+  context-free syntax
+    "/"        -> RegExp {cons("Empty")}
+    Symbol     -> RegExp {cons("Sym")}
+    RegExp "*" -> RegExp {cons("Star")}
+    RegExp "+" -> RegExp {cons("Plus")}
+    RegExp "?" -> RegExp {cons("Opt")}
+
+    RegExp "|" RegExp -> RegExp {cons("Choice"), right}
+    RegExp RegExp     -> RegExp {cons("Seq"), right}
+
+    "(" RegExp ")" -> RegExp {bracket}
+
+  context-free priorities
+    {left:
+      RegExp "*" -> RegExp
+      RegExp "+" -> RegExp
+      RegExp "?" -> RegExp
+    }
+  > RegExp     RegExp -> RegExp
+  > RegExp "|" RegExp -> RegExp

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-identifier.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-identifier.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,20 @@
+module rg-identifier
+exports
+  sorts Id QuotedIdPart
+  syntax
+    Id -> <Id-CF>
+
+    <PlainIdChars-LEX>    -> Id {cons("Plain")}
+    "[" QuotedIdPart* "]" -> Id {cons("Quoted")}
+
+    <QuotedIdChars-LEX> -> QuotedIdPart {cons("Chars")}
+     "\\" [\\\]]        -> QuotedIdPart {cons("EscapeSeq")}
+
+  sorts PlainIdChars QuotedIdChars
+  lexical syntax
+    ~[\\\]]+           -> QuotedIdChars
+    [a-zA-Z0-9\'\-\_]+ -> PlainIdChars
+
+  lexical restrictions
+    QuotedIdChars -/- ~[\\\]]
+    PlainIdChars  -/- [a-zA-Z0-9\'\-\_]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-layout.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-layout.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,21 @@
+module rg-layout
+exports
+  lexical syntax
+    [\ \t\n] -> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n]
+
+  sorts
+    LongCom
+    CommChar
+    Asterisk
+
+  lexical syntax
+    "/*" CommChar+ "*/" -> LAYOUT
+    ~[\*]    -> CommChar
+    "*"      -> Asterisk
+    Asterisk -> CommChar
+
+  lexical restrictions
+    Asterisk -/- [\/]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-nonterm.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-nonterm.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,8 @@
+module rg-nonterm
+imports rg-identifier
+exports
+  sorts NonTerm
+  context-free syntax
+    Id         -> NonTerm {cons("Nonterm")}
+    "<string>" -> NonTerm {cons("String")}
+    "<int>"    -> NonTerm {cons("Int")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-term.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rg-term.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,19 @@
+module rg-term
+imports rg-identifier
+exports
+  sorts Term IntConst
+  context-free syntax
+    Id       -> Term {cons("Term")}
+    "<conc>" -> Term {cons("ConcTerm")}
+    "<cons>" -> Term {cons("ConsTerm")}
+    "<nil>"  -> Term {cons("NilTerm")}
+    "<(" IntConst ")>" -> Term {cons("TupleTerm")}
+
+    "<some>" -> Term {cons("SomeTerm")}
+    "<none>" -> Term {cons("NoneTerm")}
+
+    "<string>" -> Term {cons("StringTerm")}
+    "<int>"    -> Term {cons("IntTerm")}
+
+  lexical syntax
+    [0-9]+   -> IntConst

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rtg.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/stratego-rtg/syntax/rtg.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,29 @@
+module rtg
+imports rg-term rg-nonterm rg-identifier rg-layout
+hiddens
+  context-free start-symbols RTG ProdRule TreeFN AnnoTreeFN NonTerm
+
+exports
+  sorts RTG Start ProdRule ProdRules AnnoTreeFN TreeFN Labelled 
+  context-free syntax
+
+    "regular" "tree" "grammar" Start ProdRules -> RTG {cons("RTG")}
+    "start" NonTerm+ -> Start {cons("Start")}
+    "productions" ProdRule+ -> ProdRules {cons("ProdRules")}
+
+    NonTerm "->" {AnnoTreeFN "|"}+ -> ProdRule {cons("ProdRule")}
+
+    TreeFN -> AnnoTreeFN
+    TreeFN Labelled+ -> AnnoTreeFN {cons("Annotated")}
+
+    Term "(" {AnnoTreeFN ","}* ")" -> TreeFN {cons("Appl")}
+    NonTerm -> TreeFN {cons("Ref")}
+
+    "." Term AnnoTreeFN -> Labelled {cons("Labelled")}
+
+  %%%
+   %% Special non-terminals used for tracing purposes
+   %%%
+  context-free syntax
+    "{" {NonTerm ","}+ "}" -> NonTerm {cons("Set")}
+    "<<" TreeFN ">>"       -> NonTerm {cons("Generated")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/Stratego-xml-info.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/Stratego-xml-info.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,19 @@
+module Stratego-xml-info
+imports Stratego-xml
+hiddens
+  context-free start-symbols StrategoModule
+
+exports
+  context-free syntax
+    "module" StrategoModName Attribute+ StrategoDecl*
+        -> StrategoModule {cons("Module")}
+
+  syntax
+
+    "<%" <LAYOUT?-CF> <StrategoStrategy-CF> <LAYOUT?-CF>
+      "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
+      -> CharDataPart+ {cons("FromApp"), prefer}
+
+    "<%" <LAYOUT?-CF> <StrategoStrategy-CF> <LAYOUT?-CF>
+      "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
+      -> FooCharDataText {cons("FromApp"), avoid}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/Stratego-xml.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/Stratego-xml.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,109 @@
+module Stratego-xml
+imports xml StrategoMix[StrategoHost]
+hiddens
+  context-free start-symbols Module[[StrategoHost]]
+
+exports
+
+  %% Term Quotation
+  context-free syntax
+    "%>" Document "<%" -> Term[[StrategoHost]]     {cons("ToTerm"), avoid}
+
+    "@>" Attribute  "<@" -> Term[[StrategoHost]]   {cons("ToTerm"), prefer}
+    "@>" Attribute* "<@" -> Term[[StrategoHost]]   {cons("ToTerm")}
+
+  syntax
+    "%>" <Content-CF>  "<%" -> <Term[[StrategoHost]]-CF> {cons("ToTerm"), prefer}
+    "%>" <Content-CF>* "<%" -> <Term[[StrategoHost]]-CF> {cons("ToTerm")}
+
+    "%>" <Content-CF>* "<%" <LAYOUT?-CF> "::" <LAYOUT?-CF> "*" -> <Term[[StrategoHost]]-CF> {cons("ToTerm")}
+
+  %% Congruence Quotation
+  context-free syntax  
+    "%>" Document "<%" -> Strategy[[StrategoHost]] {cons("ToStrategy"), avoid}
+
+  syntax
+    "%>" <Content-CF>  "<%" -> <Strategy[[StrategoHost]]-CF> {cons("ToStrategy"), prefer}
+    "%>" <Content-CF>* "<%" -> <Strategy[[StrategoHost]]-CF> {cons("ToStrategy")}
+
+  %% Content Anti Quotation
+  context-free syntax
+
+    "<%=" Term[[StrategoHost]]                 "%>" -> Content {cons("FromTerm")}
+    "<%=" Term[[StrategoHost]] "::" "content"  "%>" -> Content {cons("FromTerm")}
+
+    "<%"  Strategy[[StrategoHost]]                 "%>" -> Content {cons("FromApp")}
+    "<%"  Strategy[[StrategoHost]] "::" "content"  "%>" -> Content {cons("FromApp")}
+
+  syntax
+
+    "<%=" <LAYOUT?-CF> <Term[[StrategoHost]]-CF>    <LAYOUT?-CF> "::" <LAYOUT?-CF> "*"        <LAYOUT?-CF> "%>" -> <Content-CF>* {cons("FromTerm")}
+    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "*"        <LAYOUT?-CF> "%>" -> <Content-CF>* {cons("FromApp")}
+    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "content*" <LAYOUT?-CF> "%>" -> <Content-CF>* {cons("FromApp")}
+
+  %% Character Data Anti Quotation
+  syntax
+
+    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
+      -> FooCharDataText {cons("FromApp")}
+
+    "<%=" <LAYOUT?-CF> <Term[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
+      -> FooCharDataText {cons("FromTerm")}
+
+  %% Anti quotation for attributes
+  context-free syntax
+
+    "<@"  Strategy[[StrategoHost]]          "@>" -> Attribute  {cons("FromApp")}
+    "<@"  Strategy[[StrategoHost]] "::" "*" "@>" -> Attribute* {cons("FromApp")}
+
+    "<@="  Term[[StrategoHost]]          "@>" -> Attribute  {cons("FromTerm")}
+    "<@="  Term[[StrategoHost]] "::" "*" "@>" -> Attribute* {cons("FromTerm")}
+
+  syntax
+    %% obsolete
+    "<"  <Term[[StrategoHost]]-CF> -> <Attribute-CF>  {cons("FromTerm")}
+    "<*" <Term[[StrategoHost]]-CF> -> <Attribute*-CF> {cons("FromTerm")}
+
+  %% Attribute Value Anti Quotation
+  context-free syntax
+
+    "<@"  Strategy[[StrategoHost]] "@>" -> AttValue   {cons("FromApp")}
+    "<@=" Term[[StrategoHost]]     "@>" -> AttValue   {cons("FromTerm")}
+
+    %% obsolete
+    "<%"  Strategy[[StrategoHost]] "%>" -> AttValue   {cons("FromApp")}
+    "<%=" Term[[StrategoHost]]     "%>" -> AttValue   {cons("FromTerm")}
+
+  %% Attribute Character Data Anti Quotation
+  syntax
+
+    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "%>"
+      -> FooDoubleQuotedText {cons("FromApp")}
+
+    "<%=" <LAYOUT?-CF> <Term[[StrategoHost]]-CF> <LAYOUT?-CF> "%>"
+      -> FooDoubleQuotedText {cons("FromTerm")}
+
+    "<%" <LAYOUT?-CF> <Strategy[[StrategoHost]]-CF> <LAYOUT?-CF> "::" <LAYOUT?-CF> "cdata" <LAYOUT?-CF> "%>"
+      -> FooDoubleQuotedText {cons("FromApp")}
+
+    "<" <Term[[StrategoHost]]-CF> -> FooDoubleQuotedText {cons("FromTerm")}
+
+  %% Anti quotation for element. This anti quotation is only used if anti quotation
+  %% is used for the root element of an document.
+  context-free syntax
+
+    "<%" Strategy[[StrategoHost]] "%>" -> Element {cons("FromApp"), avoid}
+
+  %% Name Anti-Quotation
+  syntax
+
+    "<"   <Term[[StrategoHost]]-CF> -> <NCName-CF> {cons("FromTerm")}
+    "~n:" <Term[[StrategoHost]]-CF> -> <NCName-CF> {cons("FromTerm")}
+
+  variables
+    "@"    [0-9]*     -> Attribute
+    "att"  [0-9]*     -> Attribute
+    "@"    [0-9]* "*" -> Attribute*
+    "att"  [0-9]* "*" -> Attribute*
+    "atts" [0-9]*     -> Attribute*
+    "qn"   [0-9]*     -> QName {prefer}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-attribute.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-attribute.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,32 @@
+module xml-attribute
+imports xml-names xml-text
+
+exports
+
+  context-free syntax
+
+    QName "=" AttValue -> Attribute {cons("Attribute")}
+
+  syntax
+
+    "\"" DoubleQuotedPart* "\"" -> <AttValue-CF> {cons("DoubleQuoted")}
+    "'"  SingleQuotedPart* "'" -> <AttValue-CF> {cons("SingleQuoted")}
+
+    FooDoubleQuotedText -> DoubleQuotedPart {cons("Literal")}
+    FooSingleQuotedText -> SingleQuotedPart {cons("Literal")}
+
+    <DoubleQuotedText-LEX> -> FooDoubleQuotedText
+    <SingleQuotedText-LEX> -> FooSingleQuotedText
+
+    <Ref-CF> -> DoubleQuotedPart
+    <Ref-CF> -> SingleQuotedPart
+
+  lexical syntax
+
+    ~[\&\<\"]+ -> DoubleQuotedText
+    ~[\&\<\']+ -> SingleQuotedText
+
+  lexical restrictions
+
+    DoubleQuotedText -/- ~[\&\<\"]
+    SingleQuotedText -/- ~[\&\<\']
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-comments.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-comments.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,12 @@
+module xml-comments
+
+exports
+  lexical syntax
+    "<!--" (~[\-] | Dash)* "-->" -> Comment
+    "-" -> Dash
+
+  lexical restrictions
+
+    Dash -/- [\-]
+
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-document.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-document.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,24 @@
+module xml-document
+imports xml-prolog xml-whitespace xml-names xml-comments xml-text xml-attribute
+
+exports
+  sorts Document Element Content
+  context-free syntax
+
+    Prologue Element Epilogue -> Document {cons("Document")}
+
+    "<" QName Attribute* "/>" -> Element {cons("EmptyElement")}
+
+    Element -> Content
+    Comment -> Content {cons("Comment")}
+    PI      -> Content
+
+  syntax
+
+    CharData      -> <Content-CF>
+
+    "<"
+    <LAYOUT?-CF> <QName-CF> <LAYOUT?-CF> <Attribute*-CF> <LAYOUT?-CF>
+      ">" <Content-CF>* "</"
+    <LAYOUT?-CF> <QName-CF> <LAYOUT?-CF>
+    ">"  -> <Element-CF> {cons("Element")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-external.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-external.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,17 @@
+module xml-external
+
+exports
+  context-free syntax
+    "SYSTEM" SystemLit           -> ExternalID {cons("SystemExternalID")}
+    "PUBLIC" PublicLit SystemLit -> ExternalID {cons("PublicExternalID")}
+    "PUBLIC" PublicLit           -> PublicID   {cons("PublicID")  }
+
+  lexical syntax
+
+    "\"" ~[\"]* "\""     -> SystemLit
+    "'"  ~[\']* "'"     -> SystemLit
+    "\"" PubIDChar* "\"" -> PublicLit
+    "'"  PubIDChar* "'" -> PublicLit
+
+    [a-zA-Z0-9] -> PubIDChar
+    [\ \n\13\-\'\(\)\+\,\.\/\:\=\?\;\!\*\#\@\$\_\%] -> PubIDChar

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-lexical.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-lexical.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,3 @@
+module xml-lexical
+imports xml-whitespace xml-comments xml-names
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-names.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-names.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,15 @@
+module xml-names
+
+exports
+  context-free syntax
+    Qualifier? NCName -> QName     {cons("QName")}
+    NCName ":"        -> Qualifier {cons("Prefix")}
+
+  lexical syntax
+    [A-Za-z\_] [A-Za-z0-9\.\-\_]* -> NCName
+
+  lexical restrictions
+    NCName -/- [A-Za-z0-9\.\-\_]
+  
+
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-pi.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-pi.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,13 @@
+module xml-pi
+imports xml-names
+
+exports
+  context-free syntax
+    "<?" PITarget PIChars "?>" -> PI {cons("PI")}
+
+  lexical syntax
+    NCName -> PITarget
+    [Xx][Mm][Ll] -> PITarget {reject}
+
+    ( ~[\?\>] | ( [\?] ~[\>] ) )* -> PIChars
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-prolog.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-prolog.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,41 @@
+module xml-prolog
+imports xml-whitespace xml-names xml-comments xml-pi xml-external
+
+exports
+  context-free syntax
+
+    XMLDecl? Misc* DocTypePrologue? -> Prologue {cons("Prologue")}
+    Misc* -> Epilogue {cons("Epilogue")}
+    Comment -> Misc {cons("Comment")}
+    PI      -> Misc
+
+  context-free syntax
+
+    "<?xml" VersionInfo EncodingDecl? StandaloneDecl? "?>" -> XMLDecl {cons("XMLDecl")}
+
+    "standalone" "=" StandaloneValue -> StandaloneDecl {cons("StandaloneDecl")}
+    "version"    "=" VersionValue    -> VersionInfo    {cons("VersionDecl")}
+    "encoding"   "=" EncodingValue   -> EncodingDecl   {cons("EncodingDecl")}
+
+    "\"" YesNo "\"" -> StandaloneValue {cons("Standalone")}
+    "'"  YesNo "'" -> StandaloneValue {cons("StandaloneSingle")}
+
+    "\"" EncodingName "\"" -> EncodingValue {cons("Encoding")}
+    "'"  EncodingName "'" -> EncodingValue {cons("EncodingSingle")}
+
+    "\"" VersionNum "\"" -> VersionValue {cons("Version")}
+    "'"  VersionNum "'"  -> VersionValue {cons("VersionSingle")}
+
+  context-free syntax
+
+    DocTypeDecl Misc* -> DocTypePrologue {cons("DocTypePrologue")}
+
+    "<!DOCTYPE" QName ExternalID ">" -> DocTypeDecl {cons("DocTypeDecl")}
+
+  lexical syntax
+
+    [a-zA-Z0-9\_\.\:\-]+ -> VersionNum
+    [A-Za-z] [A-Za-z0-9\.\_\-]* -> EncodingName
+
+    "yes" -> YesNo
+    "no"  -> YesNo

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-text.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-text.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,60 @@
+module xml-text
+exports
+
+  syntax
+
+    CharDataPart+ -> CharData {cons("Text")}
+
+    FooCharDataText -> CharDataPart {cons("Literal")}
+    <Ref-CF> -> CharDataPart
+    "<![CDATA[" <CData-LEX> "]]>" -> CharDataPart {cons("CDATASection")}
+
+    <CharDataText-LEX> -> FooCharDataText
+
+  restrictions
+
+	%% Must be followed by `<' ...
+    CharData -/- ~[\<]
+
+	%% ... unless the `<' starts a CDATASection
+    %% (It would be better to lift CDATASections from child to sibling of Text,
+    %%  but this would change the structure of the AST...) 
+    CharData -/- [\<].[\!].[\[].[C].[D].[A].[T].[A].[\[]
+
+  lexical syntax
+
+    ~[\<\&]+ -> CharDataText
+
+  lexical restrictions
+
+    CharDataText -/- ~[\<\&]
+
+  syntax
+
+    "&#"  <NatConst-LEX> ";" -> <DecCharRef-CF> {cons("DecCharRef")}
+    "&#x" <HexConst-LEX> ";" -> <HexCharRef-CF> {cons("HexCharRef")}
+    "&"   <NCName-LEX>   ";" -> <EntityRef-CF>  {cons("EntityRef")}
+
+  context-free syntax
+
+    DecCharRef -> CharRef
+    HexCharRef -> CharRef
+    CharRef    -> Ref
+    EntityRef  -> Ref
+
+  lexical syntax
+
+    [0-9]+       -> NatConst
+    [0-9a-fA-F]+ -> HexConst
+
+  lexical syntax
+
+    (~[\]] | CloseBracket | TwoCloseBrackets )* -> CData
+
+    "]"  -> CloseBracket
+    "]]" -> TwoCloseBrackets
+
+  lexical restrictions
+
+    CloseBracket     -/- [\]]
+    TwoCloseBrackets -/- [\>]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-whitespace.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml-whitespace.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,9 @@
+module xml-whitespace
+
+exports
+  lexical syntax
+    [\ \t\n\13] -> LAYOUT
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\13]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/syntax/xml.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,4 @@
+module xml
+imports xml-lexical xml-document
+hiddens
+  context-free start-symbols Document Content Attribute

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,75 @@
+module xml-doc
+
+signature
+  constructors
+                     : CharData -> Content
+                     : PI -> Content
+    Comment          : Comment -> Content
+                     : Element -> Content
+    Element          : QName * List(Attribute) * List(Content) * QName -> Element
+    EmptyElement     : QName * List(Attribute) -> Element
+    Document         : Prologue * Element * Epilogue -> Document
+                     : String -> FooSingleQuotedText
+                     : String -> FooDoubleQuotedText
+                     : Ref -> SingleQuotedPart
+    Literal          : FooSingleQuotedText -> SingleQuotedPart
+                     : Ref -> DoubleQuotedPart
+    Literal          : FooDoubleQuotedText -> DoubleQuotedPart
+    SingleQuoted     : List(SingleQuotedPart) -> AttValue
+    DoubleQuoted     : List(DoubleQuotedPart) -> AttValue
+    Attribute        : QName * AttValue -> Attribute
+                     : EntityRef -> Ref
+                     : CharRef -> Ref
+                     : HexCharRef -> CharRef
+                     : DecCharRef -> CharRef
+    EntityRef        : String -> EntityRef
+    HexCharRef       : String -> HexCharRef
+    DecCharRef       : String -> DecCharRef
+                     : String -> FooCharDataText
+    CDATASection     : String -> CharDataPart
+                     : Ref -> CharDataPart
+    Literal          : FooCharDataText -> CharDataPart
+    Text             : List(CharDataPart) -> CharData
+    DocTypeDecl      : QName * ExternalID -> DocTypeDecl
+    DocTypePrologue  : DocTypeDecl * List(Misc) -> DocTypePrologue
+    VersionSingle    : VersionNum -> VersionValue
+    Version          : VersionNum -> VersionValue
+    EncodingSingle   : EncodingName -> EncodingValue
+    Encoding         : EncodingName -> EncodingValue
+    StandaloneSingle : YesNo -> StandaloneValue
+    Standalone       : YesNo -> StandaloneValue
+    EncodingDecl     : EncodingValue -> EncodingDecl
+    VersionDecl      : VersionValue -> VersionInfo
+    StandaloneDecl   : StandaloneValue -> StandaloneDecl
+    XMLDecl          : VersionInfo * Option(EncodingDecl) * Option(StandaloneDecl) -> XMLDecl
+                     : PI -> Misc
+    Comment          : Comment -> Misc
+    Epilogue         : List(Misc) -> Epilogue
+    Prologue         : Option(XMLDecl) * List(Misc) * Option(DocTypePrologue) -> Prologue
+    PublicExternalID : PublicLit * SystemLit -> ExternalID
+    SystemExternalID : SystemLit -> ExternalID
+    PI               : PITarget * PIChars -> PI
+                     : String -> YesNo
+                     : String -> EncodingName
+                     : String -> VersionNum
+                     : String -> PublicLit
+                     : String -> SystemLit
+                     : String -> PIChars
+                     : String -> PITarget
+    Prefix           : NCName -> Qualifier
+    QName            : Option(Qualifier) * NCName -> QName
+                     : String -> NCName
+                     : String -> Comment
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc2abox.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc2abox.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Box")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc2abox.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xml-front/trans/xml-doc2abox.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,130 @@
+module xml-doc2abox
+imports xml-doc Box libstratego-lib
+strategies
+
+  main-xml-doc2abox =
+    io-wrap(xml-doc2abox)
+
+  xml-doc2abox =
+      topdown(try(repeat(xml-to-box)))
+
+rules
+
+  xml-to-box :
+    Document(pro, e, epi) -> box |[ V vs=1 [ ~pro ~e ~epi ] ]|
+
+  xml-to-box :
+    Prologue(xmldec, miscs, doctype) -> box |[ V vs=0 [ ~*lines ] ]|
+      where <concat> 
+              [ <get-prolog-lines> xmldec
+              , miscs
+              , <get-prolog-lines> doctype ] => lines
+
+      get-prolog-lines: Some(xmldec at XMLDecl(_, _, _)) -> [xmldec]
+      get-prolog-lines: None() -> []
+      get-prolog-lines: Some(DocTypePrologue(doctype, miscs)) -> [doctype | miscs]
+
+// XMLDecl(VersionDecl(Version("1.0")),Some(EncodingDecl(Encoding("UTF-8"))),Some(StandaloneDecl(Standalone("no")))
+
+  xml-to-box:
+    Epilogue(miscs) ->  box |[ V vs=1 [ ~*miscs ] ]|
+
+  xml-to-box:
+    XMLDecl(version, encoding, standalone) -> box |[ H hs=1 [KW["<?xml"] ~*atts KW["?>"]] ]|
+      where <filter(?Some(<id>))> [encoding, standalone] => atts1
+          ; <map(decl-to-attribute)> [version | atts1] => atts
+
+rules
+
+  decl-to-attribute :
+    StandaloneDecl(Standalone(value)) -> SimpleAttribute("standalone", value)
+
+  decl-to-attribute :
+    VersionDecl(Version(value)) -> SimpleAttribute("version", value)
+
+  decl-to-attribute :
+    EncodingDecl(Encoding(value)) -> SimpleAttribute("encoding", value)
+
+overlays
+
+  SimpleAttribute(name, value) =  Attribute(QName(None(), name), DoubleQuoted([Literal(value)]))
+
+rules
+
+  xml-to-box:
+    DocTypePrologue(doctype, miscs) -> box |[ V vs=1 [ ~*[doctype | miscs] ] ]|
+
+  xml-to-box:
+    DocTypeDecl(n, ext) -> box |[ H hs=1 [KW["<!DOCTYPE"] ~n ~ext KW[">"]] ]|
+  
+  xml-to-box:
+    SystemExternalID(n) -> box |[ H hs=1 [KW["SYSTEM"] ~lit:<double-quote> n] ]|
+
+  xml-to-box:
+    PublicExternalID(n1, n2) -> box |[ H hs=1 [KW["PUBLIC"] ~lit:<double-quote> n1 ~lit:<double-quote> n2 ] ]|
+
+  xml-to-box:
+    PI(n, data) -> box |[ H hs=1 [KW["<?"] ~lit:n ~lit:data KW["?>"]] ]|
+
+  xml-to-box: Comment(cdata)       -> box |[ C[ ~lit:cdata ] ]|
+  xml-to-box: Text(parts)          -> box |[ H hs=0 [~*parts ] ]|
+  xml-to-box: CDATASection(cdata)  -> box |[ H hs=0 [ "<![CDATA[" ~lit:cdata "]]>"] ]|
+  xml-to-box: EntityRef(ncname)    -> box |[ H hs=0 [ "&" ~lit:ncname ";"] ]|
+  xml-to-box: Literal(cdata)       -> box |[ ~lit:cdata ]|
+
+  xml-to-box =
+    simple-element-to-box <+ element-to-box
+
+  simple-element-to-box:
+    EmptyElement(qname, []) -> box |[ H hs=0 [KW["<"] ~qname KW["/>"]] ]|
+
+  element-to-box:
+    EmptyElement(qname, atts) -> box |[ H hs=0 [KW["<"] H hs=1 [~qname ~*atts ] KW["/>"]] ]|
+
+/*
+  simple-element-to-box:
+    Element(qname, atts, [Text(cdata)], _) -> box |[ H hs=0 [ ~open-tag ~lit:cdata  KW["</"] ~qname KW[">"]] ]|
+//      where <lt> (<string-length> cdata, 60)
+          where <open-tag-to-box> (qname, atts) => open-tag
+  */
+
+
+  element-to-box:
+    Element(qname, atts, children, _) ->
+      box |[ H hs=0 [~open-tag  ~*children KW["</"] ~qname KW[">"]] ]|
+        where <open-tag-to-box> (qname, atts) => open-tag
+    
+/*   
+  beauty-element-to-box:
+    Element(qname, atts, children, _) ->
+      box |[ V vs=0 [
+        V is=2 vs=0 [
+          ~open-tag
+          ~*children
+        ]
+        H hs=0 [KW["</"] ~qname KW[">"]]
+      ] ]|
+    where <open-tag-to-box> (qname, atts) => open-tag
+*/
+        open-tag-to-box:
+          (qname, []) -> box |[ H hs=0 [KW["<"] ~qname KW[">"]] ]|
+      
+        open-tag-to-box:
+          (qname, atts) -> box |[ H hs=0 [KW["<"] H hs=1 [ ~qname ~*atts ] KW[">"]] ]|
+            where <gt> (<length> atts, 0)
+      
+  xml-to-box :
+    Attribute(qname, value) -> box |[ H hs=0 [~qname KW["="] ~value] ]|
+
+  xml-to-box :
+    DoubleQuoted(parts) -> box |[ H hs=0 ["\"" ~*parts "\""] ]|
+
+  xml-to-box :
+    SingleQuoted(parts) -> box |[ H hs=0 ["\'" ~*parts "\'"] ]|
+
+
+  xml-to-box:
+    QName(None(), n) -> box |[ KW[ ~lit:n ] ]|
+
+  xml-to-box:
+    QName(Some(Prefix(p)), n) -> box |[ H hs=0 [~lit:p KW[":"] ~lit:n] ]|

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/tools/strategoxt-xtc-tools.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/tools/strategoxt-xtc-tools.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,82 @@
+module strategoxt-xtc-tools
+
+/**
+ * asfix
+ */
+strategies
+
+  xtc-implode-asfix =
+    xtc-transform(!"implode-asfix", pass-verbose)
+
+  xtc-asfix-yield =
+    xtc-transform(!"asfix-yield", pass-verbose)
+
+/**
+ * gpp/box
+ */
+strategies
+
+  xtc-abox-format =
+    xtc-transform(!"abox-format", pass-verbose)
+
+  xtc-ast2abox(pps) =
+    xtc-transform(!"ast2abox",
+      <conc> (
+        <pass-verbose> ()
+      , <pps; map(xtc-find); <add-arg-flags> ("-p", <id>)> ()
+      )
+    )
+
+  xtc-abox2text =
+    xtc-transform(!"abox2text", pass-verbose)
+
+  xtc-abox2text(width) =
+    xtc-transform(!"abox2text", <conc> (["--width", <width; int-to-string> ()], <pass-verbose> ()))
+
+  xtc-parse-pp-table =
+    xtc-transform(!"parse-pp-table")
+
+/**
+ * sglr
+ */
+strategies
+
+  xtc-sglr(tbl) =
+    xtc-transform(!"sglr", !["-2A", "-p", <tbl; xtc-find> () | <pass-v-verbose> ()])
+
+  xtc-sglr(tbl, sort) =
+    xtc-transform(!"sglr", !["-2A", "-p", <tbl; xtc-find> (), "-s", <sort> () | <pass-v-verbose> ()])
+
+/**
+ * sglri
+ */
+strategies
+
+  xtc-sglri(|tbl) =
+    xtc-transform(!"sglri", !["-p", <xtc-find> tbl | <pass-verbose> ()])
+
+  xtc-sglri(|tbl, sort) =
+    xtc-transform(!"sglri", !["-p", <xtc-find> tbl, "--start", sort | <pass-verbose> ()])
+
+/**
+ * stratego
+ */
+strategies
+
+  xtc-pp-astratego =
+      xtc-stratego-ensugar
+    ; xtc-ast2abox(!["Stratego-pretty.pp"])
+    ; xtc-abox2text
+
+  xtc-stratego-ensugar = 
+    xtc-transform(!"stratego-ensugar", pass-verbose)
+
+  /* tools */
+
+  pass-v-verbose =
+      ![]; if-verbose3(!["-v"])
+
+  // :: String * [String] -> [String]
+  add-arg-flags =
+       \ (_   , []    ) -> [] \
+    <+ \ (flag, values) -> [flag | <<separate-by> (flag, <id>)> values ] \

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/xtc.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/lib/xtc/xtc.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,41 @@
+module sdf/tool/xtc
+imports
+  strategoxt-xtc-tools
+
+strategies      
+
+  xtc-parse-sdf2-module =
+    xtc-parse-sdf2(|"Module")
+
+  xtc-parse-sdf2-definition =
+    xtc-parse-sdf2(|"SDF")
+
+strategies
+
+  xtc-parse-sdf2 =
+      xtc-sglri(|"Sdf2.baf")
+    ; xtc-transform(!"sdf-desugar", pass-verbose)
+
+  xtc-parse-sdf2(|sort) =
+      xtc-sglri(|"Sdf2.baf", sort)
+    ; xtc-transform(!"sdf-desugar", pass-verbose)
+
+strategies    
+    
+  xtc-pp-sdf2 =
+      xtc-transform(!"sdf-ensugar", pass-verbose)
+    ; xtc-transform(!"core-sdf-parenthesize", pass-verbose)
+    ; xtc-ast2abox(!["Sdf2.pp.af"])
+    ; xtc-abox2text
+
+strategies
+
+  /**
+   * Normalizes an SDF syntax definition to a grammar.
+   *
+   * Result is in desugared abstract syntax.
+   */
+  xtc-sdf2-normalize(|main) =
+      xtc-transform(!"sdf2table", !["-n", "-m", main | <pass-v-verbose>])
+    ; xtc-transform(!"implodePT", pass-v-verbose)
+    ; xtc-transform(!"sdf-desugar", pass-verbose)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/SpoofaxGenerator.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/SpoofaxGenerator.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,4 @@
+module SpoofaxGenerator
+
+imports sdf2imp/main
+ 
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/RTG.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/RTG.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,45 @@
+module sdf2imp/lib/RTG
+
+signature
+  constructors
+    Labelled   : Term * AnnoTreeFN -> Labelled
+    Ref        : NonTerm -> TreeFN
+    Appl       : Term * List(AnnoTreeFN) -> TreeFN
+    Annotated  : TreeFN * List(Labelled) -> AnnoTreeFN
+               : TreeFN -> AnnoTreeFN
+    ProdRule   : NonTerm * List(AnnoTreeFN) -> ProdRule
+    ProdRules  : List(ProdRule) -> ProdRules
+    Start      : List(NonTerm) -> Start
+    RTG        : Start * ProdRules -> RTG
+    Generated  : TreeFN -> NonTerm
+    Set        : List(NonTerm) -> NonTerm
+    Int        : NonTerm
+    String     : NonTerm
+    Nonterm    : Id -> NonTerm
+    IntTerm    : Term
+    StringTerm : Term
+    NoneTerm   : Term
+    SomeTerm   : Term
+    TupleTerm  : IntConst -> Term
+    NilTerm    : Term
+    ConsTerm   : Term
+    ConcTerm   : Term
+    Term       : Id -> Term
+               : String -> IntConst
+    EscapeSeq  : Int -> QuotedIdPart
+    Chars      : String -> QuotedIdPart
+    Quoted     : List(QuotedIdPart) -> Id
+    Plain      : String -> Id
+
+
+signature
+  constructors
+    Some : a -> Option(a)
+    None : Option(a)
+
+
+signature
+  constructors
+    Cons : a * List(a) -> List(a)
+    Nil  : List(a)
+    Conc : List(a) * List(a) -> List(a)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/asfix-abstractions.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/asfix-abstractions.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,114 @@
+module asfix-abstractions
+imports
+  AsFix
+  Sdf2
+  asfix-extra
+
+signature
+constructors
+   ConcLayout: Layout -> Conclayout
+   'id : a -> a
+
+/**
+ * Lists
+ */
+overlays
+
+  conc-prod(s) = 
+    prod([cf(iter(s)),cf(opt(layout())),cf(iter(s))],cf(iter(s)),no-attrs())
+
+  iter-inj-prod(s) =
+    prod([cf(s)], cf(iter(s)), no-attrs())
+
+  af-iter-inj(s, x) =
+    appl(iter-inj-prod(s), [x])
+
+  af-conc(s,x,l,y) = 
+    appl(conc-prod(s), [x, l, y])
+
+/**
+ * START and LAYOUT
+ */
+overlays
+
+  flatlit(str) = flatlex(lit(str), str)
+
+  white(str) = flatlex(cf(opt(layout())), str)
+
+  start(s,l1,x,l2) =       
+    appl(prod([cf(opt(layout())),cf(sort(s)),cf(opt(layout()))],
+              sort("<START>"),no-attrs()),
+         [l1,x,l2])
+
+  CfLayout(l) =
+     appl(prod([lex(layout())], cf(layout()), no-attrs()), [l])
+
+  ConcCfLayout(l1, l2) = 
+     appl(prod([cf(layout()), cf(layout())], cf(layout()), attrs([assoc(left())])), [l1, l2])
+
+  NoCfLayout = 
+     appl(prod([], cf(opt(layout())), no-attrs()), [])
+     
+  CfOptLayout(l) =
+     appl(prod([cf(layout())], cf(opt(layout())), no-attrs()), [l])
+
+  Space =
+    CfLayout(appl(prod([char-class([range(9,10),13,32])],lex(layout()),attrs([prefer()])), [32]))
+
+  NewLine =
+    CfLayout(appl(prod([char-class([range(9,10),13,32])],lex(layout()),attrs([prefer()])), [10]))
+
+  OptNewLine =
+     CfOptLayout(NewLine())
+
+strategies
+
+  yield = rec x(appl(id, map(x)); \ appl(p, ts) -> <concat> ts \
+                <+ \ flatlex(_, str) -> <explode-string> str \
+	        <+ \ a -> [a] \ ); 
+          implode-string
+
+rules
+
+  flatten : appl(prod(_,srt,_), ts) -> flatlex(srt, str)
+	    where yield => str
+
+  flatten : flatlex(srt,str) -> flatlex(srt,str)
+
+  lit-tree :
+    str -> appl(prod(char-sorts, lit(str), no-attrs()), chars)
+    where <explode-string> str => chars;
+          <map( \c -> char-class([c])\ )> chars => char-sorts
+
+  conc-layout1 : 
+    (CfOptLayout(l1), CfOptLayout(l2)) -> 
+    CfOptLayout(ConcCfLayout(l1, l2))
+
+  conc-layout2 : 
+    (NoCfLayout(), l) -> l
+
+  conc-layout3 : 
+    (l, NoCfLayout()) -> l
+
+strategies
+
+  conc-layout = conc-layout1 <+ conc-layout2 <+ conc-layout3
+
+rules
+
+  UnStart : start(s,l1,x,l2) -> (l1, x, l2)
+
+  CombineLayout(s1,s2) : 
+    ((l1, x, l2), (l3, y, l4)) -> 
+    (l1, <s1> (x, <s2>(l2, l3), y), l4)
+
+strategies
+
+  concat-layout =
+    foldr1a(conc-layout <+ !ConcLayout(<id>))
+
+  foldr1a(s) =
+    rec f( 
+       \ [x] -> x \
+    <+ \ [a,b|xs] -> <f>[<s>(a, b)|xs] \
+    )

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/core-sdf-grammar2rtg.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/core-sdf-grammar2rtg.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-rtg")])
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/core-sdf-grammar2rtg.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/core-sdf-grammar2rtg.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,621 @@
+/**
+ * Converts a normalized SDF grammar in abstract syntax to an RTG in abstract syntax.
+ *
+ * @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ */
+module lib/sdf2imp/core-sdf-grammar2rtg
+imports
+  libstratego-lib
+  libstratego-rtg
+  libstratego-sdf
+  xtc
+  libstratego-xtc
+
+strategies
+
+  /**
+   * @type  Grammar -> RTG
+   */
+  core-sdf-grammar2rtg =
+    where(
+      <table-create> "generated-nonterms"
+    )
+  ; where(
+      collect-om(?syntax(_))
+    ; map(grammar2prodrules <+ fatal-err(|"sdf2rtg: Rewriting syntax section failed"); fail)
+    ; concat
+    ; if ?[] then
+        fatal-err-msg(|"No production rules in RTG. Did you specify the right main module?")
+      else
+        ?prods
+      end
+    )
+
+    /**
+     * @todo  use start symbols of SDF
+     */
+  ; collect-om(is-start-prod)
+  ; if ?[] then
+      fatal-err(|"No start productions found. Did you specify any start-symbols in the syntax definition?")
+    else
+      map(start-prod2tree; ?Ref(<id>) <+ err(!"Rewriting production to nonterm failed"); fail)
+    ; !RTG(Start(<id>), ProdRules(prods))
+    end
+
+
+/**
+ * @type  Grammar -> List(ProdRule)
+ */
+strategies
+
+  grammar2prodrules :
+    syntax(prods) ->
+      < remove-all(ignore-prod)
+      ; map({p:
+          ?p
+        ; (  listinj2prodrule
+          <+ seq2prodrule
+          <+ alt2prodrule
+          <+ var2prodrule
+          <+ opt2prodrule
+          <+ inj2prodrule
+          <+ prod2prodrule
+          <+ fatal-err(|"sdf2rtg: Rewriting production failed"); fail
+          )
+        ; where(try(<cycle-error> (p, <id>)))
+        })
+      ; remove-all(?[])
+      > prods
+
+  grammar2prodrules =
+    ?context-free-syntax(_)
+    ; fatal-err(|"context-free syntax in input hasn't been normalized to syntax")
+
+  grammar2prodrules =
+    ?lexical-syntax(_)
+    ; fatal-err(|"lexical syntax in input hasn't been normalized to syntax")
+
+  cycle-error =
+    ?(p, rtg |[ A -> A ]|)
+    ; <fatal-err(|"production rule resulted in a direct cycle")> p
+
+strategies
+
+  /**
+   * Ignore layout productions.
+   *
+   * @type Production ->? _
+   */
+  ignore-prod =
+    ?prod(_, cf(layout()), _)
+
+  ignore-prod =
+    ?prod(_, cf(opt(layout())), _)
+
+  /**
+   * Ignore lexical productions.
+   */
+  ignore-prod =
+    ?prod(_, lex(_), _)
+
+  ignore-prod = 
+    ?prod(_,lit(_), _)
+
+  ignore-prod = 
+    ?prod(_,ci-lit(_), _)
+
+  ignore-prod =
+    ?prod([lex(iter-star(char-class(_)))], cf(iter-star(char-class(_))), _)
+
+  ignore-prod =
+    ?prod([lex(_)],  sym, _)
+    ; where(<oncetd(?char-class(_))> sym)
+
+  /*
+  cf(alt(
+       char-class(simple-charclass(present(conc(range(numeric("\\0"),numeric("\\92")),range(numeric("\\94"),numeric("\\255"))))))
+     , alt(sort("CloseBracket"),sort("TwoCloseBrackets"))
+     )
+  )*/
+
+
+  /**
+   * Ignore syntax -> context-free injections
+   */
+  ignore-prod =
+    ?prod([a],  cf(a), _)
+
+  /**
+   * Ignore varsym -> context-free injections
+   */
+  ignore-prod =
+    ?prod([varsym(cf(a))], cf(a), _)
+
+  /**
+   * Ignore lit -> lit | lit | lit productions
+   */
+  ignore-prod =
+    ?prod([lit(_)], cf(alt(lit(_), more)),attrs([]))
+    ; where(
+        <rec rec(lit(id) + alt(rec, rec))> more
+      )
+
+  ignore-prod =
+    ?prod([start()], sort("SURROGATE-START"), _)
+
+  ignore-prod =
+    ?prod(_, file-start(), _)
+
+  /**
+   * Ignore a reject production that injects A into A.
+   */
+  ignore-prod =
+    ?prod(_, _, attrs(attrs)); where(<contains-reject> attrs)
+
+
+  /**
+   * Ignore aux. productions
+   */
+  ignore-prod =
+    ?prod(_, _, attrs(attrs)); where(<contains-rtg(?ignore())> attrs)
+
+  /**
+   * Ignore a bracket production that injects A into A.
+   */
+  ignore-prod =
+    prod(?syms, cf(match-sort(?x)), ?attrs(attrs))
+    ; where(
+        <contains-bracket> attrs
+      ; <not(get-cnstr-name)> attrs
+      ; <syms2trees> syms => [ rtg |[ x ]| ]
+      )
+
+  match-sort(s) =
+    sort(s)
+
+  match-sort(s) =
+    parameterized-sort(s, id)
+
+  ignore-prod =
+    is-start-prod
+
+  is-start-prod =
+    ?prod(_, start(), _)
+
+  start-prod2tree :
+    prod(syms, start(), _) -> t
+      where <syms2trees> syms => [t]
+
+strategies
+
+  /**
+   * Rewrites a context-free production with a constructor.
+   *
+   * @type Production -> ProdRule
+   */
+  prod2prodrule :
+    p at prod(syms, sym, attrs(attrs)) -> result
+    where
+        <sym2nonterm> sym => A
+      ; <syms2trees> syms => t*
+      ; if y := <get-cnstr-name> attrs then
+          !rtg |[ A -> y(t*) ]|
+        else
+          //log-prod(|Error(), "No constructor name specified in production:", p)
+          //;    log(|Error(), "Resolution: please add a cons attribute to this production.")
+          //; if-verbose1(log(|Error(), "Production in abstract syntax: ", p))
+          //; if <get-config> IgnoreMissingCons() then
+              ![]
+            //else
+            //  // FIXME SDF: http://sjofar.sen.cwi.nl:8080/show_bug.cgi?id=660
+            //     <?prod([sort("Label"), lit(_), sort("Symbol")], sort("Symbol"), _)> p
+            //     ; ![]
+            //
+            //  <+ <?prod([sort("Symbol"),lit(_),sort("Symbol")],sort("Symbol"), _)> p
+            //     ; ![]
+            // 
+            //  <+ <xtc-exit> 1
+            //end
+         end
+       ; ?result
+
+/**
+ * Injections
+ */
+rules
+
+  /**
+   * Rewrites an context-free or lexical injection.
+   *
+   * The lhs must be a simple non-terminal reference.
+   */
+  inj2prodrule :
+    prod([inj], sym, attrs(attrs)) -> rtg |[ A -> t ]|
+      where not(<get-cnstr-name> attrs)
+          ; <sym2tree> inj => t
+          ; <sym2nonterm> sym => A
+
+  /**
+   * Rewrite a bracket production which is not a 'real' injection.
+   */
+  inj2prodrule :
+    prod(syms, cf(<match-sort(?x)>), attrs(attrs)) -> rtg |[ x -> A ]|
+      where <contains-bracket> attrs
+          ; <not(get-cnstr-name)> attrs
+          ; <syms2trees> syms => [ rtg |[ A ]| ]
+
+/**
+ * Sequence
+ */
+rules
+
+  /**
+   * syms -> (syms)
+   */
+  seq2prodrule :
+    prod(syms, nt, _) -> rtg |[ x -> <(i)> (t*) ]|
+      where <is-seq-symbol> nt
+          ; <get-nonterm-of> nt => x
+          ; <syms2trees> syms => t*
+          ; <length; int-to-string> t* => i
+
+/**
+ * Alternatives
+ */
+rules
+
+  alt2prodrule :
+    prod(syms, nt, _) -> rtg |[ x -> t ]|
+      where <is-alt-symbol> nt
+          ; <get-nonterm-of> nt => x
+          ; <syms2trees> syms => [t]
+
+/**
+ * Iteration
+ */
+rules
+
+  /**
+   *  A+ -> A* 
+   */
+  listinj2prodrule :
+    prod([s1 at cf(iter(a))], s2 at cf(iter-star(a)), _) -> rtg |[ x2 -> x1 ]|
+      where <get-nonterm-of> s1 => x1
+          ; <get-nonterm-of> s2 => x2
+
+  /**
+   * -> A* 
+   * -> {A lit}* 
+   */
+  listinj2prodrule :
+    prod([], sym, _) -> rtg |[ x -> <nil>() ]|
+      where <is-list-symbol> sym
+          ; <get-nonterm-of> sym => x
+
+  /**
+   *  A -> A+
+   */
+  listinj2prodrule :
+    prod([cf(a)], cf(iter(a)), _) -> rtg |[ x1 -> <cons> (t, x2) ]|
+      where <sym2tree> cf(a) => t
+          ; <get-nonterm-of> cf(iter(a)) => x1
+          ; <get-nonterm-of> cf(iter-star(a)) => x2
+
+  /**
+   *  A -> A+
+   */
+  listinj2prodrule :
+    prod([a], iter(a), _) -> rtg |[ x1 -> <cons> (t, x2) ]|
+    where
+        <sym2tree> a => t
+      ; <get-nonterm-of> iter(a) => x1
+      ; <get-nonterm-of> iter-star(a) => x2
+
+/**
+ * Iteration with Separator
+ * Currently only separators that do not occur in the AST are supported.
+ */
+rules
+
+  /**
+   * {A lit}* lit  {A lit}+ -> {A lit}+
+   */
+  listinj2prodrule :
+    prod(syms, nt, _) -> rtg |[ x -> <conc> (y, z) ]|
+      where <is-list-symbol> nt
+          ; <get-nonterm-of> nt => x
+          ; <filter(not(is-empty-sym)); map(is-list-symbol; get-nonterm-of)> syms => [y, z]
+
+  /**
+   *  {A lit}+ -> {A lit}* 
+   */
+  listinj2prodrule :
+    prod([s1 at cf(iter-sep(a, sep))], s2 at cf(iter-star-sep(a, sep)), _) -> rtg |[ x2 -> x1 ]|
+      where <is-empty-sym> sep
+          ; <get-nonterm-of> s1 => x1
+          ; <get-nonterm-of> s2 => x2
+
+  /**
+   *  A -> {A lit}+
+   */
+  listinj2prodrule :
+    prod([cf(a)], nt at cf(iter-sep(a, sep)), _) -> rtg |[ x -> <cons> (t, x2) ]|
+      where <is-empty-sym> sep
+          ; <sym2tree> cf(a) => t
+          ; <get-nonterm-of> nt => x
+          ; <get-nonterm-of> cf(iter-star-sep(a, sep)) => x2
+
+/**
+ * Alternative
+ */
+rules
+
+  /**
+   *  A -> A?
+   */
+  opt2prodrule :
+    prod([cf(A)], nt at cf(opt(A)), _) -> rtg |[ x -> <some> (t) ]|
+      where <sym2tree> A => t
+          ; <get-nonterm-of> nt => x
+
+  /**
+   *  -> A?
+   */
+  opt2prodrule :
+    prod([], cf(opt(a)), _) -> rtg |[ x -> <none> () ]|
+      where <get-nonterm-of> cf(opt(a)) => x
+
+/**
+ * Variables
+ */
+rules
+
+  var2prodrule :
+    prod(_, varsym(sym), _) -> rtg |[ x -> meta-var(<string>) ]|
+      where <sym2nonterm> sym => x
+
+strategies
+
+  get-nonterm-of =
+   ?key
+   ; is-nonterm-generator
+   ; (  <table-get> ("generated-nonterms", key)
+     <+ <table-get> ("generated-nonterms", cf(key))
+     <+ <table-get> ("generated-nonterms", <?cf(<id>)> key)
+     <+ sdf-symbol-to-string
+        ; where(<table-put> ("generated-nonterms", key, <id>))
+     )
+
+  is-seq-symbol =
+      cf(is-seq-symbol)
+    + seq(id, is-list)
+
+  is-alt-symbol = 
+      cf(is-alt-symbol)
+    + alt(id, id)
+     
+  is-list-symbol = 
+      cf(is-list-symbol)
+    + iter-star-sep(id, id)
+    + iter-sep(id, id)
+    + iter-star(id)
+    + iter(id)
+
+  is-nonterm-generator = 
+      is-list-symbol
+    + is-seq-symbol
+    + is-alt-symbol
+    + cf(is-nonterm-generator)
+    + opt(id)
+    + varsym(id)
+
+strategies
+
+  /**
+   * @type List(Symbol) -> List(AnnoTreeFN)
+   */
+  syms2trees =
+      filter(not(is-empty-sym))
+    ; map(sym2tree)
+
+  /**
+   * @type  Symbol -> Symbol
+   */
+  is-empty-sym = ?lit(_)
+  is-empty-sym = ?ci-lit(_)
+  is-empty-sym = ?layout()
+  is-empty-sym = opt(is-empty-sym)
+  is-empty-sym = cf(is-empty-sym)
+  is-empty-sym = lex(is-empty-sym)
+  is-empty-sym = label(id, is-empty-sym)
+
+/**
+ * @type  Symbol -> AnnoTreeFN
+ */  
+strategies
+
+  sym2tree :
+    sym -> rtg |[ A ]|
+      where <sym2nonterm> sym => A
+
+  sym2tree:
+    cf(sym) -> <sym2tree> sym
+      where <not(is-nonterm-generator)> cf(sym)
+
+  sym2tree:
+    lex(sym) -> rtg |[ <string> ]|
+
+  sym2tree:
+    char-class(_) -> rtg |[ <int> ]|
+
+  sym2tree:
+    label(_,sym) -> <sym2tree> sym
+
+  sym2tree:
+    sym -> rtg |[ x ]|
+      where <get-nonterm-of> sym => x
+
+rules
+
+  sym2nonterm :
+    sym -> rtg nonterm |[ x ]|
+      where <get-nonterm-of> sym => x
+
+  sym2nonterm =
+    sort2nonterm
+
+  sym2nonterm =
+    ?cf(<sort2nonterm>)
+
+  sort2nonterm :
+    sort(x) -> rtg nonterm |[ x ]|
+
+  sort2nonterm :
+    parameterized-sort(x, params) -> rtg nonterm |[ y ]|
+    where
+      Symbol2String => y
+
+strategies
+
+  /**
+   * @type  List(Attribute) -> String
+   */
+  get-cnstr-name =
+    fetch-elem(
+      ?default(term(cons(<id>)))
+
+      // FIXME SDF: used for old SDF
+      <+ ?term(cons(<id>))
+    )
+
+  /**
+   * @type  List(Attribute) ->? _
+   */
+  contains-bracket =
+    fetch(?bracket())
+
+  /**
+   * @type  List(Attribute) ->? _
+   */
+  contains-reject =
+    fetch(?reject())
+
+  /**
+   * @type  List(Attribute) ->? _
+   */
+  contains-rtg(s) =
+    fetch(term(rtg(where(s))))
+
+strategies
+
+  err(s) = log(|Error(), <s> (), <id>)
+  dbg(s) = log(|Debug(), <s> (), <id>)
+
+strategies
+
+  sdf-symbol-to-string =
+    Symbol2String
+    ; newname
+    <+ log-sym(|Warning(), "Cannot generate a nice name for symbol", <id>)
+     ;     log(|Warning(), "  Please report this bug at ")
+     ;     log(|Warning(), "    - https://bugs.cs.uu.nl/browse/STR")
+     ;     log(|Warning(), "    - or martin.bravenboer at gmail.com")
+     ; new
+     ;     log(|Warning(), "  Resolution: falling back to the ugly name ", <id>)
+
+  Symbol2String :
+    cf(sym) -> <Symbol2String> sym
+
+  Symbol2String :
+    lex(sym) -> <Symbol2String> sym
+
+  /**
+   * @todo  This could be improved by using quoted identifiers.
+   */
+  Symbol2String :
+    char-class(_) -> "CharClass"
+
+  /**
+   * @todo  This could be improved by using quoted identifiers.
+   */
+  Symbol2String :
+    lit(_) -> "Lit"
+
+  Symbol2String :
+    ci-lit(_) -> "CaseInsensitiveLit"
+
+  Symbol2String :
+    iter(sym) -> <conc-strings> ("ListPlusOf", <Symbol2String> sym)
+
+  Symbol2String :
+    iter-star(sym) -> <conc-strings> ("ListStarOf", <Symbol2String> sym)
+
+  Symbol2String :
+    iter-sep(sym, sep) -> <conc-strings> ("ListPlusOf", <Symbol2String> sym)
+
+  Symbol2String :
+    iter-star-sep(sym, sep) -> <conc-strings> ("ListStarOf", <Symbol2String> sym)
+
+  Symbol2String :
+    sort(s) -> s
+    where
+      <is-string> s
+
+  Symbol2String :
+    parameterized-sort(x, params)  -> <concat-strings> [x, "_" | param-string]
+    where
+      <is-string> x
+      ; <map(Symbol2String)> params => param-string
+
+  Symbol2String :
+    label(_,sym) -> <Symbol2String> sym
+
+  Symbol2String :
+    opt(sym) -> <conc-strings> ("Opt", <Symbol2String> sym)
+
+  Symbol2String :
+    seq(sym, syms) ->
+      < filter(not(?lit(_) + ?ci-lit(_)))
+      ; map(Symbol2String)
+      ; <separate-by> ("_", <id>)
+      ; concat-strings
+      > [sym | syms]
+
+  Symbol2String :
+    alt(sym1, sym2) -> <concat-strings> [<Symbol2String> sym1, "_", <Symbol2String> sym2]
+
+strategies
+
+  log-sym(|severity, msg, sym) =
+    log-prod(|severity, msg, sym)
+
+  /**
+   * @todo Use libgpp
+   */
+  log-prod(|severity, msg, prod) =
+    where(
+      xtc-temp-files(
+        !prod
+      ; write-to
+      ; xtc-pp-sdf2
+      ; ?FILE(<read-text-file; trim-chars('\n' + '\r' + ' ' + '\t'); string-as-chars(filter(not('\n' + '\r')))>)
+      ; ?prodtxt
+      )
+    ; log(|severity, msg)
+    ; log(|severity, <conc-strings> ("  ", prodtxt))
+    )
+
+signature
+  constructors
+    rtg    : rtginfo -> rtg
+    ignore : rtginfo
+
+
+    /**
+     * FIXME: bootstrap problem
+
+    cilit : String -> Tree
+
+    // WTF?
+    ci-lit : String -> Tree
+     */

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/debug.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/debug.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,129 @@
+/**
+ * Debugging strategies, originally defined in dryad-compiler/lib-ext/debug.
+ *
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+module sdf2imp/lib/debug // dryad-compiler/lib-ext/debug
+
+overlays
+  MAX_TINY_LIST_PARTS         = 3
+  MAX_TINY_LIST_PARTS_1       = 4 // += 1
+  MAX_TINY_LIST_PARTS_COMMAS  = 6 // *= 2
+
+strategies
+
+  /**
+   * Writes a message to the standard output, without failing or changing the current term.
+   * Only executed if the verbosity level is 2.
+   */
+  verbose-msg(a) =
+    where(if-verbose2(<debug> <as-string(a)>))
+
+  verbose-msg(a, b) =
+    where(if-verbose2(<verbose-msg> [<as-string(a)>, <as-string(b)>]))
+
+  verbose-msg(a, b, c) =
+    where(if-verbose2(<verbose-msg> [<as-string(a)>, <as-string(b)>, <as-string(c)>]))
+
+  verbose-msg(a, b, c, d) =
+    where(if-verbose2(<verbose-msg> [<as-string(a)>, <as-string(b)>, <as-string(c)>,
+                      <as-string(d)>]))
+
+  verbose-msg(a, b, c, d, e) =
+    where(if-verbose2(<verbose-msg> [<as-string(a)>, <as-string(b)>, <as-string(c)>,
+                     <as-string(d)>, <as-string(e)>]))
+
+  verbose-msg(a, b, c, d, e, f) =
+    where(if-verbose2(<verbose-msg> [<as-string(a)>, <as-string(b)>, <as-string(c)>,
+                     <as-string(d)>, <as-string(e)>, <as-string(f)>]))
+
+  verbose-msg(a, b, c, d, e, f, g) =
+    where(if-verbose2(<verbose-msg> [<as-string(a)>, <as-string(b)>, <as-string(c)>,
+                     <as-string(d)>, <as-string(e)>, <as-string(f)>, <as-string(g)>]))
+
+  verbose-msg(a, b, c, d, e, f, g, h) =
+    where(if-verbose2(<verbose-msg> [<as-string(a)>, <as-string(b)>, <as-string(c)>,
+                     <as-string(d)>, <as-string(e)>, <as-string(f)>, <as-string(g)>,
+                     <as-string(h)>]))
+
+  as-string(s) = s; as-string <+ !"<?>"
+
+  as-string = is-string <+ write-to-string
+
+  verbose-msg = 
+    if-verbose2(
+      map(is-string <+ write-to-string);
+      separate-by(|" ");
+      concat-strings;
+      debug
+    )
+  
+  with(s) = where(verify(s, !"Internal error: with clause failed unexpectedly"))
+
+  verify(s) =
+    ?input; verify(s, !"Internal error: failure unexpected")
+
+  verify(s,message) =
+    s
+  <+
+    log(|Critical(), <as-string(message)>, <id>);
+    prim("SSL_stacktrace_get_all_frame_names");
+    report-failure
+
+  verify(s,m1,m2) =
+    verify(s, <conc-strings> (<as-string(m1)>, " ", <as-string(m2)>))
+
+  verify(s,m1,m2,m3) =
+    verify(s, <conc-strings> (<as-string(m1)>, " ", <as-string(m2)>, " ", <as-string(m3)>))
+
+  /**
+   * Same as debug, but prints a abbreviated representation of the ATerm.
+   * @see to-tiny-string
+   */
+  tiny-debug =
+    where(to-tiny-string; debug)
+  
+  tiny-debug(prefix) = 
+    where(<conc-strings; debug> (<as-string(prefix)>, <to-tiny-string>))
+  to-tiny-string =
+    to-tiny-list;    
+    <conc-strings> ("[", <concat-strings>, "]")
+  <+
+    ?name#(<id>);
+    if [] + () then
+      <strip-annos; as-string> name
+    else
+      to-tiny-list;      
+      <conc-strings> (name, "(", <concat-strings>, ")")
+    end
+
+  to-tiny-list =
+    where(
+      try(
+        overflow-by-one := <length => MAX_TINY_LIST_PARTS_1()>
+      <+
+        overflow := <gt> (<length>, MAX_TINY_LIST_PARTS())
+      )
+    );
+    try(take(|MAX_TINY_LIST_PARTS()));
+    
+    map(to-tiny-substring);
+    separate-by(|",");      
+
+    switch id
+      case !overflow-by-one:
+        <conc> (<id>, [",_"])
+      case !overflow:
+        <conc> (<id>, [",.."])
+      otherwise:
+        id
+    end
+
+  to-tiny-substring =
+     [id]; !"[_]"
+  <+ Hd; !"[..]"
+  <+ Fst; !"(..)"
+  <+ (); !"()"
+  <+ []; !"[]"
+  <+ strip-annos; ?<as-string>#(_)
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/multi-options.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/multi-options.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,40 @@
+/**
+ * Support for implementing tools that have multiple inputs and outputs.
+ *
+ * @author Martin Bravenboer <martin at cs.uu.nl>
+ */
+module sdf2imp/lib/multi-options // dryad/lib-ext/multi-options
+
+rules
+
+  /**
+   * Handles a command-line option that allows multiple values.
+   *
+   * This strategy is similar to ArgOption, but allows multiple
+   * values. e.g. -i A.java B.java. The values are not allowed to
+   * start with a -, since the - distinguishes values from option 
+   * flags.
+   *
+   * Usage is identical to ArgOption. The handle-value will get
+   * a list of values.
+   *
+   * @type  handle-value  List(String) -> _
+   * @type  is-flag       String ->?
+   */
+  MultiArgOption(is-flag, handle-value, usage) :
+    [flag | options] -> [() | rest]
+    where
+      <is-flag> flag
+
+      ; let splitter =
+              split-fetch-keep(where(explode-string => ['-' | _]))
+              ; \ (args, next-opt, tail) -> (args, [next-opt | tail]) \
+              <+ !(<id>, [])
+
+         in <splitter> options => (args, rest)
+          ; <handle-value> args
+        end
+
+  MultiArgOption(is-flag, label, usage) =
+    "register-usage-info"
+    ; register-usage(usage)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/pack-sdf-options.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/pack-sdf-options.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,145 @@
+/**
+ * @author  Martin Bravenboer <martin.bravenboer at gmail.com>
+ */
+module pack-sdf-options
+imports
+  libstratego-lib
+  libstratego-xtc
+  strategoxt-xtc-tools
+
+/**
+ * Options
+ */
+signature
+  constructors
+    IncludeDef : String -> IncludeVal
+    IncludeDef : String * List(String, Module) -> IncludeVal
+    IncludeDir : String -> IncludeVal
+    IncludeXTC : IncludeVal
+
+  constructors
+    IncludePathName : String -> Include
+    IncludeFromPath : String -> Include
+
+strategies
+
+  pack-sdf-options =
+       include-from-dir-option
+    <+ include-from-def-option
+    <+ dep-options
+    <+ of-option
+
+  of-config = 
+    <get-config> "--output-format" <+ !"txt"
+
+  of-option =
+    OutputFormatOption(|["txt", "asfix", "ast"])
+
+  OutputFormatOption(|formats) =
+    ArgOption("-of" + "--output-format"
+    , where(
+        where(<elem> (<id>, formats))
+      ; <set-config> ("--output-format", <id>)
+      <+ <fatal-error> ["pack-sdf: ", <id>, " is not a valid output format. Supported formats: " | <separate-by> (", ", formats)]
+      )
+    , <concat-strings> ["-of f            Use output format f (", <separate-by; concat-strings> (", ", formats), ")"]
+    )
+
+  include-from-def-option =
+    ArgOption("-Idef"
+    , where(<extend-config> ("-I", [IncludeDef(<id>)]))
+    , !"-Idef <lang.def>     Include modules from SDF definition <lang.def>"
+    )
+
+  /**
+   * Read SDF definitions and add current directory and XTC to include values.
+   */
+  process-options =
+    where(
+      (<get-config> "-I" <+ ![])
+    ; map(?IncludeDef(_) < process-Idef + id)
+
+      /**
+       * XTC is the final search option
+       */
+    ; <conc> (<id>, [IncludeXTC()])
+      
+      /**
+       * The first search option is the directory of the input
+       * file, or the current directory if the input is stdin.
+       */
+    ; if <get-config> "-i" => input then
+        ![IncludeDir(<dirname> input) | <id>]
+      else 
+        ![IncludeDir(".") | <id>]
+      end
+
+    ; <set-config> ("-I", <id>)
+    )
+
+  /**
+   * @type  String -> List((String, AsFix(Module)))
+   */
+  process-Idef =
+      ?IncludeDef(def)
+    ; !FILE(def)
+    ; xtc-temp-files(
+        xtc-sglr(!"Sdf2.baf", !"SDF")
+      ; read-from
+      )
+    ; collect-om(?
+        appl(prod(_, cf(sort("Module")), attrs([term(cons("module"))])), _)
+      )
+    ; map(!(<module-to-module-name>, <id>))
+    ; where(
+        if-verbose2(
+          say(<concat-strings> ["pack-sdf: SDF Syntax Definition ", def, " provides the modules "])
+        ; map(Fst; debug(!"pack-sdf:   - "))
+        )
+      )
+    ; !IncludeDef(def, <id>)
+
+  include-from-dir-option =
+    ArgOption("-I" + "--Include"
+    , where(<extend-config>("-I", [IncludeDir(<ensure-directory>)]))
+    , !"-I|--Include <dir>   Include modules from directory <dir>"
+    )
+
+  ensure-directory =
+    if not(file-exists) then
+      debug(!"pack-sdf: warning: directory specified with -I does not exist: ")
+    else
+      if not(filemode; isdir) then
+        debug(!"pack-sdf: warning: path specified with -I is a file, not a directory: ")
+      else id end
+    end
+
+  dep-options = 
+    ArgOption("--dep"
+    , where(<set-config> ("-dep", <id>))
+    , !"--dep <file>         Write make dependencies to <file>"
+    )
+
+  /**
+   * Gets the include path from the config.
+   *
+   * The current working directory . is added to this path.
+   */
+  include-path =
+    <get-config> "-I" <+ ![]
+
+  depfile-from-config =
+    <get-config> "-dep"
+
+  maybe-create-depfile =
+    where(try(create-dep-file))
+
+  create-dep-file =
+    ?files
+    ; where(
+        <get-config> "-o" => outfile
+      ; <fopen> (<depfile-from-config> (), "w") => stream
+      )
+    ; ![outfile | <separate-by(|" \\\n\t")> [":" | files]]
+    ; map(<fputs> (<id>, stream))
+    ; <fclose> stream

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/pack-sdf.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/pack-sdf.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,399 @@
+/**
+ * pack-sdf creates an SDF definition file containing all modules imported 
+ * from the given top module.
+ *
+ * pack-sdf is an instantiation of pack-modules implemented with graph-nodes. 	
+ *
+ * @authors    Merijn de Jonge <mdejonge at cwi.nl>
+ *             Eelco Visser <visser at acm.org>
+ *             Joost Visser <jvisser at cwi.nl>
+ *             Martin Bravenboer <martin.bravenboer at gmail.com>
+ */
+module pack-sdf
+imports
+  libstratego-lib
+  libstratego-xtc
+  strategoxt-xtc-tools
+  libstratego-sglr
+  sdf2imp/lib/asfix-abstractions
+  sdf2imp/lib/pack-sdf-options
+
+/**
+ * Entry point
+ */
+strategies
+
+  main-pack-sdf =
+    xtc-io-wrap(pack-sdf-options,
+      process-options
+    ; pack-sdf(|<include-path>) => (files, spec)
+    ; <maybe-create-depfile> files
+    ; !spec
+    ; where( (<fopen> (<get-config> "-o", "w") <+ stdout-stream ) => stream ) 
+    ; (  where(of-config => "txt")   < ( asfix-yield(|stream) ; <xtc-exit>0 )
+      +  where(of-config => "ast")   < implode-asfix
+      +  where(of-config => "asfix")
+      ) ; write-to <+ <fatal-error> ["pack-sdf: ", <id>, " is not a valid output format."]
+    )
+
+/**
+ * Main strategies
+ */
+strategies
+
+  pack-sdf(|mkpt) =
+      \ FILE(s) -> IncludePathName(s) \
+    ; !(<id>, mkpt, [])
+    ; graph-nodes-undef(
+        pack-sdf-parse-sdf
+      , get-sdf-imports
+        ; map(!IncludeFromPath(<id>))
+      , \ (n,x,xs) -> [x|xs] \
+      )
+    ; if ?(_, []) then
+       Fst
+       ; unzip
+       ; (id, ConcatModules) 
+      else
+        Snd
+        ; map(report-module-not-found)
+        ; <xtc-exit> 1
+      end
+
+  report-module-not-found =
+    let get-module-name =
+          ?IncludeFromPath(<id>) + ?IncludePathName(<id>)
+
+     in get-module-name => module-name
+      ; <fprintnl> (stderr(), ["pack-sdf: error: module ", module-name, " not found"])
+      ; <bagof-ImportedFrom> module-name
+      ; if [] then
+          id
+        else if ?[mod] then
+            <get-source-pathname <+ !"unknown location"> mod
+          ; <fprintnl> (stderr(), ["    imported from module ", mod, 
+                                "\n      in file ", <id>])
+        else
+            where(<fprintnl> (stderr(), ["    imported from:"]))
+          ; map({mod1 :
+              ?mod1
+            ; (get-source-pathname <+ !"at unknown location")
+            ; <fprintnl> (stderr(),   ["      module ", mod1, 
+                                    "\n        in file ", <id>])
+            })
+          end
+        end
+      ; <fprintnl> (stderr(),   [""])
+    end
+
+  /**
+   * @type  (Include, List(IncludeVal)) -> (String, AsFix(Module))
+   */
+  pack-sdf-parse-sdf =
+    ?(<id>, includes)
+    ; ?IncludeFromPath(<id>)
+    ; guarantee-extension(|"sdf")
+    ; remove-extension
+    ; ?mod
+    ; <fetch-elem(
+         include-from-dir(|mod)
+       + include-from-def(|mod)
+       + include-from-xtc(|mod)
+       )> includes
+
+  pack-sdf-parse-sdf =
+    let qualify-pathname =
+            where(explode-string => cs)
+          ; if <is-qualified> cs then
+              id
+            else
+              <implode-string> ['.', '/' | cs]
+            end
+  
+         is-qualified =
+           ?['/' | _] + ?['.' | _ ]
+
+     in ?(<id>, _)
+      ; ?IncludePathName(<qualify-pathname>)
+      ; if file-exists then
+          if-verbose1(debug(!"  including "))
+        ; include-pathname
+        else
+          <fatal-error> ["pack-sdf: error: file ", <id>, " does not exist\n"]
+        end
+    end
+
+  include-pathname :
+    file -> (file, tree)
+      where <parse-sdf2-module-to-asfix> file => tree
+          ; get-module-name-from-asfix => mod
+          ; <register-source-pathname(|mod)> file
+
+  include-from-dir(|mod) :
+    IncludeDir(dir) -> <include-pathname> file
+      where <concat-strings; file-exists> [dir,"/", mod, ".sdf"] => file
+          ; if-verbose1(debug(!"  including "))
+          ; <parse-sdf2-module-to-asfix(|mod)> file => tree
+          ; <register-source-pathname(|mod)> file
+
+  include-from-xtc(|mod) :
+    IncludeXTC() -> (file, tree)
+      where <conc-strings; xtc-find-loc> (mod, ".sdf") => file
+          ; if-verbose1(say(<concat-strings> ["  including ", mod, " from XTC repository"]))
+          ; <parse-sdf2-module-to-asfix(|mod)> file => tree
+          ; <register-source-pathname(|mod)> file
+
+  include-from-def(|mod) :
+    IncludeDef(file, mods) -> (file, Module_START(NewLine(), tree, NewLine()))
+      where <fetch-elem(?(mod, <id>))> mods => tree
+          ; if-verbose1(say(<concat-strings> ["  including ", mod, " from ", file]))
+          ; <register-source-pathname(|mod)> file
+
+strategies
+
+  register-source-pathname(|mod) =
+    ?file
+    ; rules(SourcePathName : mod -> file)
+
+  get-source-pathname =
+    SourcePathName
+
+strategies
+
+  /**
+   * Parses SDF module and checks basename of SDF module name
+   */
+  parse-sdf2-module-to-asfix =
+    let check =
+            (<conc-strings> (<base-filename>, ".sdf"), base-filename)
+          ; eq
+     in parse-sdf2-module-to-asfix(check)
+    end
+
+  /**
+   * Parses SDF module and checks full module name.
+   */
+  parse-sdf2-module-to-asfix(|mod) =
+    let check =
+          ?(<id>, _)
+          ; <eq> (<id>, mod)
+     in parse-sdf2-module-to-asfix(check)
+    end 
+
+  /**
+   * Parses SDF module.
+   *
+   * check is applied to a tuple of (actual module name, pathname of sdf)
+   */
+  parse-sdf2-module-to-asfix(check) =
+    ?pathname
+    ; ( <parse-file-pt(|<pack-sdf-table>, "Module")> pathname
+        <   ?parsetree(<id>, _)
+          ; check-module-name(check|pathname)
+        + <fatal-error> ["pack-sdf: Error: module ", pathname, " cannot be parsed\n"]
+      )
+  
+  pack-sdf-table =
+    PackSDFTable
+  <+
+    import-term(Sdf2.baf);
+    open-parse-table;
+    rules(
+      PackSDFTable := <id>
+    )
+
+  check-module-name(check|pathname) =
+    ?ptree;
+    let get-actual-modname =
+          <get-module-name-from-asfix> ptree
+
+     in where(<get-actual-modname> () => actual)
+      ; if <check> (actual, pathname) then
+          id
+        else
+          <fatal-error> ["pack-sdf: error: module name '", actual, "' in file '", pathname, "' does not correspond to filename.\n"]
+        end
+    end
+
+  get-module-name-from-asfix = 
+      collect-om(?appl(prod(_, cf(sort("Module")), _), _))
+    ; ?[<id>]
+             // module layout ModuleName
+    ; ?appl(_, [_, _, <id> | _])
+    
+    ; collect-om(?appl(prod(_, lex(sort("ModuleId")), _), _))
+    ; ?[<id>]
+    ; asfix-lex-yield
+
+  asfix-lex-yield =
+    let F  = \ appl(p, ts) -> <concat> ts \
+        F' = \ x -> [x] \
+
+     in rec x(appl(id, map(x)); F <+ F')
+    end
+    ; implode-string
+
+strategies
+
+  get-sdf-imports = 
+    where(get-module-name-from-asfix => mod)
+    ; collect(
+          ?appl(prod(_,cf(sort("Import")),_),_)
+        ; get-module-name
+      , skip-non-imports
+      )
+    ; where(
+        map({import:
+            ?import
+          ; rules(ImportedFrom :+ import -> mod)
+        })
+      )
+    <+ debug(!"a -------------------- "); fail
+
+  skip-non-imports(search, ignore) =  
+    parsetree(search,id)
+    //<+ appl(prod(id, cf(sort("Module")),id),[id,id,id,search,id,search])
+    <+ appl(prod(id, cf(opt(layout()) <+ 
+                        sort("Productions" <+ "Symbols" <+ 
+                             "Priorities" <+ "Restrictions" <+
+                             "Aliases")), id); ignore, ignore)
+    <+ appl(ignore,search)
+
+strategies
+
+  /**
+   * Obtain module name from Import construct by removing optional parameters
+   */
+  get-module-name =
+      oncetd(?appl(prod(_,cf(sort("ModuleId")),_),_); yield => y)
+    ; !y
+
+  module-to-module-name = 
+    ?appl(prod(_, cf(sort("Module")), _), [_, _, mid | _])
+    ; <get-module-name> mid
+
+  /**
+   * Composing AsFix; The parser produces an AsFix term for each module. These
+   * have to be merged into a list of modules. This entails merging the layout
+   * at the end and start of subsequent trees. Note that the prefer longets
+   * match of laout is not considered here. This means that the layout nodes may not be
+   * equavalent to the layout nodes when parsing the resulting definition file:
+   *  
+   * parse( unparse(pack(m))) != pack(m) 
+   *
+   */
+  ConcatModules =
+   rec x(
+   {w1, w2, m, m1, m2, xs:
+      []; 
+      !(NoCfLayout(), EmptyModuleIterStar(), NoCfLayout())
+   <+ 
+      [id];
+      ?[Module_START(w1, m, w2)]; 
+      !(NoCfLayout(), M-iter(m), NoCfLayout())
+   <+
+      ?[m1,m2|xs];
+      <concat-modules>( <x>[m1], <x>[m2|xs])
+   }) => (w1, modules, w2);
+   !parsetree(SDF_START(NoCfLayout(), 
+      Definition-overlay(
+         <concat-layout>[OptNewLine(), w1], 
+         Module-s-overlay(NonEmptyModuleIterStar(modules))),w2),0)
+
+
+  concat-modules =
+    ?( (w1, m1, w2), (w3, m2, w4) );
+    !(w1, MM-iter( 
+            m1, 
+            <concat-layout>[w2, OptNewLine(), OptNewLine(), w3], 
+            m2), w4)
+
+signature
+  constructors
+    'id: Arg -> ID
+
+/**
+ * Overlays for SDF constructs
+ */
+overlays 
+
+  /**
+   * Module -> <START>
+   */
+  Module_START(w1, t, w2) =
+    appl(
+      prod(
+        [ cf(opt(layout()))
+        , cf(sort("Module"))
+        , cf(opt(layout()))
+        ]
+      , sort("<START>")
+      , no-attrs()
+      )
+    , [ w1, t, w2]
+    )
+
+  /**
+   * SDF -> <START>
+   */
+  SDF_START(w1, t, w2) =
+    appl(
+      prod(
+        [ cf(opt(layout()))
+        , cf(sort("SDF"))
+        , cf(opt(layout()))
+        ]
+      , sort("<START>")
+      , no-attrs()
+      )
+    , [w1, t, w2]
+    )
+
+  /**
+   *   -> M*
+   */
+  EmptyModuleIterStar =
+    appl(prod([],cf(iter-star(sort("Module"))),no-attrs()),[])
+
+  /**
+   * M+ -> M*
+   */
+  NonEmptyModuleIterStar(m) = 
+    appl(prod([cf(iter(sort("Module")))],cf(iter-star(sort("Module"))),no-attrs()),[m])
+
+  /**
+   * M+ M+ -> M+ {left}
+   */
+  MM-iter(m1, w, m2) =
+    appl(prod([cf(iter(sort("Module"))),cf(opt(layout())),cf(iter(sort("Module")))],
+     cf(iter(sort("Module"))),attrs([assoc(left())])),[m1, w, m2])
+
+  /**
+   * M -> M+
+   */
+  M-iter( m ) = 
+    appl(prod([cf(sort("Module"))],cf(iter(sort("Module"))),no-attrs()),[m])
+
+  /**
+   *  Module* -> Definition
+   */
+  Module-s-overlay ( g_6 ) =
+    appl ( prod ( [ cf ( iter-star ( sort ( "Module" ) ) ) ] , cf ( sort ( "Definition" ) ) , no-attrs()  ) , [ g_6 ] )
+
+  /**
+   * definition Definition -> SDF
+   */
+  Definition-overlay(b_1,c_1) = 
+  appl(prod([lit("definition"),cf(opt(layout())),cf(sort("Definition"))],cf(sort("SDF")),
+         attrs([term(cons("definition"))])),[appl(prod([
+    char-class([100]),
+    char-class([101]),
+    char-class([102]),
+    char-class([105]),
+    char-class([110]),
+    char-class([105]),
+    char-class([116]),
+    char-class([105]),
+    char-class([111]),
+    char-class([110])],lit("definition"),no-attrs()),[100,101,102,105,110,105,116,105,111,110]),b_1,c_1])
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf-desugar.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf-desugar.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,42 @@
+/**
+ * sdf-desugar implements the following desugarings:
+ *
+ *   - remove double quotes in String literals: cons, lit
+ *   - replace no-attrs by attrs([])
+ *   - add quotes to generated quoted stings
+ *
+ * @author Martin Bravenboer <martin.bravenboer at gmail.com>
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+module sdf2imp/lib/sdf-desugar
+
+imports
+  libstratego-aterm
+
+strategies
+  
+  sdf-desugar =
+      topdown(repeat(SdfDesugar); try(SdfDesugarOnce))
+
+  SdfDesugar :
+    no-attrs() -> attrs([])
+
+  SdfDesugar :
+    term(default(t)) -> term(t)
+
+rules
+
+  SdfDesugarOnce =
+    alltd(EnsureQuotes);
+    term(implode-aterm)
+
+  SdfDesugarOnce :
+    lit(s) -> lit(<un-double-quote> s)
+
+  SdfDesugarOnce :
+    ci-lit(s) -> ci-lit(<un-single-quote> s)
+  
+  EnsureQuotes :
+    quoted(s) -> quoted(<double-quote> s)
+    where
+      not(<un-double-quote> s)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf-options.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf-options.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,28 @@
+/**
+ * @todo Import sdf/tool/options and remove definitions.
+ */
+module sdf2imp/lib/sdf-options // sdf-options
+strategies
+
+  sdf-main-module-option =
+    sdf-main-module-option(!"Specify main module in sdf definition")
+
+  sdf-main-module-option(s) =
+    ArgOption("-m" + "--main"
+    , where(<set-config> (SdfMainModuleFlag(), <id>))
+    , <concat-strings> ["-m mod | --main mod   ", <s> (), " [Main]"]
+    )
+
+  pass-sdf-main-module =
+    !["--main", <get-sdf-main-module>]
+
+  get-sdf-main-module =
+    <get-config> SdfMainModuleFlag() <+ !"Main"
+
+  sdf-main-module-error =
+      say(!<concat-strings> ["** ERROR -- Specified main module (", <get-sdf-main-module> (), ") not found in definition"])
+    ; fail
+
+signature
+  constructors
+    SdfMainModuleFlag : Flag

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf2rtg.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/sdf2rtg.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,47 @@
+module lib/sdf2imp/sdf2rtg
+
+imports
+  libstratego-lib
+  libstratego-xtc
+  libstratego-tool-doc
+
+signature constructors
+  IgnoreMissingCons : Option
+
+strategies
+
+  main-sdf2rtg =
+    xtc-io-wrap(
+      sdf-main-module-option + ignore-option
+    , sdf2rtg-usage
+    , sdf2rtg-about
+    , !["sdf2table", "implodePT", "sdf-desugar"]
+    , sdf2rtg; write-to
+    )
+
+  ignore-option =
+    Option("--ignore-missing-cons"
+    , <set-config> (IgnoreMissingCons(), ())
+    , !HelpString("--ignore-missing-cons", "Ignore productions that do not have a constructor (default: produce error)")
+    )
+
+  sdf2rtg-usage =
+    <tool-doc>
+      [ Usage("sdf2rtg [OPTIONS]")
+      , Summary(
+         "Generates an abstract syntax definition in the rtg language
+          from a SDF concrete syntax definition.")
+      , OptionUsage()
+      , AutoReportBugs()
+      ]
+
+  sdf2rtg-about =
+    <tool-doc>
+      [ AutoProgram()
+      , Author(Person("Martin Bravenboer", "martin.bravenboer at gmail.com"))
+      , GNU_LGPL("2002-2008", "Stratego Software Foundation <stratego at cs.uu.nl>")
+      , Config([
+          DefaultXTCRepository()
+        , CurrentXTCRepository()
+        ]) 
+      ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/xml-doc2abox.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/xml-doc2abox.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Box")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/xml-doc2abox.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/lib/xml-doc2abox.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,135 @@
+module sdf2imp/lib/xml-doc2abox // based on xml-front
+
+imports 
+  xml-doc 
+  Box
+  libstratego-lib
+  
+strategies
+
+  main-xml-doc2abox =
+    io-wrap(xml-doc2abox)
+
+  xml-doc2abox =
+      topdown(try(repeat(xml-to-box)))
+
+rules
+
+  xml-to-box :
+    Document(pro, e, epi) -> box |[ V vs=1 [ ~pro ~e ~epi ] ]|
+
+  xml-to-box :
+    Prologue(xmldec, miscs, doctype) -> box |[ V vs=0 [ ~*lines ] ]|
+      where <concat> 
+              [ <get-prolog-lines> xmldec
+              , miscs
+              , <get-prolog-lines> doctype ] => lines
+
+      get-prolog-lines: Some(xmldec at XMLDecl(_, _, _)) -> [xmldec]
+      get-prolog-lines: None() -> []
+      get-prolog-lines: Some(DocTypePrologue(doctype, miscs)) -> [doctype | miscs]
+
+// XMLDecl(VersionDecl(Version("1.0")),Some(EncodingDecl(Encoding("UTF-8"))),Some(StandaloneDecl(Standalone("no")))
+
+  xml-to-box:
+    Epilogue(miscs) ->  box |[ V vs=1 [ ~*miscs ] ]|
+
+  xml-to-box:
+    XMLDecl(version, encoding, standalone) -> box |[ H hs=1 [KW["<?xml"] ~*atts KW["?>"]] ]|
+      where <filter(?Some(<id>))> [encoding, standalone] => atts1
+          ; <map(decl-to-attribute)> [version | atts1] => atts
+
+rules
+
+  decl-to-attribute :
+    StandaloneDecl(Standalone(value)) -> SimpleAttribute("standalone", value)
+
+  decl-to-attribute :
+    VersionDecl(Version(value)) -> SimpleAttribute("version", value)
+
+  decl-to-attribute :
+    EncodingDecl(Encoding(value)) -> SimpleAttribute("encoding", value)
+
+overlays
+
+  SimpleAttribute(name, value) =  Attribute(QName(None(), name), DoubleQuoted([Literal(value)]))
+
+rules
+
+  xml-to-box:
+    DocTypePrologue(doctype, miscs) -> box |[ V vs=1 [ ~*[doctype | miscs] ] ]|
+
+  xml-to-box:
+    DocTypeDecl(n, ext) -> box |[ H hs=1 [KW["<!DOCTYPE"] ~n ~ext KW[">"]] ]|
+  
+  xml-to-box:
+    SystemExternalID(n) -> box |[ H hs=1 [KW["SYSTEM"] ~lit:<double-quote> n] ]|
+
+  xml-to-box:
+    PublicExternalID(n1, n2) -> box |[ H hs=1 [KW["PUBLIC"] ~lit:<double-quote> n1 ~lit:<double-quote> n2 ] ]|
+
+  xml-to-box:
+    PI(n, data) -> box |[ H hs=0 [KW["<?"] H hs=1 [ ~lit:n ~lit:data ] KW["?>"]] ]|
+
+  xml-to-box: Comment(cdata)       -> box |[ C[ ~lit:cdata ] ]|
+  xml-to-box: Text(parts)          -> box |[ H hs=0 [~*parts ] ]|
+  xml-to-box: CDATASection(cdata)  -> box |[ H hs=0 [ "<![CDATA[" ~lit:cdata "]]>"] ]|
+  xml-to-box: EntityRef(ncname)    -> box |[ H hs=0 [ "&" ~lit:ncname ";"] ]|
+  xml-to-box: Literal(cdata)       -> box |[ ~lit:cdata ]|
+
+  xml-to-box =
+    simple-element-to-box <+ element-to-box
+
+  simple-element-to-box:
+    EmptyElement(qname, []) -> box |[ H hs=0 [KW["<"] ~qname KW["/>"]] ]|
+
+  element-to-box:
+    EmptyElement(qname, atts) -> box |[ H hs=0 [KW["<"] H hs=1 [~qname ~*atts ] KW["/>"]] ]|
+
+/*
+  simple-element-to-box:
+    Element(qname, atts, [Text(cdata)], _) -> box |[ H hs=0 [ ~open-tag ~lit:cdata  KW["</"] ~qname KW[">"]] ]|
+//      where <lt> (<string-length> cdata, 60)
+          where <open-tag-to-box> (qname, atts) => open-tag
+  */
+
+
+  element-to-box:
+    Element(qname, atts, children, _) ->
+      box |[ H hs=0 [~open-tag  ~*children KW["</"] ~qname KW[">"]] ]|
+        where <open-tag-to-box> (qname, atts) => open-tag
+    
+/*   
+  beauty-element-to-box:
+    Element(qname, atts, children, _) ->
+      box |[ V vs=0 [
+        V is=2 vs=0 [
+          ~open-tag
+          ~*children
+        ]
+        H hs=0 [KW["</"] ~qname KW[">"]]
+      ] ]|
+    where <open-tag-to-box> (qname, atts) => open-tag
+*/
+        open-tag-to-box:
+          (qname, []) -> box |[ H hs=0 [KW["<"] ~qname KW[">"]] ]|
+      
+        open-tag-to-box:
+          (qname, atts) -> box |[ H hs=0 [KW["<"] H hs=1 [ ~qname ~*atts ] KW[">"]] ]|
+            where <gt> (<length> atts, 0)
+      
+  xml-to-box :
+    Attribute(qname, value) -> box |[ H hs=0 [~qname KW["="] ~value] ]|
+
+  xml-to-box :
+    DoubleQuoted(parts) -> box |[ H hs=0 ["\"" ~*parts "\""] ]|
+
+  xml-to-box :
+    SingleQuoted(parts) -> box |[ H hs=0 ["\'" ~*parts "\'"] ]|
+
+
+  xml-to-box:
+    QName(None(), n) -> box |[ KW[ ~lit:n ] ]|
+
+  xml-to-box:
+    QName(Some(Prefix(p)), n) -> box |[ H hs=0 [~lit:p KW[":"] ~lit:n] ]|

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/main.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/main.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/main.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/main.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,243 @@
+module sdf2imp/main
+
+imports
+  libstratego-lib
+  libstratego-xtc
+  libstratego-rtg
+
+  libjava-front
+  
+  EditorService
+  
+  sdf2imp/options
+  sdf2imp/project/-
+  sdf2imp/services/-
+  sdf2imp/util/-
+  sdf2imp/lib/-
+
+overlays
+
+  tname_ASTNODE      = tname |[ org.strategoxt.imp.runtime.parser.ast.AstNode ]|
+  tname_VISITOR      = tname |[ org.strategoxt.imp.runtime.parser.ast.AbstractVisitor ]|
+  tname_OUTLINERBASE = tname |[ org.strategoxt.imp.runtime.services.OutlinerBase ]|
+  tname_FOLDINGBASE  = tname |[ org.strategoxt.imp.runtime.services.FoldingBase ]|
+  tname_ITOKEN       = tname |[ lpg.runtime.IToken ]|
+
+strategies
+
+  main-SpoofaxGenerator =
+    option-wrap(
+      sdf2imp-options
+    , 
+      generate-spoofaxlang-example
+    <+
+      prim("SSL_stacktrace_get_all_frame_names") => trace;       
+      report-failure // proper stack traces
+    )
+  
+  sdf2imp-jvm:
+    esv -> <packed-descriptor-file-name>
+    with
+      file-exists
+    ; not(<get-config> SdfMainModuleFlag()) // (should be read from the file)
+    where
+      rules(
+        InputFile := esv
+        IsLaunchedFromEclipse: _ 
+      );
+      <sdf2imp> FILE(esv)
+  
+  /*
+  sdf2imp-static-files =
+    create-build-xml;
+    create-common-trans // needs name and project-name
+  */
+  
+  // FIXME: dirty hack for getting the .def file
+  //        (should do this based on the esv contents instead...)
+  find-def-file =
+    remove-extension;
+    rules(
+      MainDescriptorName   := <base-filename>
+      DescriptorNamePrefix := <base-filename; remove-extension>
+    );
+    with(<chdir> <dirname>; <chdir> "..");
+    guarantee-extension(|"def"); // remove .main.esv
+    base-filename;
+    (file-exists <+ !$[include/[<id>]]);
+    if not(file-exists) then
+      fatal-err-msg(|$[Accompanying .def file not found: [<id>].
+                       Maybe the project should be rebuilt?])
+    end;
+    verbose-msg(!"Found accompanying .def file:", id)
+
+strategies
+  generate-spoofaxlang-example=
+    where ( say(!"inside new sdf2imp 0.0: ") );
+    with(
+      <set-verbosity> 3
+    );
+    require-option(
+        <get-config> SdfMainModuleFlag()
+      | "Main module (-m)"
+    );
+    if not(StartSymbol) then
+	    rules(StartSymbol := "Start")
+    end;
+    create-spxlang-lexicalconstructs; 
+    create-spxlang-definitions;
+    create-spxlang-adapters;
+    create-java-strategy;
+    create-spx-common-strategies;
+    rules(
+    	DefaultDefFile := "_" 
+    	NoExistingDescriptor: _
+    );
+    say(!"Generating configuration file for spoofaxlang project. ");
+    create-spoofaxlang-config; 
+    say(!"Generating main descriptor. ");
+    create-spxlang-main-descriptor;
+    create-spxlang-editorservices;
+   
+    create-parse-controller;
+    create-validator;
+    create-build-properties;
+    create-project-file;
+    create-activator;
+    create-classpath;
+    create-manifest;
+    create-plugin-xml;
+    create-build-xml;
+    create-build-generated-xml;
+    create-builder-xml;
+    create-example-file;
+    copy-jars;
+    copy-def-file;
+    create-jdt-prefs;
+    create-project-file;
+  
+    say(!"Build succesful.")
+  	
+ 
+  sdf2imp =
+    with(
+      <set-verbosity> 3
+    );
+    if InputFile then
+      !FILE(<InputFile>);
+      if FILE(has-extension(|"esv") => esv) then
+        <find-def-file> esv;
+        rules(InputFile := <id>);
+        !FILE(<id>)
+      else
+        where(
+          <file-exists> $[include/[<InputFile>]]
+        <+
+          <file-exists <+ mkdir> "include";
+          <copy-file> (<InputFile>, "include")
+        )
+      end;
+      ?input
+    else
+      require-option(
+        <get-config> SdfMainModuleFlag()
+      | "Main module (-m)"
+      );
+      if not(StartSymbol) then
+        rules(StartSymbol := "Start")
+      end;
+      create-grammar;
+      create-pp-table;
+      create-example-trans;
+      create-java-strategy;
+      input @ FILE(inputname) := <pack-default-sdf> FILE($[syntax/[<get-sdf-main-module>].sdf]);
+      rules(DefaultDefFile := inputname)
+    end;
+    
+    configure-main-descriptor;
+    if is-heuristic-services-needed then
+      <sdf2rtg => RTG(_, ProdRules(<id>)); register-rtg> input
+    end;
+    
+    if not(IsLaunchedFromEclipse) then
+      // We could build the table here, but doing it from ant is more customizable
+      // (also, this way we don't expose our xtc underbelly)
+      <copy-or-create-parse-table> input
+    end;
+  
+    if NoExistingDescriptor then
+      create-main-descriptor
+    end;
+    
+    create-syntax-descriptor;
+    create-folding-descriptor;
+    create-outliner-descriptor;
+    create-colorer-descriptor;
+    create-builders-descriptor;
+    create-references-descriptor;
+    create-completions-descriptor;
+    create-packed-descriptor-file;
+    create-parse-controller;
+    create-validator;
+    create-build-properties;
+    create-project-file;
+    create-activator;
+    create-classpath;
+    create-manifest;
+    create-plugin-xml;
+    create-build-xml;
+    create-build-generated-xml;
+    create-builder-xml;
+    create-example-file;
+    create-common-trans;
+    copy-jars;
+    copy-def-file;
+    create-jdt-prefs;
+    create-project-file;
+    create-spoofaxlang-config; //creating spoofax configuration file 
+    say(!"Build succesful.")
+
+
+	//TODO : Currenlty, always generating derived descriptor for the time being. 
+	//Add  a check to decide whether the descriptors are needed to be regenerated.   
+	is-heuristic-services-needed = id
+/*
+    not(
+      <is-older-than> (
+        <guarantee-extension(|"rtg")> <InputFile>
+      , [ $[editor/[<descriptor-name> "-Outliner.generated.esv"]]
+        , $[editor/[<descriptor-name> "-Folding.generated.esv"]]
+        , $[editor/[<descriptor-name> "-Completions.generated.esv"]]
+        ]
+      )
+    )
+ */ 
+  // (Note that these xtc calls are intercepted by the Spoofax/IMP runtime.)
+  sdf2rtg:
+    FILE(sdf) -> rtg
+    with
+      <file-exists> <guarantee-extension(|"rtg")> sdf;
+      verbose-msg(!"Importing regular tree grammar from", id);
+      parse-rtg-file => rtg
+    <+
+      verbose-msg(!"Analyzing grammar...");
+      if FILE(has-extension(|"sdf")) then
+        fatal-err(|"Input file must be a .def file.")
+      end;
+      table := <xtc-new-file>;
+      <sdf2table> (sdf, table, ["-n"]);
+      <xtc-transform(!"implodePT")> FILE(table);
+      read-from;
+      sdf-desugar;
+      core-sdf-grammar2rtg => rtg
+
+  pack-default-sdf:
+    FILE(sdf) -> FILE(def)
+    with
+      def := $[include/[<get-sdf-main-module>].def];
+      <file-exists <+ mkdir> "include";
+      
+      <pack-sdf(|[IncludeDir("syntax")])> FILE(sdf) => (_, def-asfix);
+      stream := <fopen> (def, "w");
+      <asfix-yield(|stream)> def-asfix;
+      <fclose> stream

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/options.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/options.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,115 @@
+module sdf2imp/util/options
+
+strategies
+
+  sdf2imp-options =
+     sdf-main-module-option // -m <mod>; sets get-sdf-main-module
+  <+ input-file-option
+  <+ extensions-option
+  <+ parse-table-option
+  <+ package-name-option
+  <+ project-name-option
+  <+ start-symbol-option
+  <+ jar-option
+  <+ reset-files-option
+  <+ verbose-option
+
+  input-file-option =
+    ArgOption(
+      "-i"
+    , rules(InputFile := <id>)
+    , !"-i <grammar>.def      Set input file (optional)"
+    )
+
+  parse-table-option =
+    ArgOption(
+      "-p"
+    , rules(ParseTable := <id>)
+    , !"-p <parse table>.tbl  Set parse table (optional; None to skip table generation)"
+    )
+
+  extensions-option =
+    ArgOption(
+      "-e"
+    , rules(EditorExtensions := <id>)
+    , !"-e <extensions>       Set editor file extensions (comma separated)"
+    )
+
+  package-name-option =
+    ArgOption(
+      "-n"
+    , rules(BasePackage := <id>);
+      get-package-name(fail) // ensure legal
+    , !"-n <packagename>      Set base package name (optional)"
+    )
+
+  project-name-option =
+    ArgOption(
+      "-pn"
+    , rules(ProjectName := <id>)
+    , !"-pn <project name>    Set project name (optional)"
+    )
+
+  jar-option =
+    MultiArgOption(
+      "-jar"
+    , rules(JarLocations := <id>);
+      list-loop(
+        if not(file-exists) then
+          fatal-err(|"File does not exist")
+        end
+      )
+    , !"-jar <paths>          Set jar files to include (optional)"
+    )
+    
+  start-symbol-option =
+    ArgOption(
+      "-s"
+    , parameterized-sort-to-rtg-sort;
+      if is-substring(!",") then
+        // TODO: Multiple start symbols
+        fatal-err(|"Multiple start symbols not supported yet, please specify a single start symbol")
+      end;
+      rules(StartSymbol := <id>)
+    , !"-s <start symbol>     Set start symbol"
+    )
+
+  reset-files-option =
+    Option(
+      "-r" + "--reset"
+    , rules(ResetFiles: _)
+    , !"-r | --reset          Reset all generated files to their defaults"
+    )
+  
+  parameterized-sort-to-rtg-sort =
+    // Module[StrategoHost] -> Module_StrategoHost
+    string-replace(|"[[", "_");
+    string-replace(|"[", "_");
+    string-replace(|"]", "")
+  
+  get-package-name =
+    get-package-name(default-package-name)
+  
+  get-package-name(default) =
+    ( BasePackage
+    <+
+      default
+    );
+    string-tokenize('.');
+    map(!Id(<id>));
+    !PackageName(<id>)
+    
+  get-package-name-text =
+    BasePackage <+ default-package-name
+  
+  default-package-name =
+    get-sdf-main-module;
+    to-java-class-name;
+    lower-case;
+    <conc-strings> ("org.strategoxt.imp.generated.", <id>)
+  
+  require-option(rule|description) = 
+    rule
+  <+
+    fatal-err-msg(|<conc-strings> (description, " not specified"))
+    

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/copy-def-file.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/copy-def-file.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,12 @@
+module sdf2imp/project/copy-def-file
+    
+imports
+  sdf2imp/util/-
+
+strategies
+
+  copy-def-file =
+    if NoExistingDescriptor; InputFile; not(<file-exists> "include") then
+      <mkdir> "include";
+      <copy-file> (<InputFile>, "include")
+    end
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/copy-jars.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/copy-jars.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,14 @@
+module sdf2imp/project/copy-jars
+
+imports
+  libstratego-lib
+
+strategies
+  
+  copy-jars =
+    if JarLocations then
+      verbose-msg(!"Copying jar files", JarLocations; separate-by(|","); concat-strings);
+      <file-exists <+ mkdir> "utils";
+      JarLocations;
+      list-loop(<copy-file> (<id>, "utils"))
+    end

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-activator.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-activator.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-15")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-activator.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-activator.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,76 @@
+module sdf2imp/project/create-activator
+      
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-activator =
+    // TODO: never overwrite existing activator
+    name    := <get-main-class-name>;
+    pkgname := <get-package-name>;
+    
+    <output-java-file> compilation-unit |[
+      package pkgname;
+      
+      import org.eclipse.imp.preferences.PreferencesService;
+      import org.eclipse.imp.runtime.PluginBase;
+      import org.osgi.framework.BundleContext;
+      
+      public class Activator extends PluginBase {
+        public static final String kPluginID = "~name";
+      
+        public static final String kLanguageName = "~name";
+      
+        /**
+         * The unique instance of this plugin class
+         */
+        protected static Activator sPlugin;
+      
+        public static Activator getInstance() {
+          if (sPlugin == null) return new Activator();
+          
+          return sPlugin;
+        }
+      
+        public Activator() {
+          super();
+          sPlugin = this;
+        }
+      
+        @Override
+        public void start(BundleContext context) throws Exception {
+          super.start(context);
+        }
+      
+        @Override
+        public String getID() {
+          return kPluginID;
+        }
+      
+        @Override
+        public String getLanguageID() {
+          return kLanguageName;
+        }
+      
+        protected static PreferencesService preferencesService = null;
+      
+        /* UNDONE: Activator.getPreferencesService()
+        public static PreferencesService getPreferencesService() {
+          if (preferencesService == null) {
+            preferencesService = new PreferencesService(ResourcesPlugin
+                .getWorkspace().getRoot().getProject());
+            preferencesService.setLanguageName(kLanguageName);
+            
+            // TODO2: IMP-generated activator todo note
+            // When some actual preferences are created, put
+            // a call to the preferences initializer here
+            // (The IMP New Preferences Support wizard creates such
+            // an initializer.)
+      
+          }
+          return preferencesService;
+        }
+        */
+      }
+    ]|

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-properties.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-properties.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,20 @@
+module sdf2imp/project/create-build-properties
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-build-properties =
+    <file-exists> "build.properties"
+  <+
+    <output-text-file(|[], "build.properties")>
+"source.. = editor/java/
+output.. = bin/
+bin.includes = META-INF/,\\
+               plugin.xml,\\
+               include/,\\
+               bin/,\\
+               lib/,\\
+               .
+"
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-xml.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-xml.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,70 @@
+module project/create-build-xml
+
+imports
+  sdf2imp/options
+  sdf2imp/util/-
+  sdf2imp/project/create-example-trans
+
+strategies
+
+  create-build-xml =
+    // Note that we cannot call this file build.xml,
+    // as Eclipse will delete it as it deploys plugins
+    <file-exists> "build.main.xml"
+  <+
+    name       := <get-sdf-main-module>;
+    name'      := <trans-module-name>;
+    classname  := <get-main-class-name>;
+    if not(<file-exists>"build.main.xml") then 
+    <output-text-file(|[], "build.main.xml")>
+$[<?xml version="1.0" encoding="UTF-8" ?>
+		
+<project name="[name]" default="all">
+	
+	<!-- prject directories -->
+  <property name="trans" location="trans"/>
+  <property name="src-gen" location="editor/java"/>
+  <property name="include" location="include"/>
+  <property name="lib" location="lib"/>
+  <property name="build" location="bin"/> 
+  <property name="dist" location="bin/dist"/>
+
+	
+	  
+	<!-- Environment configuration for command-line builds -->
+  <property name="build.sdf.imports" value= "-I &quot;${basedir}&quot; "/>
+  <property name="build.stratego.args" value="
+                  --library
+                  -I &quot;${basedir}&quot;
+                  -la stratego-lib -la stratego-sglr -la stratego-gpp -la stratego-xtc -la stratego-aterm  -la strc -la stratego-sdf"/>
+
+  <condition property="build.strategoxt.sdf" value="${eclipse.spoofaximp.nativeprefix}" else="">
+  	<isset property="eclipse.spoofaximp.nativeprefix"/>
+  </condition>
+  
+  <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
+  <import file=".build/build.spx.main.generated.xml"/>
+  
+  <!-- Compiles and Generates Artefacts. Internally it calls build-spoofaxlang-jvm strategy -->
+ 	<target name="buildinit">
+  	<java classname="org.strategoxt.imp.metatooling.building.AntSpxGenerateArtefacts" failonerror="false">
+		 	<arg value="${basedir}"/>
+	  </java>
+  </target>
+	
+  <!-- Main target -->
+  <target name="all" depends="buildinit,build-spx-packages"/>
+</project>]
+	end
+
+  create-build-generated-xml =
+    <output-text-file(|[".build"], "build.spx.main.generated.xml")>
+   $[<?xml version="1.0" encoding="UTF-8" ?>
+		
+<project name="build.spx.main.generated" default="build-spx-packages">
+    <target name="build-spx-packages">
+        <echo>
+            Build Failed. Please compile and  generate all the artifacts first by clicking $[$build-all$]$ target.
+        </echo>
+    </target>
+</project>] 

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-builder-xml.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-builder-xml.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,63 @@
+module sdf2imp/project/create-builder-xml
+    
+imports
+  sdf2imp/util/-
+
+strategies
+
+  builder-xml-name =
+    // Note that we cannot use ProjectName here since
+    // it may not be set after the first time this runs
+    !$[[<get-sdf-main-module>] build.main.xml.launch]
+
+  create-builder-xml =
+    <file-exists> $[.externalToolBuilders/[<builder-xml-name>]]
+  <+
+    not(ProjectName);
+    warn-msg(|$[Project name not specified, cannot regenerate [<builder-xml-name>]])
+  <+
+    // We use plain text since the XML pretty printer has problems with this file.
+    //
+    // - It seems that when a project is initially being built,
+    //   only ${build_project} works, and ${project_loc} doesn't. 
+    // - ${project_loc} also doesn't work when a project has
+    //   just been imported from version control or the file system
+    // - Variable ${build_project} prevents the Ant builder
+    //   from detecting that this launch file belongs to the
+    //   corresponding build.main.xml.
+    // - Variable ${project_loc} works better with the Ant builder,
+    //   but causes it to ask which project to build if there
+    //   are multiple projects
+    // - PROJECT_ATTR seems to be ignored
+    //
+    // Because of these issues we hardcode the project name in this file for now.
+    //
+    // The property org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY may be optional,
+    // at least for Ant builds.
+    
+    project-name := <ProjectName>;
+    
+    <output-text-file(|[".externalToolBuilders"], <builder-xml-name>)> 
+$[ <?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="org.eclipse.ant.AntLaunchConfigurationType">
+<stringAttribute key="bad_container_name" value=".externalToolBuilders"/>
+<booleanAttribute key="org.eclipse.ant.ui.DEFAULT_VM_INSTALL" value="false"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES"/>
+<booleanAttribute key="org.eclipse.debug.ui.ATTR_LAUNCH_IN_BACKGROUND" value="false"/>
+<listAttribute key="org.eclipse.jdt.launching.CLASSPATH">
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry containerPath=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/java-1.5.0-sun-1.5.0.18&quot; path=&quot;1&quot; type=&quot;4&quot;/&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.antHome&quot;&gt;&#10;&lt;memento default=&quot;true&quot;/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+<listEntry value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#10;&lt;runtimeClasspathEntry id=&quot;org.eclipse.ant.ui.classpathentry.extraClasspathEntries&quot;&gt;&#10;&lt;memento/&gt;&#10;&lt;/runtimeClasspathEntry&gt;&#10;"/>
+</listAttribute>
+<stringAttribute key="org.eclipse.jdt.launching.CLASSPATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<booleanAttribute key="org.eclipse.jdt.launching.DEFAULT_CLASSPATH" value="false"/>
+<stringAttribute key="org.eclipse.jdt.launching.PROJECT_ATTR" value=""/>
+<stringAttribute key="org.eclipse.jdt.launching.SOURCE_PATH_PROVIDER" value="org.eclipse.ant.ui.AntClasspathProvider"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_ANT_TARGETS" value="all,"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LAUNCH_CONFIGURATION_BUILD_SCOPE" value="${none}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_LOCATION" value="${workspace_loc:/[project-name]/build.main.xml}"/>
+<stringAttribute key="org.eclipse.ui.externaltools.ATTR_WORKING_DIRECTORY" value="${workspace_loc:/[project-name]}"/>
+<stringAttribute key="process_factory_id" value="org.eclipse.ant.ui.remoteAntProcessFactory"/>
+</launchConfiguration>
+]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-classpath.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-classpath.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,20 @@
+module sdf2imp/project/create-classpath
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-classpath =
+    <file-exists> ".classpath"
+  <+
+    <output-text-file(|[], ".classpath")>
+    $[<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" excluding="trans/**" path="editor/java"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
+    ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-common-trans.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-common-trans.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,336 @@
+module sdf2imp/project/create-common-trans
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-common-trans =
+    name     := <trans-module-name>;
+    sdf-name := <get-sdf-main-module>;
+	<output-text-file(|["src", "lib"], "editor-common.generated.spx")>
+${module lib/editor-common.generated
+
+imports
+  libstratego-lib
+  libstratego-sglr
+  libstratego-gpp
+
+strategies
+
+  parse-file = parse-{name}-file
+  parse-{name}-file =
+    parse-file(
+      strsglr-perror, strsglr-report-parse-error
+    | <import-term(include/{sdf-name}.tbl)>
+    )
+
+  parse-string = parse-{name}-string
+  parse-{name}-string =
+    parse-string(
+      strsglr-report-parse-error
+    | <import-term(include/{sdf-name}.tbl)>
+    )
+  
+  parse-stream = parse-{name}-stream
+  parse-{name}-stream =
+    parse-stream(
+      strsglr-report-parse-error
+    | <import-term(include/{sdf-name}.tbl)>
+    )
+
+  pp-{name}-string =
+    ast2abox(|[<import-term(include/{sdf-name}.generated.pp.af)>,
+               <import-term(include/{sdf-name}.pp.af)>]);
+    box2text-string(|100)
+
+strategies
+  
+  /**
+   * Processes an import during semantic analysis.
+   * Ensures proper caching of files and prevents
+   * processing duplicate imports more than once.
+   *
+   * @param resolve-path  Resolves the filesystem path of this import
+   * @param parse-file    Parses a file (optionally removing definition bodies
+   *                      so only signatures are stored in the cache)
+   * @param record-declarations
+   *                      Performs semantic analysis on a tree
+   */
+  open-import(resolve-path, parse-file, record-declarations):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path       := <resolve-path> import;
+        cache-path := <import-cache-path> path;
+        if not(<IsImported> path) then
+          rules(
+            IsImported: path
+          );
+          ( <is-newer> (cache-path, path);
+            file := <ReadFromFile> cache-path
+          <+
+            file := <parse-file> path;
+            if <file-exists> path then
+              // Only cache if on filesystem (e.g., ignore libstratego-lib)
+              <WriteToBinaryFile> (cache-path, file)
+            end        
+          );
+          ${$| CurrentFile:
+            rules(CurrentFile := path);
+            <record-declarations> file
+          |$}$
+        end
+      end
+
+  open-wildcard-import(resolve-path, parse-file, record-declarations, is-source-file):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path := <resolve-path> import;
+        readdir;
+        list-loop(
+          if is-source-file then
+            <open-import(id, parse-file, record-declarations)>
+              $[[path]/[<id>]]
+          <+
+            try(?one-failed)
+          end
+        );
+        not(!one-failed)
+      end
+  
+  import-cache-path:
+    full-path -> cache-path
+    with
+      project-path := <project-path>;
+      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.cache];
+      full-path'   := <string-replace(|"/", "+"); string-replace(|"{"\\\\"}", "+"); string-replace(|":", "+")> full-path;
+      cache-path   := $[[cache-dir]/[full-path'].sig]
+
+  project-path = prim("SSL_EXT_projectpath")
+  
+  plugin-path = prim("SSL_EXT_pluginpath")
+  
+  candidate-sorts = prim("SSL_EXT_candidatesorts")
+
+  is-newer:
+    (file1, file2) -> <id>
+    where
+      <gt> (<file-exists; modification-time> file1, <file-exists; modification-time> file2) 
+
+strategies
+  
+  editor-init =
+    // Ensure all dynamic rules are properly scoped
+    try(dr-scope-all-end);
+    dr-scope-all-start
+  
+  refresh-workspace-file:
+    path -> <prim("SSL_EXT_refreshresource", path)>
+  
+  string-starts-with-capital =
+    explode-string; Hd; is-upper
+
+strategies
+  
+  origin-term      = prim("SSL_EXT_origin_term", <id>)
+  origin-text      = prim("SSL_EXT_origin_text", <id>)
+  origin-location  = prim("SSL_EXT_origin_location", <id>)
+  origin-line      = origin-location => (<id>, _, _, _)
+  origin-column    = origin-location => (_, <id>, _, _)
+  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
+  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
+  
+  origin-surrounding-comments =
+    prim("SSL_EXT_origin_surrounding_comments", "{sdf-name}", <id>)
+    
+  origin-documentation-comment =
+    origin-surrounding-comments;
+    filter(string-as-chars(documentation-comment-chars));
+    concat-strings
+  
+  documentation-comment-chars:
+    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*
+  
+  origin-track-forced(s) =
+    ![<id>]; all(s); ?[<id>]
+
+strategies
+
+  desugar-position(desugar|ast):
+    position -> position'
+    where
+      ast'  := <at-position(!<id>${$MARKER()$}$|position)> ast;
+      ast'' := <topdown(repeat(preserve-annos(${$?x; desugar; not(?x)$}$)))> ast';
+      position' := <position-of-term({$[{?_{a*}; <one(?MARKER())> a*}]})> ast''
+   
+  at-position(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+
+  at-position(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t
+
+  position-of-term(is-term):
+    t -> []
+    where
+      is-term
+  
+  position-of-term(is-term):
+    _#(t*) -> <position-of-term(is-term|0)> t*
+  
+  position-of-term(is-term|start-index):
+    [t | t*] -> position
+    where
+      if i* := <position-of-term(is-term)> t then
+        position := [start-index | i*]
+      else
+        position := <position-of-term(is-term | <inc> start-index)> t*
+      end
+
+  term-at-position(|position):
+    t -> t'
+    where
+      at-position(?t'|position) 
+
+  parent-at-position(|position):
+    t -> t'
+    where
+      !position => [i, _];
+      t' := <subterm-at(|i)> t
+  
+  parent-at-position(|position):
+    t -> <parent-at-position(|position')> t'
+    where
+      !position => [i | position' @ [_, _ | _]];
+      t' := <subterm-at(|i)> t
+
+  subterm-at(|index):
+    _#(t*) -> <index(|<inc> index)> t*
+  
+signature constructors
+
+  COMPLETION : String -> Term
+  NOCONTEXT  : Term   -> Term
+  MARKER     : Term
+
+  // Below are copies of the signatures of the terms used in example
+  // trans/{name}.str file. These definitions should also be automatically 
+  // generated in the imported include/{sdf-name}.str module. However,
+  // to ensure that the example transformation doesn't break when the
+  // syntax is changed, we also hard-coded them here.
+          
+  Module   : ID * List(Entity)   -> Module
+  Entity   : ID * List(Property) -> Entity
+  Property : ID * Type           -> Property
+  Type     : ID                  -> Type
+
+strategies
+  
+  // Set markers for a given file. Use when checking files from a queued strategy.
+  // Current term: (ast-desugared, errors, warnings, notes) tuple
+  // ast: the root node of the file to set markers on 
+  set-markers(|ast) = prim("SSL_EXT_set_markers", ast)
+
+  // Indicate that one or more files need analysis. 
+  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
+  queue-analysis = 
+       (is-list; list-loop(queue-analysis))
+    <+ prim("SSL_EXT_queue_analysis")
+
+  // Set the total number of work units to complete. Can be called multiple times. 
+  // Current term: number of work units (int).
+  set-total-work-units = prim("SSL_EXT_set_total_work_units")
+  
+  // Complete one work unit and update progress monitors.
+  // Current term: ignored
+  complete-work-unit = prim("SSL_EXT_complete_work_unit")
+  
+  // Queue a strategy for background processing with a progress indicator.
+  // Current term: the term to pass to the background strategy
+  // s: the strategy, as string
+  // description: name of the task (will be shown in progress view)
+  queue-strategy(|s,description) = prim("SSL_EXT_queue_strategy", s, description)
+  
+  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
+  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
+  set-analysis-backgrounded = !"BACKGROUNDED"
+  
+};
+
+<output-text-file(|["lib"], "refactor-common.generated.str")>
+${module lib/refactor-common.generated
+
+imports
+  libstratego-lib
+  lib/editor-common.generated
+  
+
+strategies //transformation
+
+/**
+ * Replaces elements in a list (once, starting from the right)
+ * @param match strategy for partial list
+ * @param new elements List(b)
+ * @type List(a) -> List(a,b)
+ */
+replace-sublist(match-sublist|new-elems): 
+  list -> <
+    at-suffix(match-sublist;!new-elems) <+
+    (
+      init; 
+      replace-sublist(match-sublist|new-elems);
+      at-end(![<last> list])
+    )
+  > list 
+
+/**
+ * Inserts an element at a given AST position
+ * @param List(Int), denoting an AST position
+ * @param inserted list element 
+ * @type Term -> Term
+ */
+insert-elem(|pos, elem)=
+  insert-sublist(|pos, [elem])
+
+/**
+ * Inserts a list of elements at a given AST position
+ * @param List(Int), denoting an AST position
+ * @param inserted list elements 
+ * @type Term -> Term
+ */	
+insert-sublist(|pos, elems)=
+  at-position(
+    split-at(|<last> pos);
+    ?(prefix, suffix);
+    <concat>[prefix, elems, suffix]
+    |<init> pos
+  )
+
+
+strategies //user-input
+
+/**
+ * Opens an input dialog for one string value that represents an identifier
+ * The language is used to check if the input value matches the identifier pattern
+ * @type (String, String, String, String) -> String
+ */
+input-dialog:
+  (language, title, label, default-value) -> <prim("SSL_EXT_newnamedialog", language, title, label, default-value)>
+  
+input-dialog:
+  (title, label, default-value) -> <input-dialog>("", title, label, default-value)
+
+strategies //pp-table
+	
+get-pp-table=
+  import-term(include/{sdf-name}.generated.pp.af)
+	
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-example-file.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-example-file.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,39 @@
+module sdf2imp/project/create-example-file
+    
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-example-file =
+    not(NoExistingDescriptor)
+  <+
+    with(
+      name       := <get-sdf-main-module>;
+      extensions := <require-option(EditorExtensions |"File extensions (-e)")>;
+      extension  := <string-tokenize(|[',']); Hd> extensions
+    );
+    
+    // (the XML pretty printer has problems with this file, so it's printed as text instead)
+    <output-text-file(|["test"], <add-extension> ("example", extension))>
+    <conc-strings>
+(
+"module example
+
+// Example \"", name, "\" program (see src/", name , " -Definitions.spx for the language definition)
+
+entity User {
+  name     : String
+  password : String
+  homepage : URL
+}
+
+entity BlogPosting {
+  poster : User
+  body   : String
+}
+
+entity URL {
+  location : String
+}"
+)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-example-trans.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-example-trans.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,217 @@
+module sdf2imp/project/create-example-trans
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  trans-module-name =
+     get-sdf-main-module;
+     lower-case;
+     cify
+  
+  create-example-trans =
+    <file-exists> <conc-strings> ("trans/", <trans-module-name>, ".str")
+  <+
+    name     := <trans-module-name>;
+    sdf-name := <get-sdf-main-module>;
+    
+<output-text-file(|["trans"], $[[name].str])>
+${module {name}
+
+imports
+  libstratego-lib
+  libstratego-gpp
+  libstratego-aterm
+  include/{sdf-name}
+  lib/editor-common.generated
+  check
+  generate
+  refactor
+
+rules // Main editor interface (defined by editor/{sdf-name}-Builders and -References.esv)
+  
+  // Analyzes the current program, returning a tuple with errors, warnings, and notes;
+  // each a list of (term, message) tuples or simply (message) terms.
+  editor-analyze:
+    (ast, path, project-path) -> (ast, errors, warnings, notes)
+    with
+      editor-init;
+      analyze;
+      errors   := <collect-all(constraint-error, conc)> ast;
+      warnings := <collect-all(constraint-warning, conc)> ast;
+      notes    := <collect-all(constraint-note, conc)> ast
+  
+  // Transforms a selection to Java
+  generate-java:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with
+      filename := <guarantee-extension(|"java")> path;
+      result   := <to-java> selected
+  
+  // Prints the abstract syntax ATerm of a selection.
+  generate-aterm:
+    (selected, position, ast, path, project-path) -> (filename, result)
+    with
+      filename := <guarantee-extension(|"aterm")> path;
+      result   := selected // we just return the input term
+  
+  // Resolves a reference when the user control-clicks or presses F3 in the editor.
+  // Only succeeds for nodes of the form Type(_) for which GetEntity is defined.
+  editor-resolve:
+    (node, position, ast, path, project-path) -> target
+    where
+      <debug(!"Resolve: ")> node; 
+      Type(type) := node; 
+      target     := <GetEntity> type
+
+  // Returns "hover help" information for a particular node in the editor.
+  // For references, this rule is invoked using the resolved term.
+  editor-hover:
+    (target, position, ast, path, project-path) -> $[Hover help: [<write-to-string> target]]
+
+  // Completes an identifier when the user presses control-space
+  // (the completion identifier in the AST provides additional context information)
+  editor-complete:
+    (node, position, ast, path, project-path) ->
+    ["String", "Int" | proposals]
+    where
+      if !node => Type(COMPLETION(prefix)) then
+        proposals := <all-keys-GetEntity>
+      end
+};
+
+if not(<file-exists> "trans/generate.str") then
+  <output-text-file(|["trans"], "generate.str")>
+${module generate
+
+imports
+  libstratego-lib
+  libstratego-gpp
+  libstratego-aterm
+  include/{sdf-name}
+  lib/editor-common.generated
+
+rules
+
+  to-java:
+    Module(x, d*) ->
+    $[ package [x];
+       
+       [d'*]
+     ]
+    with
+      d'* := <to-java> d*
+  
+  to-java:
+    Entity(x, p*) ->
+    $[ class [x] ${$
+           [p'*]
+       $}$
+     ]
+    with
+      p'* := <to-java> p*
+
+  to-java:
+    Property(x, Type(t)) -> $[
+      private [t] [x];
+      
+      public [t] get_[x] ${$
+          return [x];
+      $}$
+      
+      public void set_[x] ([t] [x]) ${$
+          this.[x] = [x];    
+      $}$
+  ]
+  
+  to-java:
+    Type(t) -> t
+
+  to-java:
+    t* -> <map(to-java)> t*
+}
+end;
+
+if not(<file-exists> "trans/check.str") then
+  <output-text-file(|["trans"], "check.str")>
+${module check
+
+imports
+  libstratego-lib
+  include/{sdf-name}
+  lib/editor-common.generated
+
+rules
+
+  // Analysis: does a topdown traversal of the tree,
+  // and tries to apply the record-entity rule.
+  analyze:
+    t -> t
+    with
+      <topdown(try(record-entity))> t
+
+  // Records the definition of an entity in a dynamic rule GetEntity.
+  record-entity:
+    Entity(x, body) -> Entity(x, body)
+    with
+      // For a name 'x', GetEntity will return the original 'x' tree node
+      rules(
+        GetEntity :+ x -> x
+      )
+rules
+    
+  // Reports an error if a property type is undefined.
+  // This error is reported on the type name 'type'.
+  constraint-error:
+    Property(x, Type(type)) -> (type, $[Type [type] is not defined])
+    where
+      not(!type => "String"); // String and Int are built-in types
+      not(!type => "Int");
+      not(<GetEntity> type) // no entity for this type
+  
+  // Reports an error if an entity is defined more than once.
+  // This constraint is implemented by testing if the "bag" of
+  // all entities x is not a singleton list.
+  constraint-error:
+    Entity(x, _) -> (x, $[Duplicate entity name])
+    where
+      not(<bagof-GetEntity> x => [_])
+  
+  constraint-warning:
+    Entity(x, _) -> (x, $[Entity names must start with a capital])
+    where
+      not(<string-starts-with-capital> x)
+  
+  constraint-note:
+    Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
+                                      (this note is defined in trans/check.str) ])
+}
+end;
+
+
+if not(<file-exists> "trans/refactor.str") then
+  <output-text-file(|["trans"], "refactor.str")>
+${module refactor
+
+imports
+  lib/refactor-common.generated
+  include/{sdf-name}
+  lib/editor-common.generated  
+
+rules
+ 
+  rename-entity:
+    (selected-name, position, ast, path, project-path) -> [(ast, new-ast)]
+    with
+      new-name := <input-dialog> ("{<get-sdf-main-module>}", "rename", "Rename entity:", ""); 
+      new-ast  := <topdown(try(rename-type(|selected-name, new-name)))> ast
+
+  rename-type(|old-name, new-name):
+    Entity(old-name, y) -> Entity(new-name, y)
+
+  rename-type(|old-name, new-name):
+    Type(old-name) -> Type(new-name)
+
+}
+end

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-grammar.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-grammar.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,96 @@
+module sdf2imp/project/create-grammar
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-grammar =
+    create-grammar-main;
+    create-grammar-common
+  
+  create-grammar-main =
+    <file-exists> <conc-strings> ("syntax/", <get-sdf-main-module>, ".sdf")
+  <+
+    name        := <get-sdf-main-module>;
+    startsymbol := <StartSymbol>;
+    
+    <output-text-file(|["syntax"], <conc-strings> (name, ".sdf"))>
+    <conc-strings>
+(
+"%% Grammar for the ", name, " language
+%% By default, based on an example \"entities\" syntax
+module ", name, "
+
+imports Common
+
+exports
+
+  context-free start-symbols
+    ", startsymbol, "
+
+  context-free syntax
+  
+    \"module\" ID Definition*       -> ", startsymbol, " {cons(\"Module\")}
+    \"entity\" ID \"{\" Property* \"}\" -> Definition {cons(\"Entity\")}
+    ID \":\" Type                   -> Property {cons(\"Property\")}
+    ID                            -> Type {cons(\"Type\")}
+"
+)
+  
+  create-grammar-common =
+    <file-exists> <conc-strings> ("syntax/Common.sdf")
+  <+
+    <output-text-file(|["syntax"], "Common.sdf")>
+// TODO: FLOAT
+
+// MAYBE: unicode ID: 
+//   [a-zA-Z\192-\252\255][a-zA-Z0-9\_\192-\252\254\255]* -> UID
+
+${module Common
+
+exports
+
+  lexical syntax
+  
+    [a-zA-Z][a-zA-Z0-9]* -> ID
+    "-"? [0-9]+          -> INT
+    
+    "\"" StringChar* "\"" -> STRING
+    ~[\"\n]               -> StringChar
+    "\\\""                -> StringChar
+    BackSlashChar         -> StringChar
+    "\\"                  -> BackSlashChar
+    
+    [\ \t\n\r] -> LAYOUT
+    
+    [\*]                             -> CommentChar
+    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
+    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
+    
+    -> EOF
+  
+  lexical restrictions
+  
+    %% Ensure greedy matching for lexicals
+  
+    CommentChar   -/- [\/]
+    INT           -/- [0-9]
+    ID            -/- [a-zA-Z0-9\_]
+    
+    %% EOF may not be followed by any char
+    
+    EOF           -/- ~[]
+
+    %% Backslash chars in strings may not be followed by " 
+    
+    BackSlashChar -/- [\"]
+
+  context-free restrictions
+  
+    %% Ensure greedy matching for comments
+
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\/]
+    LAYOUT? -/- [\/].[\*]
+}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-java-strategy.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-java-strategy.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,95 @@
+module sdf2imp/project/create-java-strategy
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-java-strategy =
+    create-java-strategy-1;
+    create-java-strategy-2;
+    create-java-strategy-3
+
+  create-java-strategy-1 =
+    <file-exists> "editor/java/strategies/InteropRegisterer.java"
+  <+
+    pkgname  := <get-package-name-text>;
+    pkgpart* := <string-tokenize('.')> pkgname;
+    
+    <output-text-file(|["editor","java",pkgpart*,"strategies"],"InteropRegisterer.java")>
+    $[ package [pkgname].strategies;
+
+       import org.strategoxt.lang.JavaInteropRegisterer;
+       import org.strategoxt.lang.Strategy;
+
+       /**
+        * Helper class for {@link java_strategy_0_0}.
+        */
+       public class InteropRegisterer extends JavaInteropRegisterer {
+
+         public InteropRegisterer() {
+           super(new Strategy$[$$]$ { java_strategy_0_0.instance });
+         }
+       }
+    ]
+  
+  create-java-strategy-2 =
+    <file-exists> "editor/java/strategies/java_strategy_0_0.java"
+  <+
+    pkgname  := <get-package-name-text>;
+    pkgpart* := <string-tokenize('.')> pkgname;
+    
+    <output-text-file(|["editor","java",pkgpart*,"strategies"],"java_strategy_0_0.java")>
+    $[ package [pkgname].strategies;
+
+       import org.spoofax.interpreter.terms.IStrategoTerm;
+       import org.spoofax.interpreter.terms.ITermFactory;
+       import org.strategoxt.lang.Context;
+       import org.strategoxt.lang.Strategy;
+       
+       /**
+        * Example Java strategy implementation.
+        *
+        * This strategy can be used by editor services and can be called
+        * in Stratego modules by declaring it as an external strategy
+        * as follows:
+        *
+        * <code>
+        *  external java-strategy(|)
+        * </code>
+        *
+        * @see InteropRegisterer  This class registers java_strategy_0_0 for use.
+        */
+       public class java_strategy_0_0 extends Strategy {
+         
+         public static java_strategy_0_0 instance = new java_strategy_0_0();
+       
+         @Override
+         public IStrategoTerm invoke(Context context, IStrategoTerm current) {
+           context.getIOAgent().printError("Input for java-strategy: " + current);
+           ITermFactory factory = context.getFactory();
+           return factory.makeString("Regards from java-strategy");
+         }
+       
+       }
+    ]
+  
+  create-java-strategy-3 =
+    <file-exists> "editor/java/strategies/Main.java"
+  <+
+    pkgname  := <get-package-name-text>;
+    pkgpart* := <string-tokenize('.')> pkgname;
+    
+   <output-text-file(|["editor","java",pkgpart*,"strategies"],"Main.java")>
+    $[ package [pkgname].strategies;
+
+       import org.strategoxt.lang.Context;
+       
+       public class Main {
+         
+         public static void init(Context context) {
+           // Called when the editor is being initialized
+         }
+       
+       }
+    ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-jdt-prefs.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-jdt-prefs.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,26 @@
+module sdf2imp/project/create-jdt-prefs
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-jdt-prefs =
+    <file-exists> ".settings/org.eclipse.jdt.core.prefs"
+  <+
+    pkgname  := <get-package-name-text>;
+    pkgpart* := <string-tokenize('.')> pkgname;
+    
+    <output-text-file(|[".settings"],"org.eclipse.jdt.core.prefs")>
+    $[ eclipse.preferences.version=1
+       org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+       org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+       org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+       org.eclipse.jdt.core.compiler.compliance=1.5
+       org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+       org.eclipse.jdt.core.compiler.debug.localVariable=generate
+       org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+       org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+       org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+       org.eclipse.jdt.core.compiler.source=1.5
+    ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-manifest.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-manifest.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,39 @@
+module sdf2imp/project/create-manifest
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-manifest =
+    <file-exists> "META-INF/MANIFEST.MF"
+  <+
+    name    := <get-main-class-name>;
+    package := <BasePackage <+ default-package-name>;
+    
+    <output-text-file(|["META-INF"], "MANIFEST.MF")>
+    <conc-strings>
+(
+"Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: ", name, " Plug-in
+Bundle-SymbolicName: ", package, "; singleton:=true
+Bundle-Version: 1.0.0
+Bundle-Activator: ", package, ".Activator
+Import-Package: org.osgi.framework;version=\"1.3.0\"
+Require-Bundle: org.eclipse.core.runtime,
+  org.eclipse.core.resources,
+  org.eclipse.imp.runtime,
+  org.eclipse.ui,
+  lpg.runtime,
+  org.eclipse.jface.text,
+  org.eclipse.ui.editors,
+  org.eclipse.ui.workbench.texteditor,
+  org.strategoxt.imp.runtime,
+  org.spoofax.jsglr,
+  org.strategoxt.strj
+Bundle-RequiredExecutionEnvironment: J2SE-1.5
+Bundle-ActivationPolicy: lazy
+Export-Package: ", package, "
+" // newline required
+)

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-packed-descriptor-file.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-packed-descriptor-file.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,36 @@
+module sdf2imp/project/create-packed-descriptor-file
+
+imports
+  libstratego-lib
+  sdf2imp/services/common
+  sdf2imp/util/input
+  sdf2imp/util/output
+
+strategies
+
+  create-packed-descriptor-file =
+    {| InputDirPrefix, OnImportFailure:
+      rules(
+        OnImportFailure:
+          Import(file) -> <fatal-err-msg(|["Could not import ", file])>
+      );
+      <add-input-dir-prefix> "editor/";
+      filename := <packed-descriptor-file-name>;
+      main     := <main-descriptor-name>;
+      
+      <input-descriptor-file> main;
+      remove-empty-sections;        
+      output-packed-descriptor-file(|filename)
+    <+
+      fatal-err-msg(|"Could not pack descriptor files")
+    |}
+  
+  remove-empty-sections =
+    Module(
+      id
+    , id
+    , filter(not(?_#([_, []])))
+    )
+
+  packed-descriptor-file-name =
+    <conc-strings> (<get-sdf-main-module>, ".packed.esv")

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-controller.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-controller.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-15")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-controller.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-controller.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,135 @@
+
+module sdf2imp/project/create-parse-controller
+
+imports
+  libstratego-lib
+  libstratego-xtc
+  
+  sdf2imp/lib/RTG
+    
+  sdf2imp/util/-
+
+strategies
+  
+  parse-controller-name =
+    <conc-strings> (<get-main-class-name>, "ParseController")
+
+  create-parse-controller =
+    x_name           := <parse-controller-name>;
+    x_namegenerated  := <conc-strings> (x_name, "Generated");
+    pkgname          := <get-package-name>;
+    table            := <get-sdf-main-module>;
+    
+    <output-java-file> |[
+      package pkgname;
+
+      import java.io.InputStream;
+      import java.io.IOException;
+      import java.io.File;
+      import java.io.FileInputStream;
+      
+      import org.eclipse.core.runtime.Path;
+      import org.eclipse.imp.parser.IParseController;
+      import org.strategoxt.imp.runtime.Environment;
+      import org.strategoxt.imp.runtime.dynamicloading.BadDescriptorException;
+      import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+      import org.strategoxt.imp.runtime.dynamicloading.DescriptorFactory;
+      import org.strategoxt.imp.runtime.dynamicloading.DynamicParseController;
+      
+      public class x_namegenerated extends DynamicParseController {
+
+        public static final String LANGUAGE = new String("~table");
+
+        private static final String TABLE = "/include/" + LANGUAGE + ".tbl";
+
+        private static final String DESCRIPTOR = "/include/" + LANGUAGE + ".packed.esv";
+        
+        private static volatile Descriptor descriptor;
+        
+        private static Throwable notLoadingCause;
+        
+        public static synchronized Descriptor getDescriptor() {
+          if (notLoadingCause != null)
+            throw new RuntimeException(notLoadingCause); // unexpected exception
+          if (descriptor == null)
+            createDescriptor();
+          
+          return descriptor;
+        }
+        
+        protected static synchronized void setDescriptor(Descriptor descriptor) {
+          x_namegenerated.descriptor = descriptor;
+        }
+        
+        protected static void createDescriptor() {
+            try {
+              InputStream descriptorStream = x_namegenerated.class.getResourceAsStream(DESCRIPTOR);
+              InputStream table = x_namegenerated.class.getResourceAsStream(TABLE);
+              boolean filesystem = false;
+
+              if (descriptorStream == null && new File("./" + DESCRIPTOR).exists()) {
+    	          descriptorStream = new FileInputStream("./" + DESCRIPTOR);
+    	          filesystem = true;
+    	        }
+
+              if (table == null && new File("./" + TABLE).exists()) {
+    	          table = new FileInputStream("./" + TABLE);
+    	          filesystem = true;
+    	        }
+
+              if (descriptorStream == null)
+                throw new BadDescriptorException("Could not load descriptor file from " + DESCRIPTOR + " (not found in plugin: " + getPluginLocation() + ")");
+
+              if (table == null)
+                throw new BadDescriptorException("Could not load parse table from " + TABLE + " (not found in plugin: " + getPluginLocation() + ")");
+
+              descriptor = DescriptorFactory.load(descriptorStream, table, filesystem ? Path.fromPortableString("./") : null);
+              descriptor.setAttachmentProvider(x_namegenerated.class);
+              
+            } catch (BadDescriptorException exc) {
+              notLoadingCause = exc;
+              Environment.logException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+              throw new RuntimeException("Bad descriptor for " + LANGUAGE + " plugin", exc);
+              
+            } catch (IOException exc) {
+              notLoadingCause = exc;
+              Environment.logException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+              throw new RuntimeException("I/O problem loading descriptor for " + LANGUAGE + " plugin", exc);
+            }
+        }
+  
+        private static String getPluginLocation() {
+            return x_name.class.getProtectionDomain().getCodeSource().getLocation().getFile();
+        }
+        
+        @Override
+        public IParseController getWrapped() {
+          if (!isInitialized()) {
+            if (notLoadingCause != null) throw new RuntimeException(notLoadingCause);
+            try {
+              initialize(this, getDescriptor().getLanguage());
+            } catch (BadDescriptorException exc) {
+              notLoadingCause = exc;
+              throw new RuntimeException(exc);
+            }
+          }
+          
+          return super.getWrapped();
+        }
+        
+        @Override
+        protected void setNotLoadingCause(Throwable value) {
+          notLoadingCause = value;
+          super.setNotLoadingCause(value);
+        }
+      }
+    ]|;
+    
+    default-class := |[
+      package pkgname;
+      
+      public class x_name extends x_namegenerated {}
+    ]|;
+    if not(<file-exists> <java-to-path> default-class) then
+      <output-java-file> default-class
+    end

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-table.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-parse-table.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,71 @@
+module sdf2imp/project/create-parse-table
+
+imports
+  libstratego-lib
+  libstratego-xtc
+  
+  EditorService
+  
+  sdf2imp/project/-
+  sdf2imp/services/-
+  sdf2imp/util/-
+  sdf2imp/lib/-
+
+strategies
+  
+  copy-or-create-parse-table =
+    copy-parse-table <+ xtc-ensure-file; create-parse-table <+ fatal-err(|"Could not copy or create parse table")
+  
+  copy-parse-table =
+    <eq> (<ParseTable; abspath>, <parse-table-target; abspath>) // skip copying
+  <+
+    ParseTable => "None" // skip copying
+  <+
+    ParseTable;
+    if file-exists then
+      print-filename(|[], <parse-table-target>);
+      <copy-file> (<id>, <parse-table-target>)
+    end
+    
+  create-parse-table:
+    FILE(input) -> FILE(output)
+    with
+      FILE(input') := <create-permissive-grammar> FILE(input);
+      output       := <parse-table-target>;
+      print-filename(|[], output);
+      <debug; sdf2table> (input', output, [])
+  
+  // (Note that these xtc calls are intercepted by the Spoofax/IMP runtime.)
+  sdf2table =
+    ?(input, output, options);
+    <xtc-command(!"sdf2table")> ["-i", <abspath> input, "-o", <abspath> output, "-m", <get-sdf-main-module> | <conc> (options, <pass-v-verbose>)]
+  <+
+    if <xtc-command(!"sdf2table")> ["-V"] then // ensure it's available
+      fatal-err(|["Internal error: parse table creation failed"])
+    else
+      fatal-err(|["Internal error: could not call sdf2table"])
+    end
+  
+  create-permissive-grammar:
+    FILE(input) -> FILE(output)
+    with
+      output := <permissive-grammar-target>;
+      print-filename(|[], output);
+      args   := ["-i", input, "-o", output, "--open-brackets", "on", "--optimize", "on"];
+      if-java-platform(
+        <call> ("org.strategoxt.permissivegrammars.main-make-permissive", args)
+      );
+      if-c-platform(  // FIXME: should we even bother making make-permissive an xtc executable?
+        <call> ("make-permissive", args)
+      )
+    <+
+      warn(|"Could not create permissive grammar using make-permissive");
+      output := input
+
+  permissive-grammar-target =
+    <file-exists <+ mkdir> "include";
+    <conc-strings> ("include/", <get-sdf-main-module>, "-Permissive.def")
+
+  parse-table-target =
+    <file-exists <+ mkdir> "include";
+    <conc-strings> ("include/", <get-sdf-main-module>, ".tbl")

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-plugin-xml.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-plugin-xml.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,42 @@
+module project/create-plugin-xml
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-plugin-xml =
+    <file-exists> "plugin.xml"
+  <+
+    name       := <get-sdf-main-module>;
+    parser     := <parse-controller-name>;
+    validator  := <validator-name>;
+    pkgname    := <BasePackage <+ default-package-name>;
+    extensions := <EditorExtensions>;
+    
+    <output-text-file(|[], "plugin.xml")>
+    $[<?xml version="1.0" encoding="UTF-8"?>
+    <?eclipse version="3.0"?>
+    <plugin>
+       <extension
+             point="org.eclipse.imp.runtime.languageDescription">
+          <language
+                extensions="[extensions]"
+                description="[name]"
+                language="[name]"
+                derivedFrom="DynamicRoot"
+                validator="[pkgname].[validator]"
+                validatorClass="[pkgname].[validator]"
+          ></language>
+       </extension>
+       <extension
+             id="[pkgname].parser"
+             name="[name] Parser"
+             point="org.eclipse.imp.runtime.parser">
+          <parser
+                class="[pkgname].[parser]"
+                language="[name]">
+          </parser>
+       </extension>    
+    </plugin>
+   ]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-pp-table.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-pp-table.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,16 @@
+module sdf2imp/project/create-pp-table
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-pp-table =
+    <file-exists> <conc-strings> ("syntax/", <get-sdf-main-module>, ".pp")
+  <+
+    name        := <get-sdf-main-module>;
+    
+    <output-text-file(|["syntax"], <conc-strings> (name, ".pp"))>
+    ${ %% Pretty printing table (see also {name}.generated.pp)
+       []
+     }
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-project-file.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-project-file.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,52 @@
+module sdf2imp/project/create-project-file
+    
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-project-file =
+    <file-exists> ".project";
+    where(InputFile) // if no input file: create a new .project, overwriting Eclipse's default
+  <+
+    package     := <BasePackage <+ default-package-name>;
+    builder-xml := <conc-strings> ("&lt;project&gt;/.externalToolBuilders/", <builder-xml-name>);
+    
+    <output-text-file(|[], ".project")>
+$[<?xml version="1.0" encoding="UTF-8"?>
+  <projectDescription>
+  	<name>[<ProjectName>]</name>
+  	<comment></comment>
+  	<buildSpec>
+        <buildCommand>
+          <name>org.eclipse.jdt.core.javabuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+            <name>org.eclipse.ui.externaltools.ExternalToolBuilder</name>
+            <triggers>full,incremental,</triggers>
+            <arguments>
+                <dictionary>
+                    <key>LaunchConfigHandle</key>
+                    <value>[builder-xml]</value>
+                </dictionary>
+            </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.ManifestBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+        <buildCommand>
+          <name>org.eclipse.pde.SchemaBuilder</name>
+          <arguments>
+          </arguments>
+        </buildCommand>
+      </buildSpec>
+      <natures>
+        <nature>org.eclipse.pde.PluginNature</nature>
+        <nature>org.eclipse.jdt.core.javanature</nature>
+      </natures>
+</projectDescription>
+]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-adapters.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-adapters.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,125 @@
+module sdf2imp/project/create-spxlang-adapters
+
+imports 
+	sdf2imp/options
+	sdf2imp/util/-
+	
+rules
+	create-spxlang-adapters =
+		where(
+			file-name 		  := <spx-file-name>"-Adapters" ;
+			file-extension  := ".spx";
+			package-name := <BasePackage <+ default-package-name>
+		);	
+		if not(<file-exists> <conc-strings> ("src/", file-name  , file-extension)) then 
+		 	<output-text-file(|["src"] , $[[file-name][file-extension]])>
+$[package [package-name]   
+[<create-main-adapters>]
+[<create-builders-definition>]	
+[<create-reference-resolver-definition>]
+[<create-semantic-completion-definition>]
+]
+  	end
+   
+   
+   create-main-adapters = 
+    where( 
+	    	package-name  := <BasePackage <+ default-package-name>;
+	    	language-name := <get-sdf-main-module>
+			);	 
+		
+!${// This module acts as adapter between editor services and respective custom transformations. 
+	// It specifies Stratego transformation rules to be executed for different types of editor services. 
+	// See editor-services.generated.spx for a brief introduction on the available editor services.
+	module {language-name}-MainAdapters
+ 					
+		// Builders may carry out custom transformations on a file or selection.
+		builders
+			observer : editor-analyze         	                                                                          
+	  
+			builder  : "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)
+			builder  : "Generate Java code (for selection)"   = generate-java (openeditor) (realtime)
+			builder  : "Pretty-printing (for selection)"      = prettyprint-entitylang(openeditor) (realtime)
+
+			// on save: generate-java
+						
+		// Content completion proposer and trigger is specified in the following section.
+		completions
+			completion proposer                  : editor-complete
+			completion trigger                   : ":"
+	
+		// Reference resolving and hover help
+		references
+			reference _ : editor-resolve
+			hover _     : editor-hover
+}
+		  	 	
+		create-builders-definition = 
+    where( 
+	    	package-name  := <BasePackage <+ default-package-name>;
+	    	language-name := <get-sdf-main-module>
+			);	 
+!${module Builders  
+	 	
+rules 
+	// Transforms a selection to Java
+	generate-java:
+		(selected, position, ast, path, project-path) -> (filename, result)
+		with
+			filename := <guarantee-extension(|"java")> path;
+			result   := <to-java> selected
+	 		
+	// Prints the abstract syntax ATerm of a selection.
+	generate-aterm:
+		(selected, position, ast, path, project-path) -> (filename, result)
+		with
+			filename := <guarantee-extension(|"aterm")> path;
+			result   := selected // we just return the input term
+	
+	// Prints the abstract syntax ATerm of a selection.
+	prettyprint-entitylang:
+		(selected, position, ast, path, project-path) -> (filename, result)
+		with
+			filename := <guarantee-extension(|"pp.spo")> path;
+			result   := <pp-entitylang>selected // we just return the input term
+}
+
+		create-reference-resolver-definition = 
+		where( 
+	    	package-name  := <BasePackage <+ default-package-name>;
+	    	language-name := <get-sdf-main-module>
+			);	 
+!${module Reference-Resolver  
+	
+rules
+	// Resolves a reference when the user control-clicks or presses F3 in the editor.
+  editor-resolve:
+		(node, position, ast, path, project-path) -> elem
+		where 
+			<id> node => elem
+	    		 
+	// Returns "hover help" information for a particular node in the editor.
+	// For references, this rule is invoked using the resolved term.
+	editor-hover:
+		(target, position, ast, path, project-path) -> $[Hover help: [<write-to-string> target]]
+}	
+	 	
+	create-semantic-completion-definition = 
+		where( 
+	    	package-name  := <BasePackage <+ default-package-name>;
+	    	language-name := <get-sdf-main-module>
+			);	 
+!${module SemanticCompletion
+	
+imports {package-name}.generated
+
+rules
+		// Completes an identifier when the user presses control-space
+		// (the completion identifier in the AST provides additional context information)
+		editor-complete:
+			(node, position, ast, path, project-path) ->["String", "Int" | proposals]
+			where
+				if !node => Type(COMPLETION(prefix)) then
+					proposals := <all-keys-GetEntity>
+				end
+}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-common-trans.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-common-trans.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,269 @@
+module sdf2imp/project/create-spxlang-common-trans
+
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-spx-common-strategies =
+    name          := <trans-module-name>;
+    lang-name     := <get-sdf-main-module>;
+    package-name  := <BasePackage <+ default-package-name>;
+	<output-text-file(|["src"], "editor-common.generated.spx")>
+${package {package-name}.generated
+
+module CommonStrategies
+
+imports
+  libstratego-sglr
+  libstratego-gpp 
+  
+strategies
+
+  parse-file = parse-{name}-file
+  parse-{name}-file =
+    parse-file(
+      strsglr-perror, strsglr-report-parse-error
+    | <import-term(include/{lang-name}.tbl)>
+    )
+
+  parse-string = parse-{name}-string 
+  parse-{name}-string = 
+    parse-string( 
+      strsglr-report-parse-error
+    | <import-term(include/{lang-name}.tbl)>
+    )
+  
+  parse-stream = parse-{name}-stream
+  parse-{name}-stream =
+    parse-stream(
+      strsglr-report-parse-error
+    | <import-term(include/{lang-name}.tbl)>
+    )
+
+  pp-{name}-string =
+    ast2abox(|[<import-term(include/{lang-name}.generated.pp.af)>,
+               <import-term(include/{lang-name}.pp.af)>]); 
+    box2text-string(|100)
+
+    
+
+strategies
+  
+  /**
+   * Processes an import during semantic analysis.
+   * Ensures proper caching of files and prevents
+   * processing duplicate imports more than once.
+   *
+   * @param resolve-path  Resolves the filesystem path of this import
+   * @param parse-file    Parses a file (optionally removing definition bodies
+   *                      so only signatures are stored in the cache)
+   * @param record-declarations
+   *                      Performs semantic analysis on a tree
+   */
+  open-import(resolve-path, parse-file, record-declarations):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path       := <resolve-path> import;
+        cache-path := <import-cache-path> path;
+        if not(<IsImported> path) then
+          rules(
+            IsImported: path
+          );
+          ( <is-newer> (cache-path, path);
+            file := <ReadFromFile> cache-path
+          <+
+            file := <parse-file> path;
+            if <file-exists> path then
+              // Only cache if on filesystem (e.g., ignore libstratego-lib)
+              <WriteToBinaryFile> (cache-path, file)
+            end        
+          );
+          ${$| CurrentFile:
+            rules(CurrentFile := path);
+            <record-declarations> file
+          |$}$
+        end
+      end
+
+  open-wildcard-import(resolve-path, parse-file, record-declarations, is-source-file):
+    import -> import
+    where
+      if not(!import => COMPLETION(_)) then
+        path := <resolve-path> import;
+        readdir;
+        list-loop(
+          if is-source-file then
+            <open-import(id, parse-file, record-declarations)>
+              $[[path]/[<id>]]
+          <+
+            try(?one-failed)
+          end
+        );
+        not(!one-failed)
+      end
+  
+  import-cache-path:
+    full-path -> cache-path
+    with
+      project-path := <project-path>;
+      cache-dir    := <file-exists <+ mkdir> $[[project-path]/.cache];
+      full-path'   := <string-replace(|"/", "+"); string-replace(|"{"\\\\"}", "+"); string-replace(|":", "+")> full-path;
+      cache-path   := $[[cache-dir]/[full-path'].sig]
+
+  project-path = prim("SSL_EXT_projectpath")
+  
+  plugin-path = prim("SSL_EXT_pluginpath")
+  
+  candidate-sorts = prim("SSL_EXT_candidatesorts")
+
+  is-newer:
+    (file1, file2) -> <id>
+    where
+      <gt> (<file-exists; modification-time> file1, <file-exists; modification-time> file2) 
+
+strategies
+  
+  editor-init =
+    // Ensure all dynamic rules are properly scoped
+    try(dr-scope-all-end);
+    dr-scope-all-start
+  
+  refresh-workspace-file:
+    path -> <prim("SSL_EXT_refreshresource", path)>
+  
+  string-starts-with-capital =
+    explode-string; Hd; is-upper
+
+strategies
+  
+  origin-term      = prim("SSL_EXT_origin_term", <id>)
+  origin-text      = prim("SSL_EXT_origin_text", <id>)
+  origin-location  = prim("SSL_EXT_origin_location", <id>)
+  origin-line      = origin-location => (<id>, _, _, _)
+  origin-column    = origin-location => (_, <id>, _, _)
+  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
+  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)
+  
+  origin-surrounding-comments =
+    prim("SSL_EXT_origin_surrounding_comments", "{lang-name}", <id>)
+    
+  origin-documentation-comment =
+    origin-surrounding-comments;
+    filter(string-as-chars(documentation-comment-chars));
+    concat-strings
+  
+  documentation-comment-chars:
+    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*
+  
+  origin-track-forced(s) =
+    ![<id>]; all(s); ?[<id>]
+
+strategies
+
+  desugar-position(desugar|ast):
+    position -> position'
+    where
+      ast'  := <at-position(!<id>${$MARKER()$}$|position)> ast;
+      ast'' := <topdown(repeat(preserve-annos(${$?x; desugar; not(?x)$}$)))> ast';
+      position' := <position-of-term({$[{?_{a*}; <one(?MARKER())> a*}]})> ast''
+   
+  at-position(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+
+  at-position(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t
+
+  position-of-term(is-term):
+    t -> []
+    where
+      is-term
+  
+  position-of-term(is-term):
+    _#(t*) -> <position-of-term(is-term|0)> t*
+  
+  position-of-term(is-term|start-index):
+    [t | t*] -> position
+    where
+      if i* := <position-of-term(is-term)> t then
+        position := [start-index | i*]
+      else
+        position := <position-of-term(is-term | <inc> start-index)> t*
+      end
+
+  term-at-position(|position):
+    t -> t'
+    where
+      at-position(?t'|position) 
+
+  parent-at-position(|position):
+    t -> t'
+    where
+      !position => [i, _];
+      t' := <subterm-at(|i)> t
+  
+  parent-at-position(|position):
+    t -> <parent-at-position(|position')> t'
+    where
+      !position => [i | position' @ [_, _ | _]];
+      t' := <subterm-at(|i)> t
+
+  subterm-at(|index):
+    _#(t*) -> <index(|<inc> index)> t*
+  
+signature constructors
+
+  COMPLETION : String -> Term
+  NOCONTEXT  : Term   -> Term
+  MARKER     : Term
+
+  // Below are copies of the signatures of the terms used in example
+  // {lang-name}-Definitions.spx. These definitions should also be automatically 
+  // generated in the imported include/{lang-name}-signatures.str module. However,
+  // to ensure that the example transformation doesn't break when the
+  // syntax is changed, we also hard-coded them here.
+          
+  Module   : ID * List(Entity)   -> Module
+  Entity   : ID * List(Property) -> Entity
+  Property : ID * Type           -> Property
+  Type     : ID                  -> Type   
+   
+strategies
+  
+  // Set markers for a given file. Use when checking files from a queued strategy.
+  // Current term: (ast-desugared, errors, warnings, notes) tuple
+  // ast: the root node of the file to set markers on 
+  set-markers(|ast) = prim("SSL_EXT_set_markers", ast)
+
+  // Indicate that one or more files need analysis. 
+  // Current term: ss a list of absolute file paths, or a single absolute file path to analyze
+  queue-analysis = 
+       (is-list; list-loop(queue-analysis))
+    <+ prim("SSL_EXT_queue_analysis")
+
+  // Set the total number of work units to complete. Can be called multiple times. 
+  // Current term: number of work units (int).
+  set-total-work-units = prim("SSL_EXT_set_total_work_units")
+  
+  // Complete one work unit and update progress monitors.
+  // Current term: ignored
+  complete-work-unit = prim("SSL_EXT_complete_work_unit")
+  
+  // Queue a strategy for background processing with a progress indicator.
+  // Current term: the term to pass to the background strategy
+  // s: the strategy, as string
+  // description: name of the task (will be shown in progress view)
+  queue-strategy(|s,description) = prim("SSL_EXT_queue_strategy", s, description)
+  
+  // Return the result of this strategy to indicate a non-completed (backgrounded) analysis.
+  // Editor services (hover, resolve) will be delayed until a complete analysis is performed. 
+  set-analysis-backgrounded = !"BACKGROUNDED"
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,19 @@
+module sdf2imp/project/create-spxlang-config-file
+    
+imports
+  sdf2imp/util/-
+
+strategies
+
+  create-spoofaxlang-config=
+    <file-exists> "spx.config" ;
+    verbose-msg(!"Skipping", "spx.config")
+  <+
+    <output-text-file(|[], "spx.config")>
+$[Configuration
+	Includes
+		RootDirectory			src
+					
+	CodeGeneration 
+		OutputDirectory		.shadowdir
+]
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-definitions.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-definitions.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,190 @@
+module sdf2imp/project/create-spxlang-definitions
+
+imports 
+	sdf2imp/options
+	sdf2imp/util/-
+
+rules
+	create-spxlang-definitions =
+		where(
+			file-name 		  := <spx-file-name>"-Definitions";
+			file-extension  := ".spx";
+			package-name := <BasePackage <+ default-package-name>
+		);	
+if not(<file-exists> <conc-strings> ("src/", file-name  , file-extension)) then 
+<output-text-file(|["src"] , $[[file-name][file-extension]])>
+$[package [package-name]   
+[<create-main-language-constructs>]
+[<create-lang-type-system>]
+[<create-symantic-analyzer>]
+ ]
+ end
+    	
+    create-main-language-constructs =
+	    where( 
+	    	package-name  := <BasePackage <+ default-package-name>;
+	    	language-name := <get-sdf-main-module>
+			);	 
+!${
+// Following module define the main langauge constructs for {language-name} language
+module {language-name}-MainConstructs
+
+imports {package-name}.generated 
+	
+context-free syntax    
+	"module" ID Definition*       	-> Start       ${$ "Module"  $}$ 
+	"entity" ID "${$" Property* "$}$" 	-> Definition  ${$ "Entity"  $}$
+	ID  ":" Type               		  -> Property     ${$ "Property"$}$ 
+	
+rules 
+	// Semantic analyses
+	// Reports an error if an entity is defined more than once.
+	// This constraint is implemented by testing if the "bag" of
+	// all entities x is not a singleton list.
+	constraint-error:
+		Entity(x, _) -> (x, $[Duplicate entity name])
+		where
+			not(<bagof-GetEntity> x => [_])
+		
+	constraint-warning:
+		Entity(x, _) -> (x, $[Entity names must start with a capital])
+			where
+				not(<string-starts-with-capital> x)
+	  
+	constraint-note:
+		Module(x @ "example", _) -> (x, $[This is just an example program in the "entities" language
+	                                      (this note is defined in src/{<get-sdf-main-module>}-Definitions.spx) ])
+	 
+rules
+	// Generates java codes from {language-name} language.
+	to-java: Module(x, d*) ->
+		$[package [x];
+    	[d'*]
+		 ]
+    with
+      d'* := <to-java> d*
+  
+	to-java: Entity(x, p*) ->
+    $[ class [x] ${$
+           [p'*]
+       $}$
+		]
+    with
+		p'* := <to-java> p*
+
+	to-java: Property(x, type) -> 
+		$[
+			private [<to-java>type] [x];
+      
+			public [<to-java>type] get_[x] ${$
+          return [x];
+      $}$
+      
+			public void set_[x] ([<to-java>type] [x]) ${$
+          this.[x] = [x];    
+			$}$
+		]     
+  	
+		to-java: t* -> <map(to-java)> t*
+		
+rules
+	
+	// Pretty-prints Abstract Syntax Tree to {language-name} language. 
+	pp-entitylang: Module(x, d*) ->
+		$[ module [x]
+				[d'*]
+		]
+		with
+		d'* := <pp-entitylang> d*
+  
+	pp-entitylang: Entity(x, p*) ->
+		$[ entity [x] ${$
+				[p'*]
+				$}$
+			]
+		with
+			p'* := <pp-entitylang> p*
+
+	pp-entitylang: Property(x, type) -> 
+		$[[x] : [<pp-entitylang>type] 
+		]     
+  	
+	pp-entitylang: t* -> <map(pp-entitylang)> t*
+}	
+
+
+	create-lang-type-system = 
+		where( 
+	    	language-name := <get-sdf-main-module>
+			);
+!${// Following module defines the Type-System of  {language-name} language
+module Type-System
+	
+context-free syntax
+	ID                              -> Type ${$"Type"$}$
+	"Int"														-> Type ${$"IntegerType", prefer$}$
+	"String"												-> Type ${$"StringType" , prefer$}$
+
+rules 
+	// Semantic analysis of types
+	// Reports an error if a property type is undefined.
+	// This error is reported on the type name 'type'.
+	constraint-error:
+		Type(type) -> (type, $[Type [type] is not defined])
+		where
+			not(<GetEntity> type) // no entity for this type 
+	
+rules
+	// Transforming {language-name} types to java types  
+	to-java: Type(t) -> t
+ 
+	to-java: IntegerType() -> "int"
+    
+	to-java: StringType() -> "string"  
+
+rules
+	// Pretty-prints {language-name}  types 
+	pp-entitylang : Type(t) -> t
+		
+	pp-entitylang : IntegerType() -> "Int"
+    
+	pp-entitylang : StringType() -> "String"  
+}
+
+	create-symantic-analyzer = 	
+		where( 
+	    	language-name := <get-sdf-main-module>;
+	    	 package-name  := <BasePackage <+ default-package-name>
+		);
+!${// Following module performs semantic analyses for {language-name} language
+module Semantic-Analyzer
+imports {package-name}.generated
+
+rules
+	// Analysis: does a topdown traversal of the tree,
+	// and tries to apply the record-entity rule.
+	analyze:
+		t -> t
+		with
+			<topdown(try(record-entity))> t
+	
+	// Records the definition of an entity in a dynamic rule GetEntity.
+	record-entity:
+		Entity(x, body) -> Entity(x, body)
+		with
+			// For a name 'x', GetEntity will return the original 'x' tree node
+			rules(
+				GetEntity :+ x -> x 
+			)
+rules 
+	// Analyzes the current program, returning a tuple with errors, warnings, and notes;
+	// each a list of (term, message) tuples or simply (message) terms.
+	editor-analyze:
+		(ast, path, project-path) -> (ast, errors, warnings, notes)
+		with
+			editor-init;
+			analyze;
+			errors   := <collect-all(constraint-error, conc)> ast;
+			warnings := <collect-all(constraint-warning, conc)> ast;
+			notes    := <collect-all(constraint-note, conc)> ast	
+}		
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-lexicalconstructs.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-lexicalconstructs.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,96 @@
+module sdf2imp/project/create-spxlang-lexicalconstructs
+
+imports 
+	sdf2imp/options
+	sdf2imp/util/-
+rules 
+	
+	create-spxlang-lexicalconstructs =
+		where(
+			file-name 		:= <spx-file-name>"-LexicalConstructs";
+			file-extension  := ".spx";
+			package-name := <BasePackage <+ default-package-name>
+		);	
+		
+		if not(<file-exists> <conc-strings> ("src/", file-name  , file-extension)) then 
+		 	<output-text-file(|["src"] , $[[file-name][file-extension]])>
+$[package [package-name]   
+[<create-lang-idenditifiers>]
+[<create-lang-literals>]
+[<create-lang-keywords>]
+[<create-lang-layout>]
+]
+    end
+    	
+    create-lang-idenditifiers =
+!${
+module Identifier
+	lexical syntax
+		[a-zA-Z][a-zA-Z0-9]* -> ID
+}	
+
+    create-lang-literals =
+!${	
+module Literals
+	lexical syntax
+		"-"? [0-9]+          -> INT
+		"\"" StringChar* "\"" -> STRING
+		~[\"\n]               -> StringChar
+		"\\\""                -> StringChar
+		
+		BackSlashChar         -> StringChar
+		"\\"                  -> BackSlashChar
+	
+	lexical restrictions
+	
+		//Ensure greedy matching for lexicals
+		CommentChar   -/- [\/]
+		INT           -/- [0-9]
+		ID            -/- [a-zA-Z0-9\_]
+		
+		//Backslash chars in strings may not be followed by "
+		
+		BackSlashChar -/- [\"]
+}
+	
+	create-lang-keywords = 
+!${		
+module Keywords
+	
+	lexical syntax 
+		"Int"					  			-> RESERVED
+		"String"			  			-> RESERVED
+		RESERVED 						-> ID${$reject$}$
+
+	lexical restrictions
+		//Ensure greedy matching for lexicals
+		"Int" 
+		"String"  -/- [A-Za-z0-9\_]
+}
+
+
+	create-lang-layout =  
+	!${
+
+module Layout
+	lexical syntax
+		[\ \t\n\r] -> LAYOUT
+	    
+		[\*]                             -> CommentChar
+		"/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
+		"//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT   
+	    
+		-> EOF
+	  
+	lexical restrictions 
+		//Ensure greedy matching for lexicals
+		//EOF may not be followed by any char
+		EOF           -/- ~[]
+	
+	context-free restrictions 
+  
+		//Ensure greedy matching for comments
+		LAYOUT? -/- [\ \t\n\r]
+		LAYOUT? -/- [\/].[\/]
+		LAYOUT? -/- [\/].[\*]		
+}	
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-validator.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-validator.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-15")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-validator.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-validator.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,35 @@
+module sdf2imp/project/create-validator
+
+imports
+  libstratego-lib
+  libstratego-xtc
+    
+  sdf2imp/util/-
+
+strategies
+  
+  validator-name =
+    <conc-strings> (<get-main-class-name>, "Validator")
+
+  create-validator =
+    x_name   := <validator-name>;
+    x_parser := <parse-controller-name>;
+    pkgname  := <get-package-name>;
+    
+    default-class := |[
+      package pkgname;
+
+      import org.strategoxt.imp.runtime.dynamicloading.Descriptor;
+      import org.strategoxt.imp.runtime.services.MetaFileLanguageValidator;
+
+      public class x_name extends MetaFileLanguageValidator {
+          @Override
+          public Descriptor getDescriptor() {
+              // Lazily get the descriptor
+              return x_parser.getDescriptor();
+          }
+      }
+    ]|;
+    if not(<file-exists> <java-to-path> default-class) then
+      <output-java-file> default-class
+    end

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/ast-form-heuristic.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/ast-form-heuristic.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/ast-form-heuristic.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/ast-form-heuristic.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,265 @@
+module sdf2imp/services/ast-form-heuristic
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+  sdf2imp/lib/-
+
+overlays
+  
+/**
+ * Heuristic traversal strategies.
+ *
+ * @internal
+ */
+strategies
+
+  register-rtg =
+    with(
+      list-loop(heuristic-register-production);
+      
+      verified-start-symbol
+    )
+
+  verified-start-symbol =
+    StartSymbol;
+    where(
+      bagof-Productions;
+      not([])
+    )
+  <+
+    (StartSymbol <+ !None());
+    fatal-err(|["No legal start symbol specified in ", <get-sdf-main-module>, " esv definition"])
+  
+  heuristic-register-production =
+    try(
+      ?prod;
+      heuristic-rtg-sort-name => sort;
+      
+      rules(
+        Productions :+ sort -> prod
+      )
+    )
+
+  heuristic-child-sorts =
+    ?ProdRule(
+      Nonterm(/*Plain*/(sort))
+    , [Appl(_, <id>)]
+    );
+    
+    map(?Ref(Nonterm(/*Plain*/(<id>))));
+    
+    filter(not(?sort)) // avoid circular references
+  <+
+    // Injection
+    ?ProdRule(
+      Nonterm(/*Plain*/(sort))
+    , [Ref(Nonterm(/*Plain*/(<id>)))]
+    );
+    
+    ![<not(?sort)>] // avoid circular references
+  <+
+    verify(ProdRule(id, id), !"Bad input for heuristic-child-sorts");
+    ![]
+  
+  heuristic-collect-all-rtg(condition) =
+  {| CollectAllVisited:
+    rec rec(
+      CollectAllVisited;
+      ![]
+    <+
+      { ?sort;
+        rules(CollectAllVisited: sort);
+        
+        heuristic-collect-all-visit-sort(condition, rec)
+      }
+    );
+    
+    flatten-list
+  |}
+  
+  heuristic-collect-all-visit-sort(condition, rec) =
+    bagof-Productions;
+    
+    map(heuristic-collect-all-visit-production(condition, rec))
+  
+  heuristic-collect-all-visit-production(condition, rec) =
+    ?prod;
+    heuristic-child-sorts;
+    filter(rec);
+    
+    try(![<condition> prod | <id>])
+  
+   // TODO2: Cleanup
+  
+  /**
+   * Succeeds if by following recursively the current productions single child,
+   * at some point <condition> applies for _one_ of the encountered productions.
+   */
+  heuristic-follow-single-child-productions1(condition) =
+  {| FollowVisited:
+    rec rec({
+      // Avoid infinite looping
+      not(FollowVisited) => sort; 
+      rules(FollowVisited: sort);
+        
+      bagof-Productions;
+      (
+        getfirst(condition)
+      <+
+        getfirst(
+          heuristic-child-sorts => [<rec>]
+        )
+      )
+    })
+  |}
+  
+  /**
+   * Succeeds if by following recursively the current productions single child,
+   * at some point <condition> applies for _all_ of the encountered productions.
+   */
+  heuristic-follow-single-child-productions(condition) =
+  {| FollowVisited, FollowSuccess:
+    rec rec({
+      // Avoid infinite looping
+      not(FollowVisited) => sort; 
+      rules(FollowVisited: sort);
+        
+      bagof-Productions;
+      not([]);
+      
+      map({
+        FollowSuccess
+      <+
+        condition
+      <+
+        ?prod;
+        
+         heuristic-child-sorts => [<rec>];
+          
+         rules(FollowSuccess: prod)
+        //| "Hey what's this then?")
+      });
+      Hd
+    })
+  |}
+
+/**
+ * Heuristic conditions.
+ *
+ * @internal
+ */
+strategies
+
+  heuristic-rtg-sort-name =
+    non-terminal-sort-name
+  <+
+    // Injection: use lhs name
+    ?ProdRule(
+      Nonterm(/*Plain*/(<id>))
+    , [Ref(_)]
+    )
+
+  heuristic-asfix-sort-name =
+    non-terminal-sort-name
+  <+
+    // Injection: use rhs name
+    ?ProdRule(
+      _
+    , [Ref(Nonterm(/*Plain*/(<id>)))]
+    )
+  
+  non-terminal-sort-name =
+    ?ProdRule(
+      Nonterm(/*Plain*/(<id>))
+    , [Appl(_, _)]
+    )
+  
+  constructor-name =
+    ?ProdRule(
+      _
+    , [Appl(Term(/*Plain*/(<id>)), _)]
+    )
+  
+  // TODO: Don't match the webdsl "if"
+  //       is-identifier should be more strict,
+  //       so that it matches identifiers and lists of identifiers
+  //       for _all_ productions
+  
+  heuristic-sort-is-identifier =
+    heuristic-follow-single-child-productions1(is-string-production)
+  
+  /**
+   * Succeeds if the sort points to a list of things that are not of the given sort, or one of its injections.
+   */
+  heuristic-sort-is-unvisited-list =
+    heuristic-follow-single-child-productions(is-unvisited-list-production)
+  
+  heuristic-sort-is-list =
+    heuristic-follow-single-child-productions1(is-list-production)
+  
+  heuristic-production-has-no-same-sort-descendant =
+    where(
+      rootsort := <get-list-production-item-sort>
+    <+
+      rootsort := <heuristic-rtg-sort-name>
+    );
+  
+    {| ProductionVisited:
+      rec rec({ production:
+        ProductionVisited
+      <+
+        ?production;
+        rules(ProductionVisited: production);
+        
+        heuristic-child-sorts;
+        
+        // Check condition
+        list-loop(not(?rootsort));
+        
+        // Recurse
+        list-loop(
+          bagof-Productions;
+          list-loop(rec)
+        )
+      })
+    |}
+  
+  is-string-production =
+    ?ProdRule(
+      _
+    , [Ref(String())]
+    )
+  
+  is-list-production =
+    ProdRule(
+      id
+    , [Appl(is-list-term, id)]
+    )
+
+  is-list-term =
+    ConcTerm + ConsTerm + NilTerm + TupleTerm(id)
+  
+  is-unvisited-list-production =
+    where(
+     get-list-production-item-sort;
+     not(FollowVisited)
+    )
+  <+ // TODO: Cleanup?
+    ProdRule(
+      id
+    , [Appl(is-list-term; not(ConsTerm()), id)]
+    )
+  
+  is-list-production =
+    ProdRule(
+      id
+    , [Appl(is-list-term, id)]
+    )
+  
+  get-list-production-item-sort =
+    ?ProdRule(
+      _
+    , [Appl(ConsTerm(), [Ref(Nonterm(/*Plain*/(<id>))), _])]
+    )

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/check-validity.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/check-validity.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,20 @@
+module check-validity
+
+signature constructors
+
+  Error : Term * Message -> Error
+
+strategies
+
+  check-validity:
+    packed-module -> errors
+    with
+      errors := <collect-all(constraint-error)>
+
+  constraint-error:
+    Sort(_) -> Error(<id>, "Undeclared sort")
+    where
+      not(
+        parameterized-sort-to-asfix-sort;
+        Productions
+      )

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/common.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/common.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/common.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/common.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,74 @@
+module sdf2imp/services/common
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+
+signature constructors
+
+  CommentLine : String -> Term
+  EmptyLine   : Term
+
+strategies
+
+  // TODO: General strategy for reading all esv files
+
+  // TODO2: Optimize - add string length check to conditions
+  
+  // TODO2: descriptor-name should have an aterm argument, overloading main-descriptor-name
+  descriptor-name:
+    name -> $[[prefix][name]]
+    where
+      prefix := <DescriptorNamePrefix <+ get-sdf-main-module>
+  
+  main-descriptor-name =
+    MainDescriptorName
+  <+
+    <get-config> SdfMainModuleFlag();
+    <conc-strings> (<id>, ".main")
+  
+  condition-to-java:
+    Token(x) -> |[ tokenKind == x_Name ]|
+    with
+      x_Name := <write-to-string> x
+  
+  condition-to-java:
+    Constructor(x) -> |[ "~x".equals(constructor) ]|
+  
+  condition-to-java:
+    Sort(sort) -> |[ "~sort'".equals(sort) ]|
+    where
+      sort' := <try-get-sort-name> sort
+  
+  condition-to-java:
+    ListSort(sort) -> |["~sort'".equals(sort) ]|
+    where
+      sort' := <conc-strings> (<try-get-sort-name> sort, "*")
+  
+  parameterized-sort-to-asfix-sort = parameterized-sort-to-rtg-sort
+  
+  condition-to-java:
+    descriptor |[ ~sort.~constructor ]| ->
+    java       |[ "~constructor".equals(constructor) && "~sort'".equals(sort) ]|
+    where
+      sort' := <try-get-sort-name> sort
+  
+  condition-to-java:
+    descriptor |[ _.~sort ]| -> |[ "~sort'".equals(sort) ]|
+    where
+      sort' := <try-get-sort-name> sort
+
+  // TODO: Check if constructors actually exist
+
+  try-get-sort-name =
+    parameterized-sort-to-asfix-sort;
+    where(
+      Productions
+    <+
+      // FIXME: Fail if unknown sort found (temporarily had to disable this)
+      // TODO: Renamed sorts like OptExtendsInterfaces0_Java need special treatment
+      //       looks like sdf2rtg needs to be adapted to not perform renaming like this!
+      fatal-err(|"Unknown sort referenced");
+      fail
+    )

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/configure-main-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/configure-main-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,109 @@
+module sdf2imp/services/configure-main-descriptor
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+
+strategies
+
+  /**
+   * Records the descriptor configuration, using the 
+   * existing descriptor file and/or the command-line options.
+   */
+  configure-main-descriptor =
+    current-main-descriptor-file;
+    
+    rules(MainDescriptor := <id>);
+    
+    require-option(
+      where(<get-config> SdfMainModuleFlag())
+    <+
+      where(<set-config> (SdfMainModuleFlag(), <find-main-module>));
+      with(get-sdf-main-module)
+    | <NoExistingDescriptor < !"Main module (-m)" + !"language name">
+    );
+    
+    verbose-msg(!"Using main module", get-sdf-main-module);
+    
+    require-option(
+      // Still compulsory for sdf2rtg (StrategoXT/8??)
+      where(StartSymbol) <+ rules(StartSymbol := <parameterized-sort-to-rtg-sort> <find-start-symbol>)
+    | <NoExistingDescriptor < !"Start symbols (-s)" + !"language start symbols">
+    );
+    
+    verbose-msg(!"Using start symbols", StartSymbol);
+    
+    require-option(
+      where(BasePackage) <+ rules(BasePackage := <find-package-name>)
+    | <NoExistingDescriptor < !"Package name (-p)" + !"language id">
+    );
+    
+    verbose-msg(!"Using package name", BasePackage);
+    
+    require-option(
+      where(EditorExtensions) <+ rules(EditorExtensions := <find-editor-extensions>)
+    | <NoExistingDescriptor < !"Editor file extensions (-e)" + !"language extensions">
+    );
+    
+    verbose-msg(!"Using file extensions", EditorExtensions)
+  
+  current-main-descriptor-file =
+     {| InputDirPrefix, OnImportFailure:
+       verbose-msg(!"Reading descriptor files");
+       <add-input-dir-prefix> "editor/";
+       rules(
+         OnImportFailure:
+           Import(m) -> Module("", NoImports(), [])
+           with
+             if <has-extension(|"esv")> <InputFile> then
+               fatal-err-msg(|["Could not import module ", m])
+             end
+           where
+             not(<eq> (<main-descriptor-name>, m)); // silently ignore non-main import fails
+             warn(|["Could not import module", m]) //DEBUG
+       );
+       main-descriptor-name;
+       input-descriptor-file;
+       verbose-msg(!"Existing descriptor determines generated services:", main-descriptor-name)
+     |}
+   <+
+     // Could not read the existing file: use the defaults instead, but don't overwrite the file
+     main-descriptor := <conc-strings> ("(editor/", <main-descriptor-name>, ")");
+     <warn(|"Error opening existing descriptor file; attempting to use defaults instead")> main-descriptor;
+          
+     rules(NoExistingDescriptor: _);
+     default-main-descriptor
+
+  find-main-module =
+    collect-one(?LanguageName(<id>))
+
+  find-start-symbol =
+    collect-one(?StartSymbols(<id>));
+    try(?Values(<id>));
+    try(map(?Sort(<id>)));
+    separate-by(|",");
+    concat-strings
+
+  find-editor-extensions =
+    collect-one(?Extensions(Values(<id>)));
+    separate-by(|",");
+    concat-strings
+
+  find-package-name =
+    with(
+      oncetd(?LanguageId(result))
+    <+
+      default-package-name => result
+    );
+    !result
+
+  verbosity-scope(s|level) = 
+    with( 
+      oldlevel := <verbosity>;
+      <set-verbosity> level
+    );
+    finally(
+      s
+    , <set-verbosity> oldlevel
+    )

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-builders-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-builders-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-builders-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-builders-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,122 @@
+module sdf2imp/services/create-builders-descriptor
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+  sdf2imp/services/common
+  sdf2imp/project/create-example-trans
+
+
+strategies 
+	
+	build-derived-builders-descriptor = 
+		 !|[
+        module <descriptor-name> "-Builders.generated"
+        
+        builders
+          ~
+          ~// Building and analysis is defined in Stratego program or programs:
+          ~//
+          ~//   provider : stratego-program.ctree
+          ~//   provider : stratego-library.jar
+          ~//
+          ~// Analysis is carried out by a Stratego rule that can be selected as follows:
+          ~//
+          ~//   observer : analysis-rule
+          ~//
+          ~// Any dynamic rules set in the analysis may be used by other semantic services,
+          ~// such as reference resolving or the builders.
+          ~//
+          ~// Builders may carry out custom transformations on a file or selection.
+          ~// (At run-time, they can be accessed using the toolbar button with the star icon.)
+          ~// Builders can be specified as follows:
+          ~//
+          ~//   builder : "Generate Java code" = generate-java (openeditor) (persistent) (realtime)
+          ~//
+          ~// In this example, the caption "Generate Java code" is used in the build button dropdown menu,
+          ~// and the generate-java rule is used to carry out the tranformation.
+          ~// Builder definitions can also specify any combination of the following annotations:
+          ~//
+          ~//   (cursor)      The builder should always transform the tree node at the cursor.
+          ~//   (meta)        Indicates the builder should only be available to meta-programmers
+          ~//                 (i.e., not when the plugin is deployed to end-users).
+          ~//   (openeditor)  Indicates an editor should be opened with the result.
+          ~//   (persistent)  Indicates that the resulting file should be saved to disk.
+          ~//   (realtime)    Indicates that the resulting editor should be updated in real-time
+          ~//                 as the source file is edited.
+          ~//   (source)      Always apply this builder to the source AST, not to the AST
+          ~//                 after it has been analyzed/desugared by the observer.
+          ~//
+          ~// Refactorings are used for transformations that modify the original source code;
+          ~// the original layout is preserved for unchanged fragments,
+          ~// while newly inserted nodes are pretty printed using a custom pretty-print strategy, 
+          ~// or the layout definitions in the pp-table.
+          ~//   pp-table: get-pp-table
+          ~//   pretty-print: prettyprint
+          ~//
+          ~// Refactorings can be specified as shown below, whereby Property* indicates on which constructs the
+          ~// refactoring is specified (<sort>.<constructor>).
+          ~// 
+          ~//   refactoring Property*: "Extract Entity" =  extract-entity (source)
+          ~// 
+          ~// The 'on save' handler can be used  to generate code as files are saved:
+          ~//   
+          ~//   on save : generate-java
+      ]|
+
+strategies
+	create-builders-descriptor =
+    output-initial-descriptor-file(
+      <descriptor-name> "-Builders"
+    , provider1 := <conc-strings> ("include/", <trans-module-name>, ".ctree");
+      provider2 := <conc-strings> ("include/", <trans-module-name>, "-java.jar");
+      !|[
+        module <descriptor-name> "-Builders"
+        
+        imports <descriptor-name> "-Builders.generated" //Test
+        
+        builders
+          ~~
+          ~~// This file can be used for custom analysis and builder rules.
+          ~~//
+          ~~// See the imported file for a brief introduction and examples.
+        builders
+          ~~
+          provider: ~provider1
+          provider: ~provider2
+          ~~
+          observer: editor-analyze
+          ~~
+          builder: "Generate Java code (for selection)"   = generate-java  (openeditor) (realtime)
+          builder: "Show abstract syntax (for selection)" = generate-aterm (openeditor) (realtime) (meta) (source)
+          ~~
+           
+        refactorings
+          ~~
+            
+          pp-table: get-pp-table
+          ~~
+          refactoring ID: "Rename Entity" = rename-entity (source) (cursor)
+
+          ~~
+          ~// on save: generate-java
+                
+      ]|
+    );
+    
+	output-derived-descriptor-file(
+      <descriptor-name> "-Builders.generated"
+    ,
+      build-derived-builders-descriptor
+    )
+
+
+strategies 
+	
+	create-spx-derived-builders-descriptor=
+		where ( descriptor-name := "Builders"); 
+	 !$[module [descriptor-name]
+			
+[<build-derived-builders-descriptor;pp-descriptor-contents>] 	
+	 	]

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-colorer-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-colorer-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-colorer-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-colorer-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,107 @@
+module sdf2imp/services/create-colorer-descriptor
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+
+strategies 
+	build-colorer-descriptor =
+		!|[ module <descriptor-name>"-Colorer"
+        
+        imports <descriptor-name>"-Colorer.generated"
+        
+        colorer
+          ~
+          ~// This file can be used for custom colorer rules.
+          ~//
+          ~// See the imported file for a brief introduction and examples.
+        colorer   
+          ~~
+          Type  : 66 92 217 bold
+    	]|
+
+	build-derived-colorer-descriptor =
+		 !|[module <descriptor-name>"-Colorer.generated"
+        
+      colorer
+        ~
+        ~// Sort-based highlighting with background color
+        ~//   Id: yellow green
+        ~//
+        ~// Sort- and constructor-based highlighting
+        ~//   ClassBodyDec.MethodDec: yellow
+        ~//
+        ~// Constructor-based highlighting
+        ~//   _.MethodDec: 255 0 0
+        ~//
+        ~// Example: background colors for ToMetaExpr/FromMetaExpr, if supported by the grammar
+        ~//   environment _.ToMetaExpr:   _ 220 230 200
+        ~//   environment _.FromMetaExpr: _ white
+      
+		  // TODO: Better documentation of colorer descriptor
+		  colorer Default, token-based highlighting
+		  ~~
+		    keyword    : 127 0 85     bold
+		    identifier : default
+		    string     : blue
+		    number     : darkgreen
+		    var        : 255 0 100    italic
+		    operator   : 0 0 128
+		    layout     : 63 127 95    italic
+		    
+		  ~~
+		  ~~
+		  colorer System colors
+		    ~~
+		    darkred   = 128 0 0       
+		    red       = 255 0 0       
+		    darkgreen = 0 128 0       
+		    green     = 0 255 0       
+		    darkblue  = 0 0 128       
+		    blue      = 0 0 255       
+		    cyan      = 0 255 255     
+		    magenta   = 255 0 255     
+		    yellow    = 255 255 0     
+		    white     = 255 255 255   
+		    black     = 0 0 0         
+		    gray      = 128 128 128   
+		    grey      = gray       
+		    orange    = 255 165 0
+		    pink      = 255 105 180   
+		    brown     = 139 69 19
+		    default   = _       
+      ]| 
+		
+strategies
+
+  create-colorer-descriptor =
+    output-initial-descriptor-file(
+      <descriptor-name> "-Colorer"
+    , build-derived-colorer-descriptor
+    );
+    
+    output-derived-descriptor-file(
+      <descriptor-name> "-Colorer.generated"
+    	,build-derived-colorer-descriptor
+    )
+
+strategies 
+	create-spx-colorer-descriptor = 
+		where ( descriptor-name := "Colorer");
+	!$[module [descriptor-name]
+		
+[<build-colorer-descriptor;pp-descriptor-contents>] 	
+	 	]
+		
+		
+	
+	create-spx-derived-colorer-descriptor = 
+		where ( descriptor-name := "Colorer-Generated");
+	!$[module [descriptor-name]
+			
+[<build-derived-colorer-descriptor;pp-descriptor-contents>] 	
+	 	]
+		
+		
+		
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-completions-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-completions-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-completions-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-completions-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,259 @@
+module sdf2imp/services/create-completions-descriptor
+
+imports
+  libstratego-lib
+  libstratego-sdf
+
+  sdf2imp/util/-
+  sdf2imp/main
+
+strategies
+	// TODO: remove sdf2imp related codes
+	// TODO: Infer completions from SDF  
+	build-contentcompletion-descriptor = 
+		!|[ module <descriptor-name> "-Completions"
+
+        completions
+          ~~
+          ~~// This module is used to define content completion.
+          ~~//
+          ~~// See the imported file for a brief introduction and examples.
+          ~~
+         completions
+          ~~
+          ~~// Syntax completion:
+          ~~
+          completion template Start :
+            "module " <m> (blank)
+          ~~
+          completion template Definition :
+            "entity " <e> " {" (cursor) "}"  (blank)
+          ~~
+          completion template Property : "prop" =
+            <x> " : " <T>  (blank)
+          ~~
+      ]|
+
+		build-derived-contentcompletion-descriptor = 
+		!|[
+				module <descriptor-name> "-Completions.generated"
+
+        completions
+          ~
+          ~// Syntactic content completion can be defined as follows:
+          ~//
+          ~//   completion keyword  : "keyword"
+          ~//   completion template : "if " <e> " then\n\t" <s> "\nend"
+          ~//
+          ~// This defines keyword completion for "keyword" and
+          ~// a template completion for the "if" keyword (note the use of \n, \t, and spaces).
+          ~// In this template, the text selection expands to the "e" placeholder identifier
+          ~// enclosed in <> brackets.
+          ~//
+          ~// Use the (blank) annotation if you want a template completion only to
+          ~// appear on blank lines:
+          ~//
+          ~//   completion template: "section " <title> "\n\t" (blank)
+          ~//
+          ~// You can specify a specific SDF sort for which a completion
+          ~// rule should trigger as follows:
+          ~//
+          ~//   completion template Section :
+          ~//     "section " <title> "\n\t" (blank)
+          ~//
+          ~// Finally, you can override the prefix of the completion:
+          ~//
+          ~//   completion template Statement : "assignment" =
+          ~//     <x> " = " <y> (blank)
+          ~//
+          ~// Semantic content completion can be defined as follows:
+          ~//
+          ~//   completion proposer : completion-function-call
+          ~//   completion trigger  : "\."
+          ~//
+          ~// This sets completion-function-call as the completion strategy,
+          ~// and declares that [A-Za-z0-9_]+ may be used as a lexical pattern
+          ~// to parse identifiers (used to set the text selection with suggestions).
+          ~// The completion trigger uses a regular expression to specify that
+          ~// completions should be proposed as the user types ".".
+          ~//
+          ~// Completions make use of the identifier lexical defined in YourLanguage-Syntax.esv
+          ~// to select identifiers in completion suggestions.
+          ~//
+          ~// Semantic completion uses the semantic provider defined in YourLanguage-Builders.esv
+          ~~// All semantic services may make use of the dynamic rules created by the observer.
+      ]|
+
+strategies
+	create-spx-contentcompletion-descriptor = 	
+		where(
+				descriptor-name		:=	"ContentCompletion" 
+		);
+	!$[module [descriptor-name]
+		 	
+[<build-contentcompletion-descriptor; pp-descriptor-contents>]
+	 	]
+	
+	 	
+	create-spx-derived-contentcompletion-descriptor = 	
+		where(
+				descriptor-name		:=	"ContentCompletion-Generated" 
+		);
+	!$[module [descriptor-name]
+		 	
+[<build-derived-contentcompletion-descriptor; pp-descriptor-contents>]
+	 	]		 		
+
+signature constructors
+
+  lit  : Term -> Term
+  prod : Term * Term * Term -> Term
+  deprecated : Term
+  deprecated : Term -> Term
+
+strategies
+
+  create-completions-descriptor =
+    output-initial-descriptor-file(
+      <descriptor-name> "-Completions"
+    , !|[
+        module <descriptor-name> "-Completions"
+
+        imports <descriptor-name> "-Completions.generated"
+
+        completions
+          ~~
+          ~~// This file is used to define content completion.
+          ~~//
+          ~~// See the imported file for a brief introduction and examples.
+          ~~
+        completions
+          ~~
+          ~~// Syntax completion:
+          ~~
+          completion template Start :
+            "module " <m> (blank)
+          ~~
+          completion template Definition :
+            "entity " <e> " {" (cursor) "}"  (blank)
+          ~~
+          completion template Property : "prop" =
+            <x> " : " <T>  (blank)
+          ~~
+        completions
+          ~~// Semantic (identifier) completion:
+          ~~
+          completion proposer: editor-complete
+          ~~
+          completion trigger: ":"
+      ]|
+    );
+    create-derived-completions-descriptor
+
+  
+  create-derived-completions-descriptor =
+    not(is-heuristic-services-needed);
+    verbose-msg(!"Skipping", <descriptor-name> "-Completions.generated")
+  <+
+    output-derived-descriptor-file(
+      <descriptor-name> "-Completions.generated"
+    ,
+      completion-rules := <collect-all-keywords; map(keyword-to-completion-rule)>;
+      !|[
+        module <descriptor-name> "-Completions.generated"
+
+        completions
+          ~
+          ~// Syntactic content completion can be defined as follows:
+          ~//
+          ~//   completion keyword  : "keyword"
+          ~//   completion template : "if " <e> " then\n\t" <s> "\nend"
+          ~//
+          ~// This defines keyword completion for "keyword" and
+          ~// a template completion for the "if" keyword (note the use of \n, \t, and spaces).
+          ~// In this template, the text selection expands to the "e" placeholder identifier
+          ~// enclosed in <> brackets.
+          ~//
+          ~// Use the (blank) annotation if you want a template completion only to
+          ~// appear on blank lines:
+          ~//
+          ~//   completion template: "section " <title> "\n\t" (blank)
+          ~//
+          ~// You can specify a specific SDF sort for which a completion
+          ~// rule should trigger as follows:
+          ~//
+          ~//   completion template Section :
+          ~//     "section " <title> "\n\t" (blank)
+          ~//
+          ~// Finally, you can override the prefix of the completion:
+          ~//
+          ~//   completion template Statement : "assignment" =
+          ~//     <x> " = " <y> (blank)
+          ~//
+          ~// Semantic content completion can be defined as follows:
+          ~//
+          ~//   completion proposer : completion-function-call
+          ~//   completion trigger  : "\."
+          ~//
+          ~// This sets completion-function-call as the completion strategy,
+          ~// and declares that [A-Za-z0-9_]+ may be used as a lexical pattern
+          ~// to parse identifiers (used to set the text selection with suggestions).
+          ~// The completion trigger uses a regular expression to specify that
+          ~// completions should be proposed as the user types ".".
+          ~//
+          ~// Completions make use of the identifier lexical defined in YourLanguage-Syntax.esv
+          ~// to select identifiers in completion suggestions.
+          ~//
+          ~// Semantic completion uses the semantic provider defined in YourLanguage-Builders.esv
+          ~~// All semantic services may make use of the dynamic rules created by the observer.
+
+        completions
+          ~~
+          ~// Derived completions may follow
+          ~
+          ~*completion-rules
+      ]|
+    )
+
+strategies
+
+  keyword-to-completion-rule:
+    keyword -> |[ completion keyword : ~String(keyword) ]|
+
+  collect-all-keywords =
+    (InputFile <+ DefaultDefFile);
+    parse-sdf-definition-file;
+    collect-all(?prod(<pattern-to-keywords>, _, _));
+    concat;
+    make-set
+
+  prod-to-keywords:
+    prod(pattern, _, attrs) -> keywords
+    where
+      keywords := <pattern-to-keywords> pattern;
+      not(!attrs => attrs(<one(term(?deprecated() + ?deprecated(_)))>))
+
+  pattern-to-keywords =
+    pattern-to-keywords-1 <+ pattern-to-keywords-2 <+ []
+
+  pattern-to-keywords-1:
+    [lit(lit) | p*] -> [keyword | <pattern-to-keywords> p'*]
+    where
+      <is-prefixed-keyword> lit
+    with
+      keyword-suffix := <take-while(lit(is-prefixed-keyword))> p*;
+      keyword        := <map(?lit(<id>)); separate-by(|" "); concat-strings> [lit(lit) | keyword-suffix];
+      p'*            := <drop-while(?lit(_))> p*
+
+  pattern-to-keywords-2:
+    [_ | p*] -> <pattern-to-keywords> p*
+
+  /**
+   * Tests if the given string is a keyword prefixed
+   * by non-alphabetic characters (e.g., ~java: or {annotation})
+   */
+  is-prefixed-keyword =
+    explode-string;
+    where([not(is-alpha) | id]); // not("")
+    one(is-alpha);
+    not(one("\"" + "\\")) // only allow stringchars for pretty-printing

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-folding-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-folding-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-folding-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-folding-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,155 @@
+module sdf2imp/services/create-folding-descriptor
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+  sdf2imp/services/ast-form-heuristic
+
+strategies 
+	
+	build-folding-descriptor = 
+		!|[ module <descriptor-name> "-Folding"
+        
+        folding
+          ~
+          ~// This file can be used for custom folding rules.
+          ~//
+          ~// See the imported file for a brief introduction and examples.
+		 ]|
+		 
+	build-derived-folding-descriptor = 
+		 !|[ module <descriptor-name> "-Folding.generated"
+        
+         folding Default folding definitions
+          ~
+          ~// Folding rules indicate which syntactic constructs can be folded,
+          ~// and take one of the following forms:
+          ~//
+          ~//   <sort>.<constructor>
+          ~//
+          ~//   <sort>._
+          ~//
+          ~//   _.<constructor>
+          ~//
+          ~// To indicate that an element should always be folded, add
+          ~// a (folded) annotation:
+          ~//
+          ~//   _.Imports (folded)
+          ~//
+          ~// To disable a folding rule defined elsewhere, add a (disabled) annotation:
+          ~//
+          ~//   Definition._ (disabled)
+          ~
+        ]|
+        
+strategies
+	
+	create-spx-contentfolding-descriptor = 	
+		where(
+				descriptor-name		:=	"Folding" 
+		);
+!$[module [descriptor-name]
+		 	
+[<build-folding-descriptor;pp-descriptor-contents>]
+	Start.Module
+	Definition.Entity
+]
+	
+	 	
+	create-spx-derived-contentfolding-descriptor = 	
+		where(
+				descriptor-name		:=	"Folding-Generated" 
+		);
+	!$[module [descriptor-name]
+		 	
+[<build-derived-folding-descriptor; pp-descriptor-contents>]
+	 	]	
+  
+strategies
+
+  create-folding-descriptor =
+    output-initial-descriptor-file(
+      <descriptor-name> "-Folding"
+    , !|[
+        module <descriptor-name> "-Folding"
+        
+        imports <descriptor-name> "-Folding.generated"
+        
+        folding
+          ~
+          ~// This file can be used for custom folding rules.
+          ~//
+          ~// See the imported file for a brief introduction and examples.
+      ]|
+    );
+    
+    create-derived-folding-descriptor
+  
+  create-derived-folding-descriptor =
+    not(is-heuristic-services-needed);
+    verbose-msg(!"Skipping", <descriptor-name> "-Folding.generated")
+  <+
+    output-derived-descriptor-file(
+      <descriptor-name> "-Folding.generated"
+    , 
+      heuristic-folding-productions;
+      map(create-folding-or-outliner-rule);
+      !|[
+        module <descriptor-name> "-Folding.generated"
+        
+        folding Default folding definitions
+          ~
+          ~// Folding rules indicate which syntactic constructs can be folded,
+          ~// and take one of the following forms:
+          ~//
+          ~//   <sort>.<constructor>
+          ~//
+          ~//   <sort>._
+          ~//
+          ~//   _.<constructor>
+          ~//
+          ~// To indicate that an element should always be folded, add
+          ~// a (folded) annotation:
+          ~//
+          ~//   _.Imports (folded)
+          ~//
+          ~// To disable a folding rule defined elsewhere, add a (disabled) annotation:
+          ~//
+          ~//   Definition._ (disabled)
+          ~
+          ~*<id>
+      ]|
+    )
+  
+  heuristic-folding-productions =
+    StartSymbol;
+    
+    heuristic-collect-all-rtg(
+      // UNDONE: not(is-list-production);
+      where(
+        heuristic-child-sorts;
+        one(heuristic-sort-is-list)
+      );
+      
+      where(
+        heuristic-production-has-no-same-sort-descendant
+      );
+      
+      if-verbose3(
+        verbose-msg(!"Folding match:", heuristic-asfix-sort-name, constructor-name)
+      )
+    )
+  
+  create-folding-or-outliner-rule =
+    where(sort := <heuristic-asfix-sort-name>);
+  
+    if is-list-production then
+      !descriptor |[ ~(sort)*.<constructor-name> ]|
+    <+
+      !descriptor |[ ~(sort)* ]|
+    else
+      !descriptor |[ ~sort.<constructor-name> ]|
+    <+
+      !descriptor |[ ~sort ]|
+    end

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,74 @@
+module sdf2imp/services/create-main-descriptor
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+
+strategies
+
+  create-main-descriptor =
+    output-main-descriptor-file(
+      main-descriptor-name
+    , 
+      default-main-descriptor => main-descriptor
+    );
+    
+    // Store the main descriptor in a rule for further reference,
+    // or fail if no descriptor was created
+    
+    rules(MainDescriptor := main-descriptor)
+
+  default-main-descriptor =
+    name         := <get-sdf-main-module>;
+    pkgname      := <BasePackage <+ default-package-name>;
+    extensions   := <require-option(EditorExtensions |"File extensions (-e)")>;
+    parsetable   := <parse-table-target>;
+    startsymbols := <![<StartSymbol>] <+ ![]>;
+    
+    !|[
+      module <main-descriptor-name>
+      
+      imports
+        <descriptor-name> "-Builders"
+        <descriptor-name> "-Colorer"
+        <descriptor-name> "-Completions"
+        <descriptor-name> "-Folding"
+        <descriptor-name> "-Outliner"
+        <descriptor-name> "-References"
+        <descriptor-name> "-Syntax"
+      
+      language General properties
+        ~~
+        name:    ~name
+        id:      ~pkgname
+        extends: Root
+        ~~
+        description: <conc-strings> ("\"Spoofax/IMP-generated editor for the ", name, " language\"")
+        url: http://strategoxt.org
+        ~~
+        extensions: ~extensions
+        table:  ~parsetable
+        start symbols: ~*startsymbols
+    ]|
+
+
+  default-spx-main-descriptor =
+    name         := <get-sdf-main-module>;
+    spx-descriptor-name := $[[name]-Descriptor]; 
+    pkgname      := <BasePackage <+ default-package-name>;
+    extensions   := <require-option(EditorExtensions |"File extensions (-e)")>;
+    startsymbols := <![<StartSymbol>] <+ ![]>;
+   	!|[module <main-descriptor-name>
+   		language General properties
+        ~~
+        name    :    ~name
+      	extends : Root
+      	id      : ~ pkgname
+        ~~
+        description: <conc-strings> ("\"Spoofax/IMP-generated(using spoofaxlang) editor for the ", name, " language \"")
+        url: http://strategoxt.org
+        ~~
+        extensions: ~extensions
+        start symbols: ~*startsymbols
+    ]|
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,126 @@
+module sdf2imp/services/create-outliner-descriptor
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+  sdf2imp/services/common
+  sdf2imp/services/ast-form-heuristic
+
+
+strategies 
+	
+	build-outliner-descriptor = 
+		!|[ module <descriptor-name> "-Outliner"
+        
+        outliner
+          ~
+          ~// This file can be used for custom outliner rules.
+          ~//
+          ~// See the imported file for a brief introduction and examples.
+		 ]|
+		 
+	build-derived-outliner-descriptor = 
+		 !|[ module <descriptor-name> "-Outliner.generated"
+        
+         outliner Default outliner        
+          ~
+          ~// Outliner rules indicate which syntactic constructs should be shown in the outline
+          ~// and quick outline views, and take one of the following forms:
+          ~//
+          ~//   <sort>.<constructor>
+          ~//
+          ~//   <sort>._
+          ~//
+          ~//   _.<constructor>
+          ~
+        ]|
+        
+strategies
+	
+	create-spx-outliner-descriptor = 	
+		where(
+				descriptor-name		:=	"Outliner" 
+		);
+!$[module [descriptor-name]
+		 	
+[<build-outliner-descriptor;pp-descriptor-contents>]
+	Start.Module
+	Definition.Entity
+]
+	
+	 	
+	create-spx-derived-outliner-descriptor = 	
+		where(
+				descriptor-name		:=	"Outliner-Generated" 
+		);
+	!$[module [descriptor-name]
+		 	
+[<build-derived-outliner-descriptor; pp-descriptor-contents>]
+	 	
+	 	]	
+  
+strategies
+
+  create-outliner-descriptor =
+    output-initial-descriptor-file(
+      <descriptor-name> "-Outliner"
+    , !|[
+        module <descriptor-name> "-Outliner"
+        
+        imports <descriptor-name> "-Outliner.generated"
+        
+        outliner
+          ~
+          ~// This file can be used for custom outliner rules.
+          ~//
+          ~// See the imported file for a brief introduction and examples.
+      ]|
+    );
+   create-derived-outliner-descriptor
+  
+  create-derived-outliner-descriptor =
+    not(is-heuristic-services-needed);
+    verbose-msg(!"Skipping", <descriptor-name> "-Outliner.generated")
+  <+
+    output-derived-descriptor-file(
+      <descriptor-name> "-Outliner.generated"
+    , 
+      heuristic-outliner-productions;
+      map(create-folding-or-outliner-rule);
+      !|[
+        module <descriptor-name> "-Outliner.generated"
+        
+        outliner Default outliner        
+          ~
+          ~// Outliner rules indicate which syntactic constructs should be shown in the outline
+          ~// and quick outline views, and take one of the following forms:
+          ~//
+          ~//   <sort>.<constructor>
+          ~//
+          ~//   <sort>._
+          ~//
+          ~//   _.<constructor>
+          ~
+          ~*<id>
+      ]|
+    )
+  
+  heuristic-outliner-productions =
+    StartSymbol;
+    
+    heuristic-collect-all-rtg({
+      not(is-list-production);
+      
+      where(
+        heuristic-child-sorts;
+        one(heuristic-sort-is-identifier => reason1);      
+        one(heuristic-sort-is-unvisited-list => reason2)
+      );
+      
+      if-verbose3(
+        verbose-msg(!"Outliner match:", heuristic-asfix-sort-name, constructor-name);
+        verbose-msg(!"  because:     ", !reason1);
+        verbose-msg(!"  and:         ", !reason2)
+      )
+    })

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-outliner.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-references-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-references-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-references-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-references-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,84 @@
+module sdf2imp/services/create-references-descriptor
+
+imports
+  libstratego-lib
+  libstratego-sdf
+  
+  sdf2imp/util/-
+  sdf2imp/main
+
+
+strategies 
+	
+	build-derived-references-descriptor = 
+		  !|[
+        module <descriptor-name> "-References.generated"
+        
+        references
+          ~
+          ~// Reference resolving rules can specify the syntax constructors for which
+          ~// a reference resolving function is available:
+          ~//
+          ~//   reference FunctionCall : resolve-function-call 
+          ~//
+          ~// This defines that for each FunctionCall, resolve-function-call
+          ~// will retrieve the AST node that declares it.
+          ~//
+          ~// Likewise, hover help can be specified as follows:
+          ~//
+          ~//   hover FunctionCall : hover-help-function-call
+          ~//
+          ~// Reference resolving uses the semantic provider defined in YourLanguage-Builders.esv
+          ~// All semantic services may make use of the dynamic rules created by the observer.
+      ]|
+  
+  build-references-descriptor =
+  	!|[
+        module <descriptor-name> "-References"
+        
+        imports <descriptor-name> "-References.generated"
+        
+        references
+          ~~
+          ~~// This file can be used to specify reference resolving and hover help, and content completion.
+          ~~//
+          ~~// See the imported file for a brief introduction and examples.
+          ~~
+        references
+          ~~
+          reference _ : editor-resolve
+          hover     _ : editor-hover
+      ]|
+      
+  	
+strategies
+
+  create-references-descriptor =
+    output-initial-descriptor-file(
+      <descriptor-name> "-References"
+    , build-references-descriptor 
+    );
+    create-derived-references-descriptor
+   
+    
+  create-derived-references-descriptor =
+    not(is-heuristic-services-needed);
+    verbose-msg(!"Skipping", <descriptor-name> "-References.generated")
+  <+
+    output-derived-descriptor-file(
+      <descriptor-name> "-References.generated"
+      ,build-derived-references-descriptor
+    )
+
+
+
+strategies
+	 
+	 create-spx-derived-references-descriptor =
+	 	where(
+	 		descriptor-name		:=	"References-Generated"
+ 		);
+ 		!${module {descriptor-name}
+	 	
+{<build-derived-references-descriptor; pp-descriptor-contents>}
+	 		}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-editorservices.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-editorservices.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,64 @@
+module sdf2imp/services/create-spxlang-editorservices
+
+imports 
+	sdf2imp/options
+	sdf2imp/util/-
+rules 
+	
+	create-spxlang-editorservices= 
+			output-spx-editor-services;
+			output-spx-derived-editor-services 
+	
+	output-spx-derived-editor-services = 
+		lang-name       := <get-sdf-main-module>;
+		file-name 		  := $[editor-services.generated] ;
+		file-extension  := ".spx";
+		package-name    := <BasePackage <+ default-package-name>;
+	  
+	  if is-heuristic-services-needed then 
+		<output-text-file(|["src"] , $[[file-name][file-extension]])>
+$[package [package-name].generated
+		 		
+[<create-spx-derived-builders-descriptor>]
+		 		
+[<create-spx-derived-references-descriptor>]
+		 		
+[<create-spx-derived-outliner-descriptor>]
+		 		
+[<create-spx-derived-contentfolding-descriptor>]
+		 		
+[<create-spx-derived-colorer-descriptor>]
+		 		
+[<create-spx-derived-contentcompletion-descriptor>]
+		 		
+[<create-spx-derived-syntax-descriptor>]
+		 			
+] 
+	 	else
+	 		  verbose-msg(!"Skipping", <concat-strings>["src/" , file-name ,file-extension])
+	 	end
+ 	  	
+	
+	output-spx-editor-services = 
+		lang-name       := <get-sdf-main-module>;
+		file-name 		  := <spx-file-name>"-editor-services" ;
+		file-extension  := ".spx" ;
+		package-name    := <BasePackage <+ default-package-name>;
+		
+		if  not(<file-exists> <concat-strings>["src/" , file-name , file-extension]) then 
+			<output-text-file(|["src"] , $[[file-name][file-extension]])>
+$[package [package-name]
+	 		
+[<create-spx-outliner-descriptor>]
+	 		
+[<create-spx-contentfolding-descriptor>]
+	 			
+[<create-spx-colorer-descriptor>]
+	 		
+[<create-spx-contentcompletion-descriptor>]
+	 			
+[<create-spx-syntax-descriptor>]
+]
+		else	 	 	
+ 			verbose-msg(!"Skipping", <concat-strings>["src/" , file-name ,file-extension])
+ 		end 	
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-language-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-language-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,30 @@
+module sdf2imp/services/create-spxlang-language-descriptor
+
+imports 
+	sdf2imp/options
+	sdf2imp/util/-
+rules 
+	
+	create-spxlang-main-descriptor = 
+		where(
+			lang-name       := <get-sdf-main-module>;
+			file-name 		  := <spx-file-name> "-Descriptor";
+			file-extension  := ".spx";
+			package-name    := <BasePackage <+ default-package-name>;
+			spx-descriptor-module-name := $[[lang-name]-Descriptor]
+		);
+		if not(<file-exists> <conc-strings> ("src/", file-name  , file-extension)) then 
+		 	<output-text-file(|["src"] , $[[file-name][file-extension]])>
+		 $[package [package-name]
+	 		
+module [spx-descriptor-module-name]
+	 		
+imports [package-name].generated  
+	 		
+[<default-spx-main-descriptor;pp-descriptor-contents;debug(!"pp main descriptor : ")>]
+	 			
+]
+		else
+			verbose-msg(!"Skipping", <conc-strings> ("src/", file-name  , file-extension))
+		end
+		
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-syntax-descriptor.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-syntax-descriptor.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-syntax-descriptor.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-syntax-descriptor.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,89 @@
+module sdf2imp/services/create-syntax-descriptor
+
+imports
+  libstratego-lib
+  
+  sdf2imp/util/-
+
+
+strategies
+	
+	build-syntax-descriptor  = 
+		!|[
+        module <descriptor-name> "-Syntax"
+        
+        imports <descriptor-name> "-Syntax.generated"
+        
+        language
+          ~
+          ~// This file can be used for custom syntax rules.
+          ~//
+          ~// See the imported file for a brief introduction and examples.
+      ]|
+	
+	
+	build-syntax-descriptor-generated = 
+     	// TODO: Infer syntax properties from the SDF definition?
+      !|[
+        module <descriptor-name> "-Syntax.generated"
+        
+        language Syntax properties (static defaults)
+          ~
+          ~// Comment constructs:
+          line comment: "//"
+          block comment: "/*" * "*/"
+          ~
+          ~// Fences (used for matching,
+          ~// inserting, indenting brackets):
+          fences: [  ]
+                  (  )
+                  {  }
+          ~
+          ~// Automatic indent hints
+          ~// (indent after these tokens):
+          indent after: "="
+                        ":"
+          ~
+          ~// Regular expression for identifiers:
+          identifier lexical: "[A-Za-z0-9_]+"
+      ]|
+ 
+		
+strategies
+
+	
+	create-syntax-descriptor =
+    output-initial-descriptor-file(
+      <descriptor-name> "-Syntax"
+    , build-syntax-descriptor
+    );
+    
+  output-derived-descriptor-file(
+      <descriptor-name> "-Syntax.generated"
+    ,	build-syntax-descriptor-generated
+    )
+
+strategies
+		
+	create-spx-derived-syntax-descriptor = 	
+		where(
+				descriptor-name		:=	"Syntax-Generated" 
+		);
+	 	!${ module {descriptor-name}
+		 	
+		 	{<build-syntax-descriptor-generated; pp-descriptor-contents>}
+		 	}
+	
+	
+	
+	create-spx-syntax-descriptor = 	
+		where(
+				descriptor-name		:=	"Syntax" 
+		);
+	!$[module [descriptor-name]
+		 	
+	 	[<build-syntax-descriptor ; pp-descriptor-contents>]
+	 	]
+		 			
+			
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/class-naming.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/class-naming.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,39 @@
+module sdf2imp/util/class-naming
+
+imports
+  libstratego-lib
+
+strategies
+
+  /** Create and reserve a unique Java class name. */
+  reserve-class-name =
+    to-java-class-name => name;
+    
+    for(
+      !(0, name)
+    , not((id, IsReservedClassName))
+    , {n: // Create a new name0 ... nameN until non-reserved name found
+          ?(n, _);
+          (inc, <conc-strings> (name, <write-to-string> n))
+      }
+    );
+    
+    reserved := <Snd>;
+    
+    rules(IsReservedClassName: reserved)
+  
+  to-java-class-name =
+    string-as-chars(
+      filter(is-java-identifier-char);
+      if [is-num | id] + [] then
+        !["N", <id>]
+      end;
+      [to-upper | id]
+    )
+  
+  is-java-identifier-char =
+    is-alphanum + '$' + '_'
+  
+  get-main-class-name =
+    get-sdf-main-module;
+    to-java-class-name

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/construct-text.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/construct-text.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,545 @@
+module sdf2imp/util/construct-text
+
+imports 
+  libstratego-lib 
+  libstratego-gpp
+  sdf2imp/util/origin-tracking 
+
+rules //API for text reconstruction
+
+/*
+ * Constructs the textual change associated with 
+ * the transformation that replaces a (sub)term (oldnode) with a new (sub)term (newnode).
+ * @param custom pp strategy used to construct the text fragment for nodes that miss origin information
+ * @param pp-table used to get separator information (and as backup for text construction)
+ * @type (original-node, new-node) -> ((Int,Int), String)
+ */	
+construct-textual-change(pp|pp-table):
+	(oldnode, newnode) -> (start-offset, end-offset, newText)
+	where
+		if <origin-term> newnode then
+			origin-tracked-node:=newnode
+		else
+			origin-tracked-node:=<origin-set-relation(|oldnode)> newnode
+		end
+	where
+		((start-offset, end-offset), newText):=
+	<
+		ast-change-to-text-change(
+			pp <+ (ast2abox(|[pp-table]); box2text-string(|100))|
+			pp-table
+		)
+	> REPLACEMENT(oldnode, <construct-text-by-compare(
+		pp <+ (ast2abox(|[pp-table]); box2text-string(|100))|
+		pp-table)> (oldnode, newnode)) //TODO: refactor
+
+construct-textual-change(pp|pp-table):
+	(oldnode, newnode) -> (0, 0, "")
+	where
+		<eq> (oldnode, newnode)
+
+construct-textual-change(pp|pp-table) =
+	map(construct-textual-change(pp|pp-table))
+	
+rules //text reconstruction for AST nodes
+
+/**
+ * Constructs the (dedented) textfragment for a node, using source fragments when possible.
+ * The textfragment includes (surrounding) comments, 
+ * and the start indentation is removed from all lines.
+ * @param pretty-print strategy
+ * @param pretty-print table
+ * @type node -> String
+ */
+construct-text(pp|pp-table) = 
+	construct-text-from-origin(pp|pp-table) <+
+	construct-text-for-primitive <+
+	construct-text-base-list(pp|pp-table) <+
+	construct-text-by-pp-rec(pp|pp-table) <+
+	construct-text-by-pp(pp|pp-table)
+
+construct-text-for-primitive=
+	?node;
+	(is-string <+ 
+	int-to-string);
+	add-origin-comments(|node)  
+	 
+construct-text-from-origin(pp|pp-table):
+	node -> text
+	where
+		origin-node:=<origin-term> node; 
+		<same-signature <+ unmodified-list> (node, origin-node);
+		text := <construct-text-by-compare(pp|pp-table)> (origin-node, node)
+		
+construct-text-by-compare(pp|pp-table): (origin-node, node) -> text
+	where
+		ast-changes:=<collect-ast-changes> (origin-node, node); //debug(!"ast-changes: ");
+		text-changes:=<map(ast-change-to-text-change(pp|pp-table)); flatten-list> ast-changes; //debug(!"txt-changes: ");
+		text:=<
+			apply-text-changes; //debug(!"applied: ");
+			remove-indentation(|<origin-indent-value-node> node) //;debug(!"indent-corr: ")
+		>(text-changes, <origin-text-with-comments> node, <origin-offset-with-comments> node)					
+
+construct-text-base-list(pp|pp-table)=
+	construct-list-fragments-base(pp|pp-table) <+ 
+	(?[h|[]]; !h)
+	
+construct-text-by-pp-rec(pp|pp-table):
+	node -> text
+	where
+	text:=<
+		all(try(
+			(is-list; construct-list-fragments(pp|pp-table); map(trim-chars(is-whitespace-char))) <+
+			(not(is-list); construct-text(pp|pp-table); trim-chars(is-whitespace-char))
+		)); 
+		pp;
+		trim-chars(is-whitespace-char <+?'\n');
+		add-origin-comments(|node)
+	> node
+
+construct-text-by-pp(pp|pp-table):
+	node -> <
+		pp; 
+		trim-chars(is-whitespace-char <+?'\n');
+		add-origin-comments(|node)
+	> node
+	
+add-origin-comments(|node): 
+	text -> commented-text
+	where 
+		if
+			<origin-has-comments> node
+		then
+			commented-text:=<
+				apply-text-changes; 
+				remove-indentation(|<origin-indent-value-node> node)
+			>(
+				[(
+					<origin-offset> node, 
+					<prefix-lines(|<origin-indent-node> node); trim-leading-whitespace>text
+				)], 
+				<origin-text-with-comments> node, 
+				<origin-offset-with-comments> node
+			)					
+		else
+			commented-text:=text
+		end
+
+rules //text reconstruction for AST Lists
+
+/**
+ * Constructs the textfragment for a list term consisting of a mix of elements with/without origin info.
+ * Sublist textfragments are constructed from origin or by pp and separated by the given separation.
+ * @param pretty-print strategy
+ * @param pretty-print table
+ * @param separation between the textual representation of the elements
+ * @type List -> String
+ */
+construct-list-text(pp|pp-table, sep):
+	lst -> <
+		construct-list-fragments(pp|pp-table);
+		map(trim-leading-whitespace);
+		concat-fragments(|sep)
+	> lst
+
+/**
+ * Constructs a list with textfragments that represent sublists of the original list
+ * @type List(Node)[lenth n] -> List(String)[length <= n]
+ */
+construct-list-fragments(pp|pp-table)=
+ 	at-suffix(
+ 		where(origin-sublist-term<+<eq>(<length>, 1)); 
+ 		![<id>]
+ 	); 
+ 	(init,last):=<split-init-last>;
+ 	![
+ 		<	if ?[] <+ ?[_] <+ origin-sublist-term then 
+ 				construct-list-fragments-base(pp|pp-table) 
+ 			else
+ 				construct-list-fragments(pp|pp-table)
+ 			end
+ 		> init,
+ 		<construct-list-fragments-base(pp|pp-table)> last
+ 	];
+ 	flatten-list 
+
+construct-list-fragments-base(pp|pp-table):
+	[] -> []
+	
+construct-list-fragments-base(pp|pp-table):
+	lst -> [<construct-text-from-origin(pp|pp-table)> lst]
+	where
+		<is-list> lst
+
+construct-list-fragments-base(pp|pp-table):
+	[h|[]] -> [<construct-text(pp|pp-table)> h]
+
+rules //helpers text reconstruction
+concat-fragments(|seperation)= 
+	separate-by(|seperation); 
+	concat-strings
+	
+is-whitespace-char=
+	?'\t' <+' '
+
+remove-indentation(|n)=
+	all-lines(string-as-chars(dedent-line-chars(|n)));
+	trim-chars(?' ' <+ ?'\t')//<+ ?'\n'
+		
+dedent-line-chars(|n):
+	chars -> dedented-chars
+	where
+		(
+			<lt> (n,0); 
+			indent:=<copy-char; explode-string> (<abs>n, ' '); 
+			dedented-chars:=<conc>(indent,chars)
+		)<+
+		(
+			<gt> (n,0);
+			<?[' '|tail]> chars;
+			dedented-chars:=<dedent-line-chars(|<dec> n)> tail
+		)<+
+		(
+			<gt> (n,0);
+			<?['\t'|tail]> chars; 
+			dedented-chars:=<dedent-line-chars(|<subt> (n, <tabsize>))> tail				
+		)<+
+		dedented-chars:=chars
+
+rules // ast-diff
+
+signature constructors //signatures for AST changes
+	INSERT_AT_END : OldList * NewSubList -> AST_CHANGE
+	INSERT_BEFORE : OldNode * NewSubList -> AST_CHANGE
+	DETETION : OldNode -> AST_CHANGE
+	REPLACEMENT : OldNode * NewNode -> AST_CHANGE
+
+	//with parent path to lookup separator for list elements
+	INSERT_AT_END : ParentPath * OldList * NewSubList -> AST_CHANGE
+	INSERT_BEFORE : ParentPath * OldNode * NewSubList -> AST_CHANGE
+	REPLACEMENT : ParentPath * OldNode * NewNode -> AST_CHANGE
+
+
+rules //collecting ast changes
+
+/**
+ * Constructs the diff between two AST nodes in terms of replacements, list insertions and list deletions.
+ * List elements are matched based on origin-relation or identity
+ * @type (Node1, Node2) -> List(AST_CHANGE)
+ */
+collect-ast-changes:
+	(oldTrm, newTrm) -> ast-changes
+	where
+		if <eq> (oldTrm, newTrm) then //stop for equal nodes
+			ast-changes:=[]			
+		else if <same-signature <+ unmodified-list> (oldTrm, newTrm) then //recursively compare child nodes
+			ast-changes:=<
+				zip;
+				map-with-index(collect-ast-changes-keep-parent-path(|oldTrm)); 
+				flatten-list
+			>(<get-arguments> oldTrm, <get-arguments> newTrm)  
+		else if <is-list> oldTrm; <is-list> newTrm then //compare lists
+			ast-changes:=<collect-ast-changes-in-list> (oldTrm, newTrm) 
+		else
+			ast-changes:=[REPLACEMENT(oldTrm, newTrm)] //AST node replacement 
+		end
+		end
+		end
+
+/**
+ * Constructs the diff between two AST nodes in terms of replacements, list insertions and list deletions.
+ * Parent path (constructor of parent node + index) is preserved 
+ * in case the separator must be looked up in the pp-table.
+ * @param parent node
+ * @type (Node1, Node2) -> List(AST_CHANGE)
+ */		
+collect-ast-changes-keep-parent-path(|parent):
+	(index, (old-child, new-child)) -> result
+	where
+		parent-path:=(<get-constructor> parent, index);
+		if 
+			<lt>(<length> old-child,2); 
+			<gt>(<length> new-child,1) 
+		then  //separator can not be looked up in the original list
+			result:=<
+				collect-ast-changes-in-list;
+				map(try(
+					\INSERT_BEFORE(v, w) -> INSERT_BEFORE(parent-path, v, w)\ <+
+					\INSERT_AT_END(x, y) -> INSERT_AT_END(parent-path, x, y)\ <+
+					\REPLACEMENT(t, u) -> REPLACEMENT(parent-path, t, u)\
+				))
+			> (old-child, new-child)
+		else if 
+			<not(is-list)> old-child;
+			<gt>(<length> new-child,1)
+		then //separator can not be looked up in the original list
+			result:=[REPLACEMENT(parent-path, old-child, new-child)]
+		else 
+			result:=<collect-ast-changes> (old-child, new-child)
+		end
+		end
+
+collect-ast-changes-in-list=
+	?(oldlist,newlist);
+	collect-ast-changes-in-list(|oldlist); 
+	where(
+		<at-least-one-match>(oldlist, newlist) //deleting old elements + inserting new elements gives a separation problem
+	)
+
+collect-ast-changes-in-list=
+	?(oldlist,newlist);
+	![REPLACEMENT(oldlist, newlist)];
+	where(
+		<is-list> oldlist; 
+		<is-list> newlist;
+		<not(at-least-one-match)> (oldlist, newlist)
+	)
+	
+at-least-one-match=
+	?([h|tail], newlist);
+	(<fetch(
+		where(equal(|h)<+origin-equivalent(|h))
+	)> newlist <+ 
+	<at-least-one-match> (tail, newlist))
+
+/*
+ * Compare lists and return insertions, deletions and replacements of elements
+ */		
+collect-ast-changes-in-list(|oldlist)=
+	collect-ast-changes-in-list-insert-at-end(|oldlist) <+
+	collect-ast-changes-in-list-match-header(|oldlist) <+
+	collect-ast-changes-in-list-no-header-match(|oldlist)
+
+//header element old elems exists in new elems
+//ex. ([a,b,c], [x,y,a',b']) -> [InsertBefore([x,y]), <collext-ast-changes>(a,a'), <collect-ast-changes-in-list>([b,c], [b'])]
+collect-ast-changes-in-list-match-header(|oldlist)=
+	?([old-h|old-tail], new-elems);
+	(before, new-h, after):=<split-fetch-keep(
+		where(equal(|old-h) <+ origin-equivalent(|old-h))
+	)> new-elems;
+	ast-changes:=<flatten-list>[
+		<collect-ast-changes>(old-h, new-h),
+		<collect-ast-changes-in-list(|oldlist)>(old-tail, after)
+	];
+	if <not(?[])> before then
+		![INSERT_BEFORE(old-h, before)|ast-changes]
+	end
+
+collect-ast-changes-in-list-match-header(|oldlist, new-elems):
+	old-elems -> <collect-ast-changes-in-list-match-header(|oldlist)> (old-elems, new-elems)
+
+//header element old elems is deleted
+//ex. ([a,b,c,d,e], [x,y,c',d']) -> [D([a,b]), <coll-l>([c,d,e],[x,y,c'd'])]
+collect-ast-changes-in-list-no-header-match(|oldlist)=
+	?(old-elems, new-elems);
+	resolved-suffix:=<at-suffix(collect-ast-changes-in-list-match-header(|oldlist, new-elems); ![<id>])> old-elems;
+	![DETETION(<init> resolved-suffix), <last> resolved-suffix];
+	flatten-list
+
+//all-old-elems-deleted
+//ex. ([a,b,c], [x,y,z]) -> [Del(a,b,c), <coll-ch> ([], [x,y,z])]
+collect-ast-changes-in-list-no-header-match(|oldlist)=
+	?(old-elems, new-elems);
+	where(not(at-least-one-match()));
+	![DETETION(old-elems), <collect-ast-changes-in-list-insert-at-end(|oldlist)> ([], new-elems)];
+	flatten-list
+
+//collects remaining new elems as insertions
+//ex. ([], [x,y]) -> Iend([x,y])
+collect-ast-changes-in-list-insert-at-end(|oldlist)= 
+	?([], new-elems); 
+	if <?[_|_]> new-elems then
+		![INSERT_AT_END(oldlist, new-elems)]
+	else
+		![]
+	end
+
+rules //helpers compare nodes
+	
+same-signature =
+	?(trm1, trm2);
+	where(
+		<eq>(<get-constructor> trm1, <get-constructor> trm2);
+		<eq>(<get-arguments; length> trm1, <get-arguments; length> trm2);
+		<not(is-list)> trm1; <not(is-list)> trm2
+	)
+	
+unmodified-list=
+	?(lst1, lst2);
+	<zip; map(equal <+ origin-equivalent)> (lst1, lst2)
+
+origin-equivalent=
+	?(t1,t2);
+	where(
+		<eq>(<origin-term> t1, <origin-term> t2) <+
+		<same-signature; all(not(origin-term))> (t1,t2)
+	) 
+	
+origin-equivalent(|t1):
+	t2 -> <origin-equivalent> (t1,t2)
+	
+rules //translating ast-changes to text changes
+
+rules //Replacement
+	
+ast-change-to-text-change(pp|pp-table):
+	REPLACEMENT(parent-path, old-trm, new-trm) -> <ast-change-to-text-change(pp|pp-table, separator)> REPLACEMENT(old-trm, new-trm)
+	where 
+		separator:=<get-separator-from-table(|pp-table) <+ !""> parent-path
+
+ast-change-to-text-change(pp|pp-table):
+	REPLACEMENT(old-trm, new-trm) -> <ast-change-to-text-change(pp|pp-table, sep)> REPLACEMENT(old-trm, new-trm)
+	where
+		 sep:=<last; origin-separator-text> old-trm <+
+		 sep:=<fetch-elem(origin-term); origin-separator-text> new-trm <+
+		 sep:= ""
+
+ast-change-to-text-change(pp|pp-table, sep):
+	REPLACEMENT(old-trm, new-trm) -> (offset, txt)
+	where
+		if <origin-has-comments> new-trm then
+			offset:=<origin-offset-with-comments> old-trm
+		else
+			offset:=<origin-offset> old-trm
+		end;
+		ws-sep:=<origin-separating-ws <+ !" "> new-trm;
+		txt:=<
+			(construct-list-text(pp|pp-table, <conc-strings>(sep, ws-sep)) <+ construct-text(pp|pp-table));
+			prefix-lines(|<origin-indent-node> old-trm);
+			trim-leading-whitespace 
+		> new-trm 
+
+rules //Deletion
+	
+ast-change-to-text-change(pp|pp-table):
+	DETETION(old-trm) -> deletions
+	where
+		offset:=<origin-offset-with-layout> old-trm;
+		txt:="";
+		if 
+			separator-offset:=<origin-separator-offset-with-lo> old-trm
+		then
+			deletions:=[(offset, txt), (separator-offset,"")]
+		else
+			deletions:=(offset, txt)
+		end
+		
+rules //Insert Before
+	
+ast-change-to-text-change(pp|pp-table):
+	INSERT_BEFORE(old-node, new-sublist) -> <ast-change-to-text-change(pp|pp-table, sep)> INSERT_BEFORE(old-node, new-sublist)
+	where
+		sep:= <origin-separator-text <+ !""> old-node
+
+ast-change-to-text-change(pp|pp-table):
+	INSERT_BEFORE(parent-path, old-list, new-sublist) -> 
+		<ast-change-to-text-change(pp|pp-table, separator)> INSERT_BEFORE(old-list, new-sublist)
+		where
+			separator:=<get-separator-from-table(|pp-table) <+ !""> parent-path
+
+ast-change-to-text-change(pp|pp-table, sep):
+	INSERT_BEFORE(old-node, new-sublist) -> (insert-offset, new-text)
+	where
+		indent:=<origin-indent-node> old-node; 
+		seperation := <conc-strings>(
+			sep, 
+			<origin-separating-ws <+ !" "> old-node
+		); 
+		constructed-text := <
+			construct-list-text(pp|pp-table, seperation);
+			prefix-lines(|indent);
+			trim-leading-whitespace
+		> new-sublist;
+		new-text:=<concat-strings> [constructed-text, seperation, indent]; 
+		start-offset-oldnode:=<origin-offset-with-comments; Fst> old-node; 
+		insert-offset:=(start-offset-oldnode, start-offset-oldnode)
+
+rules //Insert At End
+
+ast-change-to-text-change(pp|pp-table):
+	INSERT_AT_END(old-list, new-sublist) -> <ast-change-to-text-change(pp|pp-table, sep)> INSERT_AT_END(old-list, new-sublist)
+	where
+		sep:=<try(last); (origin-separator-text <+ !"")> old-list
+
+ast-change-to-text-change(pp|pp-table):
+	INSERT_AT_END(parent-path, old-list, new-sublist) -> 
+		<ast-change-to-text-change(pp|pp-table, separator)> INSERT_AT_END(old-list, new-sublist)
+		where
+			separator:=<get-separator-from-table(|pp-table) <+ !""> parent-path
+	
+ast-change-to-text-change(pp|pp-table, sep):
+	INSERT_AT_END(old-list, new-sublist) -> (insert-offset, new-text)
+	where 
+		indent := <try(last); origin-indent-node> old-list; 
+		seperation := <conc-strings>(
+			sep, 
+			<try(last); origin-separating-ws<+!" "> old-list
+		); 
+		constructed-text := <
+			construct-list-text(pp|pp-table, seperation);
+			prefix-lines(|indent)
+		> new-sublist;
+		if <not(?[])> old-list then  
+			new-text := <conc-strings> (seperation, constructed-text)
+		else
+			new-text :=constructed-text
+		end;
+		offset-end-list := <try(last); origin-offset-with-comments; Snd> old-list; 
+		insert-offset := (offset-end-list, offset-end-list)
+
+rules //helpers ast-change-to-text-change
+
+get-separator-from-table(|tbl):
+ 	(cons-name, argnr) -> separator
+ 	where 
+ 	arg-nr-string:=<int-to-string> argnr;
+ 	separator:=<
+ 		<collect-one(?PP-Entry(Path(cons-name,[selector(arg-nr-string, "iter-star-sep")]),x))> tbl;
+ 		!x;
+ 		filter(not(Arg("1")));
+ 		box2text-string(|100);
+ 		un-double-quote; 
+ 		trim-whitespace
+ 	>
+
+
+rules //Applying the textual modifications
+
+/*
+ * Applies textchanges (src-offset, text) to a textfragment with a given src-offset  
+ * @type (List(((Int,Int), String)), String, Int) -> String
+ */
+apply-text-changes:
+	(text-changes, text, offset) -> changed-text
+	where 
+		start-offset:=<Fst> offset;
+		ordered-text-changes:=<make-set; filter(is-modification); sort-list(LSort(compare-text-change))> text-changes;
+		changed-text:= <foldr(!(start-offset, text), apply-textual-change); Snd> ordered-text-changes
+
+apply-textual-change:
+	(change, text-info) -> (char-pos, result-text)
+	where 
+		<?(char-pos, text-fragment)> text-info; 
+		<?((change-start, change-end), change-text)> change; 
+		pos-start:=<subt>(change-start, char-pos); 
+		pos-end:=<subt>(change-end, char-pos); 
+		result-text:=<replace-in-text>
+			(text-fragment, change-text, pos-start, pos-end) 
+
+replace-in-text:
+	(old-text, text-change, pos-start, pos-end) -> result-text
+	where
+		old-chars:=<explode-string> old-text; 
+		(prefix, tail):=<split-at(|pos-start)> old-chars; 
+		(heads, suffix):=<split-at(|pos-end)> old-chars; 
+		result-text:=<conc-strings> (<implode-string> prefix, text-change, <implode-string> suffix) 
+		
+compare-text-change = 
+		?(((start-x, end-x),x), ((start-y, end-y),y));
+		not(
+			<lt> (start-x, start-y) <+ 
+			<eq> (start-x, start-y); <lt> (end-x, end-y)
+		)
+
+is-modification =
+	not(?((t, t),"")) 

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/ide-support.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/ide-support.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,86 @@
+/**
+ * Strategies used directly by the Java code of the IDE.
+ */
+module sdf2imp/util/ide-support
+
+imports
+  libstratego-lib
+  libstratego-sglr
+
+strategies
+
+  // (Used from StrategoObserver.java)
+  postprocess-feedback-results =
+    (is-list <+ ![<id>]);
+    flatten-list;
+    map(
+      try(
+        (id, postprocess-feedback-message)
+      )
+    )
+  
+  internal postprocess-feedback-message =
+    if is-list then
+      flatten-list;
+      map(is-string <+ write-to-string);
+      concat-strings
+    else
+      is-string <+ write-to-string
+    end
+  
+  simplify-ambiguity-report:
+  	amb([]) -> $[ambiguity in literal or layout]
+  
+  simplify-ambiguity-report:
+    amb(a* @ [_ | _]) -> $[either [a'*]]
+    where
+      !a*;
+      map(try(?ToMetaExpr(<id>)));
+      map(simplify-ambiguity-element);
+      where(<eq> (<id>, <make-set>)); // no duplicates
+      a'* := <separate-by(|" or ")>
+
+  simplify-ambiguity-element:
+    [x] -> $[list of [<simplify-ambiguity-element> x]]
+
+  simplify-ambiguity-element:
+    x#(_) -> x'
+    with
+      x' := <is-string <+ write-to-string> x
+
+rules
+
+  position-of-term(is-term):
+    t -> []
+    where
+      is-term
+  
+  position-of-term(is-term):
+    _#(t*) -> <position-of-term(is-term|0)> t*
+  
+  position-of-term(is-term|start-index):
+    [t | t*] -> position
+    where
+      if i* := <position-of-term(is-term)> t then
+        position := [start-index | i*]
+      else
+        position := <position-of-term(is-term | <inc> start-index)> t*
+      end
+
+  term-at-position(|position):
+    t -> t'
+    where
+      at-position(?t'|position)
+   
+  at-position(s|position):
+    c#(t*) -> t'
+    where
+      !position => [i | position']
+    where
+      t' := c#(<at-index(at-position(s|position'))> (i, t*))
+
+  at-position(s|position):
+    t -> t'
+    where
+      !position => [];
+      t' := <s> t

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/input.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/input.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,128 @@
+module sdf2imp/util/input
+
+imports
+  libstratego-gpp
+  libstratego-sglr
+  libstratego-lib
+  
+  sdf2imp/lib/-
+
+
+strategies
+	spx-file-name:
+		name -> <lower-case> $[[prefix][name]]
+    where
+    	lang-name := <get-sdf-main-module>;
+    	prefix := $[[lang-name]]
+    	
+    	
+strategies
+
+  /**
+   * Given a location and filename (no extension),
+   * parse an editor descriptor, including all imports.
+   */
+  input-descriptor-file =
+    {| IsImported:
+      ?import;
+      name := <conc-strings> (<main-descriptor-name>, ".packed");
+      <fetch-imports> Module(name, Imports([Import(import)]), [])
+    |}
+  
+  set-input-dir-prefix =
+    with(string-ends-with(|"/"));
+    rules(InputDirPrefix := <id>)
+  
+  add-input-dir-prefix =
+    <set-input-dir-prefix> <conc-strings> (<InputDirPrefix <+ !"">, <id>)
+
+/** @internal */
+strategies
+  
+  include-input-dir-prefix =
+    try(<conc-strings> (<InputDirPrefix>, <id>))
+    
+  // TODO: Optimize - file input/parsing caching
+  
+  // TODO: Multi-directory support (-I)
+  
+  input-descriptor-import =
+    ?Import(name);
+    !FILE(<add-extension; include-input-dir-prefix; file-exists> (name, "esv"));
+    parse-xtc-file-report-errors(|<parse-table-descriptor>, "Module");
+    if oncetd(?amb(_)) then
+      fatal-err(|"Parsed module has ambiguities")
+    end;
+    
+    (
+      ?Module(name, _, _)
+    <+
+      try(<OnImportFailure> Import(name)); fail // trigger failure event
+    <+
+      if <has-extension(|"esv")> <InputFile> then
+        fatal-err(|"Module name does not match file name")
+      else
+        err(|"Module name does not match file name")
+      end
+    )
+  <+
+    ?ImportRenamed(name, tail);
+    <input-descriptor-import> Import(name);
+    fetch-imports;
+    alltd(rename-sort(|tail))
+    
+  // TODO: Sort renaming could be inferred from the .def file
+  
+  rename-sort(|tail):
+    Sort(name) -> Sort(<conc-strings> (name, "_", tail))
+  
+  rename-sort(|tail):
+    ListSort(name) -> ListSort(<conc-strings> (name, "_", tail))
+  
+  fetch-imports:
+    Module(name, Imports(imports), definitions) ->
+    Module(name, Imports(imports'), definitions')
+    where
+      rules(IsImported: name);
+      
+      !imports;
+      map(
+        risky(
+          IsImported
+        <+
+          input-descriptor-import;
+          fetch-imports
+        <+
+          OnImportFailure
+        | "Unable to import module"
+        )
+      ) => imported;
+      
+      imported-defs    := <mapconcat(?Module(_, _, <id>))>;
+      definitions'     := <conc> (definitions, <id>);
+      imported-imports := <filter(?Module(_, Imports(<id>), _))> imported;
+      imports'         := <concat> [imports | <id>]
+
+  fetch-imports:
+    Module(_, NoImports(), _) -> <id>
+
+  is-older-than =
+    ?(file, otherfiles);
+    basetime := <file-exists; modification-time> file;
+    !otherfiles;
+    list-loop(
+      <lt> (basetime, <file-exists < modification-time + verbose-msg(!"Does not exist:", id); fail>)
+    )
+    
+
+/**
+ * @internal
+ */
+strategies
+  
+  parse-table-descriptor =
+    CachedParseTableDescriptor
+  <+
+    table := <open-parse-table> <import-term(EditorService.tbl)>;
+    rules(CachedParseTableDescriptor := table)
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/origin-tracking.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/origin-tracking.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,211 @@
+module sdf2imp/util/origin-tracking
+
+strategies //origin tracking strategies
+
+/* origin strategies from lib-editor extended with sublist support*/
+origin-term      = support-sublist(prim("SSL_EXT_origin_term", <id>))
+origin-text      = support-sublist(prim("SSL_EXT_origin_text", <id>))
+origin-equal(|t) = support-sublist(prim("SSL_EXT_origin_equal", <id>, t))
+
+origin-equal=
+	?(t1,t2);
+	<origin-equal(|t1)> t2
+	
+origin-set-relation(|or-node) =
+	?node;
+	!Some(or-node); 
+	all(!node); 
+	?Some(<id>)
+
+/**
+ * Returns the origin-term of a sublist
+ * @type List(Aterm) -> List(Aterm)
+ */
+origin-sublist-term = 
+	prim("SSL_EXT_origin_sublist_term","", <id>)
+
+/**
+ * Returns the start- and end- offset of the AST node
+ * @type ATerm -> (Int, Int)
+ */
+origin-offset = 
+	support-sublist(prim-origin-offset)
+
+/**
+ * Returns the start- and end- offset of the AST node, 
+ * including comments, indentation and separating whitespace
+ * @type ATerm -> (Int, Int)
+ */
+origin-offset-with-layout = 
+	support-sublist(prim-origin-offset-with-layout)
+
+/**
+ * Returns the start- and end- offset of the AST node,
+ * including comments
+ * @type ATerm -> (Int, Int)
+ */
+origin-offset-with-comments:
+	node -> (start-offset, end-offset)
+	where
+		start-offset:=<(origin-offset-comment-before <+ origin-offset); Fst> node;
+		end-offset:=<(origin-offset-comment-after <+ origin-offset); Snd> node	
+	
+/**
+ * Returns the start- and end- offset of the preceding comments
+ * that refer to the AST node (or sublist)
+ * Fails if comment does not exist
+ * @type ATerm -> (Int, Int)
+ */
+origin-offset-comment-before = 
+	support-sublist(prim-origin-offset-comment-before)
+
+/**
+ * Returns the start- and end- offset of the succeeding comments
+ * that refer to the AST node (or sublist)
+ * Fails if comment does not exist
+ * @type ATerm -> (Int, Int)
+ */
+origin-offset-comment-after = 
+	support-sublist(prim-origin-offset-comment-after)
+
+/**
+ * succeeds if the origin term of the node has associated comments
+ */
+origin-has-comments =
+	origin-offset-comment-before <+
+	origin-offset-comment-after
+
+/**
+ * Returns the indentation (string) of the start-line of the node. 
+ * For empty lists, the parent indentation + an additional tab is returned
+ * @type ATerm -> String
+ */
+origin-indent-node = 
+	try(Hd); //first element of (sub)list
+	prim-origin-indent-node
+
+/**
+ * Returns the value of the indentation of the startline 
+ * @type ATerm -> Int
+ */
+origin-indent-value-node=
+	origin-indent-node;
+	explode-string;
+	take-while(?' '<+?'\t');
+	foldr(!0, add, (?' ';!1) <+ (?'\t';tabsize))
+
+/**
+ * Returns the whitespace preceding the node (without the indentation). 
+ * @type ATerm -> String
+ */
+origin-separating-ws = 
+	support-sublist(prim-origin-separating-ws)
+
+/**
+ * Returns the separator location connected to list element or sublist
+ * @type ATerm -> (Int, Int)
+ */
+origin-separator-offset =  
+	origin-separator;
+	!(<Fst>, <Snd>)
+
+/**
+ * Returns the separator location + nearby ws and comments
+ * connected to list element or sublist
+ * @type ATerm -> (Int, Int)
+ */
+ origin-separator-offset-with-lo =
+	origin-separator-with-lo;
+	!(<Fst>, <Snd>)
+	
+/**
+ * Returns the separator connected to list element or sublist
+ * @type ATerm -> String
+ */
+origin-separator-text = 
+	origin-separator; 
+	Third
+
+/**
+ * Returns the separator text + nearby ws and comments 
+ * connected to list element or sublist
+ * @type ATerm -> String
+ */
+origin-separator-text-with-lo = 
+	origin-separator-with-lo; 
+	Third
+
+origin-separator-with-lo=
+	support-sublist(prim-origin-separator-with-lo)
+
+origin-separator=
+	support-sublist(prim-origin-separator)
+
+/**
+ * Returns the textfragment of the AST node,
+ * including comments
+ * @type ATerm -> (Int, Int)
+ */
+origin-text-with-comments=
+	?node;
+	offset := <origin-offset-with-comments> node;
+	<origin-textfragment> (<Fst> offset, <Snd> offset, node)
+
+/**
+ * Returns the textfragment from (inclusive) start- to (exclusive) end- offset. 
+ * Fails if the offsets do not correspond to a valid location in the source text
+ * @type (Int, Int, node) -> String
+ */
+origin-textfragment=
+	?(x,y, node);
+	!(x,y,<origin-term> node);
+	prim-origin-textfragment
+
+prim-origin-textfragment= prim("SSL_EXT_origin_textfragment","", <id>)
+
+/**
+ * Returns the text of the source file 
+ * @type Term -> String
+ */
+origin-sourcetext= prim("SSL_EXT_origin_sourcetext", <id>)
+
+strategies //primitives
+
+prim-origin-offset= prim("SSL_EXT_origin_offset", <id>)
+
+prim-origin-offset-with-layout= prim("SSL_EXT_origin_offset_with_layout", <id>) 
+
+prim-origin-offset-comment-before = prim("SSL_EXT_origin_comment_before", <id>) 
+
+prim-origin-offset-comment-after= prim("SSL_EXT_origin_comment_after", <id>) 
+
+prim-origin-indent-node= prim("SSL_EXT_origin_indentation", <id>)
+//todo? implement (indent empty list: parent + tab)
+
+prim-origin-separating-ws= prim("SSL_EXT_origin_separating_whitespace", <id>)
+	
+prim-origin-separator=
+	prim("SSL_EXT_origin_separator", <id>)
+
+prim-origin-separator-with-lo=
+	prim("SSL_EXT_origin_separator_with_lo", <id>)
+
+strategies //editor settings
+
+/**
+ * Returns the tabsize used in the editor. 
+ * @type  -> Int
+ */
+tabsize=!4 //TODO: use spoofax editor settings
+
+
+strategies //helpers
+
+/**
+ * Treats sublists as origin terms
+ * @param strategy to apply on an origin term 
+ * @type ATerm -> ATerm
+ */
+support-sublist(s)=
+	try(?[h|[]]; !h); 
+	((origin-sublist-term; s) <+s)
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/output.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/output.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,187 @@
+module sdf2imp/util/output
+
+imports
+  libstratego-gpp
+  libstratego-sglr
+  libjava-front
+  
+  sdf2imp/lib/-
+
+  sdf2imp/options
+  sdf2imp/util/-
+  sdf2imp/services/create-main-descriptor
+  EditorService
+
+strategies
+  
+  // pretty printing only the descriptors content 
+  pp-descriptor-contents = ?Module(_ , _, <id>) ; pp-descriptor-to-string 	 
+  
+  
+  /**
+   * Output the main descriptor file (e.g., EditorService.main.esv).
+   * This file is never overwritten.
+   */
+  output-main-descriptor-file(name, new-contents) =
+    output-descriptor-file(
+      name
+    , new-contents
+    , not(file-exists)
+    )
+  
+  /**
+   * Output an initial descriptor file (e.g., EditorService-Outliner.esv).
+   * These files are never overwritten and only generated if imported.
+   */
+  output-initial-descriptor-file(name, new-contents) =
+    output-descriptor-file(
+      name
+    , new-contents
+    , not(file-exists); is-descriptor-imported(|<name>)
+    )
+
+  /**
+   * Output an derived descriptor file (e.g., EditorService-Outliner.generated.esv).
+   * These files are always overwritten, but only if imported.
+   */
+  output-derived-descriptor-file(name, new-contents) =
+    output-descriptor-file(
+      name
+    , new-contents
+    , id 
+      // TODO: Only build derived files if imported??
+      // (doesn't currently work because transient imports are not considered)
+      // NoExistingDescriptor <+ is-descriptor-imported(|<name>)
+    )
+  
+  /**
+   * Output a descriptor file if <condition> succeeds for
+   * the full file path of the generated file.
+   *
+   * @internal
+   */
+  output-descriptor-file(name, new-contents, condition) =
+    with(
+      filename := <add-extension> (<name>, "esv");
+      path     := "editor";
+      fullpath := <conc-strings> (path, "/", filename)
+    );
+    
+    if ResetFiles <+ <condition> fullpath then
+      print-filename(|["editor"], filename);
+      new-contents;
+      (
+        ?Module(name, _ ,_);
+        pp-descriptor-to-string
+      <+
+        fatal-err(|"Illegal editor service descriptor output")
+      );
+      output-text-file'(|[path], filename)
+    else
+      verbose-msg(!"Skipping", !fullpath)
+    end
+
+  /**
+   * Output a packed descriptor file (e.g., EditorService.packed.esv).
+   */
+  output-packed-descriptor-file(|filename) =
+    with(
+      path     := "include";
+      fullpath := <conc-strings> (path, "/", filename)
+    );
+    
+    write-to-string; // pp-descriptor-to-string;
+    print-filename(|[path], filename);
+    output-text-file'(|[path], filename)
+  
+  is-descriptor-imported(|name) =
+    MainDescriptor;
+    oncetd(?Import(name) + ?ImportRenamed(name, _))
+
+/**
+ * Pretty-printing support.
+ */
+strategies
+  
+  output-java-file =
+    output-java-file(|<java-to-path>)
+
+  output-java-file(|filename) =
+    print-filename(|["editor", "java" | <to-package-name>], <base-filename> filename);
+    
+    (
+      text := <pp-java-string <+ pp-java-string-fallback>
+    <+
+      fatal-err(|"Illegal Java output")
+    );
+    
+    output-text-file'(|filename)
+  
+  java-to-path:
+    class -> fullpath
+    where
+      path     := <create-dirs> ["editor", "java" | <to-package-name>];
+      fullpath := <conc-strings> (path, "/", <class-name> class, ".java")
+    
+
+  output-xml-file(|pathparts, filename) =
+    print-filename(|pathparts, filename);
+    
+    (
+      xml-doc2abox; box2text-string(|80)
+    <+
+      fatal-err(|"Illegal XML output")
+    );
+    
+    output-text-file'(|pathparts, filename)
+  
+  output-text-file(|pathparts, filename) =
+    print-filename(|pathparts, filename);
+    output-text-file'(|pathparts, filename)
+  
+  output-text-file'(|pathparts, filename) =
+    where(path := <create-dirs> pathparts);
+    
+    output-text-file'(|<conc-strings> (path, "/", filename))
+  
+  output-text-file'(|filename) =
+    where(file := <fopen> (filename, "w"));
+    
+    <fputs> (<id>, file);
+    <fclose> file
+
+strategies
+
+  pp-java-string-fallback =
+    write-to;
+    xtc-transform(!"pp-java");
+    ?FILE(<read-text-file>);
+    warn-msg(|"PP-JAVA-STRING LIBRARY CALL FAILED; USING XTC INSTEAD")
+  
+  print-filename(|pathparts, filename) =
+    if [] := pathparts then
+      verbose-msg(!"Generating", !filename)
+    else
+      verbose-msg(!"Generating", <conc-strings> (
+                                   <separate-by(|"/"); concat-strings> pathparts
+                                 , "/", filename
+                                 ))
+    end
+  
+  create-dirs = 
+    where(root := <getcwd>);
+    map((file-exists <+ mkdir(|"w")); chdir);
+    getcwd; // return path to innermost created dir.
+    where (<chdir> root)     
+  
+  to-package-name:
+    CompilationUnit(Some(PackageDec(_, PackageName(ids))), _, _) -> xs
+    where xs := <map(?Id(<id>))> ids
+    
+  to-package-name:
+    CompilationUnit(None(), _, _) -> []
+    
+  class-name =
+    ?CompilationUnit(_, _, [ClassDec(ClassDecHead(_,Id(<id>),_,_,_),_)|_])
+  <+
+    ?CompilationUnit(_, _, [InterfaceDec(InterfaceDecHead(_,Id(<id>),_,_),_)|_])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/pp.meta
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/pp.meta	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1 @@
+Meta([Syntax("Stratego-Java-EditorService")])

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/pp.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/util/pp.str	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,46 @@
+module sdf2imp/util/pp
+
+imports
+  libstratego-gpp
+
+strategies
+
+  /**
+   * Pretty-prints the descriptor AST to a string.
+   *
+   * @type descriptor -> String
+   */
+  pp-descriptor-to-string =
+    descriptor-to-abox;
+    box2text-string(|80)
+  
+  /**
+   * Pretty-prints the descriptor AST to a Box representation.
+   *
+   * @type descriptor -> Box
+   */    
+  descriptor-to-abox =
+    topdown(try(pp-fix-string-quotes));
+    ast2box(|[<descriptor-pp-table>, <import-term(Stratego-Sugar-pretty.pp.af)>])
+  
+  descriptor-pp-table =
+    DescriptorPPTable
+  <+
+    tbl := <import-term(EditorService-pretty.pp.af)>;
+    rules(DescriptorPPTable := tbl)
+    
+  // HACK: add quotes omitted by the stratego parser
+  
+  pp-fix-string-quotes:
+    String(string) -> String(string')
+    where
+      <not(string-starts-with(|"\""))> string
+    with
+      string' := <conc-strings> ("\"", string, "\"")
+  
+  pp-fix-string-quotes:
+    Placeholder(string) -> Placeholder(string')
+    where
+      <not(string-starts-with(|"<"))> string
+    with
+      string' := <conc-strings> ("<", string, ">")

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/BuildersService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/BuildersService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,29 @@
+module BuildersService
+
+imports
+  SemanticServices
+
+exports
+  
+  syntax
+  
+    "builders" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF> {cons("Builders")}
+
+    "builders" -> <ReservedName-CF>
+  
+    "analysis" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF> {cons("Builders"), deprecated("Use 'builders' instead")}
+
+    "analysis" -> <ReservedName-CF>
+
+  context-free syntax
+    
+    "observer" ":" StrategoCall                           -> SemanticRule {cons("SemanticObserver")}
+    "builder"  ":" String "=" StrategoCall BuilderOption* -> SemanticRule {cons("Builder")}
+    "builder" "caption" ":" PropertyValue                 -> SemanticRule {cons("BuilderCaption")}
+    
+    "(openeditor)" -> BuilderOption {cons("OpenEditor")}
+    "(realtime)"   -> BuilderOption {cons("RealTime")}
+    "(persistent)" -> BuilderOption {cons("Persistent")}
+    "(meta)"       -> BuilderOption {cons("Meta")}
+    "(cursor)"     -> BuilderOption {cons("Cursor")}
+    "(source)"     -> BuilderOption {cons("Source")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/ColorerService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/ColorerService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,66 @@
+module ColorerService
+
+imports
+  Common
+
+exports
+
+  sorts
+  
+    ColorRule Font Color ColorNode MaybeColor NoColor
+    TokenKindName AttributeId Attribute
+
+  syntax
+  
+    "colorer" <SectionName-LEX> <LAYOUT?-CF> <ColorRule*-CF> -> <Section-CF> {cons("Colorer")}
+    
+    "colorer" -> <ReservedName-CF>
+
+  context-free syntax
+  
+    "environment" ColorNode ":" Attribute -> ColorRule {cons("ColorRuleAll")} %% One rule to rule them all
+                  ColorNode ":" Attribute -> ColorRule {cons("ColorRule")}
+    
+    "environment" ColorNode ":" String "=" Attribute -> ColorRule {cons("ColorRuleAllNamed")}
+                  ColorNode ":" String "=" Attribute -> ColorRule {cons("ColorRuleNamed")}
+
+    Color   MaybeColor Font -> Attribute {cons("Attribute")}
+    AttributeId             -> Attribute {cons("AttributeRef")}
+    
+    Node          -> ColorNode
+    TokenKindName -> ColorNode {cons("Token"), prefer}
+    "token" Id    -> ColorNode {cons("Literal")}
+    
+    "identifier" -> TokenKindName {cons("TK_IDENTIFIER")}
+    "number"     -> TokenKindName {cons("TK_NUMBER")}
+    "layout"     -> TokenKindName {cons("TK_LAYOUT")}
+    "string"     -> TokenKindName {cons("TK_STRING")}
+    "keyword"    -> TokenKindName {cons("TK_KEYWORD")}
+    "operator"   -> TokenKindName {cons("TK_OPERATOR")}
+    "var"        -> TokenKindName {cons("TK_VAR")}
+    "error"      -> TokenKindName {cons("TK_ERROR")}
+    "unknown"    -> TokenKindName {cons("TK_UNKNOWN")}
+    
+                    -> Font {cons("NORMAL")}
+    "bold"          -> Font {cons("BOLD")}
+    "italic"        -> Font {cons("ITALIC")}
+    "bold" "italic" -> Font {cons("BOLD_ITALIC")}
+    "italic" "bold" -> Font {cons("BOLD_ITALIC")}
+
+    %% TODO: Default "font" attribute? (would need disambiguation and merging support)
+    %%
+    %% "_" -> Font {cons("NORMAL")}
+    
+    "_"         -> Color {cons("ColorDefault")}
+    Int Int Int -> Color {cons("ColorRGB")}
+                -> NoColor {cons("NoColor")}
+    Color       -> MaybeColor
+    NoColor     -> MaybeColor
+
+    AttributeId "=" Attribute -> ColorRule {cons("ColorDef")}
+    
+    Id             -> AttributeId          %% Standard color name (e.g., 'red')
+    String         -> AttributeId          %% Descriptive color name (could be shown in IDE)
+    "_"            -> AttributeId {reject}
+    Font           -> AttributeId {reject}
+    "environment"  -> AttributeId {reject}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Comments.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Comments.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,27 @@
+module Comments[E]
+
+exports
+
+  sorts
+    CommentLine
+  
+  lexical syntax
+    ~[\n\r]* -> CommentLine[[E]]
+
+  lexical restrictions
+  
+    CommentLine[[E]] -/- ~[\n\r]
+  
+    CommentLine[[E]] -/- [\/].[\/]
+    CommentLine[[E]] -/- [\/].[\*]
+
+  syntax  
+  
+    "~//"  <CommentLine[[E]]-LEX> -> <E-CF> {cons("CommentLine"), prefer}
+    "~~//" <CommentLine[[E]]-LEX> -> <E-CF> {cons("CommentLine")}
+  
+  context-free syntax
+  
+    "~\n"  -> E {cons("EmptyLine"), avoid}
+    "~~\n" -> E {cons("EmptyLine")}
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Common.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Common.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,68 @@
+module Common
+
+exports
+
+  sorts
+    Id IdStar Int STRING CHAR BACKSLASH String Node Sort Constructor ConstructorId
+    ReservedName SectionName ModuleName Section Eof
+    Ws ShortCom LongCom CommChar
+
+  lexical syntax
+  
+    [a-zA-Z][a-zA-Z0-9\'\-\_]*     -> Id
+    [a-zA-Z][a-zA-Z0-9\'\-\_]* "*" -> IdStar
+    "-"? [0-9]+                    -> Int
+    "\"" StringChar* "\""          -> STRING
+    ~[\"\n\\]                      -> StringChar
+    "\\\""                         -> StringChar
+    BACKSLASH                      -> StringChar
+    "\\"                           -> BACKSLASH
+    
+    ~[\n\r]*                       -> SectionName
+
+    [\t\ \n\r]               -> Ws
+    "//" ~[\n]* ([\n] | Eof) -> ShortCom
+    "/*" CommChar* "*/"      -> LongCom
+    ~[\*]                    -> CommChar
+    Asterisk                 -> CommChar
+    "*"                      -> Asterisk
+    Ws                       -> LAYOUT
+    ShortCom                 -> LAYOUT
+    LongCom                  -> LAYOUT
+                             -> Eof
+  
+  lexical restrictions
+  
+    Int         -/- [0-9]
+    Id          -/- [a-zA-Z0-9\'\-\_]
+    SectionName -/- ~[\n\r]
+    Asterisk    -/- [\/]
+    BACKSLASH   -/- [\"]
+    Eof         -/- ~[]
+
+  context-free restrictions
+
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/].[\*]
+    LAYOUT? -/- [\/].[\/]
+
+  context-free syntax
+  
+    Id     -> Sort {cons("Sort")}
+    Id "*" -> Sort {cons("ListSort")}
+    STRING -> String {cons("String")}
+    
+    %% nice, but makes C-SGLR fail to parse create-builders-desciptor.str properly
+    %%        -> String {recover, avoid, ast("String(\"\")")}
+
+    Sort "." "_" -> Sort {bracket}
+    
+    "_" "." ConstructorId -> Constructor {cons("ConstructorOnly")}
+                       Id -> ConstructorId {cons("Constructor")}
+    
+    Sort                   -> Node
+    Constructor            -> Node
+    Sort "." ConstructorId -> Node {cons("SortAndConstructor")}
+    
+    ReservedName -> Node       {reject}
+    ReservedName -> ModuleName {reject}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/CompletionsService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/CompletionsService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,79 @@
+module CompletionsService
+
+imports
+  SemanticServices
+
+exports
+
+  sorts
+    CompletionPart CompletionAnno
+
+  syntax
+
+    "completions" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF> {cons("Completions")}
+
+    "completions" -> <ReservedName-CF>
+
+  context-free syntax
+
+    "completion" "proposer" ":" StrategoCall -> SemanticRule {cons("CompletionProposer")}
+
+    "completion" "lexical" ":" PropertyValue -> SemanticRule {cons("IdentifierLexical"), deprecated("Use 'identifier lexical' instead")}
+
+    "identifier" "lexical" ":" PropertyValue -> SemanticRule {cons("IdentifierLexical")}
+
+    "completion" "keyword" ":" PropertyValue OptCompletionAnno -> SemanticRule {cons("CompletionKeyword")}
+
+    %% Deprecated: conflicts with content completion
+    "completion" "template" ":" Id CompletionPart+ OptCompletionAnno -> SemanticRule {cons("CompletionTemplate"), avoid, deprecated("Add quotes to the starting literal")}
+
+    %% Deprecated: replaced by CompletionTemplateEx
+    "completion" "template" ":" Sort "=" CompletionPart CompletionPart* OptCompletionAnno -> SemanticRule {cons("CompletionTemplateWithSort"), avoid, deprecated("Move the sort before ':' and remove '='")}
+
+    %% Used as content completion triggers
+    %% "completion" "template" PropertyValue CompletionPart* OptCompletionAnno -> SemanticRule {cons("CompletionTemplate"), recover, avoid}
+    "completion" "template" Sort* ":" PropertyValue CompletionPart* CompletionAnno* -> SemanticRule {cons("CompletionTemplateEx"), recover, avoid}
+
+    "completion" "trigger" ":" PropertyValue OptCompletionAnno -> SemanticRule {cons("CompletionTrigger")}
+
+    %% New completion template
+    "completion" "template" Sort* ":" CompletionPrefix CompletionPart+ CompletionAnno* -> SemanticRule {cons("CompletionTemplateEx")}
+
+               -> CompletionPrefix {cons("NoCompletionPrefix")}
+    String "=" -> CompletionPrefix {cons("CompletionPrefix")}
+
+  context-free syntax
+
+    "completions" -> StrategoCall {reject}
+    "completion"  -> StrategoCall {reject}
+    "identifier"  -> StrategoCall {reject}
+    "observer"    -> StrategoCall {reject}
+    "builder"     -> StrategoCall {reject}
+    "occurrence"  -> StrategoCall {reject}
+    ReservedName  -> StrategoCall {reject}
+
+    String      -> CompletionPart
+    Placeholder -> CompletionPart {cons("Placeholder")}
+    "(cursor)"  -> CompletionPart {cons("Cursor")}
+    PlaceholderWithSortPrefix Id ">" -> CompletionPart {cons("PlaceholderWithSort")}
+
+                   -> OptCompletionAnno {cons("None")}
+    CompletionAnno -> OptCompletionAnno
+
+    "(disabled)" -> CompletionAnno {cons("Disable")}
+    "(disable)"  -> CompletionAnno {cons("Disable"), deprecated("Use (disabled) instead")}
+    "(blank)"    -> CompletionAnno {cons("Blank")}
+    "(linked)"   -> CompletionAnno {cons("Linked")}
+    "(blank)"    -> PropertyValue {reject}
+    "(disable)"  -> PropertyValue {reject}
+    "(linked)"   -> PropertyValue {reject}
+    "completion" -> PropertyValue {reject}
+    "template"   -> PropertyValue {reject}
+    "trigger"    -> PropertyValue {reject}
+    "identifier" -> PropertyValue {reject}
+
+  lexical syntax
+
+    "<" PlaceholderChar* ":" -> PlaceholderWithSortPrefix
+    "<" PlaceholderChar* ">" -> Placeholder
+    ~[\:\>\n]                -> PlaceholderChar

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService-pretty.pp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService-pretty.pp	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,132 @@
+[
+   PPTable                                -- R [ H [KW["pp-table"]] KW[":"] _1],
+   PrettyPrint                            -- R [ H [KW["pretty-print"]] KW[":"] _1],
+   Refactoring                            -- R [ H [ KW["refactoring"] _1 ]  KW[":"] _2 H [  KW["="] _3 _4] ],
+   Refactoring.1:iter-star                -- _1,
+   Refactoring.4:iter-star                -- _1,
+   Refactorings                           -- V is=2 [H hs=0 [KW["refactorings"] _1] A(l,l,l,l,l,l) [_2]],
+   ReferenceHoverRule   -- R [ H [ KW["reference"] _1 ] KW[":"] H [ _2 _3 ] ],
+   ReferenceRule        -- R [ H [ KW["reference"] _1 ] KW[":"] _2 ],
+   CompletionProposer   -- R [ H [ KW["completion"] KW["proposer"] ] KW[":"] _1 ],
+   CompletionLexical    -- R [ H [ KW["completion"] KW["lexical"] ] KW[":"] _1 ],
+   IdentifierLexical    -- R [ H [ KW["identifier"] KW["lexical"] ] KW[":"] _1 ],
+   Placeholder          -- H hs=0 [ _1 ],
+   PlaceholderWithSort  -- H hs=0 [ _1 _2 KW[">"] ],
+   CompletionKeyword    -- R [ H [ KW["completion"] KW["keyword"] ] KW[":"] H [ _1 _2 ] ],
+   CompletionTemplate   -- R [ H [ KW["completion"] KW["template"] ] KW[":"] H [ _1 _2 _3 ] ],
+   CompletionTemplate.2:iter-star -- _1,
+   CompletionTemplateWithSort   -- R [ V is=2 [ H [ KW["completion"] KW["template"] KW[":"] _1 KW["="]] ]
+                                                H [ _2 _3 _4 ] ],
+   CompletionTemplateWithSort.3:iter-star -- _1,
+   CompletionTemplateEx -- R [ V is=2 [ H [ KW["completion"] KW["template"] _1 KW[":"] _2 ]
+                                        H [ _3 _4 ] ] ],
+   CompletionTemplateEx.1:iter-star       -- _1,
+   CompletionTemplateEx.3:iter            -- _1,
+   CompletionTemplateEx.4:iter-star       -- _1,
+   NoCompletionPrefix                     -- ,
+   CompletionPrefix                       -- _1 KW["="],
+   CompletionTrigger    -- R [ H [ KW["completion"] KW["trigger"] ] KW[":"] H [ _1 _2 ] ],
+   HoverRule            -- R [ H [ KW["hover"]     _1 ] KW[":"] _2 ],
+   OccurrenceRule       -- R [ H [ KW["occurrence"] _1 ] H [ KW[":"] _2 ] ],
+   SemanticProvider     -- R [ H [ KW["provider"] ] KW[":"] _1 ],
+   OnSave               -- R [ H [ KW["on"] KW["save"] ] KW[":"] _1 _2 ],
+   Disambiguator        -- R [ H [ KW["disambiguator"] ] KW[":"] _1 ],
+   SemanticObserver     -- R [ H [ KW["observer"] ]  KW[":"] _1 ],
+   Builder              -- R [ H [ KW["builder"] ]   KW[":"] _1 H [ KW["="] _2 _3 ] ],
+   Builder.3:iter-star  -- _1,
+   BuilderCaption       -- R [ H [ KW["builder"] KW["caption"] ] KW[":"] _1 ],
+   OpenEditor           -- KW["(openeditor)"],
+   RealTime             -- KW["(realtime)"],
+   Persistent           -- KW["(persistent)"],
+   Meta                 -- KW["(meta)"],
+   Source               -- KW["(source)"],
+   Cursor               -- KW["(cursor)"],
+   Strategy             -- _1,
+   Attribute            -- H hs=0 [ KW["id"] KW["."] _1 ],
+   Analysis             -- V is=2 [H hs=0 [ KW["analysis"] _1 ] A(l,l,l) [_2] ],
+   References           -- V is=2 [H hs=0 [ KW["references"] _1 ] A(l,l,l) [_2] ],
+   Completions          -- V is=2 [H hs=0 [ KW["completions"] _1 ] A(l,l,l) [_2] ],
+   Occurrences          -- V is=2 [H hs=0 [ KW["occurrences"] _1 ] A(l,l,l) [_2] ],
+   Strategy             -- _1,
+   Attribute            -- H hs=0 [ KW["id"] KW["."] _1 ],
+   Builders             -- V is=2 [H hs=0 [KW["builders"] _1] A(l,l,l,l,l,l) [_2]],
+   Builders.2:iter-star -- _1,
+   Colorer              -- V is=2 [H hs=0 [KW["colorer"] _1] A(l,l,l,l,l,l) [_2]],
+   Colorer.2:iter-star  -- _1,
+   ColorDef             -- R [ _1 KW["="] _2],
+   ColorRuleAll         -- R [ H [ KW["environment"] _1 ] KW[":"] H [ _2 ] ],
+   ColorRule            -- R [ H [                   _1 ] KW[":"] H [ _2 ] ],
+   ColorRuleAllNamed    -- R [ H [ KW["environment"] _1 ] KW[":"] H [ _2 ] KW["="] H [ _3 ] ],
+   ColorRuleNamed       -- R [ H [                   _1 ] KW[":"] H [ _2 ] KW["="] H [ _3 ] ],
+   Attribute            -- _1 _2 _3,
+   Attribute            -- _1 _2 _3,
+   AttributeRef         -- _1,
+   FoldRuleAll          -- H [ KW["all"] _1 _2 ],
+   FoldRule             -- H [ _1 _2 ],
+   Blank                -- KW["(blank)"],
+   Disable              -- KW["(disabled)"],
+   Folded               -- KW["(folded)"],
+   None                 -- ,
+   OutlineRule          -- _1,
+   Values                 -- H [ _1 ],
+   Values.1:iter-star-sep -- _1 KW[","],
+   Language             -- V is=2 [H hs=0 [KW["language"] _1] A(l,l,l) [_2]],
+   Language.2:iter-star -- _1,
+   LanguageName         -- R [ KW["name"] KW[":"] _1 ],
+   LanguageId           -- R [ KW["id"] KW[":"] _1 ],
+   Extensions           -- R [ KW["extensions"] KW[":"] _1 ],
+   Description          -- R [ KW["description"] KW[":"] _1 ],
+   Table                -- R [ KW["table"] KW[":"] _1 ],
+   TableProvider        -- R [ KW["table"] KW["provider"] KW[":"] _1 ],
+   UnmanagedTablePrefix -- R [ H [ KW["unmanaged"] KW["table"] ] KW[":"] H hs=0 [ _1 KW["*"] ] ],
+   StartSymbols         -- R [ H [ KW["start"] KW["symbols"] ] KW[":"] _1 ],
+   NoStartSymbols       -- KW["_"],
+   URL                  -- R [ KW["url"] KW[":"] _1 ],
+   Extends              -- R [ KW["extends"] KW[":"] _1 ],
+   Aliases              -- R [ KW["aliases"] KW[":"] _1 ],
+   LineCommentPrefix    -- R [ H [ KW["line"] KW["comment"] ] KW[":"] _1 ],
+   BlockCommentDefs     -- R [ H [ KW["block"] KW["comment"] ] KW[":"] _1 ],
+   FenceDefs            -- R [ KW["fences"] KW[":"] A(l,l) [ _1 ] ],
+   FenceDef             -- R [ _1 _2 ],
+   IndentDefs           -- R [ H [ KW["indent"] KW["after"]] KW[":"] V [ _1 ] ],
+   IndentDef            -- _1,
+   BlockCommentDef      -- H [ _1 _2 _3 ],
+   String               -- _1,
+   NoContinuation       --,
+   CommentLine          -- R [ H hs=0 [ KW["//"] _1 ]],
+   EmptyLine            -- R [KW[""]],
+   Token                -- _1,
+   TK_IDENTIFIER        -- KW["identifier"],
+   TK_NUMBER            -- KW["number"],
+   TK_LAYOUT            -- KW["layout"],
+   TK_STRING            -- KW["string"],
+   TK_KEYWORD           -- KW["keyword"],
+   TK_OPERATOR          -- KW["operator"],
+   TK_VAR               -- KW["var"],
+   TK_JUNK              -- KW["junk"],
+   TK_UNKNOWN           -- KW["unknown"],
+   NORMAL               -- ,
+   BOLD                 -- KW["bold"],
+   ITALIC               -- KW["italic"],
+   BOLD_ITALIC          -- H [KW["bold"] KW["italic"]],
+   ColorDefault         -- KW["_"],
+   NoColor              -- ,
+   ColorRGB             -- H  [_1 _2 _3],
+   Outliner             -- V is=2 [H hs=0  [KW["outliner"] _1] V [_2]],
+   Outliner.2:iter-star -- _1,
+   Folding              -- V is=2 [H hs=0  [KW["folding"] _1] V [_2]],
+   Folding.2:iter-star  -- _1,
+   Sort                 -- _1,
+   ListSort             -- _1 KW["*"],
+   ConstructorOnly      -- H hs=0 [KW["_"] KW["."] _1],
+   Constructor          -- _1,
+   SortAndConstructor   -- H hs=0 [_1 KW["."] _2],
+   Module               -- V vs = 1 [H  [KW["module"] _1] _2 _3 ],
+   Module.3:iter-star   -- _1,
+   Imports              -- V is=2 [KW["imports"] _1],
+   Imports.1:iter       -- _1,
+   Import               -- _1,
+   ImportRenamed        -- H hs=0 [_1 KW["["] _2 KW["]"]],
+   NoImports            --
+]
+

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService.generated.pp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService.generated.pp	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,128 @@
+[
+   PPTable                                -- KW["pp-table"] KW[":"] _1,
+   PrettyPrint                            -- KW["pretty-print"] KW[":"] _1,
+   Refactoring                            -- KW["refactoring"] _1 KW[":"] _2 KW["="] _3 _4,
+   Refactoring.1:iter-star                -- _1,
+   Refactoring.4:iter-star                -- _1,
+   SemanticObserver                       -- KW["observer"] KW[":"] _1,
+   Builder                                -- KW["builder"] KW[":"] _1 KW["="] _2 _3,
+   Builder.3:iter-star                    -- _1,
+   BuilderCaption                         -- KW["builder"] KW["caption"] KW[":"] _1,
+   OpenEditor                             -- KW["(openeditor)"],
+   RealTime                               -- KW["(realtime)"],
+   Persistent                             -- KW["(persistent)"],
+   Meta                                   -- KW["(meta)"],
+   Cursor                                 -- KW["(cursor)"],
+   Source                                 -- KW["(source)"],
+   CompletionProposer                     -- KW["completion"] KW["proposer"] KW[":"] _1,
+   IdentifierLexical                      -- KW["completion"] KW["lexical"] KW[":"] _1,
+   IdentifierLexical                      -- KW["identifier"] KW["lexical"] KW[":"] _1,
+   CompletionKeyword                      -- KW["completion"] KW["keyword"] KW[":"] _1 _2,
+   CompletionTemplate                     -- KW["completion"] KW["template"] KW[":"] _1 _2 _3,
+   CompletionTemplate.2:iter              -- _1,
+   CompletionTemplateWithSort             -- KW["completion"] KW["template"] KW[":"] _1 KW["="] _2 _3 _4,
+   CompletionTemplateWithSort.3:iter-star -- _1,
+   CompletionTemplateEx                   -- KW["completion"] KW["template"] _1 KW[":"] _2 _3 _4,
+   CompletionTemplateEx.1:iter-star       -- _1,
+   CompletionTemplateEx.3:iter-star       -- _1,
+   CompletionTemplateEx.4:iter-star       -- _1,
+   CompletionTrigger                      -- KW["completion"] KW["trigger"] KW[":"] _1 _2,
+   CompletionTemplateEx                   -- KW["completion"] KW["template"] _1 KW[":"] _2 _3 _4,
+   CompletionTemplateEx.1:iter-star       -- _1,
+   CompletionTemplateEx.3:iter            -- _1,
+   CompletionTemplateEx.4:iter-star       -- _1,
+   NoCompletionPrefix                     -- ,
+   CompletionPrefix                       -- _1 KW["="],
+   Placeholder                            -- _1,
+   Cursor                                 -- KW["(cursor)"],
+   PlaceholderWithSort                    -- _1 _2 KW[">"],
+   None                                   -- ,
+   Disable                                -- KW["(disabled)"],
+   Disable                                -- KW["(disable)"],
+   Blank                                  -- KW["(blank)"],
+   Linked                                 -- KW["(linked)"],
+   ReferenceHoverRule                     -- KW["reference"] _1 KW[":"] _2 _3,
+   ReferenceRule                          -- KW["reference"] _1 KW[":"] _2,
+   HoverRule                              -- KW["hover"] _1 KW[":"] _2,
+   OccurrenceRule                         -- KW["occurrence"] _1 KW[":"] _2,
+   ColorRuleAll                           -- KW["environment"] _1 KW[":"] _2,
+   ColorRule                              -- _1 KW[":"] _2,
+   ColorRuleAllNamed                      -- KW["environment"] _1 KW[":"] _2 KW["="] _3,
+   ColorRuleNamed                         -- _1 KW[":"] _2 KW["="] _3,
+   Attribute                              -- _1 _2 _3,
+   AttributeRef                           -- _1,
+   Token                                  -- _1,
+   Literal                                -- KW["token"] _1,
+   TK_IDENTIFIER                          -- KW["identifier"],
+   TK_NUMBER                              -- KW["number"],
+   TK_LAYOUT                              -- KW["layout"],
+   TK_STRING                              -- KW["string"],
+   TK_KEYWORD                             -- KW["keyword"],
+   TK_OPERATOR                            -- KW["operator"],
+   TK_VAR                                 -- KW["var"],
+   TK_ERROR                               -- KW["error"],
+   TK_UNKNOWN                             -- KW["unknown"],
+   NORMAL                                 -- ,
+   BOLD                                   -- KW["bold"],
+   ITALIC                                 -- KW["italic"],
+   BOLD_ITALIC                            -- KW["bold"] KW["italic"],
+   BOLD_ITALIC                            -- KW["italic"] KW["bold"],
+   ColorDefault                           -- KW["_"],
+   ColorRGB                               -- _1 _2 _3,
+   NoColor                                -- ,
+   ColorDef                               -- _1 KW["="] _2,
+   OutlineRule                            -- _1,
+   FoldRule                               -- _1 _2,
+   FoldRuleAll                            -- KW["all"] _1 _2,
+   Disable                                -- KW["(disable)"],
+   Disable                                -- KW["(disabled)"],
+   Folded                                 -- KW["(folded)"],
+   None                                   -- ,
+   SemanticProvider                       -- KW["provider"] _1,
+   SemanticProvider                       -- KW["provider"] KW[":"] _1,
+   OnSave                                 -- KW["on"] KW["save"] KW[":"] _1 _2,
+   Strategy                               -- _1,
+   Attribute                              -- KW["id"] KW["."] _1,
+   None                                   -- ,
+   Values                                 -- _1,
+   Values.1:iter-star-sep                 -- _1 KW[","],
+   LanguageName                           -- KW["name"] KW[":"] _1,
+   LanguageId                             -- KW["id"] KW[":"] _1,
+   Extensions                             -- KW["extensions"] KW[":"] _1,
+   Description                            -- KW["description"] KW[":"] _1,
+   Table                                  -- KW["table"] KW[":"] _1,
+   TableProvider                          -- KW["table"] KW["provider"] KW[":"] _1,
+   StartSymbols                           -- V  [H  [KW["start"] KW["symbols"] KW[":"]] _1],
+   StartSymbols.1:iter-star               -- _1,
+   StartSymbols                           -- KW["start"] KW["symbols"] KW[":"] _1,
+   URL                                    -- KW["url"] KW[":"] _1,
+   Extends                                -- KW["extends"] KW[":"] _1,
+   Aliases                                -- KW["aliases"] KW[":"] _1,
+   UnmanagedTablePrefix                   -- KW["unmanaged"] KW["table"] KW[":"] _1 KW["*"],
+   Disambiguator                          -- KW["disambiguator"] KW[":"] _1,
+   LineCommentPrefix                      -- KW["line"] KW["comment"] KW[":"] _1,
+   BlockCommentDefs                       -- KW["block"] KW["comment"] KW[":"] _1,
+   FenceDefs                              -- V  [H  [KW["fences"] KW[":"]] _1],
+   FenceDefs.1:iter-star                  -- _1,
+   IndentDefs                             -- V  [H  [KW["indent"] KW["after"] KW[":"]] _1],
+   IndentDefs.1:iter-star                 -- _1,
+   IdentifierLexical                      -- KW["identifier"] KW["lexical"] KW[":"] _1,
+   BlockCommentDef                        -- _1 _2 _3,
+   BlockCommentDef                        -- _1 _2 _3,
+   NoContinuation                         -- ,
+   FenceDef                               -- _1 _2,
+   IndentDef                              -- _1,
+   Sort                                   -- _1,
+   ListSort                               -- _1 KW["*"],
+   String                                 -- _1,
+   ConstructorOnly                        -- KW["_"] KW["."] _1,
+   Constructor                            -- _1,
+   SortAndConstructor                     -- _1 KW["."] _2,
+   Module                                 -- KW["module"] _1 _2 _3,
+   Module.3:iter-star                     -- _1,
+   Imports                                -- V  [H  [KW["imports"]] _1],
+   Imports.1:iter                         -- _1,
+   NoImports                              -- ,
+   Import                                 -- _1,
+   ImportRenamed                          -- _1 KW["["] _2 KW["]"]
+]
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/EditorService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,40 @@
+module EditorService
+
+imports
+  Common
+  LanguageDescription
+  FoldingService
+  OutlinerService
+  ColorerService
+  ReferencesService
+  CompletionsService
+  BuildersService
+  RefactoringsService
+
+hiddens
+
+  context-free start-symbols
+    Module
+
+exports
+
+  sorts
+    Module FileName ModuleName Imports Import
+
+  lexical syntax
+  
+    [a-zA-Z0-9\-\_\.]+ -> FileName
+    {FileName "/"}+    -> ModuleName
+  
+  lexical restrictions
+  
+  	FileName    -/- [a-zA-Z0-9\-\_\.]
+
+  context-free syntax
+  	
+    "module" ModuleName Imports Section* -> Module {cons("Module")}
+    "imports" Import+                    -> Imports {cons("Imports")}
+                                         -> Imports {cons("NoImports")}
+
+    ModuleName            -> Import {cons("Import")}
+    ModuleName "[" Id "]" -> Import {cons("ImportRenamed")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/FoldingService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/FoldingService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,27 @@
+module FoldingService
+
+imports
+  Common
+
+exports
+
+  sorts
+    FoldingRule FoldingAnno
+
+  syntax
+  
+    "folding" <SectionName-LEX> <LAYOUT?-CF> <FoldingRule*-CF> -> <Section-CF> {cons("Folding")}
+    
+    "folding" -> <ReservedName-CF>
+  
+  context-free syntax
+    
+    %% TODO: Reconsider "all" keyword for siblings; we already have list sorts using '*'
+    
+          Node FoldingAnno -> FoldingRule {cons("FoldRule")}
+    "all" Node FoldingAnno -> FoldingRule {cons("FoldRuleAll")}
+
+    "(disable)"  -> FoldingAnno {cons("Disable"), deprecated("Use (disabled) instead")}
+    "(disabled)" -> FoldingAnno {cons("Disable")}
+    "(folded)"   -> FoldingAnno {cons("Folded")}
+                 -> FoldingAnno {cons("None")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/LanguageDescription.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/LanguageDescription.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,74 @@
+module LanguageDescription
+
+imports
+	Common SemanticServices
+
+exports
+  
+  sorts
+  
+    LanguageProperty PropertyValue NoContinuation PropertyValues URL
+    FenceDef BlockCommentDef IndentDef
+  
+  syntax
+  
+    "language" <SectionName-LEX> <LAYOUT?-CF> <LanguageProperty*-CF> -> <Section-CF> {cons("Language")}
+    
+    "language" -> <ReservedName-CF>
+  
+  lexical syntax
+    
+    ~[\ \t\n\r\,\:\"\=]+ -> PropertyValue {avoid}
+
+    ~[\ \t\n\r\,\/\:]+ "://" ~[\ \t\n\r]+ -> URL
+  
+  lexical restrictions
+  
+  	PropertyValue -/- ~[\ \t\n\r\,\:\"\=]
+  	URL           -/- ~[\ \t\n\r]
+  
+  context-free syntax
+  
+    { PropertyValue ","}* -> PropertyValues {cons("Values")}
+    String                -> PropertyValue
+  
+  	%% General language properties
+  
+    "name"            ":" PropertyValue  -> LanguageProperty {cons("LanguageName")}
+    "id"              ":" PropertyValue  -> LanguageProperty {cons("LanguageId")}
+    "extensions"      ":" PropertyValues -> LanguageProperty {cons("Extensions")}
+    "description"     ":" PropertyValue  -> LanguageProperty {cons("Description")}
+    "table"           ":" PropertyValue  -> LanguageProperty {cons("Table")}
+    "table" "provider" ":" StrategoCall  -> LanguageProperty {cons("TableProvider")}
+    "start" "symbols" ":" Sort*          -> LanguageProperty {cons("StartSymbols")}
+    "start" "symbols" ":" PropertyValues -> LanguageProperty {cons("StartSymbols"), avoid}
+    "url"             ":" URL            -> LanguageProperty {cons("URL")}
+    "extends"         ":" PropertyValues -> LanguageProperty {cons("Extends")}
+    "aliases"         ":" PropertyValues -> LanguageProperty {cons("Aliases")} %% deprecated
+    "unmanaged" "table" ":" Id "*"       -> LanguageProperty {cons("UnmanagedTablePrefix")}
+    "disambiguator"   ":" StrategoCall   -> LanguageProperty {cons("Disambiguator")}
+   
+     %% Syntax properties
+     
+     "line"  "comment" ":" PropertyValue      -> LanguageProperty {cons("LineCommentPrefix")}
+     "block" "comment" ":" BlockCommentDef    -> LanguageProperty {cons("BlockCommentDefs")}
+     "fences"          ":" FenceDef*          -> LanguageProperty {cons("FenceDefs")}
+     "indent" "after"  ":" IndentDef*         -> LanguageProperty {cons("IndentDefs")}
+     "identifier" "lexical" ":" PropertyValue -> LanguageProperty {cons("IdentifierLexical")}
+     
+     PropertyValue PropertyValue  PropertyValue -> BlockCommentDef {cons("BlockCommentDef")}
+     PropertyValue NoContinuation PropertyValue -> BlockCommentDef {cons("BlockCommentDef")}
+                                                -> NoContinuation {cons("NoContinuation")}
+     
+     PropertyValue PropertyValue -> FenceDef {cons("FenceDef")}
+     PropertyValue               -> IndentDef {cons("IndentDef")}
+     
+     %% Avoid ambiguities with fencedef pairs
+     "fences"     -> PropertyValue {reject}
+     "identifier" -> PropertyValue {reject}
+     "indent"     -> PropertyValue {reject}
+     "fences"     -> PropertyValue {reject}
+     "line"       -> PropertyValue {reject}
+     "block"      -> PropertyValue {reject}
+     "unmanaged"  -> Sort {reject}
+     

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/OutlinerService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/OutlinerService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,21 @@
+module OutlinerService
+
+imports
+  Common
+  %% TODO: Maybe -- StrategoMix[StrategoExpr]
+
+exports
+
+  sorts
+    OutlineRule Pattern Term PreTerm
+
+  syntax
+  
+    "outliner" <SectionName-LEX> <LAYOUT?-CF> <OutlineRule*-CF> -> <Section-CF> {cons("Outliner")}
+    
+    "outliner" -> <ReservedName-CF>
+
+  context-free syntax
+
+    Node                 -> OutlineRule {cons("OutlineRule"), prefer}
+    %% TODO: Term[[StrategoExpr]] -> OutlineRule {cons("OutlineRule")}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/RefactoringsService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/RefactoringsService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,23 @@
+module RefactoringsService
+
+imports
+  SemanticServices
+  BuildersService
+
+exports
+  
+  syntax
+  
+    "refactorings" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF> {cons("Refactorings")}
+
+    "refactorings" -> <ReservedName-CF>
+  
+  context-free syntax
+  	
+  	"pp-table" ":" StrategoCall -> SemanticRule {cons("PPTable")}
+  	"pretty-print" ":" StrategoCall -> SemanticRule {cons("PrettyPrint")}
+    "refactoring"  SemanticNode* ":" String "="   StrategoCall BuilderOption* -> SemanticRule {cons("Refactoring")}
+  
+    %%"refactoring"  ":" String "=" Node "->" StrategoCall -> SemanticRule {cons("Refactoring")} 
+    %% Node defines on what sorts/constructors the refactoring can be defiend
+    
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/ReferencesService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/ReferencesService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,28 @@
+module ReferencesService
+
+imports
+  SemanticServices
+
+exports
+
+  syntax
+  
+    "references" <SectionName-LEX> <LAYOUT?-CF> <SemanticRule*-CF> -> <Section-CF> {cons("References")}
+
+    "references" -> <ReservedName-CF>
+
+  context-free syntax
+  
+    "reference"  SemanticNode ":" StrategoCall StrategoCall -> SemanticRule {cons("ReferenceHoverRule"), deprecated}
+
+    "reference"  SemanticNode ":" StrategoCall -> SemanticRule {cons("ReferenceRule")}
+
+    "hover"      SemanticNode ":" StrategoCall -> SemanticRule {cons("HoverRule")}
+  
+    "occurrence" SemanticNode ":" StrategoCall -> SemanticRule {cons("OccurrenceRule")}
+  
+  context-free syntax
+  
+    "references" -> StrategoCall {reject}
+    "reference"  -> StrategoCall {reject}
+    "hover"      -> StrategoCall {reject}

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/SemanticServices.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/SemanticServices.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,32 @@
+module SemanticServices
+
+imports
+  Common LanguageDescription
+
+exports
+
+  sorts
+    SemanticRule SemanticNode StrategoId StrategoCall OnSaveAnno
+
+  lexical syntax
+
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* -> StrategoId
+  
+    "_"  -> SemanticNode
+
+  lexical restrictions
+  
+    StrategoId -/- [a-zA-Z0-9\'\-\_]
+
+  context-free syntax
+     
+     Node -> SemanticNode
+    "provider"     PropertyValue -> SemanticRule {cons("SemanticProvider"), deprecated("Use 'provider :'")}
+    "provider" ":" PropertyValue -> SemanticRule {cons("SemanticProvider")}
+
+    "on" "save" ":" StrategoCall OnSaveAnno -> SemanticRule {cons("OnSave")}
+
+             StrategoId -> StrategoCall {cons("Strategy")}
+    "id" "." StrategoId -> StrategoCall {cons("Attribute")}
+    
+                        -> OnSaveAnno {cons("None")}
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Stratego-Java-EditorService.generated.pp
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Stratego-Java-EditorService.generated.pp	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,888 @@
+[
+   EmptyLine                                      -- KW["~\n"],
+   EmptyLine                                      -- KW["~~\n"],
+   PPTable                                        -- KW["pp-table"] KW[":"] _1,
+   PrettyPrint                                    -- KW["pretty-print"] KW[":"] _1,
+   Refactoring                                    -- KW["refactoring"] _1 KW[":"] _2 KW["="] _3 _4,
+   Refactoring.1:iter-star                        -- _1,
+   Refactoring.4:iter-star                        -- _1,
+   SemanticObserver                               -- KW["observer"] KW[":"] _1,
+   Builder                                        -- KW["builder"] KW[":"] _1 KW["="] _2 _3,
+   Builder.3:iter-star                            -- _1,
+   BuilderCaption                                 -- KW["builder"] KW["caption"] KW[":"] _1,
+   OpenEditor                                     -- KW["(openeditor)"],
+   RealTime                                       -- KW["(realtime)"],
+   Persistent                                     -- KW["(persistent)"],
+   Meta                                           -- KW["(meta)"],
+   Cursor                                         -- KW["(cursor)"],
+   Source                                         -- KW["(source)"],
+   CompletionProposer                             -- KW["completion"] KW["proposer"] KW[":"] _1,
+   IdentifierLexical                              -- KW["completion"] KW["lexical"] KW[":"] _1,
+   IdentifierLexical                              -- KW["identifier"] KW["lexical"] KW[":"] _1,
+   CompletionKeyword                              -- KW["completion"] KW["keyword"] KW[":"] _1 _2,
+   CompletionTemplate                             -- KW["completion"] KW["template"] KW[":"] _1 _2 _3,
+   CompletionTemplate.2:iter                      -- _1,
+   CompletionTemplateWithSort                     -- KW["completion"] KW["template"] KW[":"] _1 KW["="] _2 _3 _4,
+   CompletionTemplateWithSort.3:iter-star         -- _1,
+   CompletionTemplateEx                           -- KW["completion"] KW["template"] _1 KW[":"] _2 _3 _4,
+   CompletionTemplateEx.1:iter-star               -- _1,
+   CompletionTemplateEx.3:iter-star               -- _1,
+   CompletionTemplateEx.4:iter-star               -- _1,
+   CompletionTrigger                              -- KW["completion"] KW["trigger"] KW[":"] _1 _2,
+   CompletionTemplateEx                           -- KW["completion"] KW["template"] _1 KW[":"] _2 _3 _4,
+   CompletionTemplateEx.1:iter-star               -- _1,
+   CompletionTemplateEx.3:iter                    -- _1,
+   CompletionTemplateEx.4:iter-star               -- _1,
+   NoCompletionPrefix                             -- ,
+   CompletionPrefix                               -- _1 KW["="],
+   Placeholder                                    -- _1,
+   Cursor                                         -- KW["(cursor)"],
+   PlaceholderWithSort                            -- _1 _2 KW[">"],
+   None                                           -- ,
+   Disable                                        -- KW["(disabled)"],
+   Disable                                        -- KW["(disable)"],
+   Blank                                          -- KW["(blank)"],
+   Linked                                         -- KW["(linked)"],
+   ReferenceHoverRule                             -- KW["reference"] _1 KW[":"] _2 _3,
+   ReferenceRule                                  -- KW["reference"] _1 KW[":"] _2,
+   HoverRule                                      -- KW["hover"] _1 KW[":"] _2,
+   OccurrenceRule                                 -- KW["occurrence"] _1 KW[":"] _2,
+   ColorRuleAll                                   -- KW["environment"] _1 KW[":"] _2,
+   ColorRule                                      -- _1 KW[":"] _2,
+   ColorRuleAllNamed                              -- KW["environment"] _1 KW[":"] _2 KW["="] _3,
+   ColorRuleNamed                                 -- _1 KW[":"] _2 KW["="] _3,
+   Attribute                                      -- _1 _2 _3,
+   AttributeRef                                   -- _1,
+   Token                                          -- _1,
+   Literal                                        -- KW["token"] _1,
+   TK_IDENTIFIER                                  -- KW["identifier"],
+   TK_NUMBER                                      -- KW["number"],
+   TK_LAYOUT                                      -- KW["layout"],
+   TK_STRING                                      -- KW["string"],
+   TK_KEYWORD                                     -- KW["keyword"],
+   TK_OPERATOR                                    -- KW["operator"],
+   TK_VAR                                         -- KW["var"],
+   TK_ERROR                                       -- KW["error"],
+   TK_UNKNOWN                                     -- KW["unknown"],
+   NORMAL                                         -- ,
+   BOLD                                           -- KW["bold"],
+   ITALIC                                         -- KW["italic"],
+   BOLD_ITALIC                                    -- KW["bold"] KW["italic"],
+   BOLD_ITALIC                                    -- KW["italic"] KW["bold"],
+   ColorDefault                                   -- KW["_"],
+   ColorRGB                                       -- _1 _2 _3,
+   NoColor                                        -- ,
+   ColorDef                                       -- _1 KW["="] _2,
+   OutlineRule                                    -- _1,
+   FoldRule                                       -- _1 _2,
+   FoldRuleAll                                    -- KW["all"] _1 _2,
+   Disable                                        -- KW["(disable)"],
+   Disable                                        -- KW["(disabled)"],
+   Folded                                         -- KW["(folded)"],
+   None                                           -- ,
+   SemanticProvider                               -- KW["provider"] _1,
+   SemanticProvider                               -- KW["provider"] KW[":"] _1,
+   OnSave                                         -- KW["on"] KW["save"] KW[":"] _1 _2,
+   Strategy                                       -- _1,
+   Attribute                                      -- KW["id"] KW["."] _1,
+   None                                           -- ,
+   Values                                         -- _1,
+   Values.1:iter-star-sep                         -- _1 KW[","],
+   LanguageName                                   -- KW["name"] KW[":"] _1,
+   LanguageId                                     -- KW["id"] KW[":"] _1,
+   Extensions                                     -- KW["extensions"] KW[":"] _1,
+   Description                                    -- KW["description"] KW[":"] _1,
+   Table                                          -- KW["table"] KW[":"] _1,
+   TableProvider                                  -- KW["table"] KW["provider"] KW[":"] _1,
+   StartSymbols                                   -- V  [H  [KW["start"] KW["symbols"] KW[":"]] _1],
+   StartSymbols.1:iter-star                       -- _1,
+   StartSymbols                                   -- KW["start"] KW["symbols"] KW[":"] _1,
+   URL                                            -- KW["url"] KW[":"] _1,
+   Extends                                        -- KW["extends"] KW[":"] _1,
+   Aliases                                        -- KW["aliases"] KW[":"] _1,
+   UnmanagedTablePrefix                           -- KW["unmanaged"] KW["table"] KW[":"] _1 KW["*"],
+   Disambiguator                                  -- KW["disambiguator"] KW[":"] _1,
+   LineCommentPrefix                              -- KW["line"] KW["comment"] KW[":"] _1,
+   BlockCommentDefs                               -- KW["block"] KW["comment"] KW[":"] _1,
+   FenceDefs                                      -- V  [H  [KW["fences"] KW[":"]] _1],
+   FenceDefs.1:iter-star                          -- _1,
+   IndentDefs                                     -- V  [H  [KW["indent"] KW["after"] KW[":"]] _1],
+   IndentDefs.1:iter-star                         -- _1,
+   IdentifierLexical                              -- KW["identifier"] KW["lexical"] KW[":"] _1,
+   BlockCommentDef                                -- _1 _2 _3,
+   BlockCommentDef                                -- _1 _2 _3,
+   NoContinuation                                 -- ,
+   FenceDef                                       -- _1 _2,
+   IndentDef                                      -- _1,
+   Sort                                           -- _1,
+   ListSort                                       -- _1 KW["*"],
+   String                                         -- _1,
+   ConstructorOnly                                -- KW["_"] KW["."] _1,
+   Constructor                                    -- _1,
+   SortAndConstructor                             -- _1 KW["."] _2,
+   Module                                         -- KW["module"] _1 _2 _3,
+   Module.3:iter-star                             -- _1,
+   Imports                                        -- V  [H  [KW["imports"]] _1],
+   Imports.1:iter                                 -- _1,
+   NoImports                                      -- ,
+   Import                                         -- _1,
+   ImportRenamed                                  -- _1 KW["["] _2 KW["]"],
+   ConcatIds                                      -- _1,
+   ConcatIds.1:iter-sep                           -- _1 KW["#"],
+   PreEBlock                                      -- KW["{|"] _1 KW["|"] _2 KW["|}"],
+   PreEBlock.1:iter-star                          -- _1,
+   PostEBlock                                     -- KW["{|"] _1 KW["|"] _2 KW["|}"],
+   PostEBlock.2:iter-star                         -- _1,
+   InnerBlock                                     -- V  [V vs=2 [KW["{|"] _1] KW["|}"]],
+   InnerBlock.1:iter-star                         -- _1,
+   PrePostEBlock                                  -- KW["{|"] _1 KW["|"] _2 KW["|"] _3 KW["|}"],
+   PrePostEBlock.1:iter-star                      -- _1,
+   PrePostEBlock.3:iter-star                      -- _1,
+   Assign                                         -- _1 KW["="] _2,
+   AssignMul                                      -- _1 KW["*="] _2,
+   AssignDiv                                      -- _1 KW["/="] _2,
+   AssignRemain                                   -- _1 KW["%="] _2,
+   AssignPlus                                     -- _1 KW["+="] _2,
+   AssignMinus                                    -- _1 KW["-="] _2,
+   AssignLeftShift                                -- _1 KW["<<="] _2,
+   AssignRightShift                               -- _1 KW[">>="] _2,
+   AssignURightShift                              -- _1 KW[">>>="] _2,
+   AssignAnd                                      -- _1 KW["&="] _2,
+   AssignExcOr                                    -- _1 KW["^="] _2,
+   AssignOr                                       -- _1 KW["|="] _2,
+   InstanceOf                                     -- _1 KW["instanceof"] _2,
+   Mul                                            -- _1 KW["*"] _2,
+   Div                                            -- _1 KW["/"] _2,
+   Remain                                         -- _1 KW["%"] _2,
+   Plus                                           -- _1 KW["+"] _2,
+   Minus                                          -- _1 KW["-"] _2,
+   LeftShift                                      -- _1 KW["<<"] _2,
+   RightShift                                     -- _1 KW[">>"] _2,
+   URightShift                                    -- _1 KW[">>>"] _2,
+   Lt                                             -- _1 KW["<"] _2,
+   Gt                                             -- _1 KW[">"] _2,
+   LtEq                                           -- _1 KW["<="] _2,
+   GtEq                                           -- _1 KW[">="] _2,
+   Eq                                             -- _1 KW["=="] _2,
+   NotEq                                          -- _1 KW["!="] _2,
+   LazyAnd                                        -- _1 KW["&&"] _2,
+   LazyOr                                         -- _1 KW["||"] _2,
+   And                                            -- _1 KW["&"] _2,
+   ExcOr                                          -- _1 KW["^"] _2,
+   Or                                             -- _1 KW["|"] _2,
+   Cond                                           -- _1 _2 _3,
+   Plus                                           -- KW["+"] _1,
+   Minus                                          -- KW["-"] _1,
+   PreIncr                                        -- KW["++"] _1,
+   PreDecr                                        -- KW["--"] _1,
+   Complement                                     -- KW["~"] _1,
+   Not                                            -- KW["!"] _1,
+   CastPrim                                       -- KW["("] _1 KW[")"] _2,
+   CastRef                                        -- KW["("] _1 KW[")"] _2,
+   PostIncr                                       -- _1 KW["++"],
+   PostDecr                                       -- _1 KW["--"],
+   Invoke                                         -- _1 KW["("] _2 KW[")"],
+   Invoke.2:iter-star-sep                         -- _1 KW[","],
+   Method                                         -- _1,
+   Method                                         -- _1 KW["."] _2 _3,
+   Method.2:opt                                   -- _1,
+   SuperMethod                                    -- KW["super"] KW["."] _1 _2,
+   SuperMethod.1:opt                              -- _1,
+   QSuperMethod                                   -- _1 KW["."] KW["super"] KW["."] _2 _3,
+   QSuperMethod.2:opt                             -- _1,
+   GenericMethod                                  -- _1 KW["."] _2 _3,
+   ArrayAccess                                    -- _1 _2,
+   Field                                          -- _1 KW["."] _2,
+   SuperField                                     -- KW["super"] KW["."] _1,
+   QSuperField                                    -- _1 KW["."] KW["super"] KW["."] _2,
+   NewArray                                       -- KW["new"] _1 _2 _3,
+   NewArray.2:iter                                -- _1,
+   NewArray.3:iter-star                           -- _1,
+   NewArray                                       -- KW["new"] _1 _2 _3,
+   NewArray.2:iter                                -- _1,
+   UnboundWld                                     -- _1 KW["<"] KW["?"] KW[">"],
+   Dim                                            -- KW["["] _1 KW["]"],
+   Dim                                            -- KW["["] KW["]"],
+   NewInstance                                    -- KW["new"] _1 _2 KW["("] _3 KW[")"] _4,
+   NewInstance.1:opt                              -- _1,
+   NewInstance.3:iter-star-sep                    -- _1 KW[","],
+   NewInstance.4:opt                              -- _1,
+   QNewInstance                                   -- _1 KW["."] KW["new"] _2 _3 _4 KW["("] _5 KW[")"] _6,
+   QNewInstance.2:opt                             -- _1,
+   QNewInstance.4:opt                             -- _1,
+   QNewInstance.5:iter-star-sep                   -- _1 KW[","],
+   QNewInstance.6:opt                             -- _1,
+   Lit                                            -- _1,
+   Class                                          -- _1 KW["."] KW["class"],
+   VoidClass                                      -- KW["void"] KW["."] KW["class"],
+   This                                           -- KW["this"],
+   QThis                                          -- _1 KW["."] KW["this"],
+   PackageDec                                     -- _1 KW["package"] _2 KW[";"],
+   PackageDec.1:iter-star                         -- _1,
+   TypeImportDec                                  -- KW["import"] _1 KW[";"],
+   TypeImportOnDemandDec                          -- KW["import"] _1 KW["."] KW["*"] KW[";"],
+   StaticImportDec                                -- KW["import"] KW["static"] _1 KW["."] _2 KW[";"],
+   StaticImportOnDemandDec                        -- KW["import"] KW["static"] _1 KW["."] KW["*"] KW[";"],
+   AnnoDec                                        -- _1 KW["{"] _2 KW["}"],
+   AnnoDec.2:iter-star                            -- _1,
+   AnnoDecHead                                    -- _1 KW["@"] KW["interface"] _2,
+   AnnoDecHead.1:iter-star                        -- _1,
+   AnnoDecHead.1:iter-star.1:alt                  -- _1 _2,
+   AnnoMethodDec                                  -- _1 _2 _3 KW["("] KW[")"] _4 KW[";"],
+   AnnoMethodDec.1:iter-star                      -- _1,
+   AnnoMethodDec.4:opt                            -- _1,
+   Semicolon                                      -- KW[";"],
+   DefaultVal                                     -- KW["default"] _1,
+   AbstractMethodDec                              -- _1 _2 _3 _4 KW["("] _5 KW[")"] _6 KW[";"],
+   AbstractMethodDec.1:iter-star                  -- _1,
+   AbstractMethodDec.1:iter-star.1:alt            -- _1 _2,
+   AbstractMethodDec.2:opt                        -- _1,
+   AbstractMethodDec.5:iter-star-sep              -- _1 KW[","],
+   AbstractMethodDec.6:opt                        -- _1,
+   DeprAbstractMethodDec                          -- _1 _2 _3 _4 KW["("] _5 KW[")"] _6 _7 KW[";"],
+   DeprAbstractMethodDec.1:iter-star              -- _1,
+   DeprAbstractMethodDec.1:iter-star.1:alt        -- _1 _2,
+   DeprAbstractMethodDec.2:opt                    -- _1,
+   DeprAbstractMethodDec.5:iter-star-sep          -- _1 KW[","],
+   DeprAbstractMethodDec.6:iter                   -- _1,
+   DeprAbstractMethodDec.7:opt                    -- _1,
+   ConstantDec                                    -- _1 _2 _3 KW[";"],
+   ConstantDec.1:iter-star                        -- _1,
+   ConstantDec.1:iter-star.1:alt                  -- _1 _2,
+   ConstantDec.3:iter-sep                         -- _1 KW[","],
+   InterfaceDec                                   -- _1 KW["{"] _2 KW["}"],
+   InterfaceDec.2:iter-star                       -- _1,
+   InterfaceDecHead                               -- _1 KW["interface"] _2 _3 _4,
+   InterfaceDecHead.1:iter-star                   -- _1,
+   InterfaceDecHead.1:iter-star.1:alt             -- _1 _2,
+   InterfaceDecHead.3:opt                         -- _1,
+   InterfaceDecHead.4:opt                         -- _1,
+   ExtendsInterfaces                              -- V  [H  [KW["extends"]] _1],
+   ExtendsInterfaces.1:iter-sep                   -- _1 KW[","],
+   Semicolon                                      -- KW[";"],
+   EnumDec                                        -- _1 _2,
+   EnumDecHead                                    -- _1 KW["enum"] _2 _3,
+   EnumDecHead.1:iter-star                        -- _1,
+   EnumDecHead.1:iter-star.1:alt                  -- _1 _2,
+   EnumDecHead.3:opt                              -- _1,
+   EnumBody                                       -- KW["{"] _1 _2 KW["}"],
+   EnumBody.1:iter-star-sep                       -- _1 KW[","],
+   EnumBody.2:opt                                 -- _1,
+   EnumBody                                       -- KW["{"] _1 KW[","] _2 KW["}"],
+   EnumBody.1:iter-star-sep                       -- _1 KW[","],
+   EnumBody.2:opt                                 -- _1,
+   EnumConst                                      -- _1 _2 _3,
+   EnumConst.2:opt                                -- _1,
+   EnumConst.3:opt                                -- _1,
+   EnumBodyDecs                                   -- V  [H  [KW[";"]] _1],
+   EnumBodyDecs.1:iter-star                       -- _1,
+   ConstrDec                                      -- _1 _2,
+   ConstrDecHead                                  -- _1 _2 _3 KW["("] _4 KW[")"] _5,
+   ConstrDecHead.1:iter-star                      -- _1,
+   ConstrDecHead.1:iter-star.1:alt                -- _1 _2,
+   ConstrDecHead.2:opt                            -- _1,
+   ConstrDecHead.4:iter-star-sep                  -- _1 KW[","],
+   ConstrDecHead.5:opt                            -- _1,
+   ConstrBody                                     -- KW["{"] _1 _2 KW["}"],
+   ConstrBody.1:opt                               -- _1,
+   ConstrBody.2:iter-star                         -- _1,
+   AltConstrInv                                   -- _1 KW["this"] KW["("] _2 KW[")"] KW[";"],
+   AltConstrInv.1:opt                             -- _1,
+   AltConstrInv.2:iter-star-sep                   -- _1 KW[","],
+   SuperConstrInv                                 -- _1 KW["super"] KW["("] _2 KW[")"] KW[";"],
+   SuperConstrInv.1:opt                           -- _1,
+   SuperConstrInv.2:iter-star-sep                 -- _1 KW[","],
+   QSuperConstrInv                                -- _1 KW["."] _2 KW["super"] KW["("] _3 KW[")"] KW[";"],
+   QSuperConstrInv.2:opt                          -- _1,
+   QSuperConstrInv.3:iter-star-sep                -- _1 KW[","],
+   StaticInit                                     -- KW["static"] _1,
+   InstanceInit                                   -- _1,
+   Empty                                          -- KW[";"],
+   Labeled                                        -- _1 KW[":"] _2,
+   ExprStm                                        -- _1 KW[";"],
+   If                                             -- KW["if"] KW["("] _1 KW[")"] _2,
+   If                                             -- KW["if"] KW["("] _1 KW[")"] _2 KW["else"] _3,
+   AssertStm                                      -- KW["assert"] _1 KW[";"],
+   AssertStm                                      -- KW["assert"] _1 KW[":"] _2 KW[";"],
+   Switch                                         -- KW["switch"] KW["("] _1 KW[")"] _2,
+   SwitchBlock                                    -- KW["{"] _1 _2 KW["}"],
+   SwitchBlock.1:iter-star                        -- _1,
+   SwitchBlock.2:iter-star                        -- _1,
+   SwitchGroup                                    -- _1 _2,
+   SwitchGroup.1:iter                             -- _1,
+   SwitchGroup.2:iter                             -- _1,
+   Case                                           -- KW["case"] _1 KW[":"],
+   Default                                        -- KW["default"] KW[":"],
+   While                                          -- KW["while"] KW["("] _1 KW[")"] _2,
+   DoWhile                                        -- KW["do"] _1 KW["while"] KW["("] _2 KW[")"] KW[";"],
+   For                                            -- KW["for"] KW["("] _1 KW[";"] _2 KW[";"] _3 KW[")"] _4,
+   For.2:opt                                      -- _1,
+   For.3:iter-star-sep                            -- _1 KW[","],
+   For                                            -- KW["for"] KW["("] _1 KW[";"] _2 KW[";"] _3 KW[")"] _4,
+   For.1:iter-star-sep                            -- _1 KW[","],
+   For.2:opt                                      -- _1,
+   For.3:iter-star-sep                            -- _1 KW[","],
+   ForEach                                        -- KW["for"] KW["("] _1 KW[":"] _2 KW[")"] _3,
+   Break                                          -- KW["break"] _1 KW[";"],
+   Break.1:opt                                    -- _1,
+   Continue                                       -- KW["continue"] _1 KW[";"],
+   Continue.1:opt                                 -- _1,
+   Return                                         -- KW["return"] _1 KW[";"],
+   Return.1:opt                                   -- _1,
+   Throw                                          -- KW["throw"] _1 KW[";"],
+   Synchronized                                   -- KW["synchronized"] KW["("] _1 KW[")"] _2,
+   Try                                            -- KW["try"] _1 _2,
+   Try.2:iter                                     -- _1,
+   Try                                            -- KW["try"] _1 _2 KW["finally"] _3,
+   Try.2:iter-star                                -- _1,
+   Catch                                          -- KW["catch"] KW["("] _1 KW[")"] _2,
+   LocalVarDecStm                                 -- _1 KW[";"],
+   LocalVarDec                                    -- _1 _2 _3,
+   LocalVarDec.1:iter-star                        -- _1,
+   LocalVarDec.1:iter-star.1:alt                  -- _1 _2,
+   LocalVarDec.3:iter-sep                         -- _1 KW[","],
+   Block                                          -- V  [V vs=2 [KW["{"] _1] KW["}"]],
+   Block.1:iter-star                              -- _1,
+   ClassDecStm                                    -- _1,
+   MethodDec                                      -- _1 _2,
+   MethodDecHead                                  -- _1 _2 _3 _4 KW["("] _5 KW[")"] _6,
+   MethodDecHead.1:iter-star                      -- _1,
+   MethodDecHead.1:iter-star.1:alt                -- _1 _2,
+   MethodDecHead.2:opt                            -- _1,
+   MethodDecHead.5:iter-star-sep                  -- _1 KW[","],
+   MethodDecHead.6:opt                            -- _1,
+   DeprMethodDecHead                              -- _1 _2 _3 _4 KW["("] _5 KW[")"] _6 _7,
+   DeprMethodDecHead.1:iter-star                  -- _1,
+   DeprMethodDecHead.1:iter-star.1:alt            -- _1 _2,
+   DeprMethodDecHead.2:opt                        -- _1,
+   DeprMethodDecHead.5:iter-star-sep              -- _1 KW[","],
+   DeprMethodDecHead.6:iter                       -- _1,
+   DeprMethodDecHead.7:opt                        -- _1,
+   Void                                           -- KW["void"],
+   Param                                          -- _1 _2 _3,
+   Param.1:iter-star                              -- _1,
+   Param.1:iter-star.1:alt                        -- _1 _2,
+   VarArityParam                                  -- _1 _2 KW["..."] _3,
+   VarArityParam.1:iter-star                      -- _1,
+   VarArityParam.1:iter-star.1:alt                -- _1 _2,
+   ThrowsDec                                      -- V  [H  [KW["throws"]] _1],
+   ThrowsDec.1:iter-sep                           -- _1 KW[","],
+   NoMethodBody                                   -- KW[";"],
+   ArrayInit                                      -- KW["{"] _1 KW["}"],
+   ArrayInit.1:iter-star-sep                      -- _1 KW[","],
+   ArrayInit                                      -- KW["{"] _1 KW[","] KW["}"],
+   ArrayInit.1:iter-star-sep                      -- _1 KW[","],
+   Anno                                           -- KW["@"] _1 KW["("] _2 KW[")"],
+   Anno.2:iter-star-sep                           -- _1 KW[","],
+   SingleElemAnno                                 -- KW["@"] _1 KW["("] _2 KW[")"],
+   MarkerAnno                                     -- KW["@"] _1,
+   ElemValPair                                    -- _1 KW["="] _2,
+   ElemValArrayInit                               -- KW["{"] _1 KW["}"],
+   ElemValArrayInit.1:iter-star-sep               -- _1 KW[","],
+   ElemValArrayInit                               -- KW["{"] _1 KW[","] KW["}"],
+   ElemValArrayInit.1:iter-star-sep               -- _1 KW[","],
+   FieldDec                                       -- _1 _2 _3 KW[";"],
+   FieldDec.1:iter-star                           -- _1,
+   FieldDec.1:iter-star.1:alt                     -- _1 _2,
+   FieldDec.3:iter-sep                            -- _1 KW[","],
+   VarDec                                         -- _1,
+   VarDec                                         -- _1 KW["="] _2,
+   ArrayVarDecId                                  -- _1 _2,
+   ArrayVarDecId.2:iter                           -- _1,
+   Dim                                            -- KW["["] KW["]"],
+   ClassDec                                       -- _1 _2,
+   ClassBody                                      -- V  [V vs=2 [KW["{"] _1] KW["}"]],
+   ClassBody.1:iter-star                          -- _1,
+   ClassDecHead                                   -- _1 KW["class"] _2 _3 _4 _5,
+   ClassDecHead.1:iter-star                       -- _1,
+   ClassDecHead.1:iter-star.1:alt                 -- _1 _2,
+   ClassDecHead.3:opt                             -- _1,
+   ClassDecHead.4:opt                             -- _1,
+   ClassDecHead.5:opt                             -- _1,
+   SuperDec                                       -- KW["extends"] _1,
+   ImplementsDec                                  -- V  [H  [KW["implements"]] _1],
+   ImplementsDec.1:iter-sep                       -- _1 KW[","],
+   Semicolon                                      -- KW[";"],
+   Semicolon                                      -- KW[";"],
+   CompilationUnit                                -- _1 _2 _3,
+   CompilationUnit.1:opt                          -- _1,
+   CompilationUnit.2:iter-star                    -- _1,
+   CompilationUnit.3:iter                         -- _1,
+   PackageName                                    -- _1,
+   PackageName.1:iter-sep                         -- _1 KW["."],
+   AmbName                                        -- _1,
+   AmbName                                        -- _1 KW["."] _2,
+   TypeName                                       -- _1,
+   TypeName                                       -- _1 KW["."] _2,
+   ExprName                                       -- _1,
+   ExprName                                       -- _1 KW["."] _2,
+   MethodName                                     -- _1,
+   MethodName                                     -- _1 KW["."] _2,
+   PackageOrTypeName                              -- _1,
+   PackageOrTypeName                              -- _1 KW["."] _2,
+   TypeArgs                                       -- KW["<"] _1 KW[">"],
+   TypeArgs.1:iter-sep                            -- _1 KW[","],
+   Wildcard                                       -- KW["?"] _1,
+   Wildcard.1:opt                                 -- _1,
+   WildcardUpperBound                             -- KW["extends"] _1,
+   WildcardLowerBound                             -- KW["super"] _1,
+   TypeParam                                      -- _1 _2,
+   TypeParam.2:opt                                -- _1,
+   TypeBound                                      -- V  [H  [KW["extends"]] _1],
+   TypeBound.1:iter-sep                           -- _1 KW["&"],
+   TypeParams                                     -- KW["<"] _1 KW[">"],
+   TypeParams.1:iter-sep                          -- _1 KW[","],
+   ClassOrInterfaceType                           -- _1 _2,
+   ClassOrInterfaceType.2:opt                     -- _1,
+   ClassType                                      -- _1 _2,
+   ClassType.2:opt                                -- _1,
+   InterfaceType                                  -- _1 _2,
+   InterfaceType.2:opt                            -- _1,
+   Member                                         -- _1 _2 KW["."] _3,
+   TypeVar                                        -- _1,
+   ArrayType                                      -- _1 KW["["] KW["]"],
+   Boolean                                        -- KW["boolean"],
+   Byte                                           -- KW["byte"],
+   Short                                          -- KW["short"],
+   Int                                            -- KW["int"],
+   Long                                           -- KW["long"],
+   Char                                           -- KW["char"],
+   Float                                          -- KW["float"],
+   Double                                         -- KW["double"],
+   Null                                           -- KW["null"],
+   Bool                                           -- _1,
+   True                                           -- KW["true"],
+   False                                          -- KW["false"],
+   Float                                          -- _1,
+   Float                                          -- _1,
+   Deci                                           -- _1,
+   Hexa                                           -- _1,
+   Octa                                           -- _1,
+   Public                                         -- KW["public"],
+   Private                                        -- KW["private"],
+   Protected                                      -- KW["protected"],
+   Abstract                                       -- KW["abstract"],
+   Final                                          -- KW["final"],
+   Static                                         -- KW["static"],
+   Native                                         -- KW["native"],
+   Transient                                      -- KW["transient"],
+   Volatile                                       -- KW["volatile"],
+   Synchronized                                   -- KW["synchronized"],
+   StrictFP                                       -- KW["strictfp"],
+   Id                                             -- _1,
+   ToMetaExpr                                     -- KW["e"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:expr"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["expr"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["var-init"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:bstm"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["bstm"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaListExpr                                 -- KW["java:bstm*"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr.1:iter-star                     -- _1,
+   ToMetaListExpr                                 -- KW["bstm*"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr.1:iter-star                     -- _1,
+   ToMetaExpr                                     -- KW["java:block-stm"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["block-stm"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaListExpr                                 -- KW["java:block-stm*"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr.1:iter-star                     -- _1,
+   ToMetaListExpr                                 -- KW["block-stm*"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr.1:iter-star                     -- _1,
+   ToMetaExpr                                     -- KW["java:stm"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["stm"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr                                 -- KW["switch-group"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr                                 -- KW["java:switch-group"] KW["|["] _1 KW["]|"],
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~bstm:"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~bstm*:"] _1,
+   FromMetaExpr                                   -- KW["~stm:"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~switch-group*:"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~switch-group:"] _1,
+   ToMetaExpr                                     -- KW["java:lvdec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["lvdec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:vdec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["vdec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["t"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["ty"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:type"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["type"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~type:"] _1,
+   ToMetaExpr                                     -- KW["ambname"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["ename"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["fname"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["tname"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["pkgtname"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["mod"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["anno"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["param"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:param"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["param*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star-sep                     -- _1 KW[","],
+   ToMetaExpr                                     -- KW["java:param*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star-sep                     -- _1 KW[","],
+   ToMetaExpr                                     -- KW["java:formal-param"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["formal-param"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:formal-param*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star-sep                     -- _1 KW[","],
+   ToMetaExpr                                     -- KW["formal-param*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star-sep                     -- _1 KW[","],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star-sep                     -- _1 KW[","],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star-sep                     -- _1 KW[","],
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   ToMetaExpr                                     -- KW["java:package-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["package-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:package-dec?"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:opt                               -- _1,
+   ToMetaExpr                                     -- KW["package-dec?"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:opt                               -- _1,
+   FromMetaExpr                                   -- KW["~package-dec:"] _1,
+   FromMetaExpr                                   -- KW["~package-dec?:"] _1,
+   ToMetaExpr                                     -- KW["java:import-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["import-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaListExpr                                 -- KW["java:import-dec*"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr.1:iter-star                     -- _1,
+   ToMetaListExpr                                 -- KW["import-dec*"] KW["|["] _1 KW["]|"],
+   ToMetaListExpr.1:iter-star                     -- _1,
+   FromMetaExpr                                   -- KW["~import-dec:"] _1,
+   FromMetaExpr                                   -- KW["~import-dec*:"] _1,
+   ToMetaExpr                                     -- KW["e"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:expr"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["expr"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:compilation-unit"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["compilation-unit"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:importdecl"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["importdecl"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:type-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["type-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:class-body-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["class-body-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:interface-member-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["interface-member-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:constant-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["constant-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:class-body-dec*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star                         -- _1,
+   ToMetaExpr                                     -- KW["class-body-dec*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star                         -- _1,
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star                         -- _1,
+   ToMetaListExpr                                 -- V  [V vs=2 [KW["|["] _1] KW["]|"]],
+   ToMetaListExpr.1:iter-star                     -- _1,
+   ToMetaExpr                                     -- KW["java:stm"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["stm"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:imember-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["imember-dec"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["java:imember-dec*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star                         -- _1,
+   ToMetaExpr                                     -- KW["imember-dec*"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star                         -- _1,
+   ToMetaExpr                                     -- KW["java"] KW["|["] _1 KW["]|"],
+   ToMetaExpr.1:iter-star                         -- _1,
+   ToMetaExpr                                     -- V  [V vs=2 [KW["|["] _1] KW["]|"]],
+   ToMetaExpr.1:iter-star                         -- _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~name:"] _1,
+   FromMetaExpr                                   -- KW["~*:"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~id:"] _1,
+   FromMetaExpr                                   -- KW["~idd:"] _1 KW[":"],
+   FromMetaExpr                                   -- KW["~x:"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~e:"] _1,
+   FromMetaExpr                                   -- KW["~expr:"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~"] _1,
+   FromMetaExpr                                   -- KW["~*"] _1,
+   FromMetaExpr                                   -- KW["~i:"] _1,
+   FromMetaExpr                                   -- KW["~deci:"] _1,
+   FromMetaExpr                                   -- KW["~hexa:"] _1,
+   FromMetaExpr                                   -- KW["~octa:"] _1,
+   FromMetaExpr                                   -- KW["~float:"] _1,
+   FromMetaExpr                                   -- KW["~string:"] _1,
+   FromMetaExpr                                   -- KW["~char:"] _1,
+   OverlayNoArgs                                  -- _1 KW["="] _2,
+   Overlay                                        -- _1 KW["("] _2 KW[")"] KW["="] _3,
+   Overlay.2:iter-star-sep                        -- _1 KW[","],
+   DynRuleScope                                   -- KW["{|"] _1 KW[":"] _2 KW["|}"],
+   ScopeLabels                                    -- KW["~"] _1,
+   GenDynRules                                    -- KW["rules"] KW["("] _1 KW[")"],
+   GenDynRules.1:iter-star                        -- _1,
+   AddScopeLabel                                  -- _1 KW["+"] _2,
+   UndefineDynRule                                -- _1 KW[":-"] _2,
+   SetDynRule                                     -- _1 KW[":"] _2,
+   AddDynRule                                     -- _1 KW[":+"] _2,
+   SetDynRuleMatch                                -- _1 KW[":"] _2,
+   DynRuleAssign                                  -- _1 KW[":="] _2,
+   DynRuleAssignAdd                               -- _1 KW[":+="] _2,
+   SetDynRuleDepends                              -- _1 KW[":"] _2 KW["depends"] KW["on"] _3,
+   LabeledDynRuleId                               -- _1 KW["."] _2,
+   AddLabelDynRuleId                              -- _1 KW["+"] _2,
+   DynRuleId                                      -- _1,
+   LabeledDynRuleScopeId                          -- _1 KW["."] _2,
+   DynRuleScopeId                                 -- _1,
+   RDecNoArgs                                     -- _1,
+   RDec                                           -- _1 KW["("] _2 KW[")"],
+   RDec.2:iter-star-sep                           -- _1 KW[","],
+   RDecT                                          -- _1 KW["("] _2 KW["|"] _3 KW[")"],
+   RDecT.2:iter-star-sep                          -- _1 KW[","],
+   RDecT.3:iter-star-sep                          -- _1 KW[","],
+   RuleNames                                      -- KW["~"] _1,
+   DynRuleIntersectFix                            -- KW["/"] _1 KW["\\*"] _2,
+   DynRuleIntersect                               -- _1 KW["/"] _2 KW["\\"] _3,
+   DynRuleUnion                                   -- _1 KW["\\"] _2 KW["/"] _3,
+   DynRuleIntersectUnion                          -- _1 KW["/"] _2 KW["\\"] _3 KW["/"] _4,
+   RDefNoArgs                                     -- _1 KW[":"] _2,
+   AnnoDef                                        -- _1 _2,
+   AnnoDef.1:iter                                 -- _1,
+   RDef                                           -- _1 KW["("] _2 KW[")"] KW[":"] _3,
+   RDef.2:iter-star-sep                           -- _1 KW[","],
+   RDefT                                          -- _1 KW["("] _2 KW["|"] _3 KW[")"] KW[":"] _4,
+   RDefT.2:iter-star-sep                          -- _1 KW[","],
+   RDefT.3:iter-star-sep                          -- _1 KW[","],
+   RuleNoCond                                     -- _1 KW["->"] _2,
+   Rule                                           -- _1 KW["->"] _2 KW["where"] _3,
+   Rule                                           -- _1 KW["->"] _2 _3,
+   Rule.3:iter                                    -- _1,
+   WhereClause                                    -- KW["where"] _1,
+   WithClause                                     -- KW["with"] _1,
+   SDefNoArgs                                     -- _1 KW["="] _2,
+   SDef                                           -- _1 KW["("] _2 KW[")"] KW["="] _3,
+   SDef.2:iter-star-sep                           -- _1 KW[","],
+   DefaultVarDec                                  -- _1,
+   Call                                           -- _1 KW["("] _2 KW[")"],
+   Call.2:iter-star-sep                           -- _1 KW[","],
+   ScopeDefault                                   -- KW["{"] _1 KW["}"],
+   BA                                             -- _1 _2,
+   LChoice                                        -- _1 KW["<+"] _2,
+   Rec                                            -- KW["rec"] _1 KW["("] _2 KW[")"],
+   Not                                            -- KW["not"] KW["("] _1 KW[")"],
+   Where                                          -- KW["where"] KW["("] _1 KW[")"],
+   With                                           -- KW["with"] KW["("] _1 KW[")"],
+   Test                                           -- KW["test"] KW["("] _1 KW[")"],
+   PrimNoArgs                                     -- KW["prim"] KW["("] _1 KW[")"],
+   Prim                                           -- KW["prim"] KW["("] _1 KW[","] _2 KW[")"],
+   Prim.2:iter-star-sep                           -- _1 KW[","],
+   StrCong                                        -- _1,
+   IntCong                                        -- _1,
+   RealCong                                       -- _1,
+   CharCong                                       -- _1,
+   CongQ                                          -- _1 KW["("] _2 KW[")"],
+   CongQ.2:iter-star-sep                          -- _1 KW[","],
+   AnnoCong                                       -- _1 _2,
+   StrategyCurly                                  -- KW["{"] _1 KW["}"],
+   EmptyTupleCong                                 -- KW["("] KW[")"],
+   TupleCong                                      -- KW["("] _1 KW[","] _2 KW[")"],
+   TupleCong.2:iter-sep                           -- _1 KW[","],
+   ListCongNoTail                                 -- KW["["] _1 KW["]"],
+   ListCongNoTail.1:iter-star-sep                 -- _1 KW[","],
+   ListCong                                       -- KW["["] _1 KW["|"] _2 KW["]"],
+   ListCong.1:iter-star-sep                       -- _1 KW[","],
+   ExplodeCong                                    -- _1 KW["#"] _2,
+   CallNoArgs                                     -- _1,
+   LRule                                          -- KW["\\"] _1 KW["\\"],
+   SRule                                          -- KW["("] _1 KW[")"],
+   Choice                                         -- _1 KW["+"] _2,
+   RChoice                                        -- _1 KW["+>"] _2,
+   ProceedNoArgs                                  -- KW["proceed"],
+   Proceed                                        -- KW["proceed"] KW["("] _1 KW[")"],
+   Proceed.1:iter-sep                             -- _1 KW[","],
+   CondChoice                                     -- KW["if"] _1 KW["then"] _2 KW["else"] _3 KW["end"],
+   IfThen                                         -- KW["if"] _1 KW["then"] _2 KW["end"],
+   SwitchChoiceNoOtherwise                        -- KW["switch"] _1 _2 KW["end"],
+   SwitchChoiceNoOtherwise.2:iter-star            -- _1,
+   SwitchChoice                                   -- KW["switch"] _1 _2 KW["otherwise"] KW[":"] _3 KW["end"],
+   SwitchChoice.2:iter-star                       -- _1,
+   SwitchCase                                     -- KW["case"] _1 KW[":"] _2,
+   AM                                             -- _1 KW["=>"] _2,
+   Assign                                         -- _1 KW[":="] _2,
+   ListVar                                        -- _1,
+   Var                                            -- _1,
+   BuildDefaultPT                                 -- KW["_"] _1,
+   BuildDefault                                   -- KW["_"] _1,
+   Char                                           -- _1,
+   AnnoList                                       -- _1 KW["{"] _2 KW["}"],
+   AnnoList.2:iter-star-sep                       -- _1 KW[","],
+   NoAnnoList                                     -- _1,
+   App                                            -- KW["<"] _1 KW[">"] _2,
+   App                                            -- KW["<"] _1 KW[">"] _2,
+   RootApp                                        -- _1,
+   RootApp                                        -- _1,
+   Tuple                                          -- KW["("] _1 KW[")"],
+   Tuple.1:iter-star-sep                          -- _1 KW[","],
+   List                                           -- KW["["] _1 KW["]"],
+   List.1:iter-star-sep                           -- _1 KW[","],
+   ListTail                                       -- KW["["] _1 KW["|"] _2 KW["]"],
+   ListTail.1:iter-star-sep                       -- _1 KW[","],
+   SortList                                       -- KW["["] _1 KW["]"],
+   SortList.1:iter-star-sep                       -- _1 KW[","],
+   SortListTl                                     -- KW["["] _1 KW["|"] _2 KW["]"],
+   SortListTl.1:iter-star-sep                     -- _1 KW[","],
+   SortTuple                                      -- KW["("] _1 KW[")"],
+   SortTuple.1:iter-star-sep                      -- _1 KW[","],
+   Star                                           -- KW["*"],
+   StarStar                                       -- KW["**"],
+   Sorts                                          -- V  [H  [KW["sorts"]] _1],
+   Sorts.1:iter-star                              -- _1,
+   Constructors                                   -- V  [H  [KW["constructors"]] _1],
+   Constructors.1:iter-star                       -- _1,
+   SortVar                                        -- _1,
+   SortNoArgs                                     -- _1,
+   Sort                                           -- _1 KW["("] _2 KW[")"],
+   Sort.2:iter-star-sep                           -- _1 KW[","],
+   OpDecl                                         -- _1 KW[":"] _2,
+   OpDeclQ                                        -- _1 KW[":"] _2,
+   OpDeclInj                                      -- KW[":"] _1,
+   ExtOpDecl                                      -- KW["external"] _1 KW[":"] _2,
+   ExtOpDeclQ                                     -- KW["external"] _1 KW[":"] _2,
+   ExtOpDeclInj                                   -- KW["external"] KW[":"] _1,
+   ConstType                                      -- _1,
+   FunType                                        -- _1 KW["->"] _2,
+   FunType.1:iter-sep                             -- _1 KW["*"],
+   Var                                            -- _1,
+   Wld                                            -- KW["_"],
+   Int                                            -- _1,
+   Real                                           -- _1,
+   Str                                            -- _1,
+   Op                                             -- _1 KW["("] _2 KW[")"],
+   Op.2:iter-star-sep                             -- _1 KW[","],
+   OpQ                                            -- _1 KW["("] _2 KW[")"],
+   OpQ.2:iter-star-sep                            -- _1 KW[","],
+   Explode                                        -- _1 KW["#"] KW["("] _2 KW[")"],
+   Anno                                           -- _1 KW["{^"] _2 KW["}"],
+   As                                             -- _1 KW["@"] _2,
+   As                                             -- _1 KW["@"] _2,
+   SVar                                           -- _1,
+   Let                                            -- KW["let"] _1 KW["in"] _2 KW["end"],
+   Let.1:iter-star                                -- _1,
+   CallT                                          -- _1 KW["("] _2 KW["|"] _3 KW[")"],
+   CallT.2:iter-star-sep                          -- _1 KW[","],
+   CallT.3:iter-star-sep                          -- _1 KW[","],
+   CallDynamic                                    -- KW["call"] KW["("] _1 KW["|"] _2 KW["|"] _3 KW[")"],
+   CallDynamic.2:iter-star-sep                    -- _1 KW[","],
+   CallDynamic.3:iter-star-sep                    -- _1 KW[","],
+   SDefT                                          -- _1 KW["("] _2 KW["|"] _3 KW[")"] KW["="] _4,
+   SDefT.2:iter-star-sep                          -- _1 KW[","],
+   SDefT.3:iter-star-sep                          -- _1 KW[","],
+   AnnoDef                                        -- _1 _2,
+   AnnoDef.1:iter                                 -- _1,
+   ExtSDefInl                                     -- KW["external"] _1 KW["("] _2 KW["|"] _3 KW[")"] KW["="] _4,
+   ExtSDefInl.2:iter-star-sep                     -- _1 KW[","],
+   ExtSDefInl.3:iter-star-sep                     -- _1 KW[","],
+   ExtSDef                                        -- KW["external"] _1 KW["("] _2 KW["|"] _3 KW[")"],
+   ExtSDef.2:iter-star-sep                        -- _1 KW[","],
+   ExtSDef.3:iter-star-sep                        -- _1 KW[","],
+   ExtSDef                                        -- KW["external"] _1 KW["("] _2 KW["|"] _3 KW[")"],
+   ExtSDef.2:iter-star-sep                        -- _1 KW[","],
+   ExtSDef.3:iter-star-sep                        -- _1 KW[","],
+   Extend                                         -- KW["extend"],
+   Override                                       -- KW["override"],
+   Internal                                       -- KW["internal"],
+   VarDec                                         -- _1 KW[":"] _2,
+   ParenStrat                                     -- KW["("] _1 KW[")"],
+   Fail                                           -- KW["fail"],
+   Id                                             -- KW["id"],
+   ProceedT                                       -- KW["proceed"] KW["("] _1 KW["|"] _2 KW[")"],
+   ProceedT.1:iter-star-sep                       -- _1 KW[","],
+   ProceedT.2:iter-star-sep                       -- _1 KW[","],
+   ProceedNoArgs                                  -- KW["proceed"],
+   Match                                          -- KW["?"] _1,
+   Build                                          -- KW["!"] _1,
+   Scope                                          -- KW["{"] _1 KW[":"] _2 KW["}"],
+   Scope.1:iter-star-sep                          -- _1 KW[","],
+   Seq                                            -- _1 KW[";"] _2,
+   GuardedLChoice                                 -- _1 KW["<"] _2 KW["+"] _3,
+   PrimT                                          -- KW["prim"] KW["("] _1 KW[","] _2 KW["|"] _3 KW[")"],
+   PrimT.2:iter-star-sep                          -- _1 KW[","],
+   PrimT.3:iter-star-sep                          -- _1 KW[","],
+   Some                                           -- KW["some"] KW["("] _1 KW[")"],
+   One                                            -- KW["one"] KW["("] _1 KW[")"],
+   All                                            -- KW["all"] KW["("] _1 KW[")"],
+   ImportTerm                                     -- KW["import-term"] KW["("] _1 KW[")"],
+   Module                                         -- KW["module"] _1 _2,
+   Module.2:iter-star                             -- _1,
+   Specification                                  -- V  [H  [KW["specification"]] _1],
+   Specification.1:iter-star                      -- _1,
+   Imports                                        -- V  [H  [KW["imports"]] _1],
+   Imports.1:iter-star                            -- _1,
+   Strategies                                     -- V  [H  [KW["strategies"]] _1],
+   Strategies.1:iter-star                         -- _1,
+   Signature                                      -- V  [H  [KW["signature"]] _1],
+   Signature.1:iter-star                          -- _1,
+   Import                                         -- _1,
+   Rules                                          -- V  [H  [KW["rules"]] _1],
+   Rules.1:iter-star                              -- _1,
+   Overlays                                       -- V  [H  [KW["overlays"]] _1],
+   Overlays.1:iter-star                           -- _1,
+   ToMetaExpr                                     -- KW["descriptor"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["descriptor"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["descriptor"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["descriptor"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["descriptor"] KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   ToMetaExpr                                     -- KW["|["] _1 KW["]|"],
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- _1,
+   FromMetaExpr                                   -- KW["~sort:"] _1,
+   FromMetaExpr.1:parameterized-sort              -- _1 _2,
+   FromMetaExpr.1:parameterized-sort.1:"Term"     -- ,
+   App                                            -- KW["<"] _1 KW[">"] _2,
+   App.1:parameterized-sort                       -- _1 _2,
+   App.1:parameterized-sort.1:"Strategy"          -- ,
+   App.2:parameterized-sort                       -- _1 _2,
+   App.2:parameterized-sort.1:"Term"              -- ,
+   RootApp                                        -- _1,
+   RootApp.1:parameterized-sort                   -- _1 _2,
+   RootApp.1:parameterized-sort.1:"StrategyAngle" -- 
+]
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Stratego-Java-EditorService.sdf
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/syntax/Stratego-Java-EditorService.sdf	Wed Aug 10 09:45:48 2011	(r23203)
@@ -0,0 +1,65 @@
+module Stratego-Java-EditorService
+imports
+  Stratego-Java-EBlock
+  EditorService
+  
+%%Comments[Section]
+  Comments[SemanticRule]
+  Comments[ColorRule]
+  Comments[OutlineRule]
+  Comments[FoldingRule]
+  Comments[LanguageProperty]
+  Comments[ReferenceRule]
+
+exports
+  context-free start-symbols Module[[StrategoHost]]
+
+  sorts
+    QuotedTerm
+    QuotedTerms
+
+  context-free syntax
+    
+    %% (Anti-)quotations
+    "descriptor" "|[" Module "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+    
+                 "|[" Module "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+    
+    "descriptor" "|[" OutlineRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+    "descriptor" "|[" ColorRule    "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+    "descriptor" "|[" FoldingRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr"), avoid}
+    "descriptor" "|[" SemanticRule "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+    
+                 "|[" OutlineRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+                 "|[" ColorRule    "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+                 "|[" FoldingRule  "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr"), avoid}
+                 "|[" SemanticRule "]|" -> Term[[StrategoHost]] {cons("ToMetaExpr")}
+
+    QuotedTerm -> Id {cons("FromMetaExpr"), avoid}
+    QuotedTerm -> PropertyValue {cons("FromMetaExpr"), avoid}
+    QuotedTerm -> URL {cons("FromMetaExpr"), avoid}
+    QuotedTerm -> ModuleName {cons("FromMetaExpr")}
+    QuotedTerm -> Color {cons("FromMetaExpr")}
+    QuotedTerm -> Font  {cons("FromMetaExpr")}
+    QuotedTerm -> SectionName {cons("FromMetaExpr")}
+    QuotedTerm -> SemanticRule {cons("FromMetaExpr"), avoid}
+    
+    QuotedTerms -> OutlineRule*   {cons("FromMetaExpr")}
+    QuotedTerms -> ColorRule*     {cons("FromMetaExpr")}
+    QuotedTerms -> FoldingRule*   {cons("FromMetaExpr")}
+    QuotedTerms -> PropertyValues {cons("FromMetaExpr")}
+    QuotedTerms -> SemanticRule*  {cons("FromMetaExpr")}
+
+    "~"  Term[[StrategoHost]] -> QuotedTerm  {bracket}
+    "~*" Term[[StrategoHost]] -> QuotedTerms {bracket}
+
+    "~sort:" Term[[StrategoHost]] -> Sort {cons("FromMetaExpr"), prefer}
+    
+    %% Stratego applications as anti-quotation
+    "<" Strategy[[StrategoHost]] ">" Term[[StrategoHost]] -> QuotedTerm {cons("App")}
+    StrategyAngle[[StrategoHost]]                         -> QuotedTerm {cons("RootApp"), avoid}
+
+  lexical syntax
+  
+    "<" ~[]* ">" -> PropertyValue {reject}
+    "~" ~[]*     -> PropertyValue {reject}

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 12:05:55 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 10:05:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23204 - in
	spoofax-imp/trunk: org.strategoxt.imp.metatooling/META-INF
	org.strategoxt.imp.runtime/META-INF
Message-ID: <20110810100555.CF0CC108C039@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 10:05:54 2011
New Revision: 23204
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23204&sc=1

Log:
- updated manifest.mf of metatooling and runtime for spoofax.generator

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF
   spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF	Wed Aug 10 09:45:48 2011	(r23203)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/META-INF/MANIFEST.MF	Wed Aug 10 10:05:54 2011	(r23204)
@@ -5,6 +5,7 @@
 Bundle-Version: 0.1.1.qualifier
 Require-Bundle: org.strategoxt.imp.runtime,
  org.strategoxt.imp.generator,
+ org.strategoxt.imp.spoofax.generator,
  org.eclipse.imp.runtime,
  org.spoofax.jsglr,
  org.spoofax.interpreter.core,

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Wed Aug 10 09:45:48 2011	(r23203)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/META-INF/MANIFEST.MF	Wed Aug 10 10:05:54 2011	(r23204)
@@ -21,6 +21,7 @@
  org.eclipse.debug.ui,
  org.spoofax.compiler,
  org.strategoxt.imp.generator,
+ org.strategoxt.imp.spoofax.generator,
  org.spoofax.terms,
  org.strategoxt.strj,
  org.strategoxt.imp.debug.core

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 12:08:59 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 10:08:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23205 - in
	spoofax-imp/trunk/org.strategoxt.imp.metatooling: .
	src/org/strategoxt/imp/metatooling/building
	src/org/strategoxt/imp/metatooling/wizards
Message-ID: <20110810100859.4FF4ECC2DF@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 10:08:59 2011
New Revision: 23205
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23205&sc=1

Log:
- New SpoofaxLang wizard
- AntSpxGenerateArtefacts
- Updated plugin.xml

Added:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxGenerateArtefacts.java
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewSpxEditorWizard.java
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewSpxEditorWizardPage.java
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/plugin.xml
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/plugin.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/plugin.xml	Wed Aug 10 10:05:54 2011	(r23204)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/plugin.xml	Wed Aug 10 10:08:59 2011	(r23205)
@@ -33,6 +33,19 @@
       </wizard>
    </extension>
    <extension
+         point="org.eclipse.ui.newWizards">
+      <primaryWizard
+            id="org.strategoxt.imp.metatooling.wizards.NewSpxEditorWizard">
+      </primaryWizard>
+      <wizard
+            class="org.strategoxt.imp.metatooling.wizards.NewSpxEditorWizard"
+            icon="icons/sample.gif"
+            id="org.strategoxt.imp.metatooling.wizards.NewSpxEditorWizard"
+            name="Spoofax/IMP(Spoofaxlang) editor project"
+            project="true">
+      </wizard>
+   </extension>
+   <extension
          point="org.eclipse.ant.core.antProperties">
       <antProperty
             class="org.strategoxt.imp.metatooling.NativePrefixAntPropertyProvider"

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java	Wed Aug 10 10:05:54 2011	(r23204)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java	Wed Aug 10 10:08:59 2011	(r23205)
@@ -10,15 +10,23 @@
 import org.eclipse.core.resources.ResourcesPlugin;
 import org.eclipse.core.runtime.IPath;
 import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
 import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.jobs.Job;
 import org.strategoxt.imp.metatooling.loading.DynamicDescriptorLoader;
 import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.stratego.EditorIOAgent;
 
 /**
- * Triggers descriptor building and loading from an Ant build file.
+ * Triggers spoofaxlang building and loading from an Ant build file.
  */
-public class AntSpxDescriptorBuilder {
 
+public class AntSpxDescriptorBuilder {
+	
+	//TODO :  Set Derived Resources 
+	//TODO :  Adding auto-generating the derived entries
+	
 	private static volatile boolean active;
 
 	public static void main(String[] args) {
@@ -56,6 +64,7 @@
 			}
 		} finally {
 			Environment.getStrategoLock().unlock();
+			
 		}
 	}
 
@@ -63,6 +72,7 @@
 	public static boolean isActive() {
 		return active;
 	}
+	
 
 	private static IResource getResource(String file) {
 		File fileRef = new File(file);

Added: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxGenerateArtefacts.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxGenerateArtefacts.java	Wed Aug 10 10:08:59 2011	(r23205)
@@ -0,0 +1,139 @@
+package org.strategoxt.imp.metatooling.building;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.jobs.Job;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.strategoxt.imp.editors.spoofax.trans.spoofaxlang;
+import org.strategoxt.imp.editors.spoofax.trans.build_spoofaxlang_jvm_0_0;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.stratego.EditorIOAgent;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.StrategoErrorExit;
+import org.strategoxt.lang.StrategoException;
+import org.strategoxt.lang.StrategoExit;
+import org.strategoxt.stratego_lib.dr_scope_all_end_0_0;
+import org.strategoxt.stratego_lib.dr_scope_all_start_0_0;
+
+public class AntSpxGenerateArtefacts {
+	private static volatile boolean active;
+	
+	public static boolean isActive() {
+		return active;
+	}
+	
+	private static void refresh(IResource workingdir) throws Exception
+	{
+		final int depthArg =  IResource.DEPTH_INFINITE;
+		final IResource file = workingdir;
+
+		Job job = new Job("Refresh") {
+			@Override
+			protected IStatus run(IProgressMonitor monitor) {
+				try {
+					file.touch(monitor);
+					file.refreshLocal(depthArg, monitor);
+				} catch (Exception e) {
+					Environment.logWarning("Could not refresh file", e);
+				}
+				return Status.OK_STATUS;
+			}
+		};
+		job.setSystem(true);
+		job.schedule(5000);
+		
+	}
+	
+	public static void main(String[] args) throws Exception{
+		if (args == null || args.length == 0)
+			throw new IllegalArgumentException("Project Work Directory is missing. ");
+
+		final String workingDirectoryArg = args[0];
+		final IResource file = EditorIOAgent.getResource(new File(workingDirectoryArg));
+
+		Environment.getStrategoLock().lock();
+		try {
+			if (!isActive())
+			{
+				active = true;
+				try {
+					if (!file.exists()) {
+						Environment.logException("Could not find project at following location :" + file.getLocation(), new FileNotFoundException(file.getFullPath().toOSString()));
+						System.err.println("Build failed: could not find  project at following location :" + file.getLocation());
+						System.exit(1);
+					}
+
+					EditorIOAgent agent = new EditorIOAgent();
+					agent.setAlwaysActivateConsole(true);
+					agent.setWorkingDir(file.getLocation().toOSString());
+
+					boolean success = generateArtefacts(file, new NullProgressMonitor() , agent);
+					if (!success) {
+						System.err.println("Build failed; see error log.");
+						System.exit(1);
+					}
+
+
+				} finally {
+					active = false;
+				}
+			}	
+		} finally {
+			Environment.getStrategoLock().unlock();
+			refresh(file);
+		}
+	}
+
+	public static boolean generateArtefacts(IResource file, IProgressMonitor monitor , EditorIOAgent agent) {
+		
+		IPath location = file.getLocation();
+		if (location == null) return false;
+	
+		try {
+			monitor.setTaskName("Generating artefacts for following spx project:  " + file.getName());
+			
+			if (file.exists() ) {
+				Context contextSpoofaxLang = new Context(Environment.getTermFactory(), agent);
+				contextSpoofaxLang.registerClassLoader(spoofaxlang.class.getClassLoader());
+				spoofaxlang.init(contextSpoofaxLang);
+				
+				IStrategoString input = contextSpoofaxLang.getFactory().makeString(file.getLocation().toOSString());
+				dr_scope_all_start_0_0.instance.invoke(contextSpoofaxLang, input);
+				
+				try {
+					
+					build_spoofaxlang_jvm_0_0.instance.invoke( contextSpoofaxLang , input);
+					
+				} catch (StrategoErrorExit e) {
+					Environment.logException(e);
+					throw new StrategoException("Project builder failed: " + e.getMessage() + "\nLog follows:\n\n"
+							+ agent.getLog(), e);
+				} catch (StrategoExit e) {
+					if (e.getValue() != 0) {
+						throw new StrategoException("Project builder failed.\nLog follows:\n\n"
+								+ agent.getLog(), e);
+					}
+				}
+				finally 
+				{
+					dr_scope_all_end_0_0.instance.invoke(contextSpoofaxLang, input);
+				}
+				
+				monitor.setTaskName(null);
+			}
+			return true;
+
+		} catch (Exception e) {
+			Environment.logException("Project builder failed: to generate artefacts" + file, e);
+			return false;
+		}
+
+	}	
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewSpxEditorWizard.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewSpxEditorWizard.java	Wed Aug 10 10:08:59 2011	(r23205)
@@ -0,0 +1,237 @@
+package org.strategoxt.imp.metatooling.wizards;
+
+import static org.eclipse.core.resources.IResource.DEPTH_INFINITE;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.resources.IncrementalProjectBuilder;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.core.runtime.jobs.Job;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.jface.operation.IRunnableWithProgress;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.jface.wizard.Wizard;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.ui.INewWizard;
+import org.eclipse.ui.IWorkbench;
+import org.spoofax.interpreter.core.Interpreter;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.strategoxt.imp.spoofax.generator.SpoofaxGenerator;
+import org.strategoxt.imp.metatooling.building.AntSpxGenerateArtefacts;
+import org.strategoxt.imp.metatooling.loading.DynamicDescriptorLoader;
+import org.strategoxt.imp.runtime.EditorState;
+import org.strategoxt.imp.editors.spoofax.trans.*;
+import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.stratego.EditorIOAgent;
+import org.strategoxt.lang.Context;
+import org.strategoxt.lang.StrategoErrorExit;
+import org.strategoxt.lang.StrategoException;
+import org.strategoxt.lang.StrategoExit;
+import org.strategoxt.permissivegrammars.make_permissive;
+import org.strategoxt.stratego_lib.dr_scope_all_end_0_0;
+import org.strategoxt.stratego_lib.dr_scope_all_start_0_0;
+
+/**
+ * A wizard for creating new Spoofax/IMP projects using SPX Language .
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class NewSpxEditorWizard extends Wizard implements INewWizard {
+	
+	private final NewSpxEditorWizardPage input = new NewSpxEditorWizardPage();
+	
+	private IProject lastProject;
+
+	// TODO: Support external directory and working set selection in wizard
+			
+	public NewSpxEditorWizard() {
+		setNeedsProgressMonitor(true);
+	}
+
+	public void init(IWorkbench workbench, IStructuredSelection selection) {
+		// No further initialization required
+	}
+	
+	@Override
+	public void addPages() {
+		addPage(input);
+	}
+
+	/**
+	 * This method is called when 'Finish' button is pressed in
+	 * the wizard. We will create an operation and run it
+	 * using wizard as execution context.
+	 */
+	@Override
+	public boolean performFinish() {
+		final String languageName = input.getInputLanguageName();
+		final String projectName = input.getInputProjectName();
+		final String packageName = input.getInputPackageName();
+		final String extensions = input.getInputExtensions();
+		
+		IRunnableWithProgress op = new IRunnableWithProgress() {
+			public void run(IProgressMonitor monitor) throws InvocationTargetException {
+				try {
+					doFinish(languageName, projectName, packageName, extensions, monitor);
+				} catch (Exception e) {
+					throw new InvocationTargetException(e);
+				} finally {
+					monitor.done();
+				}
+			}
+		};
+		
+		try {
+			getContainer().run(true, false, op);
+		} catch (InterruptedException e) {
+			rollback();
+			return false;
+		} catch (InvocationTargetException e) {
+			Throwable realException = e.getTargetException();
+			Environment.logException("Exception while creating new project", realException);
+			MessageDialog.openError(getShell(), "Error: " + realException.getClass().getName(), realException.getMessage());
+			rollback();
+			return false;
+		}
+		return true;
+	}
+	
+	private void rollback() {
+		// monitor.setTaskName("Undoing workspace operations");
+		try {
+			if (lastProject != null) lastProject.delete(true, null);
+		} catch (CoreException e) {
+			Environment.logException("Could not remove new project", e);
+		}
+	}
+	
+	
+ 	private void doFinish(String languageName, String projectName, String packageName, String extensions, IProgressMonitor monitor) throws IOException, CoreException {
+		final int TASK_COUNT = 20;
+		lastProject = null;
+		monitor.beginTask("Creating " + languageName + " project", TASK_COUNT);
+		
+		monitor.setTaskName("Preparing project builder");
+		EditorIOAgent agent = new EditorIOAgent();
+		agent.setAlwaysActivateConsole(true);
+		Context context = new Context(Environment.getTermFactory(), agent);
+		context.registerClassLoader(make_permissive.class.getClassLoader());
+		SpoofaxGenerator.init(context);
+		monitor.worked(1);
+
+		monitor.setTaskName("Creating project");
+		IWorkspace workspace = ResourcesPlugin.getWorkspace();
+		IProject project = lastProject = workspace.getRoot().getProject(projectName);
+		project.create(null);
+		project.open(null);
+		monitor.worked(1);
+
+		agent.setWorkingDir(project.getLocation().toOSString());
+		
+		try {
+			SpoofaxGenerator.mainNoExit(context, "-m", languageName, "-pn", projectName, "-n", packageName, "-e", extensions, "--verbose", "2");
+		} catch (StrategoErrorExit e) {
+			Environment.logException(e);
+			throw new StrategoException("Project builder failed: " + e.getMessage() + "\nLog follows:\n\n"
+					+ agent.getLog(), e);
+		} catch (StrategoExit e) {
+			if (e.getValue() != 0) {
+				throw new StrategoException("Project builder failed.\nLog follows:\n\n"
+						+ agent.getLog(), e);
+			}
+		}
+		AntSpxGenerateArtefacts.generateArtefacts(project , monitor, agent);
+		
+		monitor.worked(3);
+		refreshProject(project);
+		
+		monitor.setTaskName("Acquiring workspace lock"); // need root lock for builder
+		IWorkspaceRoot root = project.getWorkspace().getRoot();
+		Job.getJobManager().beginRule(root, monitor); // avoid ant builder launching
+		try {
+			monitor.setTaskName("Acquiring environment lock");
+			monitor.worked(1);
+			Environment.getStrategoLock().lock();
+			try { // avoid background editor loading
+				
+				monitor.setTaskName("Loading new resources");
+				project.refreshLocal(IResource.DEPTH_INFINITE, new NullProgressMonitor());
+				
+				monitor.worked(1);
+				
+				monitor.setTaskName("Building and loading example editor");
+				project.build(IncrementalProjectBuilder.FULL_BUILD, null);
+				monitor.worked(6);
+
+				// TODO: Optimize - don't reload editor (already done from Ant file)
+				// DynamicDescriptorLoader.getInstance().forceNoUpdate(descriptor);
+				
+				//monitor.setTaskName("Loading editor");
+				//IResource descriptor = project.findMember("include/" + languageName + ".packed.esv");
+				//DynamicDescriptorLoader.getInstance().forceUpdate(descriptor);
+				monitor.worked(2);
+
+				project.refreshLocal(DEPTH_INFINITE, new NullProgressMonitor());
+				monitor.worked(1);
+			
+			} finally {
+				Environment.getStrategoLock().unlock();
+			}
+		} finally {
+			Job.getJobManager().endRule(root);
+		}
+
+		monitor.setTaskName("Opening editor tabs");
+		Display display = getShell().getDisplay();
+		EditorState.asyncOpenEditor(display, project.getFile("/src/" + (languageName+"-descriptor").toLowerCase() +  ".spx"), true);
+		monitor.worked(2);
+		EditorState.asyncOpenEditor(display, project.getFile("/src/" + (languageName+"-definitions").toLowerCase() +  ".spx"), true);
+		monitor.worked(1);
+		EditorState.asyncOpenEditor(display, project.getFile("/test/example." + extensions.split(",")[0]), false);
+		refreshProject(project);
+	
+		monitor.done();
+	}
+
+	private static void refreshProject(final IProject project) {
+		// We schedule a project refresh to make all ".generated" files readable
+		Job job = new Job("Refreshing project") {
+			@Override
+			protected IStatus run(IProgressMonitor monitor) {
+				// Wait for update thread
+				Environment.getStrategoLock().lock();
+				Environment.getStrategoLock().unlock();
+				try {
+					project.refreshLocal(DEPTH_INFINITE, new NullProgressMonitor());
+				} catch (CoreException e) {
+					// Ignore
+				}
+				return Status.OK_STATUS;
+			}
+		};
+		job.setSystem(true);
+		job.schedule(5000);
+	}
+ 	
+ 	private static String toStrategoName(String languageName) {
+ 		return Interpreter.cify(languageName.toLowerCase()).replace('-', '_');
+ 	}
+
+	/*
+	private void throwCoreException(String message) throws CoreException {
+		IStatus status =
+			new Status(IStatus.ERROR, "org.strategoxt.imp.metatooling", IStatus.OK, message, null);
+		throw new CoreException(status);
+	}
+	*/
+}

Added: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewSpxEditorWizardPage.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/wizards/NewSpxEditorWizardPage.java	Wed Aug 10 10:08:59 2011	(r23205)
@@ -0,0 +1,310 @@
+package org.strategoxt.imp.metatooling.wizards;
+
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.jface.dialogs.IDialogPage;
+import org.eclipse.jface.wizard.WizardPage;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.events.ModifyEvent;
+import org.eclipse.swt.events.ModifyListener;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Label;
+import org.eclipse.swt.widgets.Text;
+
+/**
+ * The "New" wizard page allows setting the container for the new file as well
+ * as the file name. The page will only accept file name without the extension
+ * OR with the extension that matches the expected one (esv).
+ */
+
+public class NewSpxEditorWizardPage extends WizardPage {
+	
+	private Text inputProjectName;
+	
+	private Text inputLanguageName;
+	
+	private Text inputPackageName;
+	
+	private Text inputExtensions;
+	
+	private boolean isInputProjectNameChanged;
+	
+	private boolean isInputPackageNameChanged;
+	
+	private boolean isInputExtensionsChanged;
+	
+	private boolean ignoreEvents;
+
+	/**
+	 * Constructor for SampleNewWizardPage.
+	 */
+	public NewSpxEditorWizardPage() {
+		super("wizardPage");
+		setTitle("Spoofax/IMP(SpoofaxLang) Editor Project");
+		setDescription("This wizard creates a new Spoofax/IMP editor project (powered by SpoofaxLang).");
+	}
+
+	/**
+	 * @see IDialogPage#createControl(Composite)
+	 */
+	public void createControl(Composite parent) {
+		Composite container = new Composite(parent, SWT.NULL);
+		GridLayout layout = new GridLayout();
+		container.setLayout(layout);
+		layout.numColumns = 2;
+		layout.verticalSpacing = 9;
+		
+		/*
+		Label label = new Label(container, SWT.NULL);
+		label.setText("&Container:");
+		containerText = new Text(container, SWT.BORDER | SWT.SINGLE);
+		GridData gd = new GridData(GridData.FILL_HORIZONTAL);
+		containerText.setLayoutData(gd);
+		containerText.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				dialogChanged();
+			}
+		});
+		Button button = new Button(container, SWT.PUSH);
+		button.setText("Browse...");
+		button.addSelectionListener(new SelectionAdapter() {
+			@Override
+			public void widgetSelected(SelectionEvent e) {
+				handleBrowse();
+			}
+		});
+		*/
+				
+		new Label(container, SWT.NULL).setText("&Project name:");
+		inputProjectName = new Text(container, SWT.BORDER | SWT.SINGLE);
+		inputProjectName.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		inputProjectName.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				if (!ignoreEvents) {
+					distributeProjectName();
+					onChange();
+				}
+			}
+		});
+				
+		new Label(container, SWT.NULL).setText("&Language name:");
+		inputLanguageName = new Text(container, SWT.BORDER | SWT.SINGLE);
+		inputLanguageName.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		inputLanguageName.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				if (!ignoreEvents) {
+					distributeLanguageName();
+					isInputProjectNameChanged = true;
+					onChange();
+				}
+			}
+		});
+		
+		new Label(container, SWT.NULL).setText("&Plugin ID and Package name:");
+		inputPackageName = new Text(container, SWT.BORDER | SWT.SINGLE);
+		inputPackageName.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		inputPackageName.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				if (!ignoreEvents) {
+					isInputPackageNameChanged = true;
+					onChange();
+				}
+			}
+		});
+				
+		new Label(container, SWT.NULL).setText("&File extensions:");
+		inputExtensions = new Text(container, SWT.BORDER | SWT.SINGLE);
+		inputExtensions.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+		inputExtensions.addModifyListener(new ModifyListener() {
+			public void modifyText(ModifyEvent e) {
+				if (!ignoreEvents) {
+					isInputExtensionsChanged = true;
+					onChange();
+				}
+			}
+		});
+
+		setControl(container);
+		setPageComplete(false);
+		inputProjectName.setFocus();
+	}
+
+	private void distributeProjectName() {
+		if (!isInputProjectNameChanged || getInputLanguageName().length() == 0
+				|| getInputLanguageName().equals(toLanguageName(getInputProjectName()))) {
+			ignoreEvents = true;
+			inputLanguageName.setText(toLanguageName(getInputProjectName()));
+			isInputProjectNameChanged = false;
+			ignoreEvents = false;
+			distributeLanguageName();
+		}
+		if (!isInputPackageNameChanged || getInputPackageName().length() == 0
+				|| getInputPackageName().equals(toPackageName(getInputProjectName()))) {
+			ignoreEvents = true;
+			inputPackageName.setText(toPackageName(getInputProjectName()));
+			isInputPackageNameChanged = false;
+			ignoreEvents = false;
+		}
+	}
+
+	private void distributeLanguageName() {
+		if (!isInputExtensionsChanged || getInputExtensions().length() == 0
+				|| getInputExtensions().equals(toExtension(getInputLanguageName()))) {
+			ignoreEvents = true;
+			inputExtensions.setText(toExtension(getInputLanguageName()));
+			isInputExtensionsChanged = false;
+			ignoreEvents = false;
+		}
+	}
+
+	/**
+	 * Ensures that both text fields are set.
+	 */
+	private void onChange() {
+		setErrorMessage(null);
+		
+		if (getInputProjectName().length() == 0) {
+			setErrorStatus("Project name must be specified");
+			return;
+		}
+		if (getInputLanguageName().length() == 0) {
+			setErrorStatus("Language name must be specified");
+			return;
+		}	
+		
+		if (!isValidProjectName(getInputProjectName())) {
+			setErrorStatus("Project name must be valid");
+			return;
+		}
+		if (!toLanguageName(getInputLanguageName()).equalsIgnoreCase(getInputLanguageName())) {
+			setErrorStatus("Language name must be valid");
+			return;
+		}
+
+		if (getInputPackageName().length() == 0) {
+			setErrorStatus("Package name must be specified");
+			return;
+		}
+		if (!getInputPackageName().equalsIgnoreCase(toPackageName(getInputPackageName()))
+				|| getInputPackageName().indexOf("..") != -1
+				|| getInputPackageName().endsWith(".")) {
+			setErrorStatus("Package name must be valid");
+			return;
+		}
+
+		if (getInputExtensions().length() == 0) {
+			setErrorStatus("File extension must be specified");
+			return;
+		}
+		if (getInputExtensions().indexOf(".") != -1 || getInputExtensions().replace('\\', '/').indexOf("/") != -1
+				|| getInputExtensions().indexOf(":") > -1) {
+			setErrorStatus("File extension must be valid");
+			return;
+		}
+
+		IWorkspace workspace = ResourcesPlugin.getWorkspace();
+		if (workspace.getRoot().getProject(getInputProjectName()).exists()) {
+			setErrorStatus("A project with this name already exists");
+			return;
+		}
+	
+
+		if (getInputProjectName().indexOf(' ') != -1) {
+			setWarningStatus("Project names with spaces may not be supported depending on your configuration");
+		} else {
+			setErrorStatus(null);
+		}
+	}
+
+	private static boolean isValidProjectName(String name) {
+		for (char c : name.toCharArray()) {
+			if (!(Character.isLetterOrDigit(c) || c == '_' || c == ' ' || c == '-' || c == '.'
+				|| c == '(' || c == ')' || c == '#' || c == '+' || c =='[' || c == ']' || c == '@'))
+				return false;
+		}
+		return true;
+	}
+
+	private static String toLanguageName(String name) {
+		char[] input = name.replace(' ', '-').toCharArray();
+		StringBuilder output = new StringBuilder();
+		int i = 0;
+		while (i < input.length) {
+			char c = input[i++];
+			if (Character.isLetter(c) || c == '-' || c == '_') {
+				output.append(c);
+				break;
+			}
+		}
+		while (i < input.length) {
+			char c = input[i++];
+			if (Character.isLetterOrDigit(c) || c == '-' || c == '_')
+				output.append(c);
+		}
+		if (output.length() > 0)
+			output.setCharAt(0, Character.toUpperCase(output.charAt(0))); // SDF wants a capital here
+		return output.toString();
+	}
+	
+	private static String toPackageName(String name) {
+		char[] input = name.replace(' ', '-').toCharArray();
+		StringBuilder output = new StringBuilder();
+		int i = 0;
+		while (i < input.length) {
+			char c = input[i++];
+			if (Character.isLetter(c) || c == '.' || c == '_') {
+				output.append(c);
+				break;
+			}
+		}
+		while (i < input.length) {
+			char c = input[i++];
+			if (Character.isLetterOrDigit(c) || c == '.' || c == '_')
+				output.append(c);
+		}
+		String result = output.toString().replaceAll("\\.(?=\\.|[0-9]|\\Z)", "");
+		return  result;
+	}
+	
+	private static String toExtension(String name) {
+		String input = name.toLowerCase().replace("-", "").replace(".", "").replace(" ", "").replace(":", "");
+		String prefix = input.substring(0, Math.min(input.length(), 3));
+		if (input.length() == 0) return "";
+		
+		for (int i = input.length() - 1;; i--) {
+			if (!Character.isDigit(input.charAt(i)) && input.charAt(i) != '.') {
+				return prefix + input.substring(Math.max(prefix.length(), Math.min(input.length(), i + 1)));
+			} else if (i == prefix.length()) {
+				return prefix + input.substring(i);
+			}
+		}
+	}
+
+	private void setErrorStatus(String message) {
+		setErrorMessage(message);
+		setPageComplete(message == null);
+	}
+
+	private void setWarningStatus(String message) {
+		if (getErrorMessage() == null)
+			setErrorMessage(message);
+	}
+	
+	public String getInputProjectName() {
+		return inputProjectName.getText().trim();
+	}
+	
+	public String getInputLanguageName() {
+		return inputLanguageName.getText().trim();
+	}
+	
+	public String getInputPackageName() {
+		return inputPackageName.getText().trim();
+	}
+	
+	public String getInputExtensions() {
+		return inputExtensions.getText().trim();
+	}
+}
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 12:13:10 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 10:13:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23206 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF
Message-ID: <20110810101310.D6E33CC2DF@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 10:13:10 2011
New Revision: 23206
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23206&sc=1

Log:
added org.spoofax.interpreter.library.language

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF	Wed Aug 10 10:08:59 2011	(r23205)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/META-INF/MANIFEST.MF	Wed Aug 10 10:13:10 2011	(r23206)
@@ -16,6 +16,7 @@
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
   org.spoofax.jsglr,
+  org.spoofax.interpreter.library.language,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Bundle-ActivationPolicy: lazy

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 12:20:21 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 10:20:21 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23207 -
	spoofax-imp/trunk/org.strategoxt.imp.feature
Message-ID: <20110810102021.13E10CC074@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 10:20:20 2011
New Revision: 23207
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23207&sc=1

Log:
- added spoofax.generator and spoofax.configuration in feature.xml

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Wed Aug 10 10:13:10 2011	(r23206)
+++ spoofax-imp/trunk/org.strategoxt.imp.feature/feature.xml	Wed Aug 10 10:20:20 2011	(r23207)
@@ -336,5 +336,16 @@
          download-size="0"
          install-size="0"
          version="1.0.0.qualifier"/>
-
+   	
+   <plugin
+         id="org.strategoxt.imp.editors.spoofax.configuration"
+         download-size="0"
+         install-size="0"
+         version="1.0.0.qualifier"/>
+         
+	  <plugin
+         id="org.strategoxt.imp.spoofax.generator"
+         download-size="0"
+         install-size="0"
+         version="1.0.0.qualifier"/>
 </feature>

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 12:47:32 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 10:47:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23208 -
	spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project
Message-ID: <20110810104732.F1F37CC096@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 10:47:32 2011
New Revision: 23208
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23208&sc=1

Log:
building project works even if the (autogenerated) build files are not available. buildinit generates them anyway before they are needed. In the meantime, optional import for importing the build files dynamically.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-xml.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-xml.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-xml.str	Wed Aug 10 10:20:20 2011	(r23207)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-build-xml.str	Wed Aug 10 10:47:32 2011	(r23208)
@@ -43,17 +43,19 @@
   </condition>
   
   <property name="build.strategoxt.stratego" location="${user.home}/.nix-profile/bin"/>
-  <import file=".build/build.spx.main.generated.xml"/>
+  <import file=".build/build.spx.main.generated.xml" optional = "true"/>
   
   <!-- Compiles and Generates Artefacts. Internally it calls build-spoofaxlang-jvm strategy -->
  	<target name="buildinit">
-  	<java classname="org.strategoxt.imp.metatooling.building.AntSpxGenerateArtefacts" failonerror="false">
+  	<java classname="org.strategoxt.imp.metatooling.building.AntSpxGenerateArtefacts" failonerror="true">
 		 	<arg value="${basedir}"/>
 	  </java>
   </target>
 	
   <!-- Main target -->
-  <target name="all" depends="buildinit,build-spx-packages"/>
+  <target name="all" depends="buildinit">
+  	<antcall target = "build-spx-packages"/>
+  </target>
 </project>]
 	end
 

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 13:38:55 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 11:38:55 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23209 - in
	spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp:
	project services
Message-ID: <20110810113855.372422B801A@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 11:38:54 2011
New Revision: 23209
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23209&sc=1

Log:
getting rid of language id from the generated artefacts since it is optional now . dynamically emitted during the code generation if it is not specified.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str	Wed Aug 10 10:47:32 2011	(r23208)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str	Wed Aug 10 11:38:54 2011	(r23209)
@@ -12,7 +12,7 @@
     <output-text-file(|[], "spx.config")>
 $[Configuration
 	Includes
-		RootDirectory			src
+		AllDirectories			src
 					
 	CodeGeneration 
 		OutputDirectory		.shadowdir

Modified: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.str	Wed Aug 10 10:47:32 2011	(r23208)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-main-descriptor.str	Wed Aug 10 11:38:54 2011	(r23209)
@@ -64,8 +64,7 @@
         ~~
         name    :    ~name
       	extends : Root
-      	id      : ~ pkgname
-        ~~
+      	~~
         description: <conc-strings> ("\"Spoofax/IMP-generated(using spoofaxlang) editor for the ", name, " language \"")
         url: http://strategoxt.org
         ~~

From srabbelier at gmail.com  Wed Aug 10 16:50:54 2011
From: srabbelier at gmail.com (Sverre Rabbelier)
Date: Wed, 10 Aug 2011 14:50:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23210 -
	strategoxt/trunk/stratego-libraries/xtc/lib
Message-ID: <20110810145054.69B6D108C003@mx3.tudelft.nl>

Author: SverreRabbelier
Date: Wed Aug 10 14:50:54 2011
New Revision: 23210
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23210&sc=1

Log:
Revert "Generate libstratego-xtc.ctree"

This reverts commit 6fbe9347fb32bff1b14bc464c1759059e6cfb02c.

Modified:
   strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am

Modified: strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am
==============================================================================
--- strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am	Wed Aug 10 11:38:54 2011	(r23209)
+++ strategoxt/trunk/stratego-libraries/xtc/lib/Makefile.am	Wed Aug 10 14:50:54 2011	(r23210)
@@ -4,7 +4,7 @@
 
 pkgdatadir = $(datadir)/xtc
 
-nobase_pkgdata_DATA =  stratego-xtc.str libstratego-xtc.ctree $(fullstrategoxtc:.str=.rtree)
+nobase_pkgdata_DATA =  stratego-xtc.str $(fullstrategoxtc:.str=.rtree)
 data_DATA = libstratego-xtc.rtree
 lib_LTLIBRARIES = libstratego-xtc.la
 
@@ -45,9 +45,6 @@
 libstratego-xtc.rtree : lib$(stratego_xtc_module).rtree
 	cp $< $@
 
-libstratego-xtc.ctree : libstratego-xtc-posix-xsi.rtree
-	$(STRC_UNINSTALLED) -F --library -i $< -o $@ $(STRCFLAGS)
-
 stratego-xtc.str : Makefile
 	echo "module stratego-xtc imports $(stratego_xtc_module)" > $@
 

From M.A.Akhter at student.tudelft.nl  Wed Aug 10 20:25:44 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 10 Aug 2011 18:25:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23211 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen
Message-ID: <20110810182544.88F75108C003@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 10 18:25:44 2011
New Revision: 23211
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23211&sc=1

Log:
lib directory is no longer  needed

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Wed Aug 10 14:50:54 2011	(r23210)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Wed Aug 10 18:25:44 2011	(r23211)
@@ -149,7 +149,7 @@
   <mkdir dir="${src-gen}"/>
   <mkdir dir="${dist}"/>
   <mkdir dir="${include}"/>
-  <mkdir dir="${lib}"/>
+  
   
   <target name="init" if="eclipse.running">
 	  <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->

From M.A.Akhter at student.tudelft.nl  Thu Aug 11 03:48:11 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Thu, 11 Aug 2011 01:48:11 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23212 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen
Message-ID: <20110811014811.67240CC30A@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Thu Aug 11 01:48:11 2011
New Revision: 23212
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23212&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Wed Aug 10 18:25:44 2011	(r23211)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/generate.str	Thu Aug 11 01:48:11 2011	(r23212)
@@ -30,6 +30,8 @@
 strategies 
 	build-spoofaxlang = build-all(generate-artifacts-all)
 	
+	build-spoofaxlang' = build-all'(generate-artifacts-all)  // for testing purpose. remove it when it is no longer needed. 
+	
 	build-spoofaxlang-incrementally = build-all(generate-artifacts-incrementally)
 		 
 	build-all(gen-code) = 
@@ -40,16 +42,40 @@
 			;<debug>$[-------------------Getting list of errors-------------------]
 			;<get-all-analyzed-problems>() => problems  
 			;if <fail-if-has-errors>problems then
+			 	<debug>$[Compilation succeeded.];
 			 	{| ImportedDef : 
 							<gen-code>() 
-				|} 		
+				|}
 			else
-				<debug>$[Please fix the errors before building the artifacts:  [<pp-aterm-forced>problems]]
+				error-msg := $[Compilation Failed.Please fix the errors before building the artifacts:  [<pp-aterm-forced>problems]];		
+				<debug>error-msg
 			end		 
 		)
 		;!current-term //restoring current term to avoid side effects  
 
 	
+	build-all'(gen-code) = 
+		?current-term
+		;new-compile-session(
+			list-of-package-qname* := <get-package-list> 
+			;<compile-internal>list-of-package-qname*
+			;<debug>$[-------------------Getting list of errors-------------------]
+			;<get-all-analyzed-problems>() => problems  
+			;if <fail-if-has-errors>problems then
+			 	<debug>$[Compilation succeeded.];
+			 	{| ImportedDef : 
+							<gen-code>() 
+				|}
+				
+			else
+				(errors, warnings , notes) := problems;
+				 error-msg := $[Compilation Failed.Please fix the following [<length>errors] error(s) before building the artifacts:  [<pp-aterm-forced>errors]];		
+			 	fatal-err-msg(|error-msg )
+			 	
+			end		 
+		)
+		;!current-term //restoring current term to avoid side effects
+		 
 	generate-artifacts-all : () -> ()
 		where
 			<debug>$[-------------------Generating artifacts-------------------]

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str	Wed Aug 10 18:25:44 2011	(r23211)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/main.str	Thu Aug 11 01:48:11 2011	(r23212)
@@ -9,7 +9,7 @@
 imports
 	codegen/buildscripts
 	codegen/generate
-	
+	analyze/main
 imports 
 	config 
 	utils/cache
@@ -45,7 +45,9 @@
 			<+
 				prim("SSL_stacktrace_get_all_frame_names") ; report-failure
 		)
-		
+	
+	
+	//TODO : Improve error reporting. 
   build-spoofaxlang-jvm:
     current-project-location -> <id>
     with 
@@ -62,7 +64,7 @@
 			prim("SSL_stacktrace_get_all_frame_names") ; report-failure
 	
 		with	
-			<debug>$[Activating Project Configuration];
+			<debug>$[Activating Project Configuration : ];
 			initialize-configuration;        	// initializes configuration and setting up enviroment variables
 			enable-command-line-mode;  
 			<show-configuration;debug>()     //show configuration for this spx project
@@ -70,10 +72,10 @@
 			prim("SSL_stacktrace_get_all_frame_names") ; report-failure
 
 		with
-			<debug>$[Init Build];
-			<build-spoofaxlang>(); //building all the spx files in the sources directory
-			<chdir><previous-working-dir> ; 			// resetting working directory
-			<debug>$[Build Successful]
+			<debug>$[SPXLang Build: ];
+			<build-spoofaxlang'>(); //building all the spx files in the sources directory
+			<chdir><previous-working-dir> 			// resetting working directory
+			<debug>$[Intermediate artefacts have been generated successfully.]
 		<+
 			prim("SSL_stacktrace_get_all_frame_names") ; report-failure
 
@@ -87,7 +89,7 @@
 		 ;rules(ProjectPath := project-path)
 		 ;initialize-configuration
 		with
-	  	 enable-compiler-debugging
+			 enable-compiler-debugging
 	  	;<cache-currently-analyzing-ast>(<concat-strings>[project-path, "/" ,path] , ast)	 
 	  	;<build-spoofaxlang>()
 	  	;disable-compiler-debugging

From M.A.Akhter at student.tudelft.nl  Thu Aug 11 22:16:16 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Thu, 11 Aug 2011 20:16:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23213 - in
	spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp:
	project services
Message-ID: <20110811201616.2124D2B8016@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Thu Aug 11 20:16:14 2011
New Revision: 23213
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23213&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-common-trans.str
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-editorservices.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-common-trans.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-common-trans.str	Thu Aug 11 01:48:11 2011	(r23212)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-common-trans.str	Thu Aug 11 20:16:14 2011	(r23213)
@@ -9,7 +9,8 @@
     name          := <trans-module-name>;
     lang-name     := <get-sdf-main-module>;
     package-name  := <BasePackage <+ default-package-name>;
-	<output-text-file(|["src"], "editor-common.generated.spx")>
+    file-name 		:= <spx-file-name>"-editorcommon.generated.spx";
+	<output-text-file(|["src"], file-name)>
 ${package {package-name}.generated
 
 module CommonStrategies

Modified: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-editorservices.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-editorservices.str	Thu Aug 11 01:48:11 2011	(r23212)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/services/create-spxlang-editorservices.str	Thu Aug 11 20:16:14 2011	(r23213)
@@ -11,7 +11,7 @@
 	
 	output-spx-derived-editor-services = 
 		lang-name       := <get-sdf-main-module>;
-		file-name 		  := $[editor-services.generated] ;
+		file-name 		  := <spx-file-name>"-editorservices.generated" ;
 		file-extension  := ".spx";
 		package-name    := <BasePackage <+ default-package-name>;
 	  
@@ -41,7 +41,7 @@
 	
 	output-spx-editor-services = 
 		lang-name       := <get-sdf-main-module>;
-		file-name 		  := <spx-file-name>"-editor-services" ;
+		file-name 		  := <spx-file-name>"-editorservices" ;
 		file-extension  := ".spx" ;
 		package-name    := <BasePackage <+ default-package-name>;
 		

From L.C.L.Kats at tudelft.nl  Fri Aug 12 16:31:26 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 12 Aug 2011 14:31:26 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23214 - in
	spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core: .
	src/org/strategoxt/debug/core/control/events
Message-ID: <20110812143126.E8A8FCC28E@mx4.tudelft.nl>

Author: LennartKats
Date: Fri Aug 12 14:31:26 2011
New Revision: 23214
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23214&sc=1

Log:
don't include strategoxt.jar in debug plugin

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/build.properties
   spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/IEventInfoExtractorFactory.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/build.properties
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/build.properties	Thu Aug 11 20:16:14 2011	(r23213)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/build.properties	Fri Aug 12 14:31:26 2011	(r23214)
@@ -1,6 +1,7 @@
 bin.includes = META-INF/,\
                .,\
                lib/
+bin.excludes = lib/strategoxt.jar
 jars.compile.order = .
 source.. = src/
 output.. = bin/

Modified: spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/IEventInfoExtractorFactory.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/IEventInfoExtractorFactory.java	Thu Aug 11 20:16:14 2011	(r23213)
+++ spoofax-imp/trunk/org.strategoxt.imp.debug.stratego.core/src/org/strategoxt/debug/core/control/events/IEventInfoExtractorFactory.java	Fri Aug 12 14:31:26 2011	(r23214)
@@ -1,5 +1,7 @@
 package org.strategoxt.debug.core.control.events;
 
+import org.strategoxt.imp.debug.stratego.runtime.strategies.HybridInterpreterDebugRuntime;
+
 import com.sun.jdi.event.BreakpointEvent;
 import com.sun.jdi.event.MethodEntryEvent;
 import com.sun.jdi.event.MethodExitEvent;
@@ -8,7 +10,7 @@
 
 	public static IEventInfoExtractor createExtractor(BreakpointEvent event) {
 		String name = event.location().method().declaringType().name();
-		if (org.strategoxt.imp.debug.stratego.runtime.strategies.HybridInterpreterDebugRuntime.class.getName().equals(name))
+		if (HybridInterpreterDebugRuntime.class.getName().equals(name))
 		{
 			// the breakpoint in the HybridInterpreter does not have any StrategoState info, it is hit before the program is executed
 			return new EmptyExtractor(event);

From L.C.L.Kats at tudelft.nl  Fri Aug 12 16:35:53 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 12 Aug 2011 14:35:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23215 - hydra/jobs
Message-ID: <20110812143553.5CCF2108C024@mx3.tudelft.nl>

Author: LennartKats
Date: Fri Aug 12 14:35:53 2011
New Revision: 23215
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23215&sc=1

Log:
added adil's SPXLang plugins

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Fri Aug 12 14:31:26 2011	(r23214)
+++ hydra/jobs/spoofax-imp.nix	Fri Aug 12 14:35:53 2011	(r23215)
@@ -90,9 +90,11 @@
                  ${spoofaxImp}/org.strategoxt.imp.editors.sdf \
                  ${spoofaxImp}/org.strategoxt.imp.editors.spoofax \
                  ${spoofaxImp}/org.strategoxt.imp.editors.stratego \
+                 ${spoofaxImp}/org.strategoxt.imp.editors.spoofax.configuration
                  ${spoofaxImp}/org.strategoxt.imp.testing \
                  ${spoofaxImp}/org.strategoxt.imp.feature \
                  ${spoofaxImp}/org.strategoxt.imp.generator \
+                 ${spoofaxImp}/org.strategoxt.imp.spoofax.generator \
                  ${spoofaxImp}/org.strategoxt.imp.metatooling \
                  ${spoofaxImp}/org.strategoxt.imp.nativebundle \
                  ${spoofaxImp}/org.strategoxt.imp.runtime \

From L.C.L.Kats at tudelft.nl  Fri Aug 12 16:44:48 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Fri, 12 Aug 2011 14:44:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23216 - hydra/jobs
Message-ID: <20110812144448.B19587F80EB@mx1.tudelft.nl>

Author: LennartKats
Date: Fri Aug 12 14:44:48 2011
New Revision: 23216
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23216&sc=1

Log:
syntax error

Modified:
   hydra/jobs/spoofax-imp.nix

Modified: hydra/jobs/spoofax-imp.nix
==============================================================================
--- hydra/jobs/spoofax-imp.nix	Fri Aug 12 14:35:53 2011	(r23215)
+++ hydra/jobs/spoofax-imp.nix	Fri Aug 12 14:44:48 2011	(r23216)
@@ -90,7 +90,7 @@
                  ${spoofaxImp}/org.strategoxt.imp.editors.sdf \
                  ${spoofaxImp}/org.strategoxt.imp.editors.spoofax \
                  ${spoofaxImp}/org.strategoxt.imp.editors.stratego \
-                 ${spoofaxImp}/org.strategoxt.imp.editors.spoofax.configuration
+                 ${spoofaxImp}/org.strategoxt.imp.editors.spoofax.configuration \
                  ${spoofaxImp}/org.strategoxt.imp.testing \
                  ${spoofaxImp}/org.strategoxt.imp.feature \
                  ${spoofaxImp}/org.strategoxt.imp.generator \

From M.A.Akhter at student.tudelft.nl  Sat Aug 13 17:49:48 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sat, 13 Aug 2011 15:49:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23217 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration:
	editor syntax test trans
Message-ID: <20110813154948.778B32B800B@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Sat Aug 13 15:49:48 2011
New Revision: 23217
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23217&sc=1

Log:
* update spoofax.configlang with new lang construct to specify wildcards
* added config so that stroutputmode can be specified to ctree | jar . thus, configuring ctree/jar generation only requires a change of single line and thus, does not require to change in the build files. 

Primary goal of this configlang is to bring all sorts of configuration in spx.confg and demotivate endusers to change anything in the build.**.xml files

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/editor/SpoofaxConfiguration-Colorer.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/editor/SpoofaxConfiguration-Colorer.esv
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/editor/SpoofaxConfiguration-Colorer.esv	Fri Aug 12 14:44:48 2011	(r23216)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/editor/SpoofaxConfiguration-Colorer.esv	Sat Aug 13 15:49:48 2011	(r23217)
@@ -1,9 +1,38 @@
 module SpoofaxConfiguration-Colorer
 
-imports SpoofaxConfiguration-Colorer.generated
-
 colorer
                                                                       
   // This file can be used for custom colorer rules.                  
   //                                                                  
-  // See the imported file for a brief introduction and examples.     
\ No newline at end of file
+  // See the imported file for a brief introduction and examples.
+  
+  colorer Default, token-based highlighting
+                                  
+	  keyword    : 255 69 0         
+	  identifier : 0 0 255 italic 
+	  string     : blue               
+	  number     : darkgreen          
+	  var        : 255 0 100 italic   
+	  operator   : 0 0 128            
+	  layout     : 63 127 95   
+
+	colorer System colors
+                            
+	  darkred   = 128 0 0       
+	  red       = 255 0 0       
+	  darkgreen = 0 128 0       
+	  green     = 0 255 0       
+	  darkblue  = 0 0 128       
+	  blue      = 0 0 255       
+	  cyan      = 0 255 255     
+	  magenta   = 255 0 255     
+	  yellow    = 255 255 0     
+	  white     = 255 255 255   
+	  black     = 0 0 0         
+	  gray      = 128 128 128   
+	  grey      = gray          
+	  orange    = 255 165 0     
+	  pink      = 255 105 180   
+	  brown     = 139 69 19     
+	  default   = _   
+	       
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf	Fri Aug 12 14:44:48 2011	(r23216)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf	Sat Aug 13 15:49:48 2011	(r23217)
@@ -11,18 +11,22 @@
 
   	context-free syntax
   
-	    "Configuration"  ConfigSection*         -> Start {cons("Configuration")}
+	    "configuration"  ConfigSection*         -> Start {cons("Configuration")}
 	    
-	    "Includes" IncludeDefinition*    				-> ConfigSection{cons("Includes")}
-	     IncludeOption RelativePath*						-> IncludeDefinition {cons("Sources")}
-	    "SpxProjects" AbsolutePath* 						-> IncludeDefinition {cons("SpxProjects")}
-	    	
+			"src" ":"  IncludeDefinition+    				-> ConfigSection{cons("Includes")}
+	    RelativePath IncludeOption 							-> IncludeDefinition {cons("Source")}
 	    
-	    "CodeGeneration" CodeGenDefinition*     -> ConfigSection{cons("CodeGeneration")}
-	    "OutputDirectory"  RelativePath				    -> CodeGenDefinition {cons("OutputDirectory")}
+	    "projectreferences" ":" AbsolutePath* 	-> ConfigSection {cons("SpxProjects")}
+	    	
 	    
-	    "AllDirectories"												->   IncludeOption{cons("AllDirectories")}
-	    "RootDirectory"												  ->   IncludeOption{cons("RootDirectory")}
+	    "codegen:" CodeGenDefinition*    			 	-> ConfigSection{cons("CodeGeneration")}
+	    "todir" ":" RelativePath				  			-> CodeGenDefinition {cons("OutputDirectory")}
+	    "stroutputmode" ":" STROutputMode				-> CodeGenDefinition {cons("STROutputMode")}
+
+	    "ctree"																	-> STROutputMode{cons("CTree")}
+	    "jar"																		-> STROutputMode{cons("Jar")}	
+	    "|" "**"	 															->   IncludeOption{cons("All")}
+	    "|" "."												  				->   IncludeOption{cons("ThisOnly")}
 
 	lexical syntax 
 		%%STRING -> RelativePath
@@ -43,7 +47,7 @@
     "Includes"        					-> Reserved		
     "AllDirectories"   					-> Reserved		
     "CodeGeneration"            -> Reserved   
-    "RootDirectory" 				  -> Reserved		
+    "RootDirectory" 				  	-> Reserved		
    
     Reserved -> RelativePath{reject}
 	    

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config	Fri Aug 12 14:44:48 2011	(r23216)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config	Sat Aug 13 15:49:48 2011	(r23217)
@@ -1,11 +1,37 @@
-Configuration
-	Includes 
-		RootDirectory
-				test
-			
-		SpxProjects	
-			../org.strategoxt.imp.editors.spoofax
-			
-	CodeGeneration
-		OutputDirectory		.shadowdir  
-			 
\ No newline at end of file
+configuration
+	
+	// For current project, following configuration section specifies the directories 
+	// that will be included during building this project. 
+	// It can be specified as follows : 
+	//			directoryname | include-mode
+	// Here- 
+	//			
+	//			directoryname : Refers to the name of the local directory. 
+	//											It must be a relative path from the project-root.
+	//
+	//			include-mode  : It can have one of the following two values - 
+	//                           .  : includes only current directory. Subdirectories of the current directory are not included.
+	//                           ** : includes current directory and its subdirectories as well.
+	//
+	// If configuration file is missing or does not specify source, then default configuration is used during project build.
+	// By default, it includes all the directories ( and their subdirectories) of the project during build. Hence, It is  
+	// always recommended to explicitly specify the sources to include. 							  
+	src:
+		test|**
+		test|.
+	
+	codegen:
+		// todir refers to the project directory where intermediate generated 
+		// output is stored for further processing. 
+		todir			 		: .shawdowdir
+		
+		// STR outputmode can be configured as follows : jar | ctree.
+		// Based on this value, ctree or jar file generated for the packages
+		stroutputmode : jar
+		//stroutputmode : ctree
+	
+	// Other project references are specified in this configuration section.
+	projectreferences:
+			//../DatabaseLang 
+			//../DatabaseSPXLang 
+			../org.strategoxt.imp.editors.spoofax
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str	Fri Aug 12 14:44:48 2011	(r23216)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str	Sat Aug 13 15:49:48 2011	(r23217)
@@ -13,7 +13,7 @@
    SpxProjects(lst) -> <verify-project-references>lst
    
   constraint-error:
-   Sources(includeoption, list-local-dirs*) -> <verify-local-directories-exists>list-local-dirs*
+   Source(dir, includeoption) -> <verify-local-directories-exists>[dir]
 
 
   

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str	Fri Aug 12 14:44:48 2011	(r23216)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str	Sat Aug 13 15:49:48 2011	(r23217)
@@ -9,6 +9,7 @@
 	//Returns output directory for the code generation
 	get-code-output-directory = collect-all(?OutputDirectory(<id>), union) ; ?[<id>]
 
+
 	// Returns all the resolved directories 	
 	get-all-includes  = 
  	<conc>(<get-all-sources(|<project-path>)> ,   <get-sources-from-external-projects>)
@@ -16,18 +17,18 @@
  
  
 	get-all-sources(|project-path) =
- 		collect-all(?Sources(_, _));
+ 		collect-all(?Source(_, _));
  		get-local-sources;
  		map(\(s,o)-> ($[[project-path]/[s]],o)\)
  	<+ 
-  		debug(!"Failed to get list of source directory.") ; fail
+		debug(!"Failed to get list of source directory.") ; fail
  
 	get-local-sources: [] -> []
  
 	get-local-sources: 
- 	[Sources(include-option,sources*)|rest] -> result
- 	where
- 		<map(\s -> (s,include-option)\)>sources* => result';
+ 	[Source(dir , include-option)|rest] -> result
+ 	with
+ 		![(dir,include-option)] => result';
  		<conc>(<get-local-sources>rest, result') => result	 	
  
  
@@ -36,35 +37,48 @@
  	// Resolving project References 
 	get-sources-from-external-projects = 
   	get-all-project-refernces; 
-  	get-external-sources
-
+  	if  ?[_|_]  then
+  		get-external-sources
+		end
+		
 	// Returns all the external sournce collected from the project references 
  	get-external-sources: spx-projects* -> result
-	where 
-		not (?[])
-	  ;!spx-projects* => [current-project-path|rest*]
-	 where
-	 	result := <conc>( <resolve-external-sources<+ ![]>current-project-path , <get-external-sources>rest* )
+		where 
+			not (?[])
+	  	;!spx-projects* => [current-project-path|rest*]
+	 	where
+	 		if not(ref := <resolve-external-sources>current-project-path)  then
+	 			 ref := []
+	 		end
+	 		;result := <conc>( ref , <get-external-sources>rest* )
 	 	
 	get-external-sources: []  -> []
 	 
 	 
+	
 	// Resolves External Project Refernces and returns the directories configured in that configuration file
 	// Transitive imports/inclusion is not allowed. If a->b , b->c != a->c
 	resolve-external-sources =
-		where(explode-string; <not(eq)>(<Hd> , 46)) ; // not started wtih  ..
-	  	?current-project-path;
-	  	fail-if-no-directory-found;
-	  	fail-if-no-config-found;   
-	  	<parse-file>$[[current-project-path]/spx.config];
-	  	get-all-sources(|current-project-path)
+		 // not started wtih  ..
+		?current-project-path;
+  	where( 
+  		not(<string-starts-with(|"..")>current-project-path) 
+		);
+  	fail-if-no-directory-found;
+  	fail-if-no-config-found;   
+  	<parse-spoofaxconfiguration-file>$[[current-project-path]/spx.config];
+  	get-all-sources(|current-project-path)
 	
 	  	
 	resolve-external-sources =
-		where(explode-string; <eq>(<Hd> , 46)) ;
-		where(current-dir := <getcwd>);
+		?current-project-path;
+  	where( 
+  		<string-starts-with(|"..")>current-project-path 
+		);
+		where(
+			current-dir := <getcwd>
+		);
 		(
-	  		?current-project-path;
 	  		<fail-if-no-directory-found>current-project-path;
 	  		<chdir> current-project-path;
 	  		<fail-if-no-config-found><getcwd>; // verifies config file exisit in the current working directory
@@ -75,16 +89,14 @@
 	  		<chdir>current-dir  
 		)
 
-
  
 	get-all-project-refernces = 
   	collect-all(?SpxProjects(<id>), conc) ; 
   	flatten-list
   <+ 
-  	debug(!"Failed to retrieve list of projects.") ; fail 
- 
-  
-		
+  	debug(!"Failed to retrieve list of projects.");
+  	fail 
+
 rules 
 
 	// Utility strategies  

From M.A.Akhter at student.tudelft.nl  Sat Aug 13 17:50:59 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sat, 13 Aug 2011 15:50:59 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23218 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration
Message-ID: <20110813155059.55A847F804E@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Sat Aug 13 15:50:58 2011
New Revision: 23218
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23218&sc=1

Log:
added new configlang in spxlang

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.def
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.tbl

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.def
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.def	Sat Aug 13 15:49:48 2011	(r23217)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.def	Sat Aug 13 15:50:58 2011	(r23218)
@@ -57,18 +57,22 @@
 
   	context-free syntax
   
-	    "Configuration"  ConfigSection*         -> Start {cons("Configuration")}
+	    "configuration"  ConfigSection*         -> Start {cons("Configuration")}
 	    
-	    "Includes" IncludeDefinition*    				-> ConfigSection{cons("Includes")}
-	     IncludeOption RelativePath*						-> IncludeDefinition {cons("Sources")}
-	    "SpxProjects" AbsolutePath* 						-> IncludeDefinition {cons("SpxProjects")}
-	    	
+			"src" ":"  IncludeDefinition+    				-> ConfigSection{cons("Includes")}
+	    RelativePath IncludeOption 							-> IncludeDefinition {cons("Source")}
 	    
-	    "CodeGeneration" CodeGenDefinition*     -> ConfigSection{cons("CodeGeneration")}
-	    "OutputDirectory"  RelativePath				    -> CodeGenDefinition {cons("OutputDirectory")}
+	    "projectreferences" ":" AbsolutePath* 	-> ConfigSection {cons("SpxProjects")}
+	    	
 	    
-	    "AllDirectories"												->   IncludeOption{cons("AllDirectories")}
-	    "RootDirectory"												  ->   IncludeOption{cons("RootDirectory")}
+	    "codegen:" CodeGenDefinition*    			 	-> ConfigSection{cons("CodeGeneration")}
+	    "todir" ":" RelativePath				  			-> CodeGenDefinition {cons("OutputDirectory")}
+	    "stroutputmode" ":" STROutputMode				-> CodeGenDefinition {cons("STROutputMode")}
+
+	    "ctree"																	-> STROutputMode{cons("CTree")}
+	    "jar"																		-> STROutputMode{cons("Jar")}	
+	    "|" "**"	 															->   IncludeOption{cons("All")}
+	    "|" "."												  				->   IncludeOption{cons("ThisOnly")}
 
 	lexical syntax 
 		%%STRING -> RelativePath
@@ -89,7 +93,7 @@
     "Includes"        					-> Reserved		
     "AllDirectories"   					-> Reserved		
     "CodeGeneration"            -> Reserved   
-    "RootDirectory" 				  -> Reserved		
+    "RootDirectory" 				  	-> Reserved		
    
     Reserved -> RelativePath{reject}
 	    

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af	Sat Aug 13 15:49:48 2011	(r23217)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af	Sat Aug 13 15:50:58 2011	(r23218)
@@ -1 +1 @@
-PP-Table([PP-Entry(Path1("Configuration"),V([],[H([],[FBOX(KW,S("\"Configuration\""))]),Arg("1")])),PP-Entry(Path("Configuration",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("Includes"),V([],[H([],[FBOX(KW,S("\"Includes\""))]),Arg("1")])),PP-Entry(Path("Includes",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("Sources"),[Arg("1"),Arg("2")]),PP-Entry(Path("Sources",[selector("2","iter-star")]),[Arg("1")]),PP-Entry(Path1("SpxProjects"),V([],[H([],[FBOX(KW,S("\"SpxProjects\""))]),Arg("1")])),PP-Entry(Path("SpxProjects",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("CodeGeneration"),V([],[H([],[FBOX(KW,S("\"CodeGeneration\""))]),Arg("1")])),PP-Entry(Path("CodeGeneration",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("OutputDirectory"),[FBOX(KW,S("\"OutputDirectory\"")),Arg("1")]),PP-Entry(Path1("AllDirectories"),[FBOX(KW,S("\"AllDirectories\""))]),PP-Entry(Path1("RootDirectory"),[FBOX(KW,S("\"RootDirectory\""))])])
\ No newline at end of file
+PP-Table([PP-Entry(Path1("Configuration"),V([],[H([],[FBOX(KW,S("\"configuration\""))]),Arg("1")])),PP-Entry(Path("Configuration",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("Includes"),V([],[H([],[FBOX(KW,S("\"src\"")),FBOX(KW,S("\":\""))]),Arg("1")])),PP-Entry(Path("Includes",[selector("1","iter")]),[Arg("1")]),PP-Entry(Path1("Source"),[Arg("1"),Arg("2")]),PP-Entry(Path1("SpxProjects"),V([],[H([],[FBOX(KW,S("\"projectreferences\"")),FBOX(KW,S("\":\""))]),Arg("1")])),PP-Entry(Path("SpxProjects",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("CodeGeneration"),V([],[H([],[FBOX(KW,S("\"codegen:\""))]),Arg("1")])),PP-Entry(Path("CodeGeneration",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("OutputDirectory"),[FBOX(KW,S("\"todir\"")),FBOX(KW,S("\":\"")),Arg("1")]),PP-Entry(Path1("STROutputMode"),[FBOX(KW,S("\"stroutputmode\"")),FBOX(KW,S("\":\"")),Arg("1")]),PP-Entry(Path1("CTree"),[FBOX(KW,S("\"ctree\""))]),PP-Entry(Path1("Jar"),[FBOX(KW,S("\"jar\
 ""))]),PP-Entry(Path1("All"),[FBOX(KW,S("\"|\"")),FBOX(KW,S("\"**\""))]),PP-Entry(Path1("ThisOnly"),[FBOX(KW,S("\"|\"")),FBOX(KW,S("\".\""))])])
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str	Sat Aug 13 15:49:48 2011	(r23217)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str	Sat Aug 13 15:50:58 2011	(r23218)
@@ -2,12 +2,15 @@
 
 signature
   constructors
-    RootDirectory   : IncludeOption
-    AllDirectories  : IncludeOption
+    ThisOnly        : IncludeOption
+    All             : IncludeOption
+    Jar             : STROutputMode
+    CTree           : STROutputMode
+    STROutputMode   : STROutputMode -> CodeGenDefinition
     OutputDirectory : RelativePath -> CodeGenDefinition
-    SpxProjects     : List(AbsolutePath) -> IncludeDefinition
-    Sources         : IncludeOption * List(RelativePath) -> IncludeDefinition
+    Source          : RelativePath * IncludeOption -> IncludeDefinition
     CodeGeneration  : List(CodeGenDefinition) -> ConfigSection
+    SpxProjects     : List(AbsolutePath) -> ConfigSection
     Includes        : List(IncludeDefinition) -> ConfigSection
     Configuration   : List(ConfigSection) -> Start
                     : String -> AbsolutePath

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.tbl
==============================================================================
Binary file (source and/or target). No diff available.

From M.A.Akhter at student.tudelft.nl  Sat Aug 13 17:51:51 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sat, 13 Aug 2011 15:51:51 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23219 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans: .
	codegen context
Message-ID: <20110813155151.362EA2B800B@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Sat Aug 13 15:51:50 2011
New Revision: 23219
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23219&sc=1

Log:
- changes in the config, parseadapter , buildscripts due to configlang.

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Sat Aug 13 15:50:58 2011	(r23218)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Sat Aug 13 15:51:50 2011	(r23219)
@@ -1,7 +1,8 @@
 module codegen/buildscripts
 
 imports 
-  lib/editor-common.generated
+  lib/editor-common.generated
+  lib/Configuration/SpoofaxConfiguration
 imports 
 	include/SpoofaxLang
 	
@@ -54,27 +55,29 @@
 	emit-package-specific-ant : p at Package(package-untyped-qname at QName(qname-parts*)) -> $[ 
 	<target name="[package-target-name]">
 		<property name="package.path" location="[package-directory]"/>
-		<property name="lang.id.specific.directoy" value="[language-id-directory]"/>
-		<property name="package.name" value="[language-name]"/>
-		<property name="package.qname" value="[package-qname-string]"/>
-		<property name="package.main.sdf.module" value="[language-name]"/>
-		<property name="package.main.str.module" value="[language-name]"/>
-		<property name="package.main.esv.module" value="[language-name].main"/>
-		<property name="metasdfmodule" value="Stratego-[language-name]"/>
-		<property name="lang.sdf.specific.params" value="[language-sdf-specific-params]"/>
-		<property name="lang.str.specific.params" value="[language-str-specific-params]"/>
+		<property name="lang.id.specific.directoy" 		location="${src-gen}/[language-id-directory]"/>
+		<property name="lang.id.specific.subdirectoy" value ="[language-id-directory]"/>
+		<property name="package.name"             		value = "[language-name]"/>
+		<property name="package.qname"            		value = "[package-qname-string]"/>
+		<property name="package.main.sdf.module"  		value = "[language-name]"/>
+		<property name="package.main.str.module"  		value = "[language-name]"/>
+		<property name="package.main.esv.module"  		value = "[language-name].main"/>
+		<property name="metasdfmodule"            		value = "Stratego-[language-name]"/>
+		<property name="lang.sdf.specific.params" 		value = "[language-sdf-specific-params]"/>
+		<property name="lang.str.specific.params" 		value = "[language-str-specific-params]"/>
 		
 		<antcall target = "spx.default">
-		  <param name = "package.name"  value = "${package.name}"/>
-		  <param name = "package.qname"  value = "${package.qname}"/>
-		  <param name = "package.path"  value = "${package.path}"/>
-		  <param name = "lang.id.specific.directoy"  value = "${lang.id.specific.directoy}"/>
-		 	<param name = "package.main.sdf.module" value = "${package.main.sdf.module}"/>
-			<param name = "package.main.str.module" value = "${package.main.str.module}"/>
-		 	<param name = "package.main.esv.module" value = "${package.main.esv.module}"/>
-			<param name = "metasdfmodule" value = "${metasdfmodule}"/>
-			<param name="lang.sdf.specific.params" value="${lang.sdf.specific.params}"/>
-			<param name="lang.str.specific.params" value="${lang.str.specific.params}"/>
+		  <param name = "package.name"  								value = "${package.name}"/>
+		  <param name = "package.qname"  								value = "${package.qname}"/>
+		  <param name = "package.path"  								value = "${package.path}"/>
+		  <param name = "lang.id.specific.directoy"  		value = "${lang.id.specific.directoy}"/>
+		  <param name = "lang.id.specific.subdirectoy"  value = "${lang.id.specific.subdirectoy}"/>
+		 	<param name = "package.main.sdf.module" 			value = "${package.main.sdf.module}"/>
+			<param name = "package.main.str.module" 			value = "${package.main.str.module}"/>
+	 		<param name = "package.main.esv.module" 			value = "${package.main.esv.module}"/>
+			<param name = "metasdfmodule" 								value = "${metasdfmodule}"/>
+			<param name="lang.sdf.specific.params" 				value="${lang.sdf.specific.params}"/>
+			<param name="lang.str.specific.params" 				value="${lang.str.specific.params}"/>
 		</antcall>
 	</target>	
 	]
@@ -87,6 +90,7 @@
  		;package-qname-string				  :=  <package-qname-to-string>p
  		;language-sdf-specific-params := <get-idef-args>p 
  		;language-str-specific-params := ""	 
+ 		 
 
 rules
 	
@@ -110,16 +114,15 @@
 		
 rules
 			
-	get-ant-autogeneratedscript : () ->
-$[<?xml version="1.0" encoding="UTF-8" ?>
-
+	get-ant-autogeneratedscript : 
+		() -> $[<?xml version="1.0" encoding="UTF-8" ?>
 <project name="build.spx.generated">
-	<target name="spx.default" depends="spx.default.ctree"/>
+	<target name="spx.default" depends="[default-spx-target]"/>
   <target name="spx.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table, ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp, refresh"/>
 	<target name="spx.default.jar"   depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,java.jar,sdf2imp,refresh"/>
 	          
   <!-- Initialization -->
-  <available file="${build}/${lang.id.specific.directoy}/strategies/Main.class" property="java.jar.enabled"/>
+  <available file="${build}/${lang.id.specific.subdirectoy}/strategies/Main.class" property="java.jar.enabled"/>
   <condition property="java.jar.import" value="-la org.strategoxt.imp.editors.spoofax.strategies" else="">
       <isset property="java.jar.enabled"/>
   </condition>
@@ -146,7 +149,7 @@
     
 	<fail unless="build" message="Please use build.spx.main.xml to build this project or configure the required properties manually"/>
   <mkdir dir="${build}"/>
-  <mkdir dir="${src-gen}"/>
+  <mkdir dir="${src-gen}"/>
   <mkdir dir="${dist}"/>
   <mkdir dir="${include}"/>
   
@@ -180,26 +183,22 @@
 	        
 		<!--lots of redundant steps. TODO : remove the redundant build steps-->
 		<target name="refresh" if="eclipse.running">
-    		<eclipse.convertPath fileSystemPath="${basedir}" property="projectdir"/>
-        <eclipse.convertPath fileSystemPath="${packages.root}" property="packagesroot.dir"/>
-        <eclipse.convertPath fileSystemPath="${lib}" property="libdir"/>
-				<eclipse.convertPath fileSystemPath="${include}" property="includedir"/>
-				<eclipse.convertPath fileSystemPath="${src-gen}" property="eclipse.path.src-gen"/>
-				<eclipse.convertPath fileSystemPath="${build}" property="eclipse.path.build"/>	
-			
-				<eclipse.refreshLocal resource="${libdir}" depth="infinite"/>
-				<eclipse.refreshLocal resource="${libdir}/editor-common.generated.str" depth="infinite"/>
-				
+    		<eclipse.convertPath fileSystemPath="${basedir}" 			  property="projectdir"/>
+        <eclipse.convertPath fileSystemPath="${packages.root}"  property="packagesroot.dir"/>
+        <eclipse.convertPath fileSystemPath="${include}" 			  property="includedir"/>
+				<eclipse.convertPath fileSystemPath="${src-gen}" 			  property="eclipse.path.src-gen"/>
+				<eclipse.convertPath fileSystemPath="${build}" 				  property="eclipse.path.build"/>	
+				<eclipse.convertPath fileSystemPath="${basedir}/.build" property="builddir"/>
+				
 				<eclipse.refreshLocal resource="${package.path}" depth="infinite"/>
-				<eclipse.refreshLocal resource="${packages.root}" depth="infinite"/>
-				
-				<eclipse.refreshLocal resource="${projectdir}/build.spx.autogenerated.xml" depth="infinite"/>
+				<eclipse.refreshLocal resource="${packages.root}" depth="infinite"/>
+				<eclipse.refreshLocal resource="${builddir}" depth="infinite"/>
 				<eclipse.refreshLocal resource="${packagesroot.dir}" depth="infinite"/>
 				<eclipse.refreshLocal resource="${includedir}" depth="infinite"/>
-            
         <eclipse.refreshLocal resource="${eclipse.path.src-gen}" depth="infinite"/>
         <eclipse.refreshLocal resource="${eclipse.path.build}" depth="infinite"/>
-    </target>
+    </target>
+    
         
 		<target name="utils-files"> <!-- only useful for builds outside of Eclipse -->
         <mkdir dir="utils"/>
@@ -215,9 +214,6 @@
             <srcfileset dir="${packages.root}">
                 <include name="**/*.sdf"/>
             </srcfileset>
-            <srcfileset dir="${lib}">
-                <include name="**/*.def"/>
-            </srcfileset>
             <targetfileset file="${include}/${package.name}.def"/>
         </dependset>
         <available file="${include}/${package.name}.def" property="pack-sdf.available"/>
@@ -238,8 +234,6 @@
             <arg value="${packages.root}"/>
             <arg value="-I"/>
             <arg value="${package.path}"/>
-            <arg value="-I"/>
-            <arg value="${lib}"/>
             <arg line="${utils-include}"/>
             <arg line="${build.sdf.imports}"/>
             <arg line="${lang.sdf.specific.params}"/>
@@ -449,47 +443,61 @@
    </target>
 	
    <!-- Stratego to Java compiler -->
-   <target name="stratego.jar" depends="rtg2sig,utils-files">
-   	<dependset>
-    	<srcfileset dir="${package.path}">
-      	<include name="**/*.str"/>
-        <include name="**/*.astr"/>
-        <exclude name="lib/editor-common.generated.str"/>
-			</srcfileset>
-    	<targetfileset file="${src-gen}/trans/Main.java"/>
-         </dependset>
-         <available file="${src-gen}/trans/Main.java" property="strc-java.available"/>
+   <target name="stratego.jar" depends="utils-files">
+        <dependset>
+            <srcfileset dir="${package.path}">
+                <include name="**/*.str"/>
+                <include name="**/*.astr"/>
+            </srcfileset>
+            <targetfileset file="${lang.id.specific.directoy}/generated/${package.name}.java"/>
+         </dependset>
+         
+         <mkdir dir="${lang.id.specific.directoy}/generated"/>
+         <available file="${lang.id.specific.directoy}/generated/${package.name}.java" property="strc-java.available"/>
          <antcall target="copy-jar"/>
          <antcall target="stratego.jar.deletehelper"/>
+         
          <antcall target="stratego.jvm.helper">
-         		<param name="build.stratego.outputfile" value="${src-gen}/trans/Main.java"/>
+            <param name="build.stratego.outputfile" value="${lang.id.specific.directoy}/generated/${package.name}.java"/>
             <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
          </antcall>
-         <javac classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}" srcdir="${src-gen}" includes="trans/**" destdir="${build}" source="1.5" target="1.5" debug="on"/>
-         <!-- copy imported terms -->
-         <copy todir="${build}/trans">
-             <fileset dir="${src-gen}/trans" excludes="**/*.java"/>
-         </copy>
-         <jar basedir="${build}" includes="trans/**" destfile="${include}/${package.name}.tmp.jar"/>
-         <move file="${include}/${package.name}.tmp.jar" tofile="${include}/${package.name}.jar"/>
-         <delete><fileset dir="${build}" includes="trans/**"/></delete>
+         
+         <javac 
+            classpath="utils/strategoxt.jar:${src-gen}${externaljarimport}${java.jar.classpath}" srcdir="${src-gen}" 
+            includes="${lang.id.specific.subdirectoy}/generated/**" 
+            destdir="${build}" 
+            source="1.5" 
+            target="1.5" 
+            debug="on"
+        />
+        
+        <!-- copy imported terms -->
+        <copy todir="${build}/${lang.id.specific.subdirectoy}/generated">
+            <fileset dir="${lang.id.specific.directoy}/generated" excludes="**/*.java"/>
+        </copy>
+        
+        <jar basedir="${build}" includes="${lang.id.specific.subdirectoy}/generated/**" destfile="${include}/${package.name}.tmp.jar"/>
+     
+        <move file="${include}/${package.name}.tmp.jar" tofile="${include}/${package.name}.jar"/>
+        <delete>
+            <fileset dir="${build}" includes="${lang.id.specific.subdirectoy}/generated/**"/>
+        </delete>
      </target>
 	
 	
 		<!-- Stratego to Java interpreter -->
     <target name="stratego.ctree" >
     	<dependset>
-      		<srcfileset dir="${packages.root}">
-          	<include name="**/*.rtree"/>
-      			<include name="**/*.str"/>
-          </srcfileset>
-    			<srcfileset dir="${lib}">
-    	    	<include name="**/*.str"/>
-    				<exclude name="lib/editor-common.generated.str"/>
-    	    </srcfileset>
-    	    <targetfileset file="${include}/${package.name}.ctree"/>
+            <srcfileset dir="${packages.root}">
+                <include name="**/*.rtree"/>
+                <include name="**/*.str"/>
+            </srcfileset>
+            <targetfileset file="${include}/${package.name}.ctree"/>
       </dependset>
-      <available file="${include}/${package.name}.ctree" property="strc-java.available"/>
+      
+      <mkdir dir="${src-gen}/${lang.id.specific.subdirectoy}/generated"/>
+      <available file="${include}/${package.name}.ctree" property="strc-java.available"/>
+      
       <antcall target="copy-jar"/>
       <antcall target="stratego.jvm.helper">
       	<param name="build.stratego.outputfile" value="${include}/${package.name}.ctree"/>
@@ -499,40 +507,40 @@
         
     <target name="stratego.jar.deletehelper" unless="strc-java.available">
 	    <delete>
-	      <fileset dir="${src-gen}" includes="trans/**"/>
-        <fileset dir="${build}" includes="trans/**"/>
+	      	<fileset dir="${src-gen}" includes="${lang.id.specific.subdirectoy}/generated/**"/>
+          <fileset dir="${build}" includes="${lang.id.specific.subdirectoy}/generated/**"/>
       </delete>
 	  </target>
             
-  <target name="stratego.jvm.helper" unless="strc-java.available" if="build.stratego.enabled">
-  	<delete file="${include}/${package.name}.rtree" failonerror="false"/>
-  	<java classname="org.strategoxt.strj.Main" failonerror="true">
-  		<arg value="-I"/>
-    	<arg value="${package.path}"/>
-  		<arg value="-i"/>
-      <arg value="${packages.root}/${package.main.str.module}.str"/>
-      <arg value="-o"/>
-      <arg value="${build.stratego.outputfile}"/>
-  		<arg value="-p"/> 
-  	  <arg value="${package.qname}"/>  <!-- Note : added this extra parameter since, java package name does not allow dash unlike the ID is defined-->
-      <arg value="--library"/>
-      <arg value="--clean"/>
-  		<arg line="${build.stratego.args}"/>
-      <arg line="${build.stratego.extraargs}"/>
-      <arg line="${externaljarflags}"/>
-      <arg line="${externaldefimport}"/>
-      <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
-      <arg line="${lang.str.specific.params}"/>
-  </java>
-  <delete file="${include}/${package.name}.rtree" failonerror="false"/>
-  <mkdir dir="${build}/trans"/>
-</target>
+    <target name="stratego.jvm.helper" unless="strc-java.available" if="build.stratego.enabled">
+        <delete file="${include}/${package.name}.rtree" failonerror="false"/>
+        <java classname="org.strategoxt.strj.Main" failonerror="true">
+            <arg value="-I"/>
+            <arg value="${package.path}"/>
+            <arg value="-i"/>
+            <arg value="${packages.root}/${package.main.str.module}.str"/>
+            <arg value="-o"/>
+            <arg value="${build.stratego.outputfile}"/>
+            <arg value="-p"/> 
+            <arg value="${package.qname}.generated"/>  <!-- Note : added this extra parameter since, java package name does not allow dash unlike the ID is defined-->
+            <arg value="--library"/>
+            <arg value="--clean"/>
+            <arg line="${build.stratego.args}"/>
+            <arg line="${build.stratego.extraargs}"/>
+            <arg line="${externaljarflags}"/>
+            <arg line="${externaldefimport}"/>
+            <arg line="-I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
+            <arg line="${lang.str.specific.params}"/>
+        </java>
+        <delete file="${include}/${package.name}.rtree" failonerror="false"/>
+        <mkdir dir="${build}/${lang.id.specific.subdirectoy}/generated"/>
+    </target>
                 
-		<target name="clean" description="clean up">
+    <target name="clean" description="clean up">
       <delete dir="${build}"/>
       <delete file="${include}/${package.main.sdf.module}.def"/>
-      <delete dir="${src-gen}/trans"/>
-		</target>
+      <delete dir="${lang.id.specific.directoy}/generated/"/>
+    </target>
 	
 	  <!-- <target name="sdf2imp" depends="sdf2table,sdf2imp.eclipse,sdf2imp.standalone"/> -->
 	  
@@ -557,4 +565,9 @@
   </target>
 </project>
 ]
-
+where
+	if <eq>(Jar() , <STROutputStrategy> ) then 
+		default-spx-target := "spx.default.jar"
+	else
+		default-spx-target := "spx.default.ctree"
+	end		
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str	Sat Aug 13 15:50:58 2011	(r23218)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str	Sat Aug 13 15:51:50 2011	(r23219)
@@ -24,7 +24,9 @@
 	
 	root_directory = !"."
 	
-	default_output_directory= !".shadowdir"
+	default_output_directory = !".shadowdir"
+	
+	default_stroutput_strategy = !CTree()
 	
 	internal_module_name_string = !"__internal"
 	
@@ -34,16 +36,21 @@
 	
 	fallback-configuration = 
 		!Configuration(
-		  [ Includes([Sources(AllDirectories(), [<root_directory>])])
-		  , CodeGeneration([OutputDirectory(<default_output_directory>)])
+		  [ Includes([Source(<root_directory> , All())])
+		  , CodeGeneration([OutputDirectory(<default_output_directory>),STROutputMode(<default_stroutput_strategy>)])
 		  ]
 		)	
 	
 	initialize-configuration = 
 		?current-term 
-		;<parse-spoofaxconfiguration-file<+<debug>$[Failed to Load Configuration... Loading Default Configuration.]; fallback-configuration>"spx.config" => config-aterms
+		;(
+		 	<parse-spoofaxconfiguration-file
+	 	<+
+	 		<debug>$[Failed to Load Configuration.Loading Default Configuration. Please check spx.config]; fallback-configuration>"spx.config" => config-aterms
+	 	)
 		;init-output-directory
-		;init-source-directory    		
+		;init-source-directory
+		;init-str-output-strategy     		
 		;<init-ignored-directories>[".svn"]
 		;enable-caching
 		;enable-lib-cache-invalidation
@@ -55,32 +62,36 @@
 		    
 		;!current-term
 
-	show-configuration: (selected, position, ast, path, project-path) -> (filename, result)
-	with 
-		editor-init;
-		initialize-configuration 		
-	where 
-		if Enable-Caching then 
-			enabled-caching-string := "Caching of Semantic Errors is Enabled"  
-		else
-			enabled-caching-string := "Caching of Semantic Errors is Disabled"
-		end
-	where
-		filename := <guarantee-extension(|"config.resolved")> path;
-		result := $[ Spoofax-lang|Configuration  - [project-path]/spx.config
-	
-		Resolved Source Directories:  
-			[<pp-aterm><bagof-SPX-Source-Dir>]
-		
-		Ignored Subdirectories : 
-			[<pp-aterm><all-keys-Ignored-Spx-Souce-Dir>]
-		
-		Output Directory : [<pp-aterm><Autogenerated-Artifacts-Dir>]
+	//TODO  Refactor : Resuse <show-configuration>()
+	show-configuration: 
+		(selected, position, ast, path, project-path) -> (filename, result)
+		with 
+			editor-init;
+			initialize-configuration 		
+		where 
+			if Enable-Caching then 
+				enabled-caching-string := "Caching of Semantic Errors is Enabled"  
+			else
+				enabled-caching-string := "Caching of Semantic Errors is Disabled"
+			end
+		where
+			filename := <guarantee-extension(|"config.resolved")> path;
+			result := $[ Spoofax-lang|Configuration  - [project-path]/spx.config
 		
-		[enabled-caching-string] 
-				
-		]
+			Resolved Source Directories:  
+				[<pp-aterm><bagof-SPX-Source-Dir>]
+			
+			Ignored Subdirectories : 
+				[<pp-aterm><all-keys-Ignored-Spx-Souce-Dir>]
+			
+			Output Directory : [<pp-aterm><Autogenerated-Artifacts-Dir>]
+			
+			STR Output Strategy: [<pp-aterm><STROutputStrategy>]
+			
+			[enabled-caching-string] 
 					
+			]
+	//TODO Refactor 					
 	show-configuration : ()-> result
 	where 
 		if Enable-Caching then 
@@ -99,6 +110,8 @@
 		
 		Output Directory : [<pp-aterm><Autogenerated-Artifacts-Dir>]
 		
+		STR Output Strategy: [<pp-aterm><STROutputStrategy>]
+		
 		[enabled-caching-string] 
 				
 		] 
@@ -139,9 +152,16 @@
 	
 	init-output-directory : config-aterm -> config-aterm 
 	where
-  	 get-code-output-directory; setup-autogen-root-directory  			
+  	 (get-code-output-directory <+ default_output_directory); 
+  	 setup-autogen-root-directory  			
 	
 	
+	init-str-output-strategy : 
+		config-aterm -> <id>
+		where
+			(get-str-output-mode <+ default_stroutput_strategy);
+			setup-str-output-strategy
+			
 	//intializes the source directories . Compiler will only consider this directory as a valid spx sources .
 	init-source-directory : config-aterm -> config-aterm 
 	where 
@@ -152,12 +172,21 @@
 	override-configured-source-directories : localsoucedir -> localsoucedir
 	where
 		remove-existing-configuration-sourcedirs;
-		<setup-source-directories>[(localsoucedir,AllDirectories())]
+		<setup-source-directories>[(localsoucedir,All())]
 	
 	remove-existing-configuration-sourcedirs= with( rules(	SPX-Source-Dir :- _)) // removing all the configured source directory 
 
 
 rules
+	setup-str-output-strategy = 
+		?stroutputstrategy;
+		with 
+		(
+			rules(
+				STROutputStrategy := stroutputstrategy
+			) 
+		)
+			
 	setup-autogen-root-directory = 
 		?codegen-output-dir;
 		with(
@@ -167,13 +196,14 @@
 		) 
 
 	setup-source-directories: [] -> []	 
-	setup-source-directories: [configured-directory-setting|rest*] -> [configured-directory-setting|<setup-source-directories>rest*]  
-	where 
-		not(?[])
-	where 
-		rules(
-			SPX-Source-Dir :+ _ -> configured-directory-setting
-		)
+	setup-source-directories: 
+		[configured-directory-setting|rest*] -> [configured-directory-setting|<setup-source-directories>rest*]  
+		where 
+			not(?[])
+		where 
+			rules(
+				SPX-Source-Dir :+ _ -> configured-directory-setting
+			)
 				  			 	
 		
 rules  
@@ -186,80 +216,106 @@
 	
 	//Returns output directory for the code generation
 	get-code-output-directory = collect-one(?OutputDirectory(<id>))
+	
+	get-str-output-mode = collect-one(?STROutputMode(<id>))
 
 	// Returns all the resolved directories 	
 	get-all-includes  = 
- 	<conc>(<get-all-sources(|<get-project-path>)> ,   <get-sources-from-external-projects>)
+ 	<conc>(
+ 		<get-all-sources(|<get-project-path>)> ,   
+ 		<get-sources-from-external-projects> 
+	)
  	;make-set
  
  
-	convert-abs-path(|project-path) : (s, o) -> (s' , o)
-	where
+	convert-abs-path(|project-path) : 
+		(s, o) -> (s' , o)
+		where
 		 if root_directory => s  then
 		 		s' := $[[project-path]] 
 		 else
 		 		s' := $[[project-path]/[s]]
 		 end
-		 	
+	
+	
 	get-all-sources(|project-path) =
- 		collect-all(?Sources(_, _));
+ 		collect-all(?Source(_, _));
  		get-local-sources;
  		map(convert-abs-path(|project-path))
  	<+ 
-  		debug(!"Failed to get list of source directory.") ; fail
+		debug(!"Failed to get list of source directory.") ; fail
  
 	get-local-sources: [] -> []
  
 	get-local-sources: 
- 	[Sources(include-option,sources*)|rest] -> result
- 	where
- 		<map(\s -> (s,include-option)\)>sources* => result';
+ 	[Source(dir , include-option)|rest] -> result
+ 	with
+ 		![(dir,include-option)] => result';
  		<conc>(<get-local-sources>rest, result') => result	 	
- 
+ 			 	
+	get-local-sources: 
+ 	[Source(dir , include-option)|rest] -> result
+ 	with
+ 		![(dir,include-option)] => result';
+ 		<conc>(<get-local-sources>rest, result') => result	 	
+ 	
  
 rules 
  	
  	// Resolving project References 
 	get-sources-from-external-projects = 
   	get-all-project-refernces; 
-  	get-external-sources
-
-	// Returns all the external sournce collected from the project references 
- 	get-external-sources: spx-projects* -> result
-	where 
-		not (?[])
-	  ;!spx-projects* => [current-project-path|rest*]
-	 where
-	 	result := <conc>( <resolve-external-sources<+ ![]>current-project-path , <get-external-sources>rest* )
+		if  ?[_|_]  then
+  		get-external-sources
+  	end
+  	
+  	// Returns all the external sournce collected from the project references 
+ 		get-external-sources: spx-projects* -> result
+		where 
+			not (?[])
+	  	;!spx-projects* => [current-project-path|rest*]
+	 	where
+	 		if not(ref := <resolve-external-sources>current-project-path)  then
+	 			 ref := []
+	 		end
+	 		;result := <conc>( ref , <get-external-sources>rest* )
 	 	
-	get-external-sources: []  -> []
-	 
+		get-external-sources: []  -> []
 	 
+
 	// Resolves External Project Refernces and returns the directories configured in that configuration file
 	// Transitive imports/inclusion is not allowed. If a->b , b->c != a->c
 	resolve-external-sources =
-		where(explode-string; <not(eq)>(<Hd> , 46)) ; // not started wtih  ..
-	  	?current-project-path;
-	  	verify-directory-exists;
-	  	verify-config-file-exists;   
-	  	<parse-file>$[[current-project-path]/spx.config];
-	  	get-all-sources(|current-project-path)
+		 // not started wtih  ..
+		?current-project-path;
+  	where( 
+  		not(<string-starts-with(|"..")>current-project-path) 
+		);
+  	fail-if-no-directory-found;
+  	fail-if-no-config-found;   
+  	<parse-spoofaxconfiguration-file>$[[current-project-path]/spx.config];
+  	get-all-sources(|current-project-path)
 	
 	  	
 	resolve-external-sources =
-		where(explode-string; <eq>(<Hd> , 46)) ;
-		where(current-dir := <getcwd>);
+		?current-project-path;
+  	where( 
+  		<string-starts-with(|"..")>current-project-path 
+		);
+		where(
+			current-dir := <getcwd>
+		);
 		(
-	  		?current-project-path;
-	  		<verify-directory-exists>current-project-path;
+	  		<fail-if-no-directory-found>current-project-path;
 	  		<chdir> current-project-path;
-	  		<verify-config-file-exists><getcwd>; // verifies config file exisit in the current working directory
+	  		<fail-if-no-config-found><getcwd>; // verifies config file exisit in the current working directory
 	  		<parse-spoofaxconfiguration-file;get-all-sources(|<getcwd>)>"spx.config" => result;
 	  		<chdir>current-dir; 
 	  		!result
 	  	<+
 	  		<chdir>current-dir  
 		)
+ 
 	
 	get-all-project-refernces = 
   	collect-all(?SpxProjects(<id>), conc) ; 
@@ -270,7 +326,16 @@
 rules 
 
 	// Utility strategies  
-
+		// verifies whether current directory exists 
+	fail-if-no-directory-found  = is-dir-exist   <+ throw-directory-not-found-exception(fail) 
+	
+	// verfies whether there is a config file in the provided directory 
+	fail-if-no-config-found = is-spx-config-exist   <+ throw-config-not-found-exception(fail)   
+	
+	throw-directory-not-found-exception(post-processing-strategy) = debug(!"Configuration | Failed to find the directory specified: ") ;post-processing-strategy
+	
+	throw-config-not-found-exception(post-processing-strategy) = debug(!"Configuration | Failed to find spx.config file in the directory specified: ") ;post-processing-strategy
+	
 	
 	// verifies whether current directory exists 
 	verify-directory-exists  = is-dir-exist   <+ throw-directory-not-found-exception(fail) 

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str	Sat Aug 13 15:50:58 2011	(r23218)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/context/parse-adapter.str	Sat Aug 13 15:51:50 2011	(r23219)
@@ -37,7 +37,7 @@
 		readdir;
 		list-loop(
     	if <isdir> <filemode> then  //FIXME : filemode / isdir contains bug. Common folder is not considered as directory which is a bug
-    		if not(Ignored-Spx-Souce-Dir); !search-option => AllDirectories()  then
+    		if not(Ignored-Spx-Souce-Dir); !search-option => All()  then
        		 chdir;
         	 <parse-spx-compilationUnits(|search-option)<+ throw-unable-read-exception(|"Failed to read this directory : ")><getcwd>;
            <chdir> ".."

From M.A.Akhter at student.tudelft.nl  Sat Aug 13 17:53:57 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sat, 13 Aug 2011 15:53:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23220 -
	spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project
Message-ID: <20110813155357.6D84FCC2A6@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Sat Aug 13 15:53:57 2011
New Revision: 23220
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23220&sc=1

Log:
* default configuration section. 
* by default , stroutputmode is set to ctree; but can be specified as jar. 
* Tested the build with jar setting. its working as expected generating new package structure.
**** generated str = located at => languageid.generated package

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str	Sat Aug 13 15:51:50 2011	(r23219)
+++ spoofax-imp/trunk/org.strategoxt.imp.spoofax.generator/src/sdf2imp/project/create-spxlang-config-file.str	Sat Aug 13 15:53:57 2011	(r23220)
@@ -10,10 +10,40 @@
     verbose-msg(!"Skipping", "spx.config")
   <+
     <output-text-file(|[], "spx.config")>
-$[Configuration
-	Includes
-		AllDirectories			src
-					
-	CodeGeneration 
-		OutputDirectory		.shadowdir
+$[configuration
+	
+	// For current project, following configuration section specifies the directories 
+	// that will be included during building this project. 
+	// It can be specified as follows : 
+	//			directoryname | include-mode
+	// Here- 
+	//			
+	//			directoryname : Refers to the name of the local directory. 
+	//											It must be a relative path from the project-root.
+	//
+	//			include-mode  : It can have one of the following two values - 
+	//                           .  : includes only current directory. Subdirectories of the current directory are not included.
+	//                           ** : includes current directory and its subdirectories as well.
+	//
+	// If configuration file is missing or does not specify source, then default configuration is used during project build.
+	// By default, it includes all the directories ( and their subdirectories) of the project during build. Hence, It is  
+	// always recommended to explicitly specify the sources to include. 							  
+	src:
+		test|**
+		
+				
+	codegen:
+		// todir refers to the project directory where intermediate generated 
+		// output is stored for further processing. 
+		todir			 		: .shawdowdir
+		
+		// STR outputmode can be configured as follows : jar | ctree.
+		// Based on this value, ctree or jar file generated for the packages
+		stroutputmode : ctree 	
+		//stroutputmode : jar
+	
+	// Other project references are specified in this configuration section.
+	//projectreferences:
+	//	C:/work/projects/spoofax/spx-imp/source-codes/workspaces/spx-examples/SpoofaxEntityLanguage
+	//../DatabaseSPXLang
 ]
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Sun Aug 14 12:49:32 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 14 Aug 2011 10:49:32 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23221 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration:
	META-INF syntax test trans
Message-ID: <20110814104932.29A6B2B8014@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 14 10:49:31 2011
New Revision: 23221
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23221&sc=1

Log:
- added support for project referencing. A project name from current workspace can be referred as a language extension.

- added syntax checking to verify and show error incase of illegal project reference. i.e. - project does not exists in current workspace. Or project exists , but configuration file is not specifed.

- New primitive added to lookup the current workspace's project names and locations. Currently it is added in   org.spoofax.interpreter.library.language . will discuss about the correct location of this primitive later. 

- example configuration file is updated with the latest changes

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/META-INF/MANIFEST.MF
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/spoofaxconfiguration.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/META-INF/MANIFEST.MF
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/META-INF/MANIFEST.MF	Sat Aug 13 15:53:57 2011	(r23220)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/META-INF/MANIFEST.MF	Sun Aug 14 10:49:31 2011	(r23221)
@@ -14,6 +14,7 @@
   org.eclipse.ui.editors,
   org.eclipse.ui.workbench.texteditor,
   org.strategoxt.imp.runtime,
+  org.spoofax.interpreter.library.language,
   org.spoofax.jsglr,
   org.strategoxt.strj
 Bundle-RequiredExecutionEnvironment: J2SE-1.5

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf	Sat Aug 13 15:53:57 2011	(r23220)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/syntax/SpoofaxConfiguration.sdf	Sun Aug 14 10:49:31 2011	(r23221)
@@ -16,7 +16,7 @@
 			"src" ":"  IncludeDefinition+    				-> ConfigSection{cons("Includes")}
 	    RelativePath IncludeOption 							-> IncludeDefinition {cons("Source")}
 	    
-	    "projectreferences" ":" AbsolutePath* 	-> ConfigSection {cons("SpxProjects")}
+	    "projectreferences" ":" ProjectName* 	-> ConfigSection {cons("SpxProjects")}
 	    	
 	    
 	    "codegen:" CodeGenDefinition*    			 	-> ConfigSection{cons("CodeGeneration")}
@@ -29,6 +29,7 @@
 	    "|" "."												  				->   IncludeOption{cons("ThisOnly")}
 
 	lexical syntax 
+		[a-zA-Z][a-zA-Z0-9\_\-\.]* 					-> ProjectName
 		%%STRING -> RelativePath
 		PathChar                                   	-> RelativePath
 		PathChar (PathChar | Slash)* PathChar       -> RelativePath
@@ -53,14 +54,15 @@
 	    
 	    
 	lexical restrictions
-	  Slash        -/- [\/]
-		RelativePath -/- [A-Za-z0-9\_\-\/\.\+]
-			
+	  	Slash        -/-  [\/]
+	  	RelativePath -/-  [A-Za-z0-9\_\-\/\.\+]
+		ProjectName  -/- [A-Za-z0-9\_\-\.]
+		
 		"SpxProjects" 
 		"Sources" 
 		"SpxSources"
 		"Configuration" 
-    "CodeGeneration" 
+    	"CodeGeneration" 
 		"Includes"
 		"AllDirectories"
 		"RootDirectory" -/- [A-Za-z0-9\_]
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config	Sat Aug 13 15:53:57 2011	(r23220)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/test/example.config	Sun Aug 14 10:49:31 2011	(r23221)
@@ -27,11 +27,14 @@
 		
 		// STR outputmode can be configured as follows : jar | ctree.
 		// Based on this value, ctree or jar file generated for the packages
-		stroutputmode : jar
+		stroutputmode : jar 
 		//stroutputmode : ctree
 	
 	// Other project references are specified in this configuration section.
 	projectreferences:
 			//../DatabaseLang 
-			//../DatabaseSPXLang 
-			../org.strategoxt.imp.editors.spoofax
\ No newline at end of file
+			langTestD
+			    
+			  
+
+			
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str	Sat Aug 13 15:53:57 2011	(r23220)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/check.str	Sun Aug 14 10:49:31 2011	(r23221)
@@ -40,51 +40,32 @@
   
   verify-project-references : [current | rest*] -> result 
   where 
-  	not(?[])
-  where 
   	result := <conc;flatten-list>(<verify-project-reference>current , <verify-project-references>rest*)  
 
 	verify-project-reference : current -> result
 	where 
-  	if (<is-dir-exist> current) then
-  		if(<is-spx-config-exist>current) then
-  			result := []
-  		else
-  			result := [(current, $[Illegal project reference. spx.config file is not found in the following directory : [current]])]
-  		end		
+	?_{<id>};
+	if not ( <eq>("" , <id>)) then
+  	(	is-spx-config-exist
+  		;result := []
+	<+
+  		result := [(current, $[Illegal project reference. spx.config file is not found in the following project : [current]])]
+  	)
   	else
-  		result := [(current, $[Illegal project reference. Following directory is not found [current]])]
-		end 
+  		result := [(current, $[Illegal project reference. Following project [current] is not found in the current workspace])]
+	end 
 	
 	
 	is-dir-exist =  where(file-exists ; filemode ; isdir) 
 
 	
 	is-spx-config-exist  =
-		?current-project-ref;
-		where(explode-string; <not(eq)>(<Hd> , 46)) ; // not started wtih  ..
-		where(<file-exists>$[[<id>]/spx.config]) ; 
-		with(
+		where(
+			<file-exists>$[[<id>]/spx.config]
+		);
+		where(
 			spx-config-location := $[[<id>]/spx.config];
-			rules (get-config-reference : current-project-ref ->spx-config-location)   
+			rules (get-config-reference :+ current-project-ref ->spx-config-location)   
 		) 
 			
-	
-	is-spx-config-exist =
-		?current-project-ref;
-		where(
-			explode-string; <eq>(<Hd> , 46);
-			current-dir := <getcwd>
-		) ;
-		where(chdir);
-		where(
-			<file-exists>$[[<id>]/spx.config]
-			;spx-config-location := $[[<getcwd>]/spx.config]
-			;<debug> $[storing reference : "[current-project-ref]" -> "[spx-config-location]"]
-			;rules (get-config-reference : current-project-ref ->spx-config-location)
-		  ;<chdir>current-dir
-		<+
-			<chdir>current-dir;
-			fail
-		)
 		 		 		
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str	Sat Aug 13 15:53:57 2011	(r23220)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/resolve.str	Sun Aug 14 10:49:31 2011	(r23221)
@@ -92,7 +92,8 @@
  
 	get-all-project-refernces = 
   	collect-all(?SpxProjects(<id>), conc) ; 
-  	flatten-list
+  	flatten-list;
+  	filter(?_{<id>};not(<eq>("" , <id>)))
   <+ 
   	debug(!"Failed to retrieve list of projects.");
   	fail 
@@ -111,4 +112,26 @@
 	throw-directory-not-found-exception(post-processing-strategy) = debug(!"Configuration | Failed to find the directory specified: ") ;post-processing-strategy
 	
 	throw-config-not-found-exception(post-processing-strategy) = debug(!"Configuration | Failed to find spx.config file in the directory specified: ") ;post-processing-strategy
-	   	 	
\ No newline at end of file
+
+
+
+rules
+	
+	normalize: ast -> <alltd(normalized-spxproject-reference)>ast 
+		
+	normalized-spxproject-reference: 
+		SpxProjects(projectrefs*) -> SpxProjects(result) 
+		with
+			result := <map(annotate-project-location)>projectrefs*
+			
+			
+	annotate-project-location : 
+		projectname -> annotatedProjectName
+		where 
+			prim("LANG_get_all_projects_in_Workspace");
+			filter( ?(projectname, _));
+			if not(?[(_, projectlocation)]) then 
+				projectlocation := ""
+			end;
+			annotatedProjectName := projectname{projectlocation}
+				
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/spoofaxconfiguration.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/spoofaxconfiguration.str	Sat Aug 13 15:53:57 2011	(r23220)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax.configuration/trans/spoofaxconfiguration.str	Sun Aug 14 10:49:31 2011	(r23221)
@@ -17,7 +17,7 @@
     (ast, path, project-path) -> (ast, errors, warnings, notes)
     with
       editor-init;
-      errors   := <collect-all(constraint-error, conc)> ast;
+      errors   := <collect-all(constraint-error, conc)> <normalize>ast;
       warnings := [];
       notes    := []
   
@@ -25,8 +25,8 @@
   get-full-paths:
     (selected, position, ast, path, project-path) -> (filename, result)
  		where 
- 			filename := <guarantee-extension(|"config.fullpath")> path;
- 			result := <get-all-includes>selected
+ 			filename := <guarantee-extension(|"config.fullpath")> path; 
+ 			result := <get-all-includes><normalize>selected
  			
        
  // Prints the abstract syntax ATerm of a selection.
@@ -34,8 +34,8 @@
     (selected, position, ast, path, project-path) -> (filename, result)
     with
       filename := <guarantee-extension(|"aterm")> path;
-      result   := selected	// we just return the input term
-  		 
+      result   := <normalize>selected	// we just return the input term;
+        
   // Resolves a reference when the user control-clicks or presses F3 in the editor.
   // Only succeeds for nodes of the form Type(_) for which GetEntity is defined.
   editor-resolve:

From M.A.Akhter at student.tudelft.nl  Sun Aug 14 12:50:27 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 14 Aug 2011 10:50:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23222 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: .
	lib/Configuration trans
Message-ID: <20110814105027.6A1EE2B8014@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 14 10:50:27 2011
New Revision: 23222
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23222&sc=1

Log:
- spoofaxlang project is updated w.r.t new config lang

Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.def
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.pp.af
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.tbl
Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str	Sun Aug 14 10:49:31 2011	(r23221)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.str	Sun Aug 14 10:50:27 2011	(r23222)
@@ -10,11 +10,11 @@
     OutputDirectory : RelativePath -> CodeGenDefinition
     Source          : RelativePath * IncludeOption -> IncludeDefinition
     CodeGeneration  : List(CodeGenDefinition) -> ConfigSection
-    SpxProjects     : List(AbsolutePath) -> ConfigSection
+    SpxProjects     : List(ProjectName) -> ConfigSection
     Includes        : List(IncludeDefinition) -> ConfigSection
     Configuration   : List(ConfigSection) -> Start
-                    : String -> AbsolutePath
                     : String -> RelativePath
+                    : String -> ProjectName
 
 
 signature

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Sun Aug 14 10:49:31 2011	(r23221)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Sun Aug 14 10:50:27 2011	(r23222)
@@ -1,7 +1,36 @@
-Configuration
-	Includes
-		AllDirectories test
-			
-	CodeGeneration 
-		OutputDirectory		.shadowdir  
+configuration
+	
+	// For current project, following configuration section specifies the directories 
+	// that will be included during building this project. 
+	// It can be specified as follows : 
+	//			directoryname | include-mode
+	// Here- 
+	//			
+	//			directoryname : Refers to the name of the local directory. 
+	//											It must be a relative path from the project-root.
+	//
+	//			include-mode  : It can have one of the following two values - 
+	//                           .  : includes only current directory. Subdirectories of the current directory are not included.
+	//                           ** : includes current directory and its subdirectories as well.
+	//
+	// If configuration file is missing or does not specify source, then default configuration is used during project build.
+	// By default, it includes all the directories ( and their subdirectories) of the project during build. Hence, It is  
+	// always recommended to explicitly specify the sources to include. 							  
+	src:
+		test|**
+		
+				
+	codegen:
+		// todir refers to the project directory where intermediate generated 
+		// output is stored for further processing. 
+		todir			 		: .shawdowdir
+		
+		// STR outputmode can be configured as follows : jar | ctree.
+		// Based on this value, ctree or jar file generated for the packages
+		stroutputmode : ctree 	
+		//stroutputmode : jar
+	
+	// Other project references are specified in this configuration section.
+	projectreferences:
+		org.strategoxt.imp.editors.stratego  
 	
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str	Sun Aug 14 10:49:31 2011	(r23221)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/config.str	Sun Aug 14 10:50:27 2011	(r23222)
@@ -48,6 +48,7 @@
 	 	<+
 	 		<debug>$[Failed to Load Configuration.Loading Default Configuration. Please check spx.config]; fallback-configuration>"spx.config" => config-aterms
 	 	)
+	 	;normalize-config
 		;init-output-directory
 		;init-source-directory
 		;init-str-output-strategy     		
@@ -282,8 +283,7 @@
 	 	
 		get-external-sources: []  -> []
 	 
-
-	// Resolves External Project Refernces and returns the directories configured in that configuration file
+ 	// Resolves External Project Refernces and returns the directories configured in that configuration file
 	// Transitive imports/inclusion is not allowed. If a->b , b->c != a->c
 	resolve-external-sources =
 		 // not started wtih  ..
@@ -295,7 +295,7 @@
   	fail-if-no-config-found;   
   	<parse-spoofaxconfiguration-file>$[[current-project-path]/spx.config];
   	get-all-sources(|current-project-path)
-	
+  	
 	  	
 	resolve-external-sources =
 		?current-project-path;
@@ -315,14 +315,17 @@
 	  	<+
 	  		<chdir>current-dir  
 		)
- 
+
 	
+ 
 	get-all-project-refernces = 
   	collect-all(?SpxProjects(<id>), conc) ; 
-  	flatten-list
+  	flatten-list;
+  	filter(?_{<id>};not(<eq>("" , <id>)))
   <+ 
-  	debug(!"Failed to retrieve list of projects.") ; fail 
-		
+  	debug(!"Failed to retrieve list of projects.");
+  	fail 
+  			
 rules 
 
 	// Utility strategies  
@@ -351,3 +354,22 @@
 	
 	throw-config-not-found-exception(post-processing-strategy) = debug(!"Configuration | Failed to find spx.config file in the directory specified: ") ;post-processing-strategy
 	   	 		 		
+rules 
+	normalize-config: ast -> <alltd(normalized-spxproject-reference)>ast 
+		
+	normalized-spxproject-reference: 
+		SpxProjects(projectrefs*) -> SpxProjects(result) 
+		with
+			result := <map(annotate-project-location)>projectrefs*
+			
+			
+	annotate-project-location : 
+		projectname -> annotatedProjectName
+		where 
+			prim("LANG_get_all_projects_in_Workspace");
+			filter( ?(projectname, _));
+			if not(?[(_, projectlocation)]) then 
+				projectlocation := ""
+			end;
+			annotatedProjectName := projectname{projectlocation}
+				
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Sun Aug 14 12:53:10 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 14 Aug 2011 10:53:10 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23223 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language:
	META-INF src/org/spoofax/interpreter/library/language
Message-ID: <20110814105310.629972B800B@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 14 10:53:10 2011
New Revision: 23223
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23223&sc=1

Log:
- a new primitive is added to return the name and location of all the projects in current workspace. 

- is used by new config lang to resolve project reference in spxlang projects.

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LANG_get_all_projects_in_Workspace.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF	Sun Aug 14 10:50:27 2011	(r23222)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF	Sun Aug 14 10:53:10 2011	(r23223)
@@ -6,5 +6,7 @@
 Bundle-RequiredExecutionEnvironment: J2SE-1.5
 Require-Bundle: org.spoofax.interpreter.core,
  org.spoofax.terms;bundle-version="1.0.0",
- org.spoofax.jsglr;bundle-version="0.3.0"
+ org.spoofax.jsglr;bundle-version="0.3.0",
+ org.eclipse.core.runtime,
+ org.eclipse.core.resources
 Export-Package: org.spoofax.interpreter.library.language

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LANG_get_all_projects_in_Workspace.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LANG_get_all_projects_in_Workspace.java	Sun Aug 14 10:53:10 2011	(r23223)
@@ -0,0 +1,57 @@
+package org.spoofax.interpreter.library.language;
+
+import java.io.File;
+import java.net.URI;
+import java.util.Set;
+
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.IPath;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.IStrategoTuple;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * @author Lennart Kats <lennart add lclnet.nl>
+ */
+public class LANG_get_all_projects_in_Workspace extends AbstractPrimitive {
+
+	private static String NAME = "LANG_get_all_projects_in_Workspace";
+	
+	public LANG_get_all_projects_in_Workspace() {
+		super(NAME, 0, 0);
+	}
+
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
+		
+		IProject[] projects = ResourcesPlugin.getWorkspace().getRoot().getProjects();
+		ITermFactory factory = env.getFactory();
+		IStrategoList results = factory.makeList();
+		
+		for (IProject project: projects) {
+			IStrategoString projectName =factory.makeString( project.getName());
+			IStrategoString projectPath =factory.makeString( project.getLocation().toString());
+			
+			// Creating tuple for each project entry. Tuple contains project name and project path.
+			IStrategoTuple result = factory.makeTuple(
+					projectName ,
+					projectPath
+			);		
+			// Adding it to the head of the list 
+			results = factory.makeListCons(result, results);
+		}
+		env.setCurrent(results);
+		return true;
+	}
+
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Sun Aug 14 10:50:27 2011	(r23222)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Sun Aug 14 10:53:10 2011	(r23223)
@@ -21,6 +21,7 @@
 		add(new LANG_index_get(index));
 		add(new LANG_index_is_indexed_file(index));
 		add(new LANG_index_setup(index));
+		add(new LANG_get_all_projects_in_Workspace());
 	}
 
 	public String getOperatorRegistryName() {

From M.A.Akhter at student.tudelft.nl  Sun Aug 14 13:19:09 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 14 Aug 2011 11:19:09 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23224 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax
Message-ID: <20110814111909.66FD9108C006@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 14 11:19:09 2011
New Revision: 23224
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23224&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Sun Aug 14 10:53:10 2011	(r23223)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/spx.config	Sun Aug 14 11:19:09 2011	(r23224)
@@ -31,6 +31,6 @@
 		//stroutputmode : jar
 	
 	// Other project references are specified in this configuration section.
-	projectreferences:
-		org.strategoxt.imp.editors.stratego  
+	//projectreferences:
+	//	org.strategoxt.imp.editors.stratego  
 	
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Sun Aug 14 13:23:44 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 14 Aug 2011 11:23:44 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23225 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration
Message-ID: <20110814112344.01BC02B800B@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 14 11:23:43 2011
New Revision: 23225
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23225&sc=1

Log:


Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.packed.esv
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.pp.af
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.tbl   (contents, props changed)

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.generated.pp.af	Sun Aug 14 11:23:43 2011	(r23225)
@@ -0,0 +1 @@
+PP-Table([PP-Entry(Path1("Configuration"),V([],[H([],[FBOX(KW,S("\"configuration\""))]),Arg("1")])),PP-Entry(Path("Configuration",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("Includes"),V([],[H([],[FBOX(KW,S("\"src\"")),FBOX(KW,S("\":\""))]),Arg("1")])),PP-Entry(Path("Includes",[selector("1","iter")]),[Arg("1")]),PP-Entry(Path1("Source"),[Arg("1"),Arg("2")]),PP-Entry(Path1("SpxProjects"),V([],[H([],[FBOX(KW,S("\"projectreferences\"")),FBOX(KW,S("\":\""))]),Arg("1")])),PP-Entry(Path("SpxProjects",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("CodeGeneration"),V([],[H([],[FBOX(KW,S("\"codegen:\""))]),Arg("1")])),PP-Entry(Path("CodeGeneration",[selector("1","iter-star")]),[Arg("1")]),PP-Entry(Path1("OutputDirectory"),[FBOX(KW,S("\"todir\"")),FBOX(KW,S("\":\"")),Arg("1")]),PP-Entry(Path1("STROutputMode"),[FBOX(KW,S("\"stroutputmode\"")),FBOX(KW,S("\":\"")),Arg("1")]),PP-Entry(Path1("CTree"),[FBOX(KW,S("\"ctree\""))]),PP-Entry(Path1("Jar"),[FBOX(KW,S("\"jar\
 ""))]),PP-Entry(Path1("All"),[FBOX(KW,S("\"|\"")),FBOX(KW,S("\"**\""))]),PP-Entry(Path1("ThisOnly"),[FBOX(KW,S("\"|\"")),FBOX(KW,S("\".\""))])])
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.packed.esv
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.packed.esv	Sun Aug 14 11:23:43 2011	(r23225)
@@ -0,0 +1 @@
+Module("SpoofaxConfiguration.main.packed",Imports([Import("SpoofaxConfiguration.main"),Import("SpoofaxConfiguration-Builders"),Import("SpoofaxConfiguration-Colorer"),Import("SpoofaxConfiguration-Completions"),Import("SpoofaxConfiguration-Folding"),Import("SpoofaxConfiguration-Outliner"),Import("SpoofaxConfiguration-References"),Import("SpoofaxConfiguration-Syntax"),Import("SpoofaxConfiguration-Builders.generated"),Import("SpoofaxConfiguration-Completions.generated"),Import("SpoofaxConfiguration-Folding.generated"),Import("SpoofaxConfiguration-Outliner.generated"),Import("SpoofaxConfiguration-References.generated"),Import("SpoofaxConfiguration-Syntax.generated")]),[Language(" General properties",[LanguageName("SpoofaxConfiguration"),LanguageId("org.strategoxt.imp.editors.spoofax.configuration"),Extends(Values(["Root"])),Description(String("\"Spoofax/IMP-generated editor for the SpoofaxConfiguration language\"")),URL("http://strategoxt.org"),Extensions(Values(["config"])),Tabl
 e("include/SpoofaxConfiguration.tbl"),StartSymbols([Sort("Start")])]),Builders("",[SemanticProvider("include/spoofaxconfiguration.ctree"),SemanticObserver(Strategy("editor-analyze")),Builder(String("\"Show abstract syntax (for selection)\""),Strategy("generate-aterm"),[OpenEditor,RealTime,Meta,Source]),Builder(String("\"Show Resolved Path(for selection)\""),Strategy("get-full-paths"),[OpenEditor,RealTime,Meta,Source])]),Colorer(" Default, token-based highlighting",[ColorRule(Token(TK_KEYWORD),Attribute(ColorRGB("255","69","0"),NoColor,NORMAL)),ColorRule(Token(TK_IDENTIFIER),Attribute(ColorRGB("0","0","255"),NoColor,ITALIC)),ColorRule(Token(TK_STRING),AttributeRef("blue")),ColorRule(Token(TK_NUMBER),AttributeRef("darkgreen")),ColorRule(Token(TK_VAR),Attribute(ColorRGB("255","0","100"),NoColor,ITALIC)),ColorRule(Token(TK_OPERATOR),Attribute(ColorRGB("0","0","128"),NoColor,NORMAL)),ColorRule(Token(TK_LAYOUT),Attribute(ColorRGB("63","127","95"),NoColor,NORMAL))]),Colorer(" Syste
 m colors",[ColorDef("darkred",Attribute(ColorRGB("128","0","0"),NoCol B("255","105","180"),NoColor,NORMAL)),ColorDef("brown",Attribute(ColorRGB("139","69","19"),NoColor,NORMAL)),ColorDef("default",Attribute(ColorDefault,NoColor,NORMAL))]),Folding(" Default folding definitions",[FoldRule(SortAndConstructor(Sort("Start"),Constructor("Configuration")),None),FoldRule(SortAndConstructor(Sort("ConfigSection"),Constructor("Includes")),None),FoldRule(SortAndConstructor(Sort("ConfigSection"),Constructor("SpxProjects")),None),FoldRule(SortAndConstructor(Sort("ConfigSection"),Constructor("CodeGeneration")),None)]),References("",[ReferenceRule("_",Strategy("editor-resolve"))]),Language(" Syntax properties (static defaults)",[LineCommentPrefix(String("\"//\"")),BlockCommentDefs(BlockCommentDef(String("\"/*\""),"*",String("\"*/\""))),FenceDefs([FenceDef("[","]"),FenceDef("(",")"),FenceDef("{","}")]),IndentDefs([IndentDef(String("\"=\"")),IndentDef(String("\":\""))]),IdentifierLexical(String("\"[A-Za-z0-9_]+\""))])])
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.pp.af
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.pp.af	Sun Aug 14 11:23:43 2011	(r23225)
@@ -0,0 +1 @@
+PP-Table([])
\ No newline at end of file

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.tbl
==============================================================================
Binary file. No diff available.

From M.A.Akhter at student.tudelft.nl  Sun Aug 14 20:37:38 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 14 Aug 2011 18:37:38 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23226 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration
Message-ID: <20110814183738.51D9E108C006@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 14 18:37:38 2011
New Revision: 23226
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23226&sc=1

Log:


Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/lib/Configuration/SpoofaxConfiguration.packed.esv

From M.A.Akhter at student.tudelft.nl  Mon Aug 15 13:02:48 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 15 Aug 2011 11:02:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23227 -
	spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building
Message-ID: <20110815110248.42147CC05B@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 15 11:02:46 2011
New Revision: 23227
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23227&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java
   spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxGenerateArtefacts.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java	Sun Aug 14 18:37:38 2011	(r23226)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxDescriptorBuilder.java	Mon Aug 15 11:02:46 2011	(r23227)
@@ -19,13 +19,11 @@
 import org.strategoxt.imp.runtime.stratego.EditorIOAgent;
 
 /**
- * Triggers spoofaxlang building and loading from an Ant build file.
+ * Triggers loading ESV from an Ant build file.
+ * 
+ * @author Lennart Kats <lennart add lclnet.nl>
  */
-
-public class AntSpxDescriptorBuilder {
-	
-	//TODO :  Set Derived Resources 
-	//TODO :  Adding auto-generating the derived entries
+public class AntSpxDescriptorBuilder { 
 	
 	private static volatile boolean active;
 

Modified: spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxGenerateArtefacts.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxGenerateArtefacts.java	Sun Aug 14 18:37:38 2011	(r23226)
+++ spoofax-imp/trunk/org.strategoxt.imp.metatooling/src/org/strategoxt/imp/metatooling/building/AntSpxGenerateArtefacts.java	Mon Aug 15 11:02:46 2011	(r23227)
@@ -22,7 +22,13 @@
 import org.strategoxt.stratego_lib.dr_scope_all_end_0_0;
 import org.strategoxt.stratego_lib.dr_scope_all_start_0_0;
 
+/**
+ * Triggers spoofaxlang building and loading from an Ant build file.
+ */
 public class AntSpxGenerateArtefacts {
+	//TODO :  Set Derived Resources 
+	//TODO :  Adding auto-generating the derived entries
+
 	private static volatile boolean active;
 	
 	public static boolean isActive() {
@@ -108,8 +114,10 @@
 				dr_scope_all_start_0_0.instance.invoke(contextSpoofaxLang, input);
 				
 				try {
-					
+					System.out.println("Compiling SPX files and generating intermediate artefacts.");
+					System.out.println("Invoking build-spoofaxlang-jvm.");
 					build_spoofaxlang_jvm_0_0.instance.invoke( contextSpoofaxLang , input);
+					System.out.println("Intermediate artefacts have been generated successfully.");
 					
 				} catch (StrategoErrorExit e) {
 					Environment.logException(e);

From M.A.Akhter at student.tudelft.nl  Mon Aug 15 13:04:23 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 15 Aug 2011 11:04:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23228 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax
Message-ID: <20110815110423.C9BE22B8003@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 15 11:04:23 2011
New Revision: 23228
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23228&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml	Mon Aug 15 11:02:46 2011	(r23227)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/build.main.xml	Mon Aug 15 11:04:23 2011	(r23228)
@@ -47,9 +47,9 @@
         <target name="all" depends="meta-sdf2table-stratego-sdf2,meta-sdf2table-stratego-esv,meta-sdf2table-strategostratego,spoofaximp.default.jar"/>
 				-->
 				
-				<target name="spoofaximp.edited.jar" depends="meta-sdf2table-stratego-sdf2,meta-sdf2table-stratego-esv,meta-sdf2table-strategostratego,check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,spx.stratego.jar,sdf2imp,refresh"/>
+		<target name="spoofaximp.edited.jar" depends="meta-sdf2table-stratego-sdf2,meta-sdf2table-stratego-esv,meta-sdf2table-strategostratego,check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,java.jar,spx.stratego.jar,sdf2imp,refresh"/>
 	
-				<target name="all" depends = "spoofaximp.edited.jar"/>
+		<target name="all" depends = "spoofaximp.edited.jar"/>
 					
 	
         <!-- Target to create -Permissive grammar and parse table for Stratego-Sdf2.def -->
@@ -105,8 +105,7 @@
         	<mkdir dir= "${src-gen}/org/strategoxt/imp/editors/spoofax/trans" />
       		<property name="src-gen2" location="${src-gen}/org/strategoxt/imp/editors/spoofax/trans"/>
                 	
-      		<available file="${src-gen2}/Main.java" property="strc-java.available"/>
-        	<dependset>
+      		<dependset>
   	        <srcfileset dir="${basedir}">
 	            <include name="**/*.str"/>
               <include name="**/*.astr"/>
@@ -114,11 +113,8 @@
             </srcfileset>
             <targetfileset file="${src-gen2}/${strmodule}.java"/>
 	        </dependset>
-          
-        		
           <antcall target="copy-jar"/>
-          <antcall target="spx.stratego.jar.deletehelper"/>
-          <antcall target="spx.stratego.jvm.helper">
+        	<antcall target="spx.stratego.jvm.helper">
 	          <param name="build.stratego.outputfile" value="${src-gen2}/${strmodule}.java"/>
             <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
           </antcall>
@@ -140,14 +136,16 @@
       		<jar basedir="${build}" includes="org/strategoxt/imp/editors/spoofax/trans/**" destfile="${include}/${strmodule}.tmp.jar"/>
         	
       	  <move file="${include}/${strmodule}.tmp.jar" tofile="${include}/${strmodule}.jar"/>
-          <delete><fileset dir="${build}" includes="trans/**"/></delete>
+          <delete>
+          	<fileset dir="${build}" includes="org/strategoxt/imp/editors/spoofax/trans/**"/>
+          </delete>
         </target>
 	 			
 				
 				<target name="spx.stratego.jar.deletehelper">
   	      <delete>
-	          <fileset dir="${src-gen2}" includes="**"/>
-            <fileset dir="${build}" includes="trans/**"/>
+	          <fileset dir="${src-gen}" includes="org/strategoxt/imp/editors/spoofax/trans/**"/>
+            <fileset dir="${build}" includes="org/strategoxt/imp/editors/spoofax/trans/**"/>
 	        </delete>
         </target>
 	
@@ -155,6 +153,8 @@
   	      <echo> Main Class  : ${build.stratego.outputfile}</echo>
 					<echo> PackageName : ${str.package-name}</echo>
 					
+					<antcall target="spx.stratego.jar.deletehelper"/>
+					
 					<delete file="${include}/${strmodule}.rtree" failonerror="false"/>
           <java classname="org.strategoxt.strj.Main" failonerror="true">
             <arg value="-i"/>
@@ -172,6 +172,6 @@
             <arg line="-I &quot;${lib}&quot; -I &quot;${include}&quot; --cache-dir &quot;${basedir}/.cache&quot;"/>
           </java>
           <delete file="${include}/${strmodule}.rtree" failonerror="false"/>
-          <mkdir dir="${build}/trans"/>
+          <mkdir dir="${build}/org/strategoxt/imp/editors/spoofax/trans"/>
         </target>
 </project>

From M.A.Akhter at student.tudelft.nl  Mon Aug 15 13:07:42 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 15 Aug 2011 11:07:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23229 - in
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax: .
	trans/codegen
Message-ID: <20110815110742.2F7D67F8060@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 15 11:07:41 2011
New Revision: 23229
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23229&sc=1

Log:
* more changes in spxlang  generated build script

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/.classpath
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/.classpath
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/.classpath	Mon Aug 15 11:04:23 2011	(r23228)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/.classpath	Mon Aug 15 11:07:41 2011	(r23229)
@@ -1,8 +1,9 @@
 <?xml version="1.0" encoding="UTF-8" ?>
 
 <classpath>
-	<classpathentry kind="src" excluding="trans/**" path="editor/java"/>
+	<classpathentry kind="src" path="editor/java"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
 	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
 	<classpathentry kind="output" path="bin"/>
+	<classpathentry exported="true" kind="lib" path="include/spoofaxlang.jar" sourcepath="editor/java"/>
 </classpath>
\ No newline at end of file

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Mon Aug 15 11:04:23 2011	(r23228)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/codegen/buildscripts.str	Mon Aug 15 11:07:41 2011	(r23229)
@@ -39,47 +39,51 @@
 		
 <project name="[main-ant-output-file-name]" default="build-spx-packages">
     <!-- autogenerated artifacts relative directory path -->	
-		<property name="packages.root" location="[packages-root]"/>
-		
-		<import file="[autogen-ant-output-file-name].xml"/>
-	  [<map(emit-package-specific-ant)>pakage-qname*]
-		
-		<!-- Main target -->
-  	<target name="build-spx-packages" depends="[build-package-dependencies]"/>
+    <property name="packages.root" location="[packages-root]"/>
+    
+    <import file="[autogen-ant-output-file-name].xml"/>
+    [<map(emit-package-specific-ant)>pakage-qname*]
+    
+    <!-- Main target -->
+    <target name="build-spx-packages">
+      [build-package-dependencies]
+    
+    </target>
+  	
 </project>] 
 	with 
 		packages-root                :=	<Autogenerated-Artifacts-Dir>;
-		build-package-dependencies   :=	<map(get-package-target-name);separate-by(|",");concat-strings>pakage-qname*
+		build-package-dependencies   :=	<map(get-package-target-name);concat-strings>pakage-qname*
 	
 	
 	emit-package-specific-ant : p at Package(package-untyped-qname at QName(qname-parts*)) -> $[ 
-	<target name="[package-target-name]">
-		<property name="package.path" location="[package-directory]"/>
-		<property name="lang.id.specific.directoy" 		location="${src-gen}/[language-id-directory]"/>
-		<property name="lang.id.specific.subdirectoy" value ="[language-id-directory]"/>
-		<property name="package.name"             		value = "[language-name]"/>
-		<property name="package.qname"            		value = "[package-qname-string]"/>
-		<property name="package.main.sdf.module"  		value = "[language-name]"/>
-		<property name="package.main.str.module"  		value = "[language-name]"/>
-		<property name="package.main.esv.module"  		value = "[language-name].main"/>
-		<property name="metasdfmodule"            		value = "Stratego-[language-name]"/>
-		<property name="lang.sdf.specific.params" 		value = "[language-sdf-specific-params]"/>
-		<property name="lang.str.specific.params" 		value = "[language-str-specific-params]"/>
-		
-		<antcall target = "spx.default">
-		  <param name = "package.name"  								value = "${package.name}"/>
-		  <param name = "package.qname"  								value = "${package.qname}"/>
-		  <param name = "package.path"  								value = "${package.path}"/>
-		  <param name = "lang.id.specific.directoy"  		value = "${lang.id.specific.directoy}"/>
-		  <param name = "lang.id.specific.subdirectoy"  value = "${lang.id.specific.subdirectoy}"/>
-		 	<param name = "package.main.sdf.module" 			value = "${package.main.sdf.module}"/>
-			<param name = "package.main.str.module" 			value = "${package.main.str.module}"/>
-	 		<param name = "package.main.esv.module" 			value = "${package.main.esv.module}"/>
-			<param name = "metasdfmodule" 								value = "${metasdfmodule}"/>
-			<param name="lang.sdf.specific.params" 				value="${lang.sdf.specific.params}"/>
-			<param name="lang.str.specific.params" 				value="${lang.str.specific.params}"/>
-		</antcall>
-	</target>	
+  <target name="[package-target-name]">
+    <property name="package.path" location="[package-directory]"/>
+    <property name="lang.id.specific.directoy"    location="${src-gen}/[language-id-directory]"/>
+    <property name="lang.id.specific.subdirectoy" value ="[language-id-directory]"/>
+    <property name="package.name"                 value = "[language-name]"/>
+    <property name="package.qname"                value = "[package-qname-string]"/>
+    <property name="package.main.sdf.module"      value = "[language-name]"/>
+    <property name="package.main.str.module"      value = "[language-name]"/>
+    <property name="package.main.esv.module"      value = "[language-name].main"/>
+    <property name="metasdfmodule"                value = "Stratego-[language-name]"/>
+    <property name="lang.sdf.specific.params"     value = "[language-sdf-specific-params]"/>
+    <property name="lang.str.specific.params"     value = "[language-str-specific-params]"/>
+    
+    <antcall target = "spx.default">
+      <param name = "package.name"                  value = "${package.name}"/>
+      <param name = "package.qname"                 value = "${package.qname}"/>
+      <param name = "package.path"                  value = "${package.path}"/>
+      <param name = "lang.id.specific.directoy"     value = "${lang.id.specific.directoy}"/>
+      <param name = "lang.id.specific.subdirectoy"  value = "${lang.id.specific.subdirectoy}"/>
+      <param name = "package.main.sdf.module"       value = "${package.main.sdf.module}"/>
+      <param name = "package.main.str.module"       value = "${package.main.str.module}"/>
+      <param name = "package.main.esv.module"       value = "${package.main.esv.module}"/>
+      <param name = "metasdfmodule"                 value = "${metasdfmodule}"/>
+      <param name="lang.sdf.specific.params"        value="${lang.sdf.specific.params}"/>
+      <param name="lang.str.specific.params"        value="${lang.str.specific.params}"/>
+    </antcall>
+  </target>	
 	]
 	with 
 		relative-autogen-path         :=  <qname-to-path>package-untyped-qname
@@ -95,9 +99,12 @@
 rules
 	
 	get-package-target-name : 
-		Package(q at QName(qname-parts*)) -> $[build.package.[package-qname-str]]
-		where
-			package-qname-str					:= 	<convert-qname(|".")>q
+		Package(q at QName(qname-parts*)) -> 
+$[  
+  <echo> Invoking following ANT target : "build.package.[package-qname-str]" </echo>
+  <antcall target="build.package.[package-qname-str]" />]
+    where
+      package-qname-str					:= 	<convert-qname(|".")>q
 	
 	get-package-target-name : 
 		package-qname at QName(qname-parts*) -> $[build.package.[package-qname-str]]
@@ -117,84 +124,86 @@
 	get-ant-autogeneratedscript : 
 		() -> $[<?xml version="1.0" encoding="UTF-8" ?>
 <project name="build.spx.generated">
-	<target name="spx.default" depends="[default-spx-target]"/>
-  <target name="spx.default.ctree" depends="check-classpath,init,sdf2table,meta-sdf2table, ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp, refresh"/>
-	<target name="spx.default.jar"   depends="check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,java.jar,sdf2imp,refresh"/>
-	          
-  <!-- Initialization -->
-  <available file="${build}/${lang.id.specific.subdirectoy}/strategies/Main.class" property="java.jar.enabled"/>
-  <condition property="java.jar.import" value="-la org.strategoxt.imp.editors.spoofax.strategies" else="">
-      <isset property="java.jar.enabled"/>
-  </condition>
-  <condition property="java.jar.classpath" value=":${include}/${package.main.str.module}-java.jar" else="">
-      <isset property="java.jar.enabled"/>
-  </condition>
-  <available file="${packages.root}/${package.main.str.module}.rtree" property="build.stratego.enabled"/>
-  <dirname property="externaldefdir" file="${externaldef}"/>
-  <condition property="externaldefimport" value="-I ${externaldefdir}" else="">
-      <isset property="externaldef"/>
-  </condition>
-  <condition property="externaljarimport" value=":${externaljar}" else="">
-      <isset property="externaljar"/>
-  </condition>
-  <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
-      <isset property="eclipse.running"/>
-  </condition>
-  <condition property="externaljarflags" value="${externaljarflags}" else="">
-      <isset property="externaljarflags"/>
-  </condition>
-  <condition property="metasdfmodule.available" value="1">
-      <available file="${packages.root}/${metasdfmodule}.sdf"/>
-  </condition>
-    
-	<fail unless="build" message="Please use build.spx.main.xml to build this project or configure the required properties manually"/>
+  <target name="spx.default" depends="[default-spx-target]"/>
+  <target name="spx.default.ctree" depends="setup-params,check-classpath,init,sdf2table,meta-sdf2table, ppgen,pppack,stratego.aster,stratego.ctree,java.jar,sdf2imp, refresh"/>
+  <target name="spx.default.jar"   depends="setup-params,check-classpath,init,sdf2table,meta-sdf2table,ppgen,pppack,stratego.aster,stratego.jar,java.jar,sdf2imp,refresh"/>
+	
+  <!-- Initialization -->
+  <fail unless="build" message="Please use build.spx.main.xml to build this project or configure the required properties manually"/>
   <mkdir dir="${build}"/>
-  <mkdir dir="${src-gen}"/>
+  <mkdir dir="${src-gen}"/>
   <mkdir dir="${dist}"/>
   <mkdir dir="${include}"/>
-  
-  
+
+  <target name="setup-params">
+    <available file="${build}/${lang.id.specific.subdirectoy}/strategies/Main.class" property="java.jar.enabled"/>
+    <available file="${packages.root}/${package.main.str.module}.rtree" property="build.stratego.enabled"/>
+    <dirname property="externaldefdir" file="${externaldef}"/>
+    
+     <condition property="java.jar.import" value="-la ${package.qname}.strategies" else="">
+        <isset property="java.jar.enabled"/>
+      </condition>
+      <condition property="java.jar.classpath" value=":${include}/${package.main.str.module}-java.jar" else="">
+        <isset property="java.jar.enabled"/>
+      </condition>
+      <condition property="externaldefimport" value="-I ${externaldefdir}" else="">
+        <isset property="externaldef"/>
+      </condition>
+      <condition property="externaljarimport" value=":${externaljar}" else="">
+        <isset property="externaljar"/>
+      </condition>
+      <condition property="build.compiler" value="org.eclipse.jdt.core.JDTCompilerAdapter">
+        <isset property="eclipse.running"/>
+      </condition>
+      <condition property="externaljarflags" value="${externaljarflags}" else="">
+        <isset property="externaljarflags"/>
+      </condition>
+      <condition property="metasdfmodule.available" value="1">
+        <available file="${packages.root}/${metasdfmodule}.sdf"/>
+      </condition>
+  </target>
+
   <target name="init" if="eclipse.running">
-	  <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
-	  <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
-	      <arg value="${include}"/>
-	  </java>
-	</target>
-	      
-		<target name="check-classpath">
-        <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
-        <antcall target="check-classpath.helper"/>  
-		</target>
-  	
-		<target name="java.jar" if="java.jar.enabled">
-    		<jar basedir="${build}" excludes="{packages.root}/**" update="true" destfile="${include}/${package.name}-java.jar"/>
- 		</target>
+    <!-- refresh one file/dir in the project to trigger an Ant rebuild with the next build command -->
+    <java classname="org.strategoxt.imp.metatooling.building.AntForceRefreshScheduler" failonerror="false">
+        <arg value="${include}"/>
+    </java>
+  </target>
+        
+  <target name="check-classpath">
+    <available classname="org.strategoxt.imp.generator.sdf2imp" property="check-classpath.available"/>
+    <antcall target="check-classpath.helper"/>  
+  </target>
+      
+  <target name="java.jar" if="java.jar.enabled">
+    <jar basedir="${build}" excludes="{packages.root}/**" update="true" destfile="${include}/${package.name}-java.jar"/>
+  </target>
 		
-		<target name="check-classpath.helper" unless="check-classpath.available">
-	        <echo level="error" message="Could not load the Spoofax plugin loading classes."/>
-	        <echo level="error" message="Make sure it is on the class path."/>
-	        <echo level="error" message=""/>               
-	        <echo level="error" message="In Eclipse, make sure the Ant builder is configured properly:"/>
-	        <echo level="error" message="right-click on build.main.xml, go to Run as, Ant build..., JRE tab,"/>
-	        <echo level="error" message="and ensure Run in the same JRE as the workspace is selected"/>
-	        <echo level="error" message="alternatively, build the project using Build Project in the Project menu"/>
-	        <fail/>
-	    </target>
+  <target name="check-classpath.helper" unless="check-classpath.available">
+    <echo level="error" message="Could not load the Spoofax plugin loading classes."/>
+    <echo level="error" message="Make sure it is on the class path."/>
+    <echo level="error" message=""/>               
+    <echo level="error" message="In Eclipse, make sure the Ant builder is configured properly:"/>
+    <echo level="error" message="right-click on build.main.xml, go to Run as, Ant build..., JRE tab,"/>
+    <echo level="error" message="and ensure Run in the same JRE as the workspace is selected"/>
+    <echo level="error" message="alternatively, build the project using Build Project in the Project menu"/>
+    <fail/>
+  </target>
 	        
-		<!--lots of redundant steps. TODO : remove the redundant build steps-->
-		<target name="refresh" if="eclipse.running">
-    		<eclipse.convertPath fileSystemPath="${basedir}" 			  property="projectdir"/>
+    <!--lots of redundant steps. TODO : remove the redundant build steps-->
+    <target name="refresh" if="eclipse.running">
+        <eclipse.convertPath fileSystemPath="${basedir}" 			  property="projectdir"/>
         <eclipse.convertPath fileSystemPath="${packages.root}"  property="packagesroot.dir"/>
         <eclipse.convertPath fileSystemPath="${include}" 			  property="includedir"/>
-				<eclipse.convertPath fileSystemPath="${src-gen}" 			  property="eclipse.path.src-gen"/>
-				<eclipse.convertPath fileSystemPath="${build}" 				  property="eclipse.path.build"/>	
-				<eclipse.convertPath fileSystemPath="${basedir}/.build" property="builddir"/>
-				
-				<eclipse.refreshLocal resource="${package.path}" depth="infinite"/>
-				<eclipse.refreshLocal resource="${packages.root}" depth="infinite"/>
-				<eclipse.refreshLocal resource="${builddir}" depth="infinite"/>
-				<eclipse.refreshLocal resource="${packagesroot.dir}" depth="infinite"/>
-				<eclipse.refreshLocal resource="${includedir}" depth="infinite"/>
+        <eclipse.convertPath fileSystemPath="${src-gen}" 			  property="eclipse.path.src-gen"/>
+        <eclipse.convertPath fileSystemPath="${build}" 				  property="eclipse.path.build"/>	
+        <eclipse.convertPath fileSystemPath="${basedir}/.build" property="builddir"/>
+        
+        <eclipse.refreshLocal resource="${package.path}" depth="infinite"/>
+        <eclipse.refreshLocal resource="${packages.root}" depth="infinite"/>
+        <eclipse.refreshLocal resource="${builddir}" depth="infinite"/>
+        <eclipse.refreshLocal resource="${packagesroot.dir}" depth="infinite"/>
+        <eclipse.refreshLocal resource="${includedir}" depth="infinite"/>
         <eclipse.refreshLocal resource="${eclipse.path.src-gen}" depth="infinite"/>
         <eclipse.refreshLocal resource="${eclipse.path.build}" depth="infinite"/>
     </target>
@@ -240,19 +249,19 @@
         </java>
     </target>
 	
-	<target name="copy-sdf" if="externaldef">
-		  <copy file="${externaldef}" tofile="${include}/${package.name}.def" preservelastmodified="true"/>
-	  </target>
+  <target name="copy-sdf" if="externaldef">
+    <copy file="${externaldef}" tofile="${include}/${package.name}.def" preservelastmodified="true"/>
+  </target>
 
-	<!-- SDF-To-Table -->
-	<target name="meta-sdf2table" if="metasdfmodule.available">
-		<fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def"/>
-		<antcall target="sdf2table">
-			<param name="sdfmodule" value="${metasdfmodule}"/>
-			<param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}"/>
-		</antcall>
-		<antcall target="meta-sdf2table.helper"/>
-    </target>
+  <!-- SDF-To-Table -->
+  <target name="meta-sdf2table" if="metasdfmodule.available">
+    <fail unless="eclipse.spoofaximp.jars" message="Property eclipse.spoofaximp.jars must point to the directory containing StrategoMix.def"/>
+    <antcall target="sdf2table">
+      <param name="sdfmodule" value="${metasdfmodule}"/>
+      <param name="build.sdf.imports" value="-Idef &quot;${eclipse.spoofaximp.jars}/StrategoMix.def&quot; ${build.sdf.imports}"/>
+    </antcall>
+    <antcall target="meta-sdf2table.helper"/>
+  </target>
 	
 	<target name="meta-sdf2table.helper" if="eclipse.running">
 	   <eclipse.convertPath fileSystemPath="${include}" property="includeresource"/>
@@ -454,9 +463,9 @@
          
          <mkdir dir="${lang.id.specific.directoy}/generated"/>
          <available file="${lang.id.specific.directoy}/generated/${package.name}.java" property="strc-java.available"/>
-         <antcall target="copy-jar"/>
+         <antcall target="copy-jar"/>
          <antcall target="stratego.jar.deletehelper"/>
-         
+         
          <antcall target="stratego.jvm.helper">
             <param name="build.stratego.outputfile" value="${lang.id.specific.directoy}/generated/${package.name}.java"/>
             <param name="build.stratego.extraargs" value="-la java-front ${java.jar.import}"/>
@@ -477,7 +486,6 @@
         </copy>
         
         <jar basedir="${build}" includes="${lang.id.specific.subdirectoy}/generated/**" destfile="${include}/${package.name}.tmp.jar"/>
-     
         <move file="${include}/${package.name}.tmp.jar" tofile="${include}/${package.name}.jar"/>
         <delete>
             <fileset dir="${build}" includes="${lang.id.specific.subdirectoy}/generated/**"/>

From M.A.Akhter at student.tudelft.nl  Sat Aug 20 10:25:00 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sat, 20 Aug 2011 08:25:00 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23230 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language:
	META-INF src/jdbm src/jdbm/btree src/jdbm/helper
	src/jdbm/htree src/jdbm/recman src/org/spoofax/...
Message-ID: <20110820082500.6291A108C007@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Sat Aug 20 08:24:59 2011
New Revision: 23230
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23230&sc=1

Log:
- Added modified jdbm package (sources) for persisting symbol table and index .
- Added a new package for spx lang. 
- New prim added to index SPX modules

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/InverseHashView.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryHashMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryStoreMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryTreeMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordListener.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryHashMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryKeyExtractor.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryTreeMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/Serializer.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SerializerInput.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SerializerOutput.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BPage.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTree.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSecondarySortedMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSortedMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/LeadingValueCompressionProvider.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/package.html
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/AbstractPrimaryMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/ByteArrayComparator.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/ComparableComparator.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/DefaultSerializer.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/JdbmBase.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/LongHashMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/LongPacker.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/OpenByteArrayInputStream.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/OpenByteArrayOutputStream.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/PrimaryStoreMapImpl.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/RecordManagerImpl.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/SecondaryKeyHelper.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/Serialization.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/StoreReference.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/Tuple.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/TupleBrowser.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/package.html
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTree.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTreeMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTreeSecondaryMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashBucket.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashDirectory.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashNode.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/package.html
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/package.html
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BaseRecordManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BlockIo.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BlockView.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/CacheRecordManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/DataPage.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FileHeader.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreeLogicalRowIdPage.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreeLogicalRowIdPageManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreePhysicalRowIdPage.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreePhysicalRowIdPageManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/Location.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/LogicalRowIdManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/Magic.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageCursor.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageHeader.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PhysicalRowIdManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordFile.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordHeader.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/TransactionManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/TranslationPage.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/package.html
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF	Mon Aug 15 11:07:41 2011	(r23229)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/META-INF/MANIFEST.MF	Sat Aug 20 08:24:59 2011	(r23230)
@@ -9,4 +9,5 @@
  org.spoofax.jsglr;bundle-version="0.3.0",
  org.eclipse.core.runtime,
  org.eclipse.core.resources
-Export-Package: org.spoofax.interpreter.library.language
+Export-Package: org.spoofax.interpreter.library.language,
+ org.spoofax.interpreter.library.language.spxlang

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/InverseHashView.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/InverseHashView.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+/**
+ * Provides inverse view on persisted map.
+ * It uses hash index to find Key which belongs to Value. Value must correctly implement hashCode .
+ * Internally is backed by SecondaryTreeMap which uses value hashCode as Secondary key.  
+ * 
+ * @author Jan Kotek
+ *
+ * @param <K>
+ * @param <V>
+ */
+public interface InverseHashView<K, V>{
+
+	/**
+	 * Finds first primary key which corresponds to value. There may be more then one, others are ignored
+	 * @param val 
+	 * @return first primary key found or null if not found
+	 */
+	K findKeyForValue(V val);
+	
+	/**
+	 * Finds primary keys which corresponds to value. There may be more then one, others are ignored
+	 * @param val 
+	 * @return  primary keys found 
+	 */
+	Iterable<K> findKeysForValue(V val);
+
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryHashMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryHashMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+/**
+ * Primary HashMap which persist data in storage.  
+ * Behavior is very similar to  <code>java.util.HashMap/code>, this map also uses hash index to lookup keys
+ * But it adds some methods to create secondary views
+ * <p>
+ * Performance note: keys and values are stored as part of index nodes. 
+ * They are deserialized on each index lookup. 
+ * This may lead to performance degradation and OutOfMemoryExceptions.  
+ * If your values are big (>500 bytes) you may consider using <code>PrimaryStoreMap</code>
+ * or <code<StoreReference</code> to minimalize size of index.
+ *  
+ * @author Jan Kotek
+ *
+ * @param <K> key type
+ * @param <V> value type
+ */
+public interface PrimaryHashMap<K,V> extends PrimaryMap<K,V>{
+	
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,95 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+import java.util.Comparator;
+import java.util.Map;
+
+import jdbm.helper.JdbmBase;
+
+/**
+ * Primary Map which persist data in storage. 
+ * Behavior is very similar to  <code>java.util.HashMap/code>.
+ * PrimaryMaps have some additional methods to create secondary views. 
+ * <p>
+ *  
+ * @author Jan Kotek
+ *
+ * @param <K> key type
+ * @param <V> value type
+ */
+public interface PrimaryMap<K,V> extends JdbmBase<K,V>, Map<K,V>{
+
+	/**
+	 * Secondary hash view over this PrimaryMap. 
+	 * It is readonly, is auto updated as PrimaryMaps is modified. 
+	 * View is indexed and persisted, so lookup is always fast
+	 *  
+	 * @param <A> type of secondary key
+	 * @param objectName under this name view will be stored in storage
+	 * @param secondaryKeyExtractor extracts secondary key from primary map
+	 * @return secondary map 
+	 */
+	<A> SecondaryHashMap<A,K,V> secondaryHashMap(String objectName, 
+			SecondaryKeyExtractor<A,K,V> secondaryKeyExtractor);
+
+	<A> SecondaryHashMap<A,K,V> secondaryHashMapManyToOne(String objectName, 
+			SecondaryKeyExtractor<Iterable<A>,K,V> secondaryKeyExtractor);
+
+
+	<A> SecondaryTreeMap<A,K,V> secondaryTreeMap(String objectName, 
+			SecondaryKeyExtractor<A,K,V> secondaryKeyExtractor,Comparator<A> secondaryKeyComparator);
+
+	@SuppressWarnings("unchecked")
+	<A extends Comparable> SecondaryTreeMap<A,K,V> secondaryTreeMap(String objectName, 
+			SecondaryKeyExtractor<A,K,V> secondaryKeyExtractor);
+
+	<A> SecondaryTreeMap<A,K,V> secondaryTreeMapManyToOne(String objectName, 
+			SecondaryKeyExtractor<Iterable<A>,K,V> secondaryKeyExtractor,Comparator<A> secondaryKeyComparator);
+
+	@SuppressWarnings("unchecked")
+	<A extends Comparable> SecondaryTreeMap<A,K,V> secondaryTreeMapManyToOne(String objectName, 
+			SecondaryKeyExtractor<Iterable<A>,K,V> secondaryKeyExtractor);
+
+    <A> SecondaryHashMap<A,K,V> secondaryHashMap(String objectName,
+            SecondaryKeyExtractor<A,K,V> secondaryKeyExtractor, Serializer<A> secondaryKeySerializer);
+
+    <A> SecondaryHashMap<A,K,V> secondaryHashMapManyToOne(String objectName,
+            SecondaryKeyExtractor<Iterable<A>,K,V> secondaryKeyExtractor, Serializer<A> secondaryKeySerializer);
+
+
+    <A> SecondaryTreeMap<A,K,V> secondaryTreeMap(String objectName,
+            SecondaryKeyExtractor<A,K,V> secondaryKeyExtractor,Comparator<A> secondaryKeyComparator,
+            Serializer<A> secondaryKeySerializer);
+
+    @SuppressWarnings("unchecked")
+    <A extends Comparable> SecondaryTreeMap<A,K,V> secondaryTreeMap(String objectName,
+            SecondaryKeyExtractor<A,K,V> secondaryKeyExtractor,
+            Serializer<A> secondaryKeySerializer);
+
+    <A> SecondaryTreeMap<A,K,V> secondaryTreeMapManyToOne(String objectName,
+            SecondaryKeyExtractor<Iterable<A>,K,V> secondaryKeyExtractor,Comparator<A> secondaryKeyComparator,
+            Serializer<A> secondaryKeySerializer);
+
+    @SuppressWarnings("unchecked")
+    <A extends Comparable> SecondaryTreeMap<A,K,V> secondaryTreeMapManyToOne(String objectName,
+            SecondaryKeyExtractor<Iterable<A>,K,V> secondaryKeyExtractor,
+            Serializer<A> secondaryKeySerializer);
+
+
+	InverseHashView<K,V> inverseHashView(String name);
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryStoreMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryStoreMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,37 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+import java.util.Map;
+
+/**
+ * Primary map which stores references to storage entries.
+ * PrimaryHashMap or PrimaryTreeMap stores keys and values as part of index.    
+ * This map stores only <b>record id</b> and values are fetch lazily. 
+ *  
+ *  
+ * 
+ * @author Jan Kotek
+ *
+ * @param <K> key is record id in storage
+ * @param <V> value is lazily fetch record
+ */
+public interface PrimaryStoreMap<K extends Long,V> extends PrimaryMap<Long,V> {
+	
+	Long putValue(V v);
+	
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryTreeMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/PrimaryTreeMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,52 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+import java.util.SortedMap;
+
+/**
+ * Primary HashMap which persist data in storage.  
+ * Behavior is very similar to  <code>java.util.HashMap/code>, this map also uses b-tree index to lookup keys
+ * But it adds some methods to create secondary views
+ * <p>
+ * Performance note: keys and values are stored as part of index nodes. 
+ * They are deserialized on each index lookup. 
+ * This may lead to performance degradation and OutOfMemoryExceptions.  
+ * If your values are big (>500 bytes) you may consider using <code>PrimaryStoreMap</code>
+ * or <code<StoreReference</code> to minimalize size of index.
+ *  
+ * @author Jan Kotek
+ *
+ * @param <K> key type
+ * @param <V> value type
+ */
+
+public interface PrimaryTreeMap<K,V>  extends PrimaryMap<K,V>, SortedMap<K,V>{
+	
+	/**
+	 * In case primary key is Long, new unique Key is generated, otherwise exception is thrown 
+	 * @param <K>
+	 */
+	Long newLongKey();
+	
+	/**
+	 * In case primary key is Integer, new unique Key is generated, otherwise exception is thrown 
+	 * @param <K>
+	 */
+	Integer newIntegerKey();
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordListener.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordListener.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+import java.io.IOException;
+
+/**
+ * An listener notifed when record is inserted, updated or removed 
+ * 
+ * @author Jan Kotek
+ *
+ * @param <K> key type
+ * @param <V> value type
+ */
+public interface RecordListener<K,V> {
+	
+	void recordInserted(K key, V value)throws IOException;
+	
+	void recordUpdated(K key, V oldValue, V newValue)throws IOException;
+	
+	void recordRemoved(K key, V value)throws IOException;
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,355 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm;
+
+import java.io.IOException;
+import java.util.Comparator;
+
+/**
+ *  An interface to manages records, which are objects serialized to byte[] on background.
+ *  <p>
+ *  The set of record operations is simple: fetch, insert, update and delete.
+ *  Each record is identified using a "rowid" and contains a byte[] data block serialized to object.
+ *  Rowids are returned on inserts and you can store them someplace safe
+ *  to be able to get  back to them.  Data blocks can be as long as you wish,
+ *  and may have lengths different from the original when updating.
+ *  <p>
+ *  RecordManager is responsible for handling transactions. 
+ *  JDBM2 supports only single transaction for data store. 
+ *  See <code>commit</code> and <code>roolback</code> methods for more details. 
+ *  <p> 
+ *  RecordManader is also factory for primary Maps. 
+ *  <p>
+ * @author <a href="mailto:opencoeli at gmail.com">Jan Kotek</a>
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @author <a href="cg at cdegroot.com">Cees de Groot</a>
+ */
+public interface  RecordManager
+{
+
+	public static final String DEFAULT_RELATIVE_PATH_INDEX = ".index" ;
+	
+    /**
+     * Recid indicating no record (e.g. null)
+     */
+    public static final long NULL_RECID = 0;
+
+
+
+    /**
+     *  Inserts a new record using standard java object serialization.
+     *
+     *  @param obj the object for the new record.
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract long insert( Object obj )
+        throws IOException;
+
+    
+    /**
+     *  Inserts a new record using a custom serializer.
+     *
+     *  @param obj the object for the new record.
+     *  @param serializer a custom serializer
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract <A> long insert( A obj, Serializer<A> serializer )
+        throws IOException;
+
+
+    /**
+     *  Deletes a record.
+     *
+     *  @param recid the rowid for the record that should be deleted.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract void delete( long recid )
+        throws IOException;
+
+
+    /**
+     *  Updates a record using standard java object serialization.
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @throws IOException when one of the underlying I/O operations fails or given recid does not exists.
+     */
+    public abstract void update( long recid, Object obj )
+        throws IOException;
+
+
+    /**
+     *  Updates a record using a custom serializer.
+     *  If given recid does not exist, IOException will be thrown before/during commit (cache).  
+     *  
+     *
+     *  @param recid the recid for the record that is to be updated.
+     *  @param obj the new object for the record.
+     *  @param serializer a custom serializer
+     *  @throws IOException when one of the underlying I/O operations fails
+     */
+    public abstract <A> void update( long recid, A obj, Serializer<A> serializer )
+        throws IOException;
+
+    
+    /**
+     *  Fetches a record using standard java object serialization.
+     *  If given recid does not exist, IOException will be thrown before/during commit (cache).  
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @return the object contained in the record, null if given recid does not exist
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract Object fetch( long recid )
+        throws IOException;
+
+
+    /**
+     *  Fetches a record using a custom serializer.
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @param serializer a custom serializer
+     *  @return the object contained in the record, null if given recid does not exist
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract <A> A fetch( long recid, Serializer<A> serializer )
+        throws IOException;
+
+    /**
+     *  Fetches a record using a custom serializer and optionaly disabled cache
+     *
+     *  @param recid the recid for the record that must be fetched.
+     *  @param serializer a custom serializer
+     *  @param disableCache true to disable any caching mechanism
+     *  @return the object contained in the record, null if given recid does not exist  
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract <A> A fetch( long recid, Serializer<A> serializer, boolean disableCache )
+        throws IOException;
+
+    /**
+     *  Closes the record manager and release resources. 
+     *  Record manager can not be used after it was closed	
+     *
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public abstract void close()
+        throws IOException;
+
+
+    /**
+     * Empty cache. This may be usefull if you need to release memory.
+     * 
+     * @throws IOException
+     */
+    public abstract void clearCache() throws IOException;
+
+    /**
+     * Defragments storage, so it consumes less space.
+     * This commits any uncommited data.  
+     * 
+     * @throws IOException
+     */
+    public abstract void defrag() throws IOException;
+    
+
+
+    /**
+     * Commit (make persistent) all changes since beginning of transaction.
+     * JDBM supports only single transaction.
+     */
+    public abstract void commit()
+        throws IOException;
+
+
+    /**
+     * Rollback (cancel) all changes since beginning of transaction.
+     * JDBM supports only single transaction. 
+     * This operations affects all maps created by this RecordManager. 	
+     */
+    public abstract void rollback()
+        throws IOException;
+
+
+
+
+    /**
+     * Obtain the record id of a named object. Returns 0 if named object
+     * doesn't exist.
+     * Named objects are used to store Map views and other well known objects.
+     */
+    public abstract long getNamedObject( String name )
+        throws IOException;
+
+
+    /**
+     * Set the record id of a named object.
+     * Named objects are used to store Map views and other well known objects.
+     */
+    public abstract void setNamedObject( String name, long recid )
+        throws IOException;
+
+    
+
+    /**
+     * Creates or load existing Primary Hash Map which persists data into DB.
+     * 
+     * 
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @return
+     */
+	public <K, V> PrimaryHashMap<K, V> hashMap(String name);
+
+
+
+    /**
+     * Creates or load existing Primary Hash Map which persists data into DB.
+     * This method uses custom serializer for keys.
+     *
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @param keySerializer serializer to be used for Keys
+     * @return
+     */
+	public <K, V> PrimaryHashMap<K, V> hashMap(String name, Serializer<K> keySerializer);
+
+
+
+    /**
+     * Creates or load existing Primary Hash Map which persists data into DB.
+     * Map will use custom serializers for Keys and Values.
+     * Leave keySerializer null to use default serializer for keys
+     *
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @param keySerializer serializer to be used for Keys, leave null to use default serializer
+     * @param valueSerializer serializer to be used for Values
+     * @return
+     */
+	public <K, V> PrimaryHashMap<K, V> hashMap(String name, Serializer<K> keySerializer, Serializer<V> valueSerializer);
+
+    /**
+     * Creates or load existing Primary TreeMap which persists data into DB.
+     * 
+     * 
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @return
+     */
+
+	@SuppressWarnings("unchecked")
+	public <K extends Comparable, V> PrimaryTreeMap<K, V> treeMap(String name);
+
+    /**
+     * Creates or load existing TreeMap which persists data into DB.
+     * 
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @param valueSerializer Serializer used for values. This may reduce disk space usage.
+     * @return
+     */
+	@SuppressWarnings("unchecked")
+	public <K extends Comparable, V> PrimaryTreeMap<K, V> treeMap(String name, Serializer<V> valueSerializer);
+	
+    /**
+     * Creates or load existing TreeMap which persists data into DB.
+     * 
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @param valueSerializer Serializer used for values. This may reduce disk space usage.
+     * @param keySerializer Serializer used for keys. This may reduce disk space usage.
+     * @return
+     */
+	@SuppressWarnings("unchecked")
+	public <K extends Comparable, V> PrimaryTreeMap<K, V> treeMap(String name, 
+			Serializer<V> valueSerializer, Serializer<K> keySerializer);
+	
+    /**
+     * Creates or load existing TreeMap which persists data into DB.
+     * 
+     * 
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @param keyComparator Comparator used to sort keys
+     * @return
+     */
+	public <K, V> PrimaryTreeMap<K, V> treeMap(String name, Comparator<K> keyComparator);
+
+    /**
+     * Creates or load existing TreeMap which persists data into DB.
+     * 
+     * 
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @param keyComparator Comparator used to sort keys
+     * @param valueSerializer Serializer used for values. This may reduce disk space usage
+     * @return
+     */
+	public <K, V> PrimaryTreeMap<K, V> treeMap(String name,
+			Comparator<K> keyComparator, Serializer<V> valueSerializer) ;
+	
+    /**
+     * Creates or load existing TreeMap which persists data into DB. 
+     * 
+     * @param <K> Key type
+     * @param <V> Value type
+     * @param name record name
+     * @param keyComparator Comparator used to sort keys
+     * @param valueSerializer Serializer used for values. This may reduce disk space usage
+     * @param keySerializer Serializer used for keys. This may reduce disk space usage     * 
+     * @return
+     */
+	public <K, V> PrimaryTreeMap<K, V> treeMap(String name,
+			Comparator<K> keyComparator, Serializer<V> valueSerializer, Serializer<K> keySerializer) ;
+	
+	/**
+     * Creates or load existing StoreMap which persists data into DB.
+     *  
+     * @param <V> Value type
+     * @param name record name
+     * @param valueSerializer Serializer used for values. This may reduce disk space usage
+     * @return map
+     */
+	public <V> PrimaryStoreMap<Long, V> storeMap(String name,
+				Serializer<V> valueSerializer) ;
+	
+	/**
+     * Creates or load existing Primary StoreMap which persists data into DB.
+     *  
+     * @param <V> Value type
+     * @param name record name
+     * @return map
+     */
+	public <V> PrimaryStoreMap<Long, V> storeMap(String name);
+
+
+	
+
+}
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,127 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm;
+
+import jdbm.recman.BaseRecordManager;
+import jdbm.recman.CacheRecordManager;
+
+import java.io.IOException;
+import java.util.Properties;
+
+/**
+ * This is the factory class to use for instantiating {@link RecordManager}
+ * instances.
+ * 
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @author <a href="cg at cdegroot.com">Cees de Groot</a>
+ * @version $Id: RecordManagerFactory.java,v 1.2 2005/06/25 23:12:31 doomdark
+ *          Exp $
+ */
+public final class RecordManagerFactory {
+
+	/**
+	 * Create a record manager.
+	 * 
+	 * @param name
+	 *            Name of the record file.
+	 * @throws IOException
+	 *             if an I/O related exception occurs while creating or opening
+	 *             the record manager.
+	 * @throws UnsupportedOperationException
+	 *             if some options are not supported by the implementation.
+	 * @throws IllegalArgumentException
+	 *             if some options are invalid.
+	 */
+	public static RecordManager createRecordManager(String name)
+			throws IOException {
+		return createRecordManager(name, new Properties());
+	}
+
+	/**
+	 * Create a record manager.
+	 * 
+	 * @param name
+	 *            Name of the record file.
+	 * @param options
+	 *            Record manager options.
+	 * @throws IOException
+	 *             if an I/O related exception occurs while creating or opening
+	 *             the record manager.
+	 * @throws UnsupportedOperationException
+	 *             if some options are not supported by the implementation.
+	 * @throws IllegalArgumentException
+	 *             if some options are invalid.
+	 */
+	@SuppressWarnings("unchecked")
+	public static RecordManager createRecordManager(String name,
+			Properties options) throws IOException {
+			
+			RecordManager recman = new BaseRecordManager( name , RecordManagerOptions.INDEX_DIRECTORY_RELATIVE_PATH);
+            
+            String value = options.getProperty( RecordManagerOptions.DISABLE_TRANSACTIONS, "false" );
+            if ( value.equalsIgnoreCase( "TRUE" ) ) {
+                ( (BaseRecordManager) recman ).disableTransactions();
+            }
+
+            value = options.getProperty(RecordManagerOptions.COMPRESS,"false");
+            boolean compress = value.equalsIgnoreCase("TRUE");
+            if(compress)
+                    ( (BaseRecordManager) recman ).setCompress(true);
+
+            value = options.getProperty(RecordManagerOptions.APPEND_TO_END,"true");
+            boolean append = value.equalsIgnoreCase("TRUE");
+            if(append)
+                    ( (BaseRecordManager) recman ).setAppendToEnd(true);
+
+
+            String cacheType = options.getProperty( RecordManagerOptions.CACHE_TYPE, "auto" );
+
+            value = options.getProperty( RecordManagerOptions.CACHE_SIZE, "1000" );
+            int cacheSize = Integer.parseInt( value );
+
+            if("auto".equals(cacheType)){
+                    try{
+                            //disable SOFT if available memory is bellow 50 MB
+                            if(Runtime.getRuntime().maxMemory()<=50000000)
+                                    cacheType = "mru";
+                            else
+                                    cacheType = "soft";
+                    }catch(Exception e){
+                            cacheType = "mru";
+                    }
+            }
+
+            if ("mru".equals(cacheType)) {
+                    if(cacheSize>0){
+                            recman = new CacheRecordManager( recman,cacheSize,false);
+                    }
+            }else if ("soft".equals(cacheType)) {
+                    // cachesize is the size of the internal MRU, not the soft cache
+                    recman = new CacheRecordManager(recman, cacheSize,true);
+
+            }else if ("none".equals(cacheType)) {
+                    //do nothing
+            }else{
+                    throw new IllegalArgumentException("Unknown cache type: "+cacheType);
+            }
+
+            return recman;
+
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,89 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm;
+
+/**
+ * Standard options for RecordManager.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @author <a href="cg at cdegroot.com">Cees de Groot</a>
+ * @version $Id: RecordManagerOptions.java,v 1.1 2002/05/31 06:33:20 boisvert Exp $
+ */
+public class RecordManagerOptions
+{
+
+    /**
+     * Class name of the provider factory. Defaults to {@link jdbm.recman.Provider}.
+     */
+    public static final String PROVIDER_FACTORY = "jdbm.provider";
+
+    /**
+     * Option to create a thread-safe record manager.
+     */
+    public static final String THREAD_SAFE = "jdbm.threadSafe";
+
+
+    /**
+     * Option to automatically commit data after each operation.
+     */
+    public static final String AUTO_COMMIT = "jdbm.autoCommit";
+
+
+    /**
+     * Option to disable transaction (to increase performance at the cost of
+     * potential data loss).
+     * <br>Possible values: <u>false</u>|true.
+     */
+    public static final String DISABLE_TRANSACTIONS = "jdbm.disableTransactions";
+    	
+
+    /**
+     * Option to disable free space reclaim. New records are always
+     * inserted to end of file. Usefull mainly on batch imports.
+     * You will need to defrag() store after you are done
+     *
+     * <br>Possible values: <u>false</u>|true.
+     */
+    public static final String APPEND_TO_END = "jdbm.appendToEnd";
+
+    /**
+     * Type of cache to use. 
+     * <br>Possible values: <u>auto</u>|none|mru|soft.
+     * <p> 
+     * With auto soft cache is used if VM have more then 1000 MB available.
+     * Bellow that mru cache is used.
+     * 
+     */
+    public static final String CACHE_TYPE = "jdbm.cache.type";
+
+    
+    /**
+     * Size of the MRU cache. This affects cache type "mru" and cache type "soft".
+     * <br>Default value: <u>1000</u>.
+     */
+    public static final String CACHE_SIZE = "jdbm.cache.size";
+
+
+    /**
+     * Compress pages in RecordManager with ZLIB. 
+     * This may result in better space usage, but lower performance.
+     * <br>Possible values: <u>false</u>|true.
+     */
+	public static final String COMPRESS = "jdbm.compress";
+
+	public static final String INDEX_DIRECTORY_RELATIVE_PATH = ".index";
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryHashMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryHashMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,50 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+import java.util.Map;
+
+/**
+ * Secondary HashMap. It provides view over primary data. 
+ * This map is updated automatically as primary map changes. 
+ * This map is unmodifiable, any attempt to modify it will throw 'UnsupportedOperationException'
+ * 
+ * @author Jan Kotek
+ *
+ * @param <A> Type of secondary key
+ * @param <K> Type of primary key
+ * @param <V> Type of value in primary map
+ */
+public interface SecondaryHashMap<A,K,V> extends Map<A,Iterable<K>>{
+	
+	/**
+	 * Convert primary key to primary value. 
+	 * This will query primary table and returns result, it is little shortcut.
+	 * 
+	 * @param k primary key 
+	 * @return value from primary table
+	 */
+	V getPrimaryValue(K k); 
+	
+	/**
+	 * Returns values from primary map which are matching given secondary key
+	 * @param a
+	 * @return Iterable over values, this never returns null. 
+	 */
+	Iterable<V> getPrimaryValues(A a);
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryKeyExtractor.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryKeyExtractor.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,39 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+/**
+ * 
+ * Extract secondary key from record in primary map.
+ * 
+ * @author Jan Kotek
+ *
+ * @param <A> Type of secondary key
+ * @param <K> Type of primary key
+ * @param <V> Type of primary value
+ */
+public interface SecondaryKeyExtractor<A,K,V> {
+	
+	/**
+	 * Extracts secondary key from primary map
+	 * 
+	 * @param key key in primary table
+	 * @param value value in primary table
+	 * @return secondary key or null to skip this record
+	 */
+	A extractSecondaryKey(K key, V value);
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryTreeMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SecondaryTreeMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,49 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm;
+
+import java.util.SortedMap;
+
+/**
+ * Secondary TreeMap. It provides view over primary data. 
+ * This map is updated automatically as primary map changes. 
+ * This map is unmodifiable, any attempt to modify it will throw 'UnsupportedOperationException'
+ * 
+ * @author Jan Kotek
+ *
+ * @param <A> Type of secondary key
+ * @param <K> Type of primary key
+ * @param <V> Type of value in primary map
+ */
+public interface SecondaryTreeMap<A,K,V> extends SortedMap<A,Iterable<K>>{
+
+	/**
+	 * Convert primary key to primary value. 
+	 * This will query primary table and returns result, it is little shortcut.
+	 * 
+	 * @param k primary key 
+	 * @return value from primary table
+	 */
+	V getPrimaryValue(K k);
+
+	/**
+	 * Returns values from primary map which are matching given secondary key
+	 * @param a
+	 * @return Iterable over values, this never returns null. 
+	 */
+	Iterable<V> getPrimaryValues(A a);
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/Serializer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/Serializer.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,53 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm;
+
+import java.io.IOException;
+
+/**
+ * Interface used to provide a serialization mechanism other than a class' normal
+ * serialization.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ */
+public interface Serializer<A>   
+{
+
+    /**
+     * Serialize the content of an object into a byte array.
+     *
+     * @param out DataOutputStream to save object into
+     * @param obj Object to serialize
+     * 
+     */
+     public void serialize(SerializerOutput out,A obj )
+        throws IOException;
+        
+        
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized DataInputStream to read object from
+     * @return deserialized object
+     * @throws IOException
+     * @throws ClassNotFoundException 
+     */
+     public A deserialize( SerializerInput in )
+        throws IOException, ClassNotFoundException;
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SerializerInput.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SerializerInput.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,52 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+import jdbm.helper.Serialization;
+import jdbm.helper.LongPacker;
+
+/**
+ * 
+ * Input for Serializer
+ * 
+ * @author Jan Kotek
+ *
+ */
+public class SerializerInput extends DataInputStream{
+
+	
+	public SerializerInput(InputStream in) {
+		super(in);
+	}
+
+	@SuppressWarnings("unchecked")
+	public <V> V readObject() throws ClassNotFoundException, IOException{
+		return (V) Serialization.readObject(this);
+	}
+	
+	public long readPackedLong() throws IOException{
+		return LongPacker.unpackLong(this);
+	}
+	
+	public int readPackedInt() throws IOException{
+		return LongPacker.unpackInt(this);
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SerializerOutput.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/SerializerOutput.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,62 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm;
+
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import jdbm.helper.LongPacker;
+import jdbm.helper.Serialization;
+
+
+/**
+ * 
+ * Output for Serializer
+ * 
+ * @author Jan Kotek
+ *
+ */
+public class SerializerOutput extends DataOutputStream{
+	
+	
+	public SerializerOutput(OutputStream out) {
+		super(out);
+	}
+
+	public void writeObject(Object obj) throws IOException{
+		Serialization.writeObject(this, obj);
+	}
+	
+	public void writePackedLong(long i) throws IOException{
+		LongPacker.packLong(this, i);
+	}
+
+	public void writePackedInt(int i) throws IOException{
+		LongPacker.packInt(this, i);
+	}
+
+    /**
+     * Reset counter inside DataOutputStream.
+     * Workaround method if SerializerOutput instance is reused
+     *
+     */
+        public void __resetWrittenCounter(){
+            written = 0;
+        }
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BPage.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BPage.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,1521 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.btree;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+import jdbm.RecordManager;
+import jdbm.Serializer;
+import jdbm.SerializerInput;
+import jdbm.SerializerOutput;
+import jdbm.helper.ComparableComparator;
+import jdbm.helper.DefaultSerializer;
+import jdbm.helper.LongPacker;
+import jdbm.helper.OpenByteArrayInputStream;
+import jdbm.helper.OpenByteArrayOutputStream;
+import jdbm.helper.Serialization;
+import jdbm.helper.Tuple;
+import jdbm.helper.TupleBrowser;
+
+/**
+ * Page of a Btree.
+ * <p>
+ * The page contains a number of key-value pairs.  Keys are ordered to allow
+ * dichotomic search.
+ * <p>
+ * If the page is a leaf page, the keys and values are user-defined and
+ * represent entries inserted by the user.
+ * <p>
+ * If the page is non-leaf, each key represents the greatest key in the
+ * underlying BPages and the values are recids pointing to the children BPages.
+ * The only exception is the rightmost BPage, which is considered to have an
+ * "infinite" key value, meaning that any insert will be to the left of this
+ * pseudo-key
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @version $Id: BPage.java,v 1.6 2003/09/21 15:46:59 boisvert Exp $
+ */
+public final class BPage<K,V>
+    implements Serializer<BPage<K,V>>
+{
+
+    private static final boolean DEBUG = false;
+
+
+
+    /**
+     * Parent B+Tree.
+     */
+    transient BTree<K,V> _btree;
+
+
+    /**
+     * This BPage's record ID in the PageManager.
+     */
+    protected transient long _recid;
+
+
+    /**
+     * Flag indicating if this is a leaf BPage.
+     */
+    protected boolean _isLeaf;
+
+
+    /**
+     * Keys of children nodes
+     */
+    protected K[] _keys;
+
+
+    /**
+     * Values associated with keys.  (Only valid if leaf BPage)
+     */
+    protected V[] _values;
+
+
+    /**
+     * Children pages (recids) associated with keys.  (Only valid if non-leaf BPage)
+     */
+    protected long[] _children;
+
+    
+    /**
+     * Index of first used item at the page
+     */
+    protected int _first;
+
+
+    /**
+     * Previous leaf BPage (only if this BPage is a leaf)
+     */
+    protected long _previous;
+
+
+    /**
+     * Next leaf BPage (only if this BPage is a leaf)
+     */
+    protected long _next;
+
+    /**
+     * Return the B+Tree that is the owner of this {@link BPage}.
+     */
+    public BTree<K,V> getBTree() {
+        return _btree;
+    }
+
+    /**
+     * No-argument constructor used by serialization.
+     */
+    public BPage()
+    {
+        // empty
+    }
+
+
+    /**
+     * Root page overflow constructor
+     */
+    @SuppressWarnings("unchecked")
+	BPage( BTree<K,V> btree, BPage<K,V> root, BPage<K,V> overflow )
+        throws IOException
+    {
+        _btree = btree;
+
+        _isLeaf = false;
+
+        _first = _btree._pageSize-2;
+
+        _keys = (K[]) new Object[ _btree._pageSize ];
+        _keys[ _btree._pageSize-2 ] = overflow.getLargestKey();
+        _keys[ _btree._pageSize-1 ] = root.getLargestKey();
+
+        _children = new long[ _btree._pageSize ];
+        _children[ _btree._pageSize-2 ] = overflow._recid;
+        _children[ _btree._pageSize-1 ] = root._recid;
+
+        _recid = _btree._recman.insert( this, this );
+    }
+
+
+    /**
+     * Root page (first insert) constructor.
+     */
+    @SuppressWarnings("unchecked")
+	BPage( BTree<K,V> btree, K key, V value )
+        throws IOException
+    {
+        _btree = btree;
+
+        _isLeaf = true;
+
+        _first = btree._pageSize-2;
+
+        _keys = (K[]) new Object[ _btree._pageSize ];
+        _keys[ _btree._pageSize-2 ] = key;
+        _keys[ _btree._pageSize-1 ] = null;  // I am the root BPage for now
+
+        _values = (V[]) new Object[ _btree._pageSize ];
+        _values[ _btree._pageSize-2 ] = value;
+        _values[ _btree._pageSize-1 ] = null;  // I am the root BPage for now
+
+        _recid = _btree._recman.insert( this, this );
+    }
+
+
+    /**
+     * Overflow page constructor.  Creates an empty BPage.
+     */
+    @SuppressWarnings("unchecked")
+	BPage( BTree<K,V> btree, boolean isLeaf )
+        throws IOException
+    {
+        _btree = btree;
+
+        _isLeaf = isLeaf;
+
+        // page will initially be half-full
+        _first = _btree._pageSize/2;
+
+        _keys = (K[]) new Object[ _btree._pageSize ];
+        if ( isLeaf ) {
+            _values = (V[]) new Object[ _btree._pageSize ];
+        } else {
+            _children = new long[ _btree._pageSize ];
+        }
+
+        _recid = _btree._recman.insert( this, this );
+    }
+
+
+    /**
+     * Get largest key under this BPage.  Null is considered to be the
+     * greatest possible key.
+     */
+    K getLargestKey()
+    {
+        return _keys[ _btree._pageSize-1 ];
+    }
+
+
+    /**
+     * Return true if BPage is empty.
+     */
+    boolean isEmpty()
+    {
+        if ( _isLeaf ) {
+            return ( _first == _values.length-1 );
+        } else {
+            return ( _first == _children.length-1 );
+        }
+    }
+
+
+    /**
+     * Return true if BPage is full.
+     */
+    boolean isFull() {
+        return ( _first == 0 );
+    }
+
+
+    /**
+     * Find the object associated with the given key.
+     *
+     * @param height Height of the current BPage (zero is leaf page)
+     * @param key The key
+     * @return TupleBrowser positionned just before the given key, or before
+     *                      next greater key if key isn't found.
+     */
+    TupleBrowser<K,V> find( int height, K key )
+        throws IOException
+    {
+        int index = findChildren( key );
+
+        /*
+        if ( DEBUG ) {
+            System.out.println( "BPage.find() current: " + this
+                                + " height: " + height);
+        }
+        */
+
+        height -= 1;
+
+        if ( height == 0 ) {
+            // leaf BPage
+            return new Browser<K,V>( this, index );
+        } else {
+            // non-leaf BPage
+            BPage<K,V> child = childBPage( index );
+            return child.find( height, key );
+        }
+    }
+
+
+    /**
+     * Find value associated with the given key.
+     *
+     * @param height Height of the current BPage (zero is leaf page)
+     * @param key The key
+     * @return TupleBrowser positionned just before the given key, or before
+     *                      next greater key if key isn't found.
+     */
+    V findValue( int height, K key )
+        throws IOException
+    {
+        int index = findChildren( key );
+
+        /*
+        if ( DEBUG ) {
+            System.out.println( "BPage.find() current: " + this
+                                + " height: " + height);
+        }
+        */
+
+        height -= 1;
+
+        if ( height == 0 ) {
+
+            K key2 =   _keys[ index ];
+//          // find returns the matching key or the next ordered key, so we must
+//          // check if we have an exact match
+          if ( key2==null || _btree._comparator.compare( key, key2 ) != 0 ) 
+              return null;
+            
+            return _values[ index ];
+
+            // leaf BPage
+            //return new Browser<K,V>( this, index );
+        } else {
+            // non-leaf BPage
+            BPage<K,V> child = childBPage( index );
+            return child.findValue( height, key );
+        }
+    }
+
+
+    /**
+     * Find first entry and return a browser positioned before it.
+     *
+     * @return TupleBrowser positionned just before the first entry.
+     */
+    TupleBrowser<K,V> findFirst()
+        throws IOException
+    {
+        if ( _isLeaf ) {
+            return new Browser<K,V>( this, _first );
+        } else {
+            BPage<K,V> child = childBPage( _first );
+            return child.findFirst();
+        }
+    }
+
+    /** 
+     * Deletes this BPage and all children pages from the record manager
+     */
+    void delete() 
+        throws IOException
+    {
+        if (_isLeaf){
+            if (_next != 0){
+                BPage<K,V> nextBPage = loadBPage(_next);
+                if (nextBPage._previous == _recid){ // this consistency check can be removed in production code
+                    nextBPage._previous = _previous;
+                    _btree._recman.update(nextBPage._recid, nextBPage, nextBPage);
+                } else {
+                    throw new Error("Inconsistent data in BTree");
+                }
+            }
+            if (_previous != 0){
+                BPage<K,V> previousBPage = loadBPage(_previous);
+                if (previousBPage._next != _recid){ // this consistency check can be removed in production code
+                    previousBPage._next = _next;
+                    _btree._recman.update(previousBPage._recid, previousBPage, previousBPage);
+                } else {
+                    throw new Error("Inconsistent data in BTree");
+                }
+            }
+        } else {
+            int left = _first;
+            int right = _btree._pageSize-1;
+
+            for (int i = left; i <= right; i++){
+                BPage<K,V> childBPage = loadBPage(_children[i]);
+                childBPage.delete();
+            }
+        }
+        
+        _btree._recman.delete(_recid);
+    }
+    
+    /**
+     * Insert the given key and value.
+     * <p>
+     * Since the Btree does not support duplicate entries, the caller must
+     * specify whether to replace the existing value.
+     *
+     * @param height Height of the current BPage (zero is leaf page)
+     * @param key Insert key
+     * @param value Insert value
+     * @param replace Set to true to replace the existing value, if one exists.
+     * @return Insertion result containing existing value OR a BPage if the key
+     *         was inserted and provoked a BPage overflow.
+     */
+    InsertResult<K,V> insert( int height, K key, V value, boolean replace )
+        throws IOException
+    {
+        InsertResult<K,V>  result;
+        long          overflow;
+
+        int index = findChildren( key );
+
+        height -= 1;
+        if ( height == 0 )  {
+
+            result = new InsertResult<K,V>();
+
+            // inserting on a leaf BPage
+            overflow = -1;
+            if ( DEBUG ) {
+                System.out.println( "Bpage.insert() Insert on leaf Bpage key=" + key
+                                    + " value=" + value + " index="+index);
+            }
+            if ( compare( key, _keys[ index ] ) == 0 ) {
+                // key already exists
+                if ( DEBUG ) {
+                    System.out.println( "Bpage.insert() Key already exists." ) ;
+                }
+                result._existing =  _values[ index ];
+                if ( replace ) {
+                    _values [ index ] = value;
+                    _btree._recman.update( _recid, this, this );
+                }
+                // return the existing key
+                return result;
+            }
+        } else {
+            // non-leaf BPage
+            BPage<K,V> child = childBPage( index );
+            result = child.insert( height, key, value, replace );
+
+            if ( result._existing != null ) {
+                // return existing key, if any.
+                return result;
+            }
+
+            if ( result._overflow == null ) {
+                // no overflow means we're done with insertion
+                return result;
+            }
+
+            // there was an overflow, we need to insert the overflow page
+            // on this BPage
+            if ( DEBUG ) {
+                System.out.println( "BPage.insert() Overflow page: " + result._overflow._recid );
+            }
+            key = result._overflow.getLargestKey();
+            overflow = result._overflow._recid;
+
+            // update child's largest key
+            _keys[ index ] = child.getLargestKey();
+
+            // clean result so we can reuse it
+            result._overflow = null;
+        }
+
+        // if we get here, we need to insert a new entry on the BPage
+        // before _children[ index ]
+        if ( !isFull() ) {
+            if ( height == 0 ) {
+                insertEntry( this, index-1, key, value );
+            } else {
+                insertChild( this, index-1, key, overflow );
+            }
+            _btree._recman.update( _recid, this, this );
+            return result;
+        }
+
+        // page is full, we must divide the page
+        int half = _btree._pageSize >> 1;
+        BPage<K,V> newPage = new BPage<K,V>( _btree, _isLeaf );
+        if ( index < half ) {
+            // move lower-half of entries to overflow BPage,
+            // including new entry
+            if ( DEBUG ) {
+                System.out.println( "Bpage.insert() move lower-half of entries to overflow BPage, including new entry." ) ;
+            }
+            if ( height == 0 ) {
+                copyEntries( this, 0, newPage, half, index );
+                setEntry( newPage, half+index, key, value );
+                copyEntries( this, index, newPage, half+index+1, half-index-1 );
+            } else {
+                copyChildren( this, 0, newPage, half, index );
+                setChild( newPage, half+index, key, overflow );
+                copyChildren( this, index, newPage, half+index+1, half-index-1 );
+            }
+        } else {
+            // move lower-half of entries to overflow BPage,
+            // new entry stays on this BPage
+            if ( DEBUG ) {
+                System.out.println( "Bpage.insert() move lower-half of entries to overflow BPage. New entry stays" ) ;
+            }
+            if ( height == 0 ) {
+                copyEntries( this, 0, newPage, half, half );
+                copyEntries( this, half, this, half-1, index-half );
+                setEntry( this, index-1, key, value );
+            } else {
+                copyChildren( this, 0, newPage, half, half );
+                copyChildren( this, half, this, half-1, index-half );
+                setChild( this, index-1, key, overflow );
+            }
+        }
+
+        _first = half-1;
+
+        // nullify lower half of entries
+        for ( int i=0; i<_first; i++ ) {
+            if ( height == 0 ) {
+                setEntry( this, i, null, null );
+            } else {
+                setChild( this, i, null, -1 );
+            }
+        }
+
+        if ( _isLeaf ) {
+            // link newly created BPage
+            newPage._previous = _previous;
+            newPage._next = _recid;
+            if ( _previous != 0 ) {
+                BPage<K,V> previous = loadBPage( _previous );
+                previous._next = newPage._recid;
+                _btree._recman.update( _previous, previous, this );
+
+            }
+            _previous = newPage._recid;
+        }
+
+        _btree._recman.update( _recid, this, this );
+        _btree._recman.update( newPage._recid, newPage, this );
+
+        result._overflow = newPage;
+        return result;
+    }
+
+
+    /**
+     * Remove the entry associated with the given key.
+     *
+     * @param height Height of the current BPage (zero is leaf page)
+     * @param key Removal key
+     * @return Remove result object
+     */
+    RemoveResult<K,V> remove( int height, K key )
+        throws IOException
+    {
+        RemoveResult<K,V> result;
+
+        int half = _btree._pageSize / 2;
+        int index = findChildren( key );
+
+        height -= 1;
+        if ( height == 0 ) {
+            // remove leaf entry
+            if ( compare( _keys[ index ], key ) != 0 ) {
+                throw new IllegalArgumentException( "Key not found: " + key );
+            }
+            result = new RemoveResult<K,V>();
+            result._value =  _values[ index ];
+            removeEntry( this, index );
+
+            // update this BPage
+            _btree._recman.update( _recid, this, this );
+
+        } else {
+            // recurse into Btree to remove entry on a children page
+            BPage<K,V> child = childBPage( index );
+            result = child.remove( height, key );
+
+            // update children
+            _keys[ index ] = child.getLargestKey();
+            _btree._recman.update( _recid, this, this );
+
+            if ( result._underflow ) {
+                // underflow occured
+                if ( child._first != half+1 ) {
+                    throw new IllegalStateException( "Error during underflow [1]" );
+                }
+                if ( index < _children.length-1 ) {
+                    // exists greater brother page
+                    BPage<K,V> brother = childBPage( index+1 );
+                    int bfirst = brother._first;
+                    if ( bfirst < half ) {
+                        // steal entries from "brother" page
+                        int steal = ( half - bfirst + 1 ) / 2;
+                        brother._first += steal;
+                        child._first -= steal;
+                        if ( child._isLeaf ) {
+                            copyEntries( child, half+1, child, half+1-steal, half-1 );
+                            copyEntries( brother, bfirst, child, 2*half-steal, steal );
+                        } else {
+                            copyChildren( child, half+1, child, half+1-steal, half-1 );
+                            copyChildren( brother, bfirst, child, 2*half-steal, steal );
+                        }                            
+
+                        for ( int i=bfirst; i<bfirst+steal; i++ ) {
+                            if ( brother._isLeaf ) {
+                                setEntry( brother, i, null, null );
+                            } else {
+                                setChild( brother, i, null, -1 );
+                            }
+                        }
+
+                        // update child's largest key
+                        _keys[ index ] = child.getLargestKey();
+
+                        // no change in previous/next BPage
+
+                        // update BPages
+                        _btree._recman.update( _recid, this, this );
+                        _btree._recman.update( brother._recid, brother, this );
+                        _btree._recman.update( child._recid, child, this );
+
+                    } else {
+                        // move all entries from page "child" to "brother"
+                        if ( brother._first != half ) {
+                            throw new IllegalStateException( "Error during underflow [2]" );
+                        }
+
+                        brother._first = 1;
+                        if ( child._isLeaf ) {
+                            copyEntries( child, half+1, brother, 1, half-1 );
+                        } else {
+                            copyChildren( child, half+1, brother, 1, half-1 );
+                        }
+                        _btree._recman.update( brother._recid, brother, this );
+
+
+                        // remove "child" from current BPage
+                        if ( _isLeaf ) {
+                            copyEntries( this, _first, this, _first+1, index-_first );
+                            setEntry( this, _first, null, null );
+                        } else {
+                            copyChildren( this, _first, this, _first+1, index-_first );
+                            setChild( this, _first, null, -1 );
+                        }
+                        _first += 1;
+                        _btree._recman.update( _recid, this, this );
+
+                        // re-link previous and next BPages
+                        if ( child._previous != 0 ) {
+                            BPage<K,V> prev = loadBPage( child._previous );
+                            prev._next = child._next;
+                            _btree._recman.update( prev._recid, prev, this );
+                        }
+                        if ( child._next != 0 ) {
+                            BPage<K,V> next = loadBPage( child._next );
+                            next._previous = child._previous;
+                            _btree._recman.update( next._recid, next, this );
+
+                        }
+
+                        // delete "child" BPage
+                        _btree._recman.delete( child._recid );
+                    }
+                } else {
+                    // page "brother" is before "child"
+                    BPage<K,V> brother = childBPage( index-1 );
+                    int bfirst = brother._first;
+                    if ( bfirst < half ) {
+                        // steal entries from "brother" page
+                        int steal = ( half - bfirst + 1 ) / 2;
+                        brother._first += steal;
+                        child._first -= steal;
+                        if ( child._isLeaf ) {
+                            copyEntries( brother, 2*half-steal, child,
+                                         half+1-steal, steal );
+                            copyEntries( brother, bfirst, brother,
+                                         bfirst+steal, 2*half-bfirst-steal );
+                        } else {
+                            copyChildren( brother, 2*half-steal, child,
+                                          half+1-steal, steal );
+                            copyChildren( brother, bfirst, brother,
+                                          bfirst+steal, 2*half-bfirst-steal );
+                        }
+
+                        for ( int i=bfirst; i<bfirst+steal; i++ ) {
+                            if ( brother._isLeaf ) {
+                                setEntry( brother, i, null, null );
+                            } else {
+                                setChild( brother, i, null, -1 );
+                            }
+                        }
+
+                        // update brother's largest key
+                        _keys[ index-1 ] = brother.getLargestKey();
+
+                        // no change in previous/next BPage
+
+                        // update BPages
+                        _btree._recman.update( _recid, this, this );
+                        _btree._recman.update( brother._recid, brother, this );
+                        _btree._recman.update( child._recid, child, this );
+
+                    } else {
+                        // move all entries from page "brother" to "child"
+                        if ( brother._first != half ) {
+                            throw new IllegalStateException( "Error during underflow [3]" );
+                        }
+
+                        child._first = 1;
+                        if ( child._isLeaf ) {
+                            copyEntries( brother, half, child, 1, half );
+                        } else {
+                            copyChildren( brother, half, child, 1, half );
+                        }
+                        _btree._recman.update( child._recid, child, this );
+
+                        // remove "brother" from current BPage
+                        if ( _isLeaf ) {
+                            copyEntries( this, _first, this, _first+1, index-1-_first );
+                            setEntry( this, _first, null, null );
+                        } else {
+                            copyChildren( this, _first, this, _first+1, index-1-_first );
+                            setChild( this, _first, null, -1 );
+                        }
+                        _first += 1;
+                        _btree._recman.update( _recid, this, this );
+
+                        // re-link previous and next BPages
+                        if ( brother._previous != 0 ) {
+                            BPage<K,V> prev = loadBPage( brother._previous );
+                            prev._next = brother._next;
+                            _btree._recman.update( prev._recid, prev, this );
+                        }
+                        if ( brother._next != 0 ) {
+                            BPage<K,V> next = loadBPage( brother._next );
+                            next._previous = brother._previous;
+                            _btree._recman.update( next._recid, next, this );
+                        }
+
+                        // delete "brother" BPage
+                        _btree._recman.delete( brother._recid );
+                    }
+                }
+            }
+        }
+
+        // underflow if page is more than half-empty
+        result._underflow = _first > half;
+
+        return result;
+    }
+
+
+    /**
+     * Find the first children node with a key equal or greater than the given
+     * key.
+     *
+     * @return index of first children with equal or greater key.
+     */
+    private int findChildren( K key )
+    {
+        int left = _first;
+        int right = _btree._pageSize-1;
+
+        // binary search
+        while ( left < right )  {
+            int middle = ( left + right ) / 2;
+            if ( compare( _keys[ middle ], key ) < 0 ) {
+                left = middle+1;
+            } else {
+                right = middle;
+            }
+        }
+        return right;
+    }
+
+
+    /**
+     * Insert entry at given position.
+     */
+    private static <K,V> void insertEntry( BPage<K,V> page, int index,
+                                     K key, V value )
+    {
+        K[] keys = page._keys;
+        V[] values = page._values;
+        int start = page._first;
+        int count = index-page._first+1;
+
+        // shift entries to the left
+        System.arraycopy( keys, start, keys, start-1, count );
+        System.arraycopy( values, start, values, start-1, count );
+        page._first -= 1;
+        keys[ index ] = key;
+        values[ index ] = value;
+    }
+
+
+    /**
+     * Insert child at given position.
+     */
+    private static <K,V> void  insertChild( BPage<K,V> page, int index,
+                                     K key, long child )
+    {
+        K[] keys = page._keys;
+        long[] children = page._children;
+        int start = page._first;
+        int count = index-page._first+1;
+
+        // shift entries to the left
+        System.arraycopy( keys, start, keys, start-1, count );
+        System.arraycopy( children, start, children, start-1, count );
+        page._first -= 1;
+        keys[ index ] = key;
+        children[ index ] = child;
+    }
+    
+    /**
+     * Remove entry at given position.
+     */
+    private static <K,V> void removeEntry( BPage<K,V> page, int index )
+    {
+        K[] keys = page._keys;
+        V[] values = page._values;
+        int start = page._first;
+        int count = index-page._first;
+
+        System.arraycopy( keys, start, keys, start+1, count );
+        keys[ start ] = null;
+        System.arraycopy( values, start, values, start+1, count );
+        values[ start ] = null;
+        page._first++;
+    }
+
+
+    /**
+     * Remove child at given position.
+     */
+/*    
+    private static void removeChild( BPage page, int index )
+    {
+        Object[] keys = page._keys;
+        long[] children = page._children;
+        int start = page._first;
+        int count = index-page._first;
+
+        System.arraycopy( keys, start, keys, start+1, count );
+        keys[ start ] = null;
+        System.arraycopy( children, start, children, start+1, count );
+        children[ start ] = (long) -1;
+        page._first++;
+    }
+*/
+    
+    /**
+     * Set the entry at the given index.
+     */
+    private static <K,V> void setEntry( BPage<K,V> page, int index, K key, V value )
+    {
+        page._keys[ index ] = key;
+        page._values[ index ] = value;
+    }
+
+
+    /**
+     * Set the child BPage recid at the given index.
+     */
+    private static <K,V> void setChild( BPage<K,V> page, int index, K key, long recid )
+    {
+        page._keys[ index ] = key;
+        page._children[ index ] = recid;
+    }
+    
+    
+    /**
+     * Copy entries between two BPages
+     */
+    private static <K,V> void copyEntries( BPage<K,V> source, int indexSource,
+                                     BPage<K,V> dest, int indexDest, int count )
+    {
+        System.arraycopy( source._keys, indexSource, dest._keys, indexDest, count);
+        System.arraycopy( source._values, indexSource, dest._values, indexDest, count);
+    }
+
+
+    /**
+     * Copy child BPage recids between two BPages
+     */
+    private static <K,V> void copyChildren( BPage<K,V> source, int indexSource,
+                                      BPage<K,V> dest, int indexDest, int count )
+    {
+        System.arraycopy( source._keys, indexSource, dest._keys, indexDest, count);
+        System.arraycopy( source._children, indexSource, dest._children, indexDest, count);
+    }
+
+    
+    /**
+     * Return the child BPage at given index.
+     */
+    BPage<K,V> childBPage( int index )
+        throws IOException
+    {
+        return loadBPage( _children[ index ] );
+    }
+
+
+    /**
+     * Load the BPage at the given recid.
+     */
+	private BPage<K,V> loadBPage( long recid )
+        throws IOException
+    {
+        BPage<K,V> child = (BPage<K,V>) _btree._recman.fetch( recid, this );
+        child._recid = recid;
+        child._btree = _btree;
+        return child;
+    }
+
+    
+    private final int compare( K value1, K value2 )
+    {
+        if ( value1 == null ) {
+            return 1;
+        }
+        if ( value2 == null ) {
+            return -1;
+        }
+        return _btree._comparator.compare( value1, value2 );
+    }
+
+    public static byte[] readByteArray( DataInputStream in )
+        throws IOException
+    {
+        int len = LongPacker.unpackInt(in);
+        if ( len == 0 ) {
+            return null;
+        }
+        byte[] buf = new byte[ len-1 ];
+        in.readFully( buf );
+        return buf;
+    }
+
+
+    public static void writeByteArray(SerializerOutput out, byte[] buf)
+        throws IOException
+    {
+        if ( buf == null ) {
+            out.write( 0 );
+        } else {
+        	LongPacker.packInt( out, buf.length+1);
+            out.write( buf );
+        }
+    }
+
+    /**
+     * Dump the structure of the tree on the screen.  This is used for debugging
+     * purposes only.
+     */
+    private void dump( int height )
+    {
+        String prefix = "";
+        for ( int i=0; i<height; i++ ) {
+           prefix += "    ";
+        }
+        System.out.println( prefix + "-------------------------------------- BPage recid=" + _recid);
+        System.out.println( prefix + "first=" + _first );
+        for ( int i=0; i< _btree._pageSize; i++ ) {
+            if ( _isLeaf ) {
+                System.out.println( prefix + "BPage [" + i + "] " + _keys[ i ] + " " + _values[ i ] );
+            } else {
+                System.out.println( prefix + "BPage [" + i + "] " + _keys[ i ] + " " + _children[ i ] );
+            }
+        }
+        System.out.println( prefix + "--------------------------------------" );
+    }
+
+
+    /**
+     * Recursively dump the state of the BTree on screen.  This is used for
+     * debugging purposes only.
+     */
+    void dumpRecursive( int height, int level )
+        throws IOException
+    {
+        height -= 1;
+        level += 1;
+        if ( height > 0 ) {
+            for ( int i=_first; i<_btree._pageSize; i++ ) {
+                if ( _keys[ i ] == null ) break;
+                BPage<K,V> child = childBPage( i );
+                child.dump( level );
+                child.dumpRecursive( height, level );
+            }
+        }
+    }
+
+// 
+//   JAN KOTEK: assertConsistency was commented out, as it was not referenced from anywhere    
+//    /**
+//     * Assert the ordering of the keys on the BPage.  This is used for testing
+//     * purposes only.
+//     */
+//    private void assertConsistency()
+//    {
+//        for ( int i=_first; i<_btree._pageSize-1; i++ ) {
+//            if ( compare( (byte[]) _keys[ i ], (byte[]) _keys[ i+1 ] ) >= 0 ) {
+//                dump( 0 );
+//                throw new Error( "BPage not ordered" );
+//            }
+//        }
+//    }
+//
+//
+//    /**
+//     * Recursively assert the ordering of the BPage entries on this page
+//     * and sub-pages.  This is used for testing purposes only.
+//     */
+//    void assertConsistencyRecursive( int height ) 
+//        throws IOException 
+//    {
+//        assertConsistency();
+//        if ( --height > 0 ) {
+//            for ( int i=_first; i<_btree._pageSize; i++ ) {
+//                if ( _keys[ i ] == null ) break;
+//                BPage child = childBPage( i );
+//                if ( compare( (byte[]) _keys[ i ], child.getLargestKey() ) != 0 ) {
+//                    dump( 0 );
+//                    child.dump( 0 );
+//                    throw new Error( "Invalid child subordinate key" );
+//                }
+//                child.assertConsistencyRecursive( height );
+//            }
+//        }
+//    }
+
+
+    private static final int LEAF = Serialization.BPAGE_LEAF;
+    private static final int NOT_LEAF = Serialization.BPAGE_NONLEAF;
+    
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized Byte array representation of the object
+     * @return deserialized object
+     *
+     */
+    @SuppressWarnings("unchecked")
+	public BPage<K,V> deserialize( SerializerInput ois ) 
+        throws IOException
+    {
+    	
+
+      BPage<K,V> bpage = new BPage<K,V>();
+
+  	  switch(ois.read()){
+  		case LEAF:bpage._isLeaf = true;break;
+  		case NOT_LEAF:bpage._isLeaf = false;break;
+  		default: throw new InternalError("wrong BPage header");
+  	  }
+            
+      if ( bpage._isLeaf ) {
+          bpage._previous = LongPacker.unpackLong(ois);
+          bpage._next = LongPacker.unpackLong(ois);
+      }
+
+      
+      bpage._first = LongPacker.unpackInt(ois);
+
+      try {
+
+           bpage._keys = readKeys(ois,bpage._first);
+           
+      } catch ( ClassNotFoundException except ) {
+          throw new IOException( except.getMessage() );
+      }
+      
+      if ( bpage._isLeaf ) {
+          
+          try {
+              readValues(ois, bpage);
+          } catch ( ClassNotFoundException except ) {
+              throw new IOException( except);
+          }
+      } else {
+          bpage._children = new long[ _btree._pageSize ];
+          for ( int i=bpage._first; i<_btree._pageSize; i++ ) {
+              bpage._children[ i ] = LongPacker.unpackLong(ois);
+          }
+      }
+      
+      return bpage;
+
+    }
+
+    
+    /** 
+     * Serialize the content of an object into a byte array.
+     *
+     * @param obj Object to serialize
+     * @return a byte array representing the object's state
+     *
+     */
+    public void serialize(SerializerOutput oos, BPage<K,V> obj ) 
+        throws IOException
+    {
+
+        
+        // note:  It is assumed that BPage instance doing the serialization is the parent
+        // of the BPage object being serialized.
+        
+        BPage<K,V> bpage =  obj;
+        
+        oos.writeByte( bpage._isLeaf?LEAF:NOT_LEAF );
+        if ( bpage._isLeaf ) {
+            LongPacker.packLong(oos, bpage._previous );
+            LongPacker.packLong(oos, bpage._next );
+        }
+                
+        LongPacker.packInt(oos, bpage._first );
+
+       	writeKeys(oos, bpage._keys,bpage._first);        	
+
+        if ( bpage._isLeaf ) {
+        	writeValues(oos, bpage);
+        } else {
+            for ( int i=bpage._first; i<_btree._pageSize; i++ ) {
+            	LongPacker.packLong(oos,  bpage._children[ i ] );
+            }
+        }
+        
+    }
+    
+
+	private void readValues(DataInputStream ois, BPage<K, V> bpage) throws IOException, ClassNotFoundException {
+		  bpage._values = (V[]) new Object[ _btree._pageSize ];
+	
+		  if ( _btree.valueSerializer == null||   _btree.valueSerializer == DefaultSerializer.INSTANCE) {
+			  V[] vals= (V[]) Serialization.readObject(ois);
+			  for ( int i=bpage._first; i<_btree._pageSize; i++ ) {
+				  bpage._values[i] = vals[i - bpage._first];	  
+			  }
+		  }else{
+	          
+			  for ( int i=bpage._first; i<_btree._pageSize; i++ ) {                  
+		          byte[] serialized = readByteArray( ois );
+		          if ( serialized != null ) {
+		              bpage._values[ i ] = _btree.valueSerializer.deserialize( new SerializerInput( new ByteArrayInputStream(serialized)) );
+		          }
+		      }
+		  }
+	}
+
+
+	private void writeValues(SerializerOutput oos, BPage<K, V> bpage) throws IOException {
+		if ( _btree.valueSerializer == null || _btree.valueSerializer == DefaultSerializer.INSTANCE ) {
+			Object[] vals2 = Arrays.copyOfRange(bpage._values, bpage._first, bpage._values.length);
+			Serialization.writeObject(oos, vals2);
+		}else{
+			for ( int i=bpage._first; i<_btree._pageSize; i++ ) {                                                
+		        if ( bpage._values[ i ] != null ) {
+		        	ByteArrayOutputStream baos = new ByteArrayOutputStream();
+		            _btree.valueSerializer.serialize(new SerializerOutput(baos), bpage._values[ i ] );
+		            writeByteArray( oos, baos.toByteArray() );
+		        } else {
+		            writeByteArray( oos, null );
+		        }
+		    }
+		}
+	}
+
+
+	private static final int ALL_NULL = 0;
+	private static final int ALL_INTEGERS = 1 << 5;
+	private static final int ALL_INTEGERS_NEGATIVE = 2 <<5;
+	private static final int ALL_LONGS = 3 <<5;
+	private static final int ALL_LONGS_NEGATIVE = 4 <<5;
+	private static final int ALL_STRINGS = 5 <<5;
+	private static final int ALL_OTHER = 6 <<5;
+
+	
+	private K[] readKeys(SerializerInput ois, final int firstUse) throws IOException, ClassNotFoundException {
+		Object[] ret = new Object[_btree._pageSize];
+		final int type = ois.read();
+		if(type == ALL_NULL){
+			return (K[])ret;
+		}else if(type == ALL_INTEGERS || type == ALL_INTEGERS_NEGATIVE){
+			long first = LongPacker.unpackLong(ois);
+			if(type == ALL_INTEGERS_NEGATIVE)
+				first = -first;
+			ret[firstUse] = Integer.valueOf((int)first);
+			for(int i = firstUse+1;i<_btree._pageSize;i++){
+//				ret[i] = Serialization.readObject(ois);
+				long v = LongPacker.unpackLong(ois);
+				if(v == 0) continue; //null
+				v = v +first ;
+				ret[i] = Integer.valueOf((int)v);
+				first =v;
+			}
+			return (K[]) ret;
+		}else if(type == ALL_LONGS || type == ALL_LONGS_NEGATIVE){
+			long first = LongPacker.unpackLong(ois);
+			if(type == ALL_LONGS_NEGATIVE)
+				first = -first;
+
+			ret[firstUse] = Long.valueOf(first);
+			for(int i = firstUse+1;i<_btree._pageSize;i++){
+				//ret[i] = Serialization.readObject(ois);
+				long v = LongPacker.unpackLong(ois);
+				if(v == 0) continue; //null
+				v = v +first ;
+				ret[i] = Long.valueOf(v);
+				first = v;
+			}
+			return (K[]) ret;
+		}else if(type == ALL_STRINGS){			
+			byte[] previous = null;
+			for(int i = firstUse;i<_btree._pageSize;i++){
+				byte[] b = LeadingValueCompressionProvider.readByteArray(ois, previous, 0);
+				if(b == null ) continue;
+				ret[i] = new String(b);
+				previous = b;
+			}
+			return (K[]) ret;			
+			
+		}else if(type == ALL_OTHER){
+			if(_btree.keySerializer == null || _btree.keySerializer == DefaultSerializer.INSTANCE){
+				for (int i = firstUse ; i < _btree._pageSize; i++) {
+					ret[i] = DefaultSerializer.INSTANCE.deserialize(ois);
+				}			
+				return (K[]) ret;
+			}
+
+			
+			Serializer ser = _btree.keySerializer!=null? _btree.keySerializer : DefaultSerializer.INSTANCE;
+			OpenByteArrayInputStream in1 = null;
+			SerializerInput in2 = null;
+			byte[] previous = null;
+			for(int i = firstUse;i<_btree._pageSize;i++){
+				byte[] b = LeadingValueCompressionProvider.readByteArray(ois, previous, 0);
+				if(b == null ) continue;
+				if(in1 == null){
+					in1 = new OpenByteArrayInputStream(b);
+					in2 = new SerializerInput(in1);
+				}
+				in1.reset(b, b.length);
+				ret[i] = ser.deserialize(in2);
+				previous = b;
+			}
+			return (K[]) ret;			
+
+		}else{ 
+			throw new InternalError("unknown bpage header type: "+type);
+		}
+		
+	}
+    
+	
+	
+	@SuppressWarnings("unchecked")
+	private void writeKeys(SerializerOutput oos, K[] keys, final int firstUse) throws IOException {		
+		if(keys.length!=_btree._pageSize)
+			throw new IllegalArgumentException("wrong keys size");
+				
+		//check if all items on key are null
+		boolean allNull = true;
+		for (int i = firstUse ; i < _btree._pageSize; i++) {
+			if(keys[i]!=null){
+				allNull = false;
+				break;
+			}
+		}
+		if(allNull){
+			oos.write(ALL_NULL);
+			return;
+		}
+
+		/**
+		 * Special compression to compress Long and Integer
+		 */
+		if (_btree._comparator == ComparableComparator.INSTANCE && 
+				(_btree.keySerializer == null || _btree.keySerializer == DefaultSerializer.INSTANCE)) {
+			boolean allInteger = true;
+			for (int i = firstUse ; i <_btree._pageSize; i++) {
+				if (keys[i]!=null && keys[i].getClass() != Integer.class) {
+					allInteger = false;
+					break;
+				}
+			}
+			boolean allLong = true;
+			for (int i = firstUse ; i < _btree._pageSize; i++) {
+				if (keys[i]!=null &&  (keys[i].getClass() != Long.class ||
+						//special case to exclude Long.MIN_VALUE from conversion, causes problems to LongPacker
+					((Long)keys[i]).longValue() == Long.MIN_VALUE)
+				) {
+					allLong = false;
+					break;
+				}												
+			}
+			
+			if(allLong){
+				//check that diff between MIN and MAX fits into PACKED_LONG
+				long max = Long.MIN_VALUE;
+				long min = Long.MAX_VALUE;
+				for(int i = firstUse;i <_btree._pageSize;i++){
+					if(keys[i] == null) continue;
+					long v = (Long)keys[i];
+					if(v>max) max = v;
+					if(v<min) min = v;
+				}
+				//now convert to Double to prevent overflow errors
+				double max2 = max;
+				double min2 = min;
+				double maxDiff = Long.MAX_VALUE;
+				if(max2 - min2 >maxDiff/2) // divide by two just to by sure
+					allLong = false;
+				
+			}
+			
+			if(allLong && allInteger)
+				throw new InternalError();
+
+			if ( allLong || allInteger) {
+				long first = ((Number) keys[firstUse ]).longValue();
+				//write header
+				if(allInteger){ 
+					if(first>0)oos.write(ALL_INTEGERS );
+					else oos.write(ALL_INTEGERS_NEGATIVE );
+				}else if(allLong){
+					if(first>0)oos.write(ALL_LONGS );
+					else oos.write(ALL_LONGS_NEGATIVE );
+				}else{
+					throw new InternalError();
+				}
+				
+				//write first
+				LongPacker.packLong(oos,Math.abs(first));
+				//write others
+				for(int i = firstUse+1;i<_btree._pageSize;i++){
+//					Serialization.writeObject(oos, keys[i]);
+					if(keys[i] == null)
+						LongPacker.packLong(oos,0);
+					else{
+						long v = ((Number) keys[i]).longValue();
+						if(v<=first) throw new InternalError("not ordered");
+						LongPacker.packLong(oos, v-first);
+						first=  v;
+					}
+				}
+				return;
+			}else{
+				//another special case for Strings
+				boolean allString = true;
+				for (int i = firstUse ; i < _btree._pageSize; i++) {
+					if (keys[i]!=null &&  (keys[i].getClass() != String.class)
+					) {
+						allString = false;
+						break;
+					}												
+				}
+				if(allString){
+					oos.write(ALL_STRINGS );
+					byte[] previous = null;
+					for (int i = firstUse ; i < _btree._pageSize; i++) {
+						if(keys[i] == null){
+							LeadingValueCompressionProvider.writeByteArray(oos, null, previous, 0);
+						}else{
+							byte[] b = ((String)keys[i]).getBytes();
+							LeadingValueCompressionProvider.writeByteArray(oos, b, previous, 0);
+							previous = b;
+						}
+					}
+					return;
+				}
+			}
+		}
+		
+		/**
+		 * other case, serializer is provided or other stuff
+		 */
+		oos.write(ALL_OTHER );
+		if(_btree.keySerializer == null || _btree.keySerializer == DefaultSerializer.INSTANCE){
+			for (int i = firstUse ; i < _btree._pageSize; i++) {
+				DefaultSerializer.INSTANCE.serialize(oos, keys[i]);
+			}		
+			return;
+		}
+		
+		//custom serializer is provided, use it
+		
+		Serializer ser = _btree.keySerializer;
+		byte[] previous = null;
+		byte[] buffer = new byte[1024];
+		OpenByteArrayOutputStream out2 = new OpenByteArrayOutputStream(buffer);
+		SerializerOutput out3 = new SerializerOutput(out2);
+		for (int i = firstUse ; i < _btree._pageSize; i++) {
+			if(keys[i] == null){
+				LeadingValueCompressionProvider.writeByteArray(oos, null, previous, 0);
+			}else{
+				out2.reset();
+				ser.serialize(out3,keys[i]);
+				byte[] b = out2.toByteArray();
+				LeadingValueCompressionProvider.writeByteArray(oos, b, previous, 0);
+				previous = b;
+			}			
+		}
+			
+		return;
+		
+		
+	}
+
+
+
+	/** STATIC INNER CLASS
+     *  Result from insert() method call
+     */
+    static class InsertResult<K,V> {
+
+        /**
+         * Overflow page.
+         */
+        BPage<K,V> _overflow;
+
+        /**
+         * Existing value for the insertion key.
+         */
+        V _existing;
+
+    }
+
+    /** STATIC INNER CLASS
+     *  Result from remove() method call
+     */
+    static class RemoveResult<K,V> {
+
+        /**
+         * Set to true if underlying pages underflowed
+         */
+        boolean _underflow;
+
+        /**
+         * Removed entry value
+         */
+        V _value;
+    }
+
+
+    /** PRIVATE INNER CLASS
+     * Browser to traverse leaf BPages.
+     */
+    static class Browser<K,V>
+        implements TupleBrowser<K,V>
+    {
+
+        /**
+         * Current page.
+         */
+        private BPage<K,V> _page;
+
+
+        /**
+         * Current index in the page.  The index positionned on the next
+         * tuple to return.
+         */
+        private int _index;
+
+
+        /**
+         * Create a browser.
+         *
+         * @param page Current page
+         * @param index Position of the next tuple to return.
+         */
+        Browser( BPage<K,V> page, int index )
+        {
+            _page = page;
+            _index = index;
+        }
+
+        public boolean getNext( Tuple<K,V> tuple )
+            throws IOException
+        {
+            if ( _index < _page._btree._pageSize ) {
+                if ( _page._keys[ _index ] == null ) {
+                    // reached end of the tree.
+                    return false;
+                }
+            } else if ( _page._next != 0 ) {
+                // move to next page
+                _page = _page.loadBPage( _page._next );
+                _index = _page._first;
+            }
+            tuple.setKey( _page._keys[ _index ] );
+            tuple.setValue(  _page._values[ _index ] );
+            _index++;
+            return true;
+        }
+
+        public boolean getPrevious( Tuple<K,V> tuple )
+            throws IOException
+        {
+            if ( _index == _page._first ) {
+
+                if ( _page._previous != 0 ) {
+                    _page = _page.loadBPage( _page._previous );
+                    _index = _page._btree._pageSize;
+                } else {
+                    // reached beginning of the tree
+                    return false;
+                }
+            }
+            _index--;
+            tuple.setKey( _page._keys[ _index ] );
+            tuple.setValue(  _page._values[ _index ] );
+            return true;
+
+        }
+    }    
+
+    /**
+     * Used for debugging and testing only.  Recursively obtains the recids of
+     * all child BPages and adds them to the 'out' list.
+     * @param out
+     * @param height
+     * @throws IOException
+     */
+    void dumpChildPageRecIDs(List out, int height)
+    throws IOException
+    {
+        height -= 1;
+        if ( height > 0 ) {
+            for ( int i=_first; i<_btree._pageSize; i++ ) {
+                if ( _children[ i ] == RecordManager.NULL_RECID ) continue;
+                
+                BPage child = childBPage( i );
+                out.add(new Long(child._recid));
+                child.dumpChildPageRecIDs( out, height );
+            }
+        }
+    }
+    
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTree.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTree.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,730 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.btree;
+
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import jdbm.RecordListener;
+import jdbm.RecordManager;
+import jdbm.Serializer;
+import jdbm.helper.ComparableComparator;
+import jdbm.helper.JdbmBase;
+import jdbm.helper.Tuple;
+import jdbm.helper.TupleBrowser;
+
+/**
+ * B+Tree persistent indexing data structure.  B+Trees are optimized for
+ * block-based, random I/O storage because they store multiple keys on
+ * one tree node (called <code>BPage</code>).  In addition, the leaf nodes
+ * directly contain (inline) the values associated with the keys, allowing a
+ * single (or sequential) disk read of all the values on the page.
+ * <p>
+ * B+Trees are n-airy, yeilding log(N) search cost.  They are self-balancing,
+ * preventing search performance degradation when the size of the tree grows.
+ * <p>
+ * Keys and associated values must be <code>Serializable</code> objects. The
+ * user is responsible to supply a serializable <code>Comparator</code> object
+ * to be used for the ordering of entries, which are also called <code>Tuple</code>.
+ * The B+Tree allows traversing the keys in forward and reverse order using a
+ * TupleBrowser obtained from the browse() methods.
+ * <p>
+ * This implementation does not directly support duplicate keys, but it is
+ * possible to handle duplicates by inlining or referencing an object collection
+ * as a value.
+ * <p>
+ * There is no limit on key size or value size, but it is recommended to keep
+ * both as small as possible to reduce disk I/O.   This is especially true for
+ * the key size, which impacts all non-leaf <code>BPage</code> objects.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @version $Id: BTree.java,v 1.6 2005/06/25 23:12:31 doomdark Exp $
+ */
+public class BTree<K,V> 
+    implements Externalizable, JdbmBase<K,V>
+{
+
+    private static final long serialVersionUID = 8883213742777032628L;
+
+    private static final boolean DEBUG = false;
+
+
+
+    /**
+     * Default page size (number of entries per node)
+     */
+    public static final int DEFAULT_SIZE = 32;
+
+
+    /**
+     * Page manager used to persist changes in BPages
+     */
+    protected transient RecordManager _recman;
+
+
+    /**
+     * This BTree's record ID in the PageManager.
+     */
+    private transient long _recid;
+
+
+    /**
+     * Comparator used to index entries.
+     */
+    protected Comparator<K> _comparator;
+
+
+    /**
+     * Serializer used to serialize index keys (optional)
+     */
+    protected Serializer<K> keySerializer;
+
+
+    /**
+     * Serializer used to serialize index values (optional)
+     */
+    protected Serializer<V> valueSerializer;
+
+
+    public Serializer<K> getKeySerializer() {
+		return keySerializer;
+	}
+
+
+	public void setKeySerializer(Serializer<K> keySerializer) {
+		this.keySerializer = keySerializer;
+	}
+
+
+	public Serializer<V> getValueSerializer() {
+		return valueSerializer;
+	}
+
+
+	public void setValueSerializer(Serializer<V> valueSerializer) {
+		this.valueSerializer = valueSerializer;
+	}
+
+	/**
+     * Height of the B+Tree.  This is the number of BPages you have to traverse
+     * to get to a leaf BPage, starting from the root.
+     */
+    private int _height;
+
+
+    /**
+     * Recid of the root BPage
+     */
+    private transient long _root;
+
+
+    /**
+     * Number of entries in each BPage.
+     */
+    protected int _pageSize;
+
+
+    /**
+     * Total number of entries in the BTree
+     */
+    protected volatile int _entries;
+
+    
+    /**
+     * Serializer used for BPages of this tree
+     */
+    private transient BPage<K,V> _bpageSerializer;
+    
+    
+    /**
+     * Listeners which are notified about changes in records
+     */
+    protected List<RecordListener<K,V>> recordListeners = new CopyOnWriteArrayList<RecordListener<K, V>>();
+    
+    protected ReadWriteLock lock = new ReentrantReadWriteLock();
+
+    /**
+     * No-argument constructor used by serialization.
+     */
+    public BTree()
+    {
+        // empty
+    }
+
+
+    /**
+     * Create a new persistent BTree, with 16 entries per node.
+     *
+     * @param recman Record manager used for persistence.
+     * @param comparator Comparator used to order index entries
+     */
+    public static <K,V> BTree<K,V> createInstance( RecordManager recman,
+                                        Comparator<K> comparator)
+        throws IOException
+    {
+        return createInstance( recman, comparator, null, null, DEFAULT_SIZE );
+    }
+    
+    /**
+     * Create a new persistent BTree, with 16 entries per node.
+     *
+     * @param recman Record manager used for persistence.
+     * @param comparator Comparator used to order index entries
+     */
+    @SuppressWarnings("unchecked")
+	public static <K extends Comparable,V> BTree<K,V> createInstance( RecordManager recman)
+        throws IOException
+    {
+    	BTree<K,V> ret = createInstance( recman, ComparableComparator.INSTANCE, null, null, DEFAULT_SIZE ); 
+        return ret;
+    }
+
+
+
+    /**
+     * Create a new persistent BTree, with 16 entries per node.
+     *
+     * @param recman Record manager used for persistence.
+     * @param keySerializer Serializer used to serialize index keys (optional)
+     * @param valueSerializer Serializer used to serialize index values (optional)
+     * @param comparator Comparator used to order index entries
+     */
+    public static <K,V> BTree<K,V> createInstance( RecordManager recman,
+                                        Comparator<K> comparator,
+                                        Serializer<K> keySerializer,
+                                        Serializer<V> valueSerializer )
+        throws IOException
+    {
+        return createInstance( recman, comparator, keySerializer, 
+                               valueSerializer, DEFAULT_SIZE );
+    }
+
+
+    /**
+     * Create a new persistent BTree with the given number of entries per node.
+     *
+     * @param recman Record manager used for persistence.
+     * @param comparator Comparator used to order index entries
+     * @param keySerializer Serializer used to serialize index keys (optional)
+     * @param valueSerializer Serializer used to serialize index values (optional)
+     * @param pageSize Number of entries per page (must be even).
+     */
+    public static <K,V> BTree<K,V> createInstance( RecordManager recman,
+                                        Comparator<K> comparator,
+                                        Serializer<K> keySerializer,
+                                        Serializer<V> valueSerializer,
+                                        int pageSize )
+        throws IOException
+    {
+        BTree<K,V> btree;
+
+        if ( recman == null ) {
+            throw new IllegalArgumentException( "Argument 'recman' is null" );
+        }
+
+        if ( comparator == null ) {
+            throw new IllegalArgumentException( "Argument 'comparator' is null" );
+        }
+        if ( ! ( comparator instanceof Serializable ) ) {
+            throw new IllegalArgumentException( "Argument 'comparator' must be serializable" );
+        }
+
+
+        // make sure there's an even number of entries per BPage
+        if ( ( pageSize & 1 ) != 0 ) {
+            throw new IllegalArgumentException( "Argument 'pageSize' must be even" );
+        }
+
+        btree = new BTree<K,V>();
+        btree._recman = recman;
+        btree._comparator = comparator;
+        btree.keySerializer = keySerializer;
+        btree.valueSerializer = valueSerializer;
+        btree._pageSize = pageSize;
+        btree._bpageSerializer = new BPage<K,V>();
+        btree._bpageSerializer._btree = btree;
+        btree._recid = recman.insert( btree );
+        return btree;
+    }
+
+
+    /**
+     * Load a persistent BTree.
+     *
+     * @param recman RecordManager used to store the persistent btree
+     * @param recid Record id of the BTree
+     */
+    @SuppressWarnings("unchecked")
+	public static <K,V> BTree<K,V> load( RecordManager recman, long recid )
+        throws IOException
+    {
+        BTree<K,V> btree = (BTree<K,V>) recman.fetch( recid );
+        btree._recid = recid;
+        btree._recman = recman;
+        btree._bpageSerializer = new BPage<K,V>();
+        btree._bpageSerializer._btree = btree;
+        return btree;
+    }
+    
+    /**
+     * Get the {@link ReadWriteLock} associated with this BTree.
+     * This should be used with browsing operations to ensure
+     * consistency.
+     * @return
+     */
+    public ReadWriteLock getLock() {
+		return lock;
+	}
+
+    /**
+     * Insert an entry in the BTree.
+     * <p>
+     * The BTree cannot store duplicate entries.  An existing entry can be
+     * replaced using the <code>replace</code> flag.   If an entry with the
+     * same key already exists in the BTree, its value is returned.
+     *
+     * @param key Insert key
+     * @param value Insert value
+     * @param replace Set to true to replace an existing key-value pair.
+     * @return Existing value, if any.
+     */
+    public V insert(final K key, final V value,
+                                       final boolean replace )
+        throws IOException
+    {
+        if ( key == null ) {
+            throw new IllegalArgumentException( "Argument 'key' is null" );
+        }
+        if ( value == null ) {
+            throw new IllegalArgumentException( "Argument 'value' is null" );
+        }
+        try {
+        	lock.writeLock().lock();
+	        BPage<K,V> rootPage = getRoot();
+	
+	        if ( rootPage == null ) {
+	            // BTree is currently empty, create a new root BPage
+	            if (DEBUG) {
+	                System.out.println( "BTree.insert() new root BPage" );
+	            }
+	            rootPage = new BPage<K,V>( this, key, value );
+	            _root = rootPage._recid;
+	            _height = 1;
+	            _entries = 1;
+	            _recman.update( _recid, this );
+	            //notifi listeners
+	            for(RecordListener<K,V> l : recordListeners){
+	            	l.recordInserted(key, value);
+	            }
+	            return null;
+            } else {
+	        BPage.InsertResult<K,V> insert = rootPage.insert( _height, key, value, replace );
+            boolean dirty = false;
+            if ( insert._overflow != null ) {
+                // current root page overflowed, we replace with a new root page
+                if ( DEBUG ) {
+                    System.out.println( "BTree.insert() replace root BPage due to overflow" );
+                }
+                rootPage = new BPage<K,V>( this, rootPage, insert._overflow );
+                _root = rootPage._recid;
+                _height += 1;
+                dirty = true;
+            }
+            if ( insert._existing == null ) {
+                _entries++;
+                dirty = true;
+            }
+            if ( dirty ) {
+                _recman.update( _recid, this );
+            }
+            //notify listeners
+            for(RecordListener<K,V> l : recordListeners){
+            	if(insert._existing==null)
+            		l.recordInserted(key, value);
+            	else
+            		l.recordUpdated(key, insert._existing, value);
+            }
+
+            // insert might have returned an existing value
+            return insert._existing;
+           }
+        } finally {
+        	lock.writeLock().unlock();
+        }
+    }
+
+
+    /**
+     * Remove an entry with the given key from the BTree.
+     *
+     * @param key Removal key
+     * @return Value associated with the key, or null if no entry with given
+     *         key existed in the BTree.
+     */
+    public V remove( K key )
+        throws IOException
+    {
+        if ( key == null ) {
+            throw new IllegalArgumentException( "Argument 'key' is null" );
+        }
+        try {
+        	lock.writeLock().lock();
+	        BPage<K,V> rootPage = getRoot();
+	        if ( rootPage == null ) {
+	            return null;
+	        }
+	        boolean dirty = false;
+	        BPage.RemoveResult<K,V> remove = rootPage.remove( _height, key );
+	        if ( remove._underflow && rootPage.isEmpty() ) {
+	            _height -= 1;
+	            dirty = true;
+	
+	            // TODO:  check contract for BPages to be removed from recman.
+	            if ( _height == 0 ) {
+	                _root = 0;
+	            } else {
+	                _root = rootPage.childBPage( _pageSize-1 )._recid;
+	            }
+	        }
+	        if ( remove._value != null ) {
+	            _entries--;
+	            dirty = true;
+	        }
+	        if ( dirty ) {
+	            _recman.update( _recid, this );
+	        }
+	        if(remove._value!=null)
+	        	for(RecordListener<K,V> l : recordListeners)
+	        		l.recordRemoved(key,remove._value);
+	        return remove._value;
+        } finally {
+        	lock.writeLock().unlock();
+        }
+    }
+
+
+    /**
+     * Find the value associated with the given key.
+     *
+     * @param key Lookup key.
+     * @return Value associated with the key, or null if not found.
+     */
+    public V find( K key )
+        throws IOException
+    {
+        if ( key == null ) {
+            throw new IllegalArgumentException( "Argument 'key' is null" );
+        }
+        try {
+        	lock.readLock().lock();
+	        BPage<K,V> rootPage = getRoot();
+	        if ( rootPage == null ) {
+	            return null;
+	        }
+	
+	        return rootPage.findValue( _height, key );
+        } finally {
+        	lock.readLock().unlock();
+        }
+//        Tuple<K,V> tuple = new Tuple<K,V>( null, null );
+//        TupleBrowser<K,V> browser = rootPage.find( _height, key );
+//
+//        if ( browser.getNext( tuple ) ) {
+//            // find returns the matching key or the next ordered key, so we must
+//            // check if we have an exact match
+//            if ( _comparator.compare( key, tuple.getKey() ) != 0 ) {
+//                return null;
+//            } else {
+//                return tuple.getValue();
+//            }
+//        } else {
+//            return null;
+//        }
+    }
+
+
+    /**
+     * Find the value associated with the given key, or the entry immediately
+     * following this key in the ordered BTree.
+     *
+     * @param key Lookup key.
+     * @return Value associated with the key, or a greater entry, or null if no
+     *         greater entry was found.
+     */
+    public Tuple<K,V> findGreaterOrEqual( K key )
+        throws IOException
+    {
+        Tuple<K,V>         tuple;
+        TupleBrowser<K,V>  browser;
+
+        if ( key == null ) {
+            // there can't be a key greater than or equal to "null"
+            // because null is considered an infinite key.
+            return null;
+        }
+
+        tuple = new Tuple<K,V>( null, null );
+        browser = browse( key );
+        if ( browser.getNext( tuple ) ) {
+            return tuple;
+        } else {
+            return null;
+        }
+    }
+
+
+    /**
+     * Get a browser initially positioned at the beginning of the BTree.
+     * <p><b>
+     * WARNING: ?If you make structural modifications to the BTree during
+     * browsing, you will get inconsistent browing results.
+     * </b>
+     *
+     * @return Browser positionned at the beginning of the BTree.
+     */
+    @SuppressWarnings("unchecked")
+	public TupleBrowser<K,V> browse()
+        throws IOException
+    {
+    	try {
+        	lock.readLock().lock();
+	        BPage<K,V> rootPage = getRoot();
+	        if ( rootPage == null ) {
+	            return EmptyBrowser.INSTANCE;
+	        }
+	        TupleBrowser<K,V> browser = rootPage.findFirst();
+	        return browser;
+    	} finally {
+    		lock.readLock().unlock();
+    	}
+    }
+
+
+    /**
+     * Get a browser initially positioned just before the given key.
+     * <p><b>
+     * WARNING: ?If you make structural modifications to the BTree during
+     * browsing, you will get inconsistent browing results.
+     * </b>
+     *
+     * @param key Key used to position the browser.  If null, the browser
+     *            will be positionned after the last entry of the BTree.
+     *            (Null is considered to be an "infinite" key)
+     * @return Browser positionned just before the given key.
+     */
+    @SuppressWarnings("unchecked")
+	public TupleBrowser<K,V> browse( K key )
+        throws IOException
+    {
+    	try {
+        	lock.readLock().lock();
+	    	BPage<K,V> rootPage = getRoot();
+	        if ( rootPage == null ) {
+	            return EmptyBrowser.INSTANCE;
+	        }
+	        TupleBrowser<K,V> browser = rootPage.find( _height, key );
+	        return browser;
+    	} finally {
+    		lock.readLock().unlock();
+    	}
+    }
+
+
+    /**
+     * Return the number of entries (size) of the BTree.
+     */
+    public int size()
+    {
+        return _entries;
+    }
+
+
+    /**
+     * Return the persistent record identifier of the BTree.
+     */
+    public long getRecid()
+    {
+        return _recid;
+    }
+
+
+    /**
+     * Return the root BPage, or null if it doesn't exist.
+     */
+    BPage<K,V> getRoot()
+        throws IOException
+    {
+        if ( _root == 0 ) {
+            return null;
+        }
+        BPage<K,V> root = (BPage<K,V>) _recman.fetch( _root, _bpageSerializer );
+        if (root != null) {
+            root._recid = _root;
+            root._btree = this;
+        }
+        return root;
+    }
+
+    /**
+     * Implement Externalizable interface.
+     */
+    @SuppressWarnings("unchecked")
+	public void readExternal( ObjectInput in )
+        throws IOException, ClassNotFoundException
+    {
+        _comparator = (Comparator<K>) in.readObject();
+      //serializer is not persistent from 2.0        
+//        _keySerializer = (Serializer<K>) in.readObject();
+//        _valueSerializer = (Serializer<V>) in.readObject();
+        _height = in.readInt();
+        _root = in.readLong();
+        _pageSize = in.readInt();
+        _entries = in.readInt();
+    }
+
+
+    /**
+     * Implement Externalizable interface.
+     */
+    public void writeExternal( ObjectOutput out )
+        throws IOException
+    {
+        out.writeObject( _comparator );
+        //serializer is not persistent from 2.0         
+//        out.writeObject( _keySerializer );
+//        out.writeObject( _valueSerializer );
+        out.writeInt( _height );
+        out.writeLong( _root );
+        out.writeInt( _pageSize );
+        out.writeInt( _entries );
+    }
+
+
+    /*
+    public void assert() throws IOException {
+        BPage root = getRoot();
+        if ( root != null ) {
+            root.assertRecursive( _height );
+        }
+    }
+    */
+
+
+    /*
+    public void dump() throws IOException {
+        BPage root = getRoot();
+        if ( root != null ) {
+            root.dumpRecursive( _height, 0 );
+        }
+    }
+    */
+
+
+    /** PRIVATE INNER CLASS
+     *  Browser returning no element.
+     */
+    static class EmptyBrowser<K,V>
+    	implements TupleBrowser<K,V>    {
+
+        @SuppressWarnings("unchecked")
+		static TupleBrowser INSTANCE = new EmptyBrowser();
+        
+        private EmptyBrowser(){}
+
+        public boolean getNext( Tuple<K,V> tuple )
+        {
+            return false;
+        }
+
+        public boolean getPrevious( Tuple<K,V> tuple )
+        {
+            return false;
+        }
+    }
+    
+    public BTreeSortedMap<K,V> asMap(){
+    	return new BTreeSortedMap<K, V>(this,false);
+    }
+    
+    /**
+     * add RecordListener which is notified about record changes
+     * @param listener
+     */
+    public void addRecordListener(RecordListener<K,V> listener){
+    	recordListeners.add(listener);
+    }
+
+    /**
+     * remove RecordListener which is notified about record changes
+     * @param listener
+     */
+    public void removeRecordListener(RecordListener<K,V> listener){
+    	recordListeners.remove(listener);
+    }
+
+
+	public RecordManager getRecordManager() {
+		return _recman;
+	}
+	
+
+    public Comparator<K> getComparator() {
+        return _comparator;
+    }
+
+    /** 
+     * Deletes all BPages in this BTree, then deletes the tree from the record manager
+     */
+    public void delete()
+        throws IOException
+    {
+    	try {
+        	lock.writeLock().lock();
+	        BPage<K,V> rootPage = getRoot();
+	        if (rootPage != null)
+	            rootPage.delete();
+	        _recman.delete(_recid);
+    	} finally {
+    		lock.writeLock().unlock();
+    	}
+    }
+    
+    /**
+     * Used for debugging and testing only.  Populates the 'out' list with
+     * the recids of all child pages in the BTree.
+     * @param out
+     * @throws IOException
+     */
+    void dumpChildPageRecIDs(List<Long> out) throws IOException{
+        BPage<K,V> root = getRoot();
+        if ( root != null ) {
+            out.add(root._recid);
+            root.dumpChildPageRecIDs( out, _height);
+        }
+    }
+ }
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSecondarySortedMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSecondarySortedMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,46 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.btree;
+
+import java.io.IOError;
+import java.io.IOException;
+
+import jdbm.SecondaryTreeMap;
+import jdbm.helper.JdbmBase;
+import jdbm.helper.SecondaryKeyHelper;
+
+public class BTreeSecondarySortedMap<A,K,V> extends BTreeSortedMap<A,Iterable<K>> 
+	implements SecondaryTreeMap<A,K,V>{
+
+	protected final JdbmBase<K,V > b;
+	public BTreeSecondarySortedMap(BTree<A, Iterable<K>> tree, JdbmBase<K,V> b) {
+		super(tree, true);
+		this.b = b;
+	}
+	
+	public V getPrimaryValue(K k) {		
+		try {
+			return b.find(k);
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+	}
+
+	public Iterable<V> getPrimaryValues(A a) { 
+		return SecondaryKeyHelper.translateIterable(b, get(a));
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSortedMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSortedMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,367 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.btree;
+
+import java.io.IOError;
+import java.io.IOException;
+import java.util.AbstractSet;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.SortedMap;
+
+import jdbm.PrimaryTreeMap;
+import jdbm.RecordListener;
+import jdbm.RecordManager;
+import jdbm.helper.AbstractPrimaryMap;
+import jdbm.helper.Tuple;
+import jdbm.helper.TupleBrowser;
+
+
+public class BTreeSortedMap<K,V> extends AbstractPrimaryMap<K,V> implements PrimaryTreeMap<K,V>{
+	
+	protected final BTree<K,V> tree;
+	
+	protected final K fromKey;
+	
+	protected final K toKey;
+	
+	protected final boolean readonly;
+	
+	public BTreeSortedMap(BTree<K,V> tree, boolean readonly){
+		this(tree,readonly, null,null);
+	}
+	
+	protected BTreeSortedMap(BTree<K,V> tree, boolean readonly, K fromKey, K toKey){
+		this.tree = tree;
+		this.fromKey = fromKey;
+		this.toKey = toKey;
+		this.readonly = readonly;
+	}
+
+	@Override
+	public Set<java.util.Map.Entry<K, V>> entrySet() {
+		return new AbstractSet<Entry<K,V>>(){
+			
+			protected Entry<K,V> newEntry(K k,V v){
+				return new SimpleEntry<K,V>(k,v){
+					private static final long serialVersionUID = 978651696969194154L;
+
+					public V setValue(V arg0) {
+						BTreeSortedMap.this.put(getKey(), arg0);
+						return super.setValue(arg0);
+					};
+					
+				};
+			}
+
+			public boolean add(java.util.Map.Entry<K, V> e) {
+				if(readonly)
+					throw new UnsupportedOperationException("readonly");
+				
+				try {
+					if(e.getKey() == null)
+						throw new NullPointerException("Can not add null key");
+					if(!inBounds(e.getKey()))
+						throw new IllegalArgumentException("key outside of bounds");
+					return tree.insert(e.getKey(), e.getValue(), true) == null;
+				} catch (IOException e1) {
+					throw new IOError(e1);
+				}
+			}
+
+			@SuppressWarnings("unchecked")
+			public boolean contains(Object o) {
+				
+				if(o instanceof Entry){
+					Entry<K,V> e = (java.util.Map.Entry<K, V>) o;
+					try {
+						if(!inBounds(e.getKey()))
+							return false;
+						if(e.getKey()!=null && tree.find(e.getKey())!=null)
+							return true;
+					} catch (IOException e1) {
+						throw new IOError(e1);
+					}
+				}
+				return false;
+			}
+
+
+			public Iterator<java.util.Map.Entry<K, V>> iterator() {
+				try {
+					final TupleBrowser<K,V> br = fromKey==null ? 
+							tree.browse() : tree.browse(fromKey);				
+				return new Iterator<Entry<K,V>>(){
+					
+					private Entry<K,V> next;
+					private K lastKey;
+					void ensureNext(){
+						try{
+							Tuple<K,V> t = new Tuple<K,V>();	
+							if(br.getNext(t) && inBounds(t.getKey()))
+								next = newEntry(t.getKey(),t.getValue());
+							else
+								next = null;
+						} catch (IOException e1) {
+							throw new IOError(e1);
+						}						
+					}
+					{
+						ensureNext();
+					}
+					
+					
+
+					public boolean hasNext() {
+						return next!=null;
+					}
+
+					public java.util.Map.Entry<K, V> next() {
+						if(next == null)
+							throw new NoSuchElementException();
+						Entry<K,V> ret = next;
+						lastKey = ret.getKey();
+						//move to next position
+						ensureNext();
+						return ret;
+					}
+
+					public void remove() {
+						if(readonly)
+							throw new UnsupportedOperationException("readonly");
+						
+						if(lastKey == null)
+							throw new IllegalStateException();
+
+							BTreeSortedMap.this.remove(lastKey);
+							lastKey = null;
+					}};
+					
+				} catch (IOException e) {
+					throw new IOError(e);
+				}
+					
+			}
+
+			@SuppressWarnings("unchecked")
+			public boolean remove(Object o) {
+				if(readonly)
+					throw new UnsupportedOperationException("readonly");
+				
+				if(o instanceof Entry){
+					Entry<K,V> e = (java.util.Map.Entry<K, V>) o;
+					try {
+						//check for nulls
+						if(e.getKey() == null || e.getValue() == null)
+							return false;
+						if(!inBounds(e.getKey()))
+							throw new IllegalArgumentException("out of bounds");
+						//find old value, must be same as item in entry
+						V v = get(e.getKey());
+						if(v == null || !e.getValue().equals(v))
+							return false;
+						V v2 = tree.remove(e.getKey());
+						return v2!=null;
+					} catch (IOException e1) {
+						throw new IOError(e1);
+					}
+				}
+				return false;
+
+			}
+
+
+
+			@SuppressWarnings("unchecked")
+			public int size() {
+				if(fromKey == null && toKey == null)
+					return tree.size();
+				else{
+					int counter = 0;
+					Iterator i = iterator();
+					while(i.hasNext()){
+						i.next();
+						counter++;
+					}
+					return counter;									
+				}
+			}
+
+		};
+	}
+	
+	public boolean inBounds(K e) {
+		if(fromKey!=null && comparator().compare(e,fromKey)<0)
+			return false;
+		if(toKey!=null && comparator().compare(e,toKey)>=0)
+			return false;
+		return true;
+	}
+
+	@SuppressWarnings("unchecked")
+	@Override
+	public V get(Object key) {
+		try{
+			if(key == null)
+				return null;
+			if(!inBounds((K)key))
+				return null;
+			return tree.find((K) key);
+		}catch (ClassCastException e){
+			return null;
+		}catch (IOException e){
+			throw new IOError(e);
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	@Override
+	public V remove(Object key) {
+		if(readonly)
+			throw new UnsupportedOperationException("readonly");
+		
+		try{
+			if(key == null || tree.find((K) key)== null)
+				return null;
+			if(!inBounds((K) key))
+				throw new IllegalArgumentException("out of bounds");
+			return tree.remove((K) key);
+		}catch (ClassCastException e){
+			return null;
+		}catch (IOException e){
+			throw new IOError(e);
+		}
+	}
+	
+	public V put(K key, V value) {
+		if(readonly)
+			throw new UnsupportedOperationException("readonly");
+		
+		try {
+			if(key == null || value == null)
+				throw new NullPointerException("Null key or value");
+			if(!inBounds(key))
+				throw new IllegalArgumentException("out of bounds");
+			return tree.insert(key, value, true);
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+	};
+	
+	@SuppressWarnings("unchecked")
+	@Override
+	public boolean containsKey(Object key) {
+		if(key == null)
+			return false;
+		try {
+			if(!inBounds((K) key))
+				return false;
+			V v = tree.find((K) key);
+			return v!=null;
+		} catch (IOException e) {
+			throw new IOError(e);
+		} catch (ClassCastException e){
+			return false;
+		}
+	}
+
+	public Comparator<? super K> comparator() {
+		return tree._comparator;
+	}
+
+	public K firstKey() {
+		if(size() == 0)
+			throw new NoSuchElementException();
+		try{
+			TupleBrowser<K,V> b = fromKey==null?tree.browse():tree.browse(fromKey);
+			Tuple<K,V> t = new Tuple<K,V>();
+			b.getNext(t);
+			return t.getKey();
+		}catch(IOException e){
+			throw new IOError(e);
+		}
+	}
+	
+	public K lastKey() {
+		if(size() == 0)
+			throw new NoSuchElementException();
+		try{
+			TupleBrowser<K,V> b = toKey==null?tree.browse(null):tree.browse(toKey);
+			Tuple<K,V> t = new Tuple<K,V>();
+			b.getPrevious(t);
+			return t.getKey();
+		}catch(IOException e){
+			throw new IOError(e);
+		}
+	}
+
+
+	public SortedMap<K, V> headMap(K toKey) {
+		return new BTreeSortedMap<K, V>(tree, readonly,null, toKey);
+	}
+
+
+	public SortedMap<K, V> subMap(K fromKey, K toKey) {
+		if(comparator().compare(fromKey,toKey)>0)
+			throw new IllegalArgumentException("fromKey is bigger then toKey");
+		return new BTreeSortedMap<K, V>(tree, readonly,fromKey, toKey);
+	}
+
+	public SortedMap<K, V> tailMap(K fromKey) {
+		return new BTreeSortedMap<K, V>(tree, readonly,fromKey, null);
+	}
+
+	public BTree<K, V> getTree() {
+		return tree;
+	}
+
+
+
+	public void addRecordListener(RecordListener<K, V> listener) {
+		tree.addRecordListener(listener);
+	}
+
+	public RecordManager getRecordManager() {
+		return tree.getRecordManager();
+	}
+
+	public void removeRecordListener(RecordListener<K, V> listener) {
+		tree.removeRecordListener(listener);
+	}
+
+	public Integer newIntegerKey() {
+		if(isEmpty())
+			return  new Integer(0);
+		K k = lastKey();
+		return  new Integer(((Integer)k).intValue()+1);
+	}
+
+	public Long newLongKey() {
+		if(isEmpty())
+			return  new Long(0);
+		K k = lastKey();
+		return new Long(((Long)k).longValue()+1);
+	}
+
+    public void clear(){
+        Iterator<K> keyIter = keySet().iterator();
+        while(keyIter.hasNext())
+            remove(keyIter.next());
+    }
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/LeadingValueCompressionProvider.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/LeadingValueCompressionProvider.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,124 @@
+package jdbm.btree;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import jdbm.helper.LongPacker;
+
+
+
+/**
+ * Provider for implementations {@link ByteArrayCompressor}suitable for storing
+ * binary data, {@link BinaryCompressionProvider}, or {@link String} data,
+ * {@link StringCompressionProvider}.
+ * 
+ * @author Kevin Day
+ */
+
+class LeadingValueCompressionProvider {
+
+
+	/**
+	 * Read previously written data
+	 */	
+    static byte[] readByteArray( DataInputStream in, byte[] previous, int ignoreLeadingCount ) throws IOException
+	{
+	    int len = LongPacker.unpackInt(in) -1;
+	    if (len == -1)
+	    	return null;
+	    
+	    int actualCommon = 0;
+	    
+    	actualCommon = LongPacker.unpackInt(in);
+
+	    
+	    byte[] buf = new byte[ len ];
+
+	    if (previous == null){
+	    	actualCommon = 0;
+	    }
+	    
+	    
+    	if (actualCommon > 0){
+    		in.readFully( buf, 0, ignoreLeadingCount);
+    		System.arraycopy(previous, ignoreLeadingCount, buf, ignoreLeadingCount, actualCommon - ignoreLeadingCount);
+    	}
+	    in.readFully( buf, actualCommon, len - actualCommon );
+	    return buf;
+	}
+	
+    /**
+     * Writes the contents of buf to the DataOutput out, with special encoding if
+     * there are common leading bytes in the previous group stored by this compressor.
+     */
+	static void writeByteArray( DataOutputStream out, byte[] buf, byte[] previous, int ignoreLeadingCount ) throws IOException
+	{
+	    if ( buf == null ) {
+	        LongPacker.packInt(out, 0);
+	        return;
+	    }
+	    
+    	int actualCommon = ignoreLeadingCount;
+
+    	if (previous != null){
+	    	int maxCommon = buf.length > previous.length ? previous.length : buf.length;
+	   
+	    	if (maxCommon > Short.MAX_VALUE) maxCommon = Short.MAX_VALUE;
+	    	
+	    	for (; actualCommon < maxCommon; actualCommon++) {
+				if (buf[actualCommon] != previous[actualCommon])
+					break;
+			}
+    	}
+	     
+
+       	// there are enough common bytes to justify compression
+       	LongPacker.packInt(out,buf.length+1 );// store as +1, 0 indicates null
+       	LongPacker.packInt(out,actualCommon );
+       	out.write( buf, 0, ignoreLeadingCount);
+       	out.write( buf, actualCommon, buf.length - actualCommon );
+	    
+	}	
+	
+    
+ 
+    
+//    static String findCommonStringPrefix(Object[] strs) {
+//    	int commonChars = 1;
+//
+//    	String minimalString = null;
+//    	int minimalSize =Integer.MAX_VALUE;
+//    	//find first non null string and minimal size
+//    	for(Object s2:strs){
+//    		String s = (String) s2;
+//    		if(s!=null && minimalSize>s.length()){
+//    			minimalSize = s.length();
+//    			minimalString = s;
+//    		}
+//    	}
+//    	//all null
+//    	if(minimalString == null)
+//    		return null;
+//    	
+//    	String previousPrefix = "";
+//    	while(commonChars<=minimalSize){
+//    		String prefix = minimalString.substring(0,commonChars);
+//    		//check if all strings stars with the same prefix
+//    		for(Object s2:strs){
+//    			String s = (String) s2;
+//    			if(s!=null && !s.startsWith(prefix)){    				
+//    				//does not start, return previous
+//    				return previousPrefix;
+//    			}
+//    		}
+//    		
+//    		//all ok, add one more common byte
+//    		previousPrefix = prefix;
+//    		commonChars++; 
+//    	}
+//    	return previousPrefix;
+//		
+//	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/package.html
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/package.html	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,12 @@
+<!-- $Id: package.html,v 1.1 2001/05/19 16:01:32 boisvert Exp $ -->
+<html>
+  <body>
+    <p>B+Tree (scalable persistent tree) data structure implementation.</p>
+
+    <dl>
+      <dt><b>Version: </b></dt><dd>$Revision: 1.1 $ $Date: 2001/05/19 16:01:32 $</dd>
+      <dt><b>Author: </b></dt><dd><a href="mailto:boisvert at intalio.com">Alex Boisvert</a></dd>
+    </dl>
+
+  </body>
+</html>

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/AbstractPrimaryMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/AbstractPrimaryMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,119 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.IOException;
+import java.util.AbstractMap;
+import java.util.Comparator;
+import java.util.Map;
+
+import jdbm.*;
+
+public abstract class AbstractPrimaryMap<K, V> extends AbstractMap<K,V> implements PrimaryHashMap<K, V>{
+
+	
+	public <A> SecondaryHashMap<A, K,V> secondaryHashMap(String objectName,
+			SecondaryKeyExtractor<A, K,V> secondaryKeyExtractor) {
+		return SecondaryKeyHelper.secondaryHashMap(objectName,secondaryKeyExtractor,this,null);
+	}
+
+	public <A> SecondaryTreeMap<A, K, V> secondaryTreeMap(String objectName,
+			SecondaryKeyExtractor<A, K, V> secondaryKeyExtractor,
+			Comparator<A> secondaryKeyComparator) {
+		return SecondaryKeyHelper.secondaryTreeMap(objectName,secondaryKeyExtractor,secondaryKeyComparator,this,null);
+	}
+
+	@SuppressWarnings("unchecked")
+	public <A extends Comparable> SecondaryTreeMap<A, K, V> secondaryTreeMap(
+			String objectName, SecondaryKeyExtractor<A, K, V> secondaryKeyExtractor) {
+		return SecondaryKeyHelper.secondaryTreeMap(objectName,secondaryKeyExtractor,
+				ComparableComparator.INSTANCE,this,null);
+	}
+
+
+	public <A> SecondaryHashMap<A, K,V> secondaryHashMapManyToOne(String objectName,
+			SecondaryKeyExtractor<Iterable<A>, K,V> secondaryKeyExtractor) {
+		return SecondaryKeyHelper.secondaryHashMapManyToOne(objectName,secondaryKeyExtractor,this,null);
+	}
+
+	public <A> SecondaryTreeMap<A, K, V> secondaryTreeMapManyToOne(String objectName,
+			SecondaryKeyExtractor<Iterable<A>, K, V> secondaryKeyExtractor,
+			Comparator<A> secondaryKeyComparator) {
+		return SecondaryKeyHelper.secondarySortedMapManyToOne(objectName,secondaryKeyExtractor,secondaryKeyComparator,this,null);
+	}
+
+	@SuppressWarnings("unchecked")
+	public <A extends Comparable> SecondaryTreeMap<A, K, V> secondaryTreeMapManyToOne(
+			String objectName, SecondaryKeyExtractor<Iterable<A>, K, V> secondaryKeyExtractor) {
+		return SecondaryKeyHelper.secondarySortedMapManyToOne(objectName,secondaryKeyExtractor,
+				ComparableComparator.INSTANCE,this,null);
+	}
+
+
+	public <A> SecondaryHashMap<A, K,V> secondaryHashMap(String objectName,
+			SecondaryKeyExtractor<A, K,V> secondaryKeyExtractor,
+            Serializer<A> secondaryKeySerializer) {
+		return SecondaryKeyHelper.secondaryHashMap(objectName,secondaryKeyExtractor,this,secondaryKeySerializer);
+	}
+
+	public <A> SecondaryTreeMap<A, K, V> secondaryTreeMap(String objectName,
+			SecondaryKeyExtractor<A, K, V> secondaryKeyExtractor,
+			Comparator<A> secondaryKeyComparator,
+            Serializer<A> secondaryKeySerializer) {
+		return SecondaryKeyHelper.secondaryTreeMap(objectName,secondaryKeyExtractor,secondaryKeyComparator,this,secondaryKeySerializer);
+	}
+
+	@SuppressWarnings("unchecked")
+	public <A extends Comparable> SecondaryTreeMap<A, K, V> secondaryTreeMap(
+			String objectName, SecondaryKeyExtractor<A, K, V> secondaryKeyExtractor,
+            Serializer<A> secondaryKeySerializer) {
+		return SecondaryKeyHelper.secondaryTreeMap(objectName,secondaryKeyExtractor,
+				ComparableComparator.INSTANCE,this,secondaryKeySerializer);
+	}
+
+
+	public <A> SecondaryHashMap<A, K,V> secondaryHashMapManyToOne(String objectName,
+			SecondaryKeyExtractor<Iterable<A>, K,V> secondaryKeyExtractor,
+            Serializer<A> secondaryKeySerializer) {
+		return SecondaryKeyHelper.secondaryHashMapManyToOne(objectName,secondaryKeyExtractor,this,secondaryKeySerializer);
+	}
+
+	public <A> SecondaryTreeMap<A, K, V> secondaryTreeMapManyToOne(String objectName,
+			SecondaryKeyExtractor<Iterable<A>, K, V> secondaryKeyExtractor,
+			Comparator<A> secondaryKeyComparator,
+            Serializer<A> secondaryKeySerializer) {
+		return SecondaryKeyHelper.secondarySortedMapManyToOne(objectName,secondaryKeyExtractor,secondaryKeyComparator,this,secondaryKeySerializer);
+	}
+
+	@SuppressWarnings("unchecked")
+	public <A extends Comparable> SecondaryTreeMap<A, K, V> secondaryTreeMapManyToOne(
+			String objectName, SecondaryKeyExtractor<Iterable<A>, K, V> secondaryKeyExtractor,
+            Serializer<A> secondaryKeySerializer) {
+		return SecondaryKeyHelper.secondarySortedMapManyToOne(objectName,secondaryKeyExtractor,
+				ComparableComparator.INSTANCE,this,secondaryKeySerializer);
+	}
+	
+	public InverseHashView<K, V> inverseHashView(String objectName) {
+		return SecondaryKeyHelper.inverseHashView(this,objectName);
+	}
+	
+
+
+	public V find(K k) throws IOException {
+		return get(k);
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/ByteArrayComparator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/ByteArrayComparator.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,103 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.Serializable;
+import java.util.Comparator;
+
+/**
+ * Comparator for byte arrays.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @version $Id: ByteArrayComparator.java,v 1.4 2002/05/31 06:33:20 boisvert Exp $
+ */
+public final class ByteArrayComparator
+    implements Comparator<byte[]>, Serializable
+{
+
+    /**
+     * Version id for serialization.
+     */
+    final static long serialVersionUID = 1L;
+
+
+    /**
+     * Compare two objects.
+     *
+     * @param obj1 First object
+     * @param obj2 Second object
+     * @return a positive integer if obj1 > obj2, 0 if obj1 == obj2,
+     *         and a negative integer if obj1 < obj2
+     */
+     public int compare( byte[] obj1, byte[] obj2 )
+     {
+        if ( obj1 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj1' is null" );
+        }
+
+        if ( obj2 == null ) {
+            throw new IllegalArgumentException( "Argument 'obj2' is null" );
+        }
+
+        return compareByteArray( obj1,  obj2 );
+     }
+
+
+    /**
+     * Compare two byte arrays.
+     */
+    public static int compareByteArray( byte[] thisKey, byte[] otherKey )
+    {
+        int len = Math.min( thisKey.length, otherKey.length );
+
+        // compare the byte arrays
+        for ( int i=0; i<len; i++ ) {
+            if ( thisKey[i] >= 0 ) {
+                if ( otherKey[i] >= 0 ) {
+                    // both positive
+                    if ( thisKey[i] < otherKey[i] ) {
+                        return -1;
+                    } else if ( thisKey[i] > otherKey[i] ) {
+                        return 1;
+                    }
+                } else {
+                    // otherKey is negative => greater (because MSB is 1)
+                    return -1;
+                }
+            } else {
+                if ( otherKey[i] >= 0 ) {
+                    // thisKey is negative => greater (because MSB is 1)
+                    return 1;
+                } else {
+                    // both negative
+                    if ( thisKey[i] < otherKey[i] ) {
+                        return -1;
+                    } else if ( thisKey[i] > otherKey[i] ) {
+                        return 1;
+                    }
+                }
+            }
+        }
+        if ( thisKey.length == otherKey.length) {
+            return 0;
+        }
+        if ( thisKey.length < otherKey.length ) {
+            return -1;
+        }
+        return 1;
+    }
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/ComparableComparator.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/ComparableComparator.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,44 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.Serializable;
+import java.util.Comparator;
+
+/**
+ * 
+ * Compares comparables. Default comparator for most of java types
+ * 
+ * @author Jan Kotek
+ *
+ * @param <A>
+ */
+ at SuppressWarnings("unchecked") 
+public class ComparableComparator<A extends Comparable>
+	implements Comparator<A>,Serializable {	
+	
+	/** use this instance, dont allocate new*/
+	public final static Comparator INSTANCE =  new ComparableComparator();
+
+	private static final long serialVersionUID = 1678377822276476166L;
+	
+	/** everyone should use INSTANCE*/
+	private ComparableComparator(){};
+
+	public int compare(Comparable o1, Comparable o2) {
+        return o1.compareTo(o2);
+    }
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/DefaultSerializer.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/DefaultSerializer.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,78 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.helper;
+
+
+import java.io.IOException;
+
+import jdbm.Serializer;
+import jdbm.SerializerInput;
+import jdbm.SerializerOutput;
+
+/**
+ * Default java serializer. Constructor is privite, use  DefaultSerializer.INSTANCE
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ */
+public class DefaultSerializer
+    implements Serializer<Object>
+{
+
+	private static final long serialVersionUID = -3818545055661017388L;
+	
+	public static final DefaultSerializer INSTANCE = new DefaultSerializer();
+    
+    
+    /**
+     * Construct a DefaultSerializer, is private to make sure every one uses INSTANCE
+     */
+    private DefaultSerializer()
+    {
+        // no op
+    }
+
+    
+    /**
+     * Serialize the content of an object into a byte array.
+     *
+     * @param obj Object to serialize
+     * @return a byte array representing the object's state
+     */
+     public void serialize(SerializerOutput out,Object obj)
+        throws IOException
+     {    
+    	 out.writeObject(obj);        
+     }
+        
+        
+    /**
+     * Deserialize the content of an object from a byte array.
+     *
+     * @param serialized Byte array representation of the object
+     * @return deserialized object
+     */
+     public Object deserialize(SerializerInput in )
+        throws IOException
+     {
+         try {
+            return in.readObject();
+         } catch ( ClassNotFoundException except ) {
+            throw new IOException( except );
+         }
+     }
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/JdbmBase.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/JdbmBase.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,58 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.IOException;
+
+import jdbm.RecordListener;
+import jdbm.RecordManager;
+
+/**
+ * common interface for Trees and PrimaryMaps
+ * 
+ * @author Jan Kotek
+ *
+ * @param <K> key type
+ * @param <V> value type
+ */
+public interface JdbmBase<K,V> {
+
+	/**  
+	 * @return underlying record manager 
+	 */
+	RecordManager getRecordManager();
+	
+    /**
+     * add RecordListener which is notified about record changes
+     * @param listener
+     */
+    void addRecordListener(RecordListener<K,V> listener);
+    
+    /**
+     * remove RecordListener which is notified about record changes
+     * @param listener
+     */
+    void removeRecordListener(RecordListener<K,V> listener);
+    
+    /**
+     * Find Value for given Key
+     * @param k key
+     * @return value or null if not found
+     * @throws IOException
+     */
+    V find(K k) throws IOException;
+    
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/LongHashMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/LongHashMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,587 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package jdbm.helper;
+
+import java.io.Serializable;
+import java.util.Arrays;
+import java.util.ConcurrentModificationException;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Hash Map which uses primitive long as key. 
+ * Main advantage is new instanceof of Long does not have to be created for each lookup.
+ * <p>
+ * This code comes from Android, which in turns comes to Apache Harmony. 
+ * This class was modified to use primitive longs and stripped down to consume less space. 
+ * <p>
+ * Author of JDBM modifications: Jan Kotek
+ * <p>
+ * Note: This map have weakened hash function, this works well for JDBM, but may be wrong for many other applications.  
+ */
+public class LongHashMap<V> implements  Serializable {
+    private static final long serialVersionUID = 362499999763181265L;
+
+    protected int elementCount;
+
+    protected Entry<V>[] elementData;
+
+    private final float loadFactor;
+
+    protected int threshold;
+
+    transient int modCount = 0;	
+
+    private static final int DEFAULT_SIZE = 16;
+    
+    transient Entry<V> reuseAfterDelete = null;
+
+    static final class Entry<V> {
+
+        Entry<V> next;
+
+        long key;
+        V value;
+        
+        public boolean equals(Object object) {
+            if (this == object) {
+                return true;
+            }
+            if (object instanceof Entry) {
+                Entry<?> entry = (Entry) object;
+                return ( key == entry.key)
+                        && (value == null ? entry.value == null : value
+                                .equals(entry.value));
+            }
+            return false;
+        }
+
+
+        
+        public int hashCode() {
+            return (int)(key)
+                    ^ (value == null ? 0 : value.hashCode());
+        }
+
+        
+        
+        public String toString() {
+            return key + "=" + value;
+        }
+        
+
+        
+        Entry(long theKey) {
+        	this.key = theKey;
+        	this.value = null;
+        }
+
+        Entry(long theKey, V theValue) {
+            this.key = theKey;
+            this.value = theValue;
+            //origKeyHash = (int)(theKey ^ (theKey >>> 32));
+        }
+
+    }
+    
+
+    interface EntryType<RT,VT> {
+        RT get(Entry<VT> entry);
+    }
+
+    static class HashMapIterator<E,VT> implements Iterator<E> {
+        private int position = 0;
+
+        int expectedModCount;
+
+        final EntryType<E, VT> type;
+
+        boolean canRemove = false;
+
+        Entry<VT> entry;
+
+        Entry<VT> lastEntry;
+
+        final LongHashMap<VT> associatedMap;
+
+        HashMapIterator(EntryType<E, VT> value, LongHashMap<VT> hm) {
+            associatedMap = hm;
+            type = value;
+            expectedModCount = hm.modCount;
+        }
+
+        public boolean hasNext() {
+            if (entry != null) {
+                return true;
+            }
+            // BEGIN android-changed
+            Entry<VT>[] elementData = associatedMap.elementData;
+            int length = elementData.length;
+            int newPosition = position;
+            boolean result = false;
+
+            while (newPosition < length) {
+                if (elementData[newPosition] == null) {
+                    newPosition++;
+                } else {
+                    result = true;
+                    break;
+                }
+            }
+
+            position = newPosition;
+            return result;
+            // END android-changed
+        }
+
+        void checkConcurrentMod() throws ConcurrentModificationException {
+            if (expectedModCount != associatedMap.modCount) {
+                throw new ConcurrentModificationException();
+            }
+        }
+
+        public E next() {
+            // BEGIN android-changed
+            // inline checkConcurrentMod()
+            if (expectedModCount != associatedMap.modCount) {
+                throw new ConcurrentModificationException();
+            }
+            if (!hasNext()) {
+                throw new NoSuchElementException();
+            }
+
+            Entry<VT> result;
+            Entry<VT> _entry  = entry;
+            if (_entry == null) {
+                result = lastEntry = associatedMap.elementData[position++];
+                entry = lastEntry.next;
+            } else {
+                if (lastEntry.next != _entry) {
+                    lastEntry = lastEntry.next;
+                }
+                result = _entry;
+                entry = _entry.next;
+            }
+            canRemove = true;
+            return type.get(result);
+            // END android-changed
+        }
+
+        public void remove() {
+            checkConcurrentMod();
+            if (!canRemove) {
+                throw new IllegalStateException();
+            }
+
+            canRemove = false;
+            associatedMap.modCount++;
+            if (lastEntry.next == entry) {
+                while (associatedMap.elementData[--position] == null) {
+                    // Do nothing
+                }
+                associatedMap.elementData[position] = associatedMap.elementData[position].next;
+                entry = null;
+            } else {
+                lastEntry.next = entry;
+            }
+            if(lastEntry!=null){
+            	Entry<VT> reuse = lastEntry;
+            	lastEntry = null;
+            	reuse.key = Long.MIN_VALUE;
+            	reuse.value = null;
+            	associatedMap.reuseAfterDelete = reuse;
+            }
+
+            associatedMap.elementCount--;
+            expectedModCount++;
+        }
+    }
+
+
+
+    @SuppressWarnings("unchecked")
+    Entry<V>[] newElementArray(int s) {
+        return new Entry[s];
+    }
+
+    /**
+     * Constructs a new empty {@code HashMap} instance.
+     * 
+     * @since Android 1.0
+     */
+    public LongHashMap() {
+        this(DEFAULT_SIZE);
+    }
+
+    /**
+     * Constructs a new {@code HashMap} instance with the specified capacity.
+     * 
+     * @param capacity
+     *            the initial capacity of this hash map.
+     * @throws IllegalArgumentException
+     *                when the capacity is less than zero.
+     * @since Android 1.0
+     */
+    public LongHashMap(int capacity) {
+        if (capacity >= 0) {
+            elementCount = 0;
+            elementData = newElementArray(capacity == 0 ? 1 : capacity);
+            loadFactor = 0.75f; // Default load factor of 0.75
+            computeMaxSize();
+        } else {
+            throw new IllegalArgumentException();
+        }
+    }
+
+    /**
+     * Constructs a new {@code HashMap} instance with the specified capacity and
+     * load factor.
+     * 
+     * @param capacity
+     *            the initial capacity of this hash map.
+     * @param loadFactor
+     *            the initial load factor.
+     * @throws IllegalArgumentException
+     *                when the capacity is less than zero or the load factor is
+     *                less or equal to zero.
+     * @since Android 1.0
+     */
+    public LongHashMap(int capacity, float loadFactor) {
+        if (capacity >= 0 && loadFactor > 0) {
+            elementCount = 0;
+            elementData = newElementArray(capacity == 0 ? 1 : capacity);
+            this.loadFactor = loadFactor;
+            computeMaxSize();
+        } else {
+            throw new IllegalArgumentException();
+        }
+    }
+
+
+
+    // BEGIN android-changed
+    /**
+     * Removes all mappings from this hash map, leaving it empty.
+     * 
+     * @see #isEmpty
+     * @see #size
+     * @since Android 1.0
+     */
+    
+    public void clear() {
+        if (elementCount > 0) {
+            elementCount = 0;
+            Arrays.fill(elementData, null);
+            modCount++;
+        }
+    }
+    // END android-changed
+
+    /**
+     * Returns a shallow copy of this map.
+     * 
+     * @return a shallow copy of this map.
+     * @since Android 1.0
+     */
+    
+
+    private void computeMaxSize() {
+        threshold = (int) (elementData.length * loadFactor);
+    }
+
+    /**
+     * Returns whether this map contains the specified key.
+     * 
+     * @param key
+     *            the key to search for.
+     * @return {@code true} if this map contains the specified key,
+     *         {@code false} otherwise.
+     * @since Android 1.0
+     */
+    
+    public boolean containsKey(long key) {
+            int hash = (int)(key);
+            int index = (hash & 0x7FFFFFFF) % elementData.length;
+            Entry<V> m = findNonNullKeyEntry(key, index, hash);
+        return m != null;
+    }
+
+    /**
+     * Returns whether this map contains the specified value.
+     * 
+     * @param value
+     *            the value to search for.
+     * @return {@code true} if this map contains the specified value,
+     *         {@code false} otherwise.
+     * @since Android 1.0
+     */
+    
+    public boolean containsValue(Object value) {
+        if (value != null) {
+            for (int i = elementData.length; --i >= 0;) {
+                Entry<V> entry = elementData[i];
+                while (entry != null) {
+                    if (value.equals(entry.value)) {
+                        return true;
+                    }
+                    entry = entry.next;
+                }
+            }
+        } else {
+            for (int i = elementData.length; --i >= 0;) {
+                Entry<V> entry = elementData[i];
+                while (entry != null) {
+                    if (entry.value == null) {
+                        return true;
+                    }
+                    entry = entry.next;
+                }
+            }
+        }
+        return false;
+    }
+
+
+    /**
+     * Returns the value of the mapping with the specified key.
+     * 
+     * @param key
+     *            the key.
+     * @return the value of the mapping with the specified key, or {@code null}
+     *         if no mapping for the specified key is found.
+     * @since Android 1.0
+     */
+    
+    public V get(long key) {
+        Entry<V> m;
+        int hash = (int)(key);
+        int index = (hash & 0x7FFFFFFF) % elementData.length;
+        m = findNonNullKeyEntry(key, index, hash);
+
+        if (m != null) {
+            return m.value;
+        }
+        return null;
+    }
+
+    final Entry<V> findNonNullKeyEntry(long key, int index, int keyHash) {
+        Entry<V> m = elementData[index];
+            while (m != null) {
+
+                    if (key == m.key) {
+                        return m;
+                    }
+
+                m = m.next;
+
+        }
+        return null;
+    }
+
+
+    /**
+     * Returns whether this map is empty.
+     * 
+     * @return {@code true} if this map has no elements, {@code false}
+     *         otherwise.
+     * @see #size()
+     * @since Android 1.0
+     */
+    
+    public boolean isEmpty() {
+        return elementCount == 0;
+    }
+
+    /**
+     * @return iterator over keys
+     */
+    
+//      public Iterator<K> keyIterator(){
+//                 return new HashMapIterator<K, K, V>(
+//                            new MapEntry.Type<K, K, V>() {
+//                                public K get(Entry<K, V> entry) {
+//                                    return entry.key;
+//                                }
+//                            }, HashMap.this);
+//
+//     }
+
+    /**
+     * Maps the specified key to the specified value.
+     * 
+     * @param key
+     *            the key.
+     * @param value
+     *            the value.
+     * @return the value of any previous mapping with the specified key or
+     *         {@code null} if there was no such mapping.
+     * @since Android 1.0
+     */
+    
+
+    public V put(long key, V value) {
+        Entry<V> entry;
+            int hash =(int)(key);
+            int index = (hash & 0x7FFFFFFF) % elementData.length;
+            entry = findNonNullKeyEntry(key, index, hash);
+            if (entry == null) {
+                modCount++;
+                if (++elementCount > threshold) {
+                    rehash();
+                    index = (hash & 0x7FFFFFFF) % elementData.length;
+                }
+                entry = createHashedEntry(key, index);
+            }
+
+
+        V result = entry.value;
+        entry.value = value;
+        return result;
+    }
+
+    Entry<V> createEntry(long key, int index, V value) {
+        Entry<V> entry = reuseAfterDelete; 
+        if(entry == null){ 
+        	entry = new Entry<V>(key, value);
+        }else{
+        	reuseAfterDelete = null;
+        	entry.key = key;
+        	entry.value = value;
+        }
+        
+        entry.next = elementData[index];
+        elementData[index] = entry;
+        return entry;
+    }
+
+    Entry<V> createHashedEntry(long key, int index) {
+        Entry<V> entry = reuseAfterDelete; 
+        if(entry == null) {
+        	entry = new Entry<V>(key);
+        }else{
+        	reuseAfterDelete = null;
+        	entry.key = key;
+        	entry.value = null;
+        }
+
+        entry.next = elementData[index];
+        elementData[index] = entry;
+        return entry;
+    }
+
+
+    void rehash(int capacity) {
+        int length = (capacity == 0 ? 1 : capacity << 1);
+
+        Entry<V>[] newData = newElementArray(length);
+        for (int i = 0; i < elementData.length; i++) {
+            Entry<V> entry = elementData[i];
+            while (entry != null) {
+                int index = ((int)entry.key & 0x7FFFFFFF) % length;
+                Entry<V> next = entry.next;
+                entry.next = newData[index];
+                newData[index] = entry;
+                entry = next;
+            }
+        }
+        elementData = newData;
+        computeMaxSize();
+    }
+
+    void rehash() {
+        rehash(elementData.length);
+    }
+
+    /**
+     * Removes the mapping with the specified key from this map.
+     * 
+     * @param key
+     *            the key of the mapping to remove.
+     * @return the value of the removed mapping or {@code null} if no mapping
+     *         for the specified key was found.
+     * @since Android 1.0
+     */
+    
+    public V remove(long key) {
+        Entry<V> entry = removeEntry(key);
+        if(entry == null)
+        	return null;
+        V ret = entry.value;
+        entry.value = null;
+        entry.key = Long.MIN_VALUE;
+        reuseAfterDelete = entry;
+        
+        return ret;
+    }
+
+    Entry<V> removeEntry(long key) {
+        int index = 0;
+        Entry<V> entry;
+        Entry<V> last = null;
+
+        int hash = (int)(key);
+        index = (hash & 0x7FFFFFFF) % elementData.length;
+        entry = elementData[index];
+         while (entry != null && !(/*((int)entry.key) == hash &&*/ key == entry.key)) {
+             last = entry;
+              entry = entry.next;
+         }
+         
+         if (entry == null) {
+             return null;
+         }
+         
+        if (last == null) {
+            elementData[index] = entry.next;
+        } else {
+            last.next = entry.next;
+        }
+        modCount++;
+        elementCount--;
+        return entry;
+    }
+
+    /**
+     * Returns the number of elements in this map.
+     * 
+     * @return the number of elements in this map.
+     * @since Android 1.0
+     */
+    
+    public int size() {
+        return elementCount;
+    }
+
+    /**
+     * @returns iterator over values in map
+     */
+    public Iterator<V> valuesIterator() {
+        return new HashMapIterator<V, V>(
+                new EntryType<V,  V>() {
+                    public V get(Entry< V> entry) {
+                        return entry.value;
+                    }
+                }, LongHashMap.this);
+
+    }
+
+
+}
+
+
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/LongPacker.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/LongPacker.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,206 @@
+/*******************************************************************************
+ * (c) 2003-2003 CognitiveWeb.  All Rights Reserved.  Contact
+ * information for CognitiveWeb is available at
+ *  http://www.CognitiveWeb.org
+ *
+ * Portions Copyright (c) 2002-2003 Bryan Thompson.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+
+package jdbm.helper;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+/**
+ * Packing utility for non-negative <code>long</code> values.
+ * <p>
+ * Originaly distributed under CognitiveWeb Open Source License Version, 
+ * got permission to relicense under Apache2 license 
+ * 
+ * @author <a href="mailto:thompsonbry at users.sourceforge.net">Bryan Thompson</a>
+ * @version $Id: LongPacker.java,v 1.4 2006/05/02 16:20:07 thompsonbry Exp $
+ */
+
+public final class LongPacker
+{
+    
+    
+    /**
+     * Packs a non-negative long value into the minimum #of bytes in which the
+     * value can be represented and writes those bytes onto the output stream.
+     * The first byte determines whether or not the long value was packed and,
+     * if packed, how many bytes were required to represent the packed long
+     * value. When the high bit of the first byte is a one (1), then the long
+     * value could not be packed and the long value is found by clearing the
+     * high bit and interpreting the first byte plus the next seven (7) bytes as
+     * a long. Otherwise the next three (3) bits are interpreted as an unsigned
+     * integer giving the #of bytes (nbytes) required to represent the packed
+     * long value. To recover the long value the high nibble is cleared and the
+     * first byte together with the next nbytes are interpeted as an unsigned
+     * long value whose leading zero bytes were not written.
+     * 
+     * <pre>
+     *    
+     * [0|1|2|3|4|5|6|7]
+     *  1 - - -	  nbytes = 8, clear high bit and interpret this plus the next 7 bytes as a long.
+     *  0 1 1 1	  nbytes = 7, clear high nibble and interpret this plus the next 6 bytes as a long. 
+     *  0 1 1 0	  nbytes = 6, clear high nibble and interpret this plus the next 5 bytes as a long. 
+     *  0 1 0 1	  nbytes = 5, clear high nibble and interpret this plus the next 4 bytes as a long.
+     *  0 1 0 0	  nbytes = 4, clear high nibble and interpret this plus the next 3 bytes as a long.
+     *  0 0 1 1	  nbytes = 3, clear high nibble and interpret this plus the next 3 bytes as a long.
+     *  0 0 1 0	  nbytes = 2, clear high nibble and interpret this plus the next byte as a long.
+     *  0 0 0 1	  nbytes = 1, clear high nibble.  value is the low nibble.
+     *  
+     * </pre>
+     */ 
+
+    static final public int packLong( DataOutput os, long v ) throws IOException {
+        /*
+         * You can only pack non-negative long values with this method.
+         */
+        if( v < 0 ) {
+            throw new IllegalArgumentException( "negative value: v="+v );
+        }
+        /*
+         * If the high byte is non-zero then we will write the value as a normal
+         * long and return nbytes == 8. This case handles large positive long
+         * values.
+         */
+        if( ( v >> 56 ) != 0 ) {
+            os.write( (byte)((0xff & (v >> 56))|0x80) ); // note: set the high bit.
+            os.write( (byte)(0xff & (v >> 48)) );
+            os.write( (byte)(0xff & (v >> 40)) );
+            os.write( (byte)(0xff & (v >> 32)) );
+            os.write( (byte)(0xff & (v >> 24)) );
+            os.write( (byte)(0xff & (v >> 16)) );
+            os.write( (byte)(0xff & (v >>  8)) );
+            os.write( (byte)(0xff & v) );
+            return 8;
+        }
+        // #of nibbles required to represent the long value.
+        final int nnibbles = getNibbleLength( v );
+        // Is [nnibbles] even? (If it is even then we need to pad out an extra zero
+        // nibble in the first byte.)
+        final boolean evenNibbleCount = ( nnibbles == ( ( nnibbles >> 1 ) << 1 ) );
+        // #of bytes required to represent the long value (plus the header nibble).
+        final int nbytes = ( ( nnibbles +1 ) >> 1 ) + (evenNibbleCount?1:0);
+        
+        int nwritten = 0;
+        if( evenNibbleCount ) {
+            /*
+             * An even nibble count requires that we pad the low nibble of the
+             * first byte with zeros.
+             */
+            // header byte. low nibble is empty.
+            byte b = (byte) ( nbytes << 4 );
+            os.write( b );
+            nwritten++;
+            // remaining bytes containing the packed value.
+            for( int i=(nnibbles-2)<<2; i>=0; i-=8 ) {
+                b = (byte) (0xff & (v >> i));
+                os.write( b );
+                nwritten++;
+            }
+        } else {
+            /*
+             * An odd nibble count means that we pack the first nibble of the
+             * long value into the low nibble of the header byte. In this case
+             * the first nibble will always be the low nibble of the first
+             * non-zero byte in the long value (the high nibble of that byte
+             * must be zero since there is an odd nibble count).
+             */
+            byte highByte = (byte) (0xff & (v >> ((nbytes-1)*8) ));
+            byte b = (byte) ( ( nbytes << 4 ) | highByte );
+            os.write( b );
+            nwritten++;
+            for( int i=(nnibbles-3)<<2; i>=0; i-=8 ) {
+                b = (byte) (0xff & (v >> i));
+                os.write( b );
+                nwritten++;
+            }
+        }
+        return nwritten;
+    }
+
+    /**
+     * Return the #of non-zero nibbles, counting from the first non-zero nibble
+     * in the long value. A value of <code>0L</code> is considered to be one
+     * nibble for our purposes.
+     * 
+     * @param v
+     *            The long value.
+     * 
+     * @return The #of nibbles in [1:16].
+     */
+    
+    static final protected int getNibbleLength( long v )
+    {
+        for( int i=56, j=16; i>=0; i-=8, j-=2 ) {
+            if( (0xf0 & (v >> i)) != 0 ) return j;
+            if( (0x0f & (v >> i)) != 0 ) return j-1;
+        }
+        if( v != 0 ) throw new AssertionError( "v="+v );
+        return 1; // value is zero, which is considered to be one nibble for our purposes.
+    }
+    
+    /**
+     * Unpack a long value from the input stream.
+     * 
+     * @param is The input stream.
+     * 
+     * @return The long value.
+     * 
+     * @throws IOException
+     */
+    
+    static final public long unpackLong( DataInput is ) throws IOException
+    {
+        int b = is.readByte();
+        int nbytes;
+        long l;
+        if( ( b & 0x80 ) != 0 ) {
+            // high bit is set.
+            nbytes = 8; // use 8 bytes (this one plus the next 7).
+            l = b & 0x7f; // clear the high bit - the rest of the byte is the start value.
+        } else {
+            // high bit is clear.
+            nbytes = b >> 4; // nbytes is the upper nibble. (right shift one nibble).
+            l = b & 0x0f; // starting value is lower nibble (clear the upper nibble).
+        }
+        for( int i=1; i<nbytes; i++ ) {
+            // Read the next byte.
+            b = is.readByte(); // readByte( is );
+            // Shift the existing value one byte left and add into the low (unsigned) byte.
+            l = (l << 8) + (0xff & b);
+        }
+        return l;
+    }
+
+    
+    static final public int packInt( DataOutput os, int v ) throws IOException {
+    	return packLong(os,v);
+    }
+    
+    static final public int unpackInt( DataInput is ) throws IOException{
+    	long val = unpackLong(is);
+    	if(val>Integer.MAX_VALUE)
+    		throw new InternalError("too big int: "+val);
+    	return (int) val;
+    }
+    
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/OpenByteArrayInputStream.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/OpenByteArrayInputStream.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,38 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.ByteArrayInputStream;
+
+public class OpenByteArrayInputStream extends ByteArrayInputStream{
+
+	public OpenByteArrayInputStream(byte[] buf) {
+		super(buf);
+	}
+	
+	public byte[] getBuf(){
+		return buf;
+	}
+	
+	
+	public void reset(byte[] buf, int count){
+		this.buf = buf;
+		this.count = count;		
+		this.pos = 0;
+		this.mark = 0;
+	}	
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/OpenByteArrayOutputStream.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/OpenByteArrayOutputStream.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,38 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.ByteArrayOutputStream;
+
+public class OpenByteArrayOutputStream extends ByteArrayOutputStream{
+	
+	
+	public OpenByteArrayOutputStream(byte[] buf) {
+		this.buf = buf;
+	}
+
+
+	public byte[] getBuf(){
+		return buf;
+	}
+
+	
+	public void reset(byte[] buf){
+		this.buf = buf;
+		this.count = 0;		
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/PrimaryStoreMapImpl.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/PrimaryStoreMapImpl.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,230 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.IOError;
+import java.io.IOException;
+import java.util.AbstractSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import jdbm.PrimaryMap;
+import jdbm.PrimaryStoreMap;
+import jdbm.RecordListener;
+import jdbm.RecordManager;
+import jdbm.Serializer;
+
+public class PrimaryStoreMapImpl<K extends Long, V> extends AbstractPrimaryMap<Long, V>
+	implements PrimaryStoreMap<K, V>{
+	
+	final protected PrimaryMap<Long,String> map;	
+	final protected Serializer<V> valueSerializer;
+	final protected List<RecordListener<Long,V>> listeners = new CopyOnWriteArrayList<RecordListener<Long,V>>();
+
+	public PrimaryStoreMapImpl(PrimaryMap<Long, String> map,Serializer<V> valueSerializer2) {
+		this.map = map;
+		this.valueSerializer = valueSerializer2;
+		map.addRecordListener(new RecordListener<Long,String>(){
+
+			public void recordInserted(Long key,String value) throws IOException {
+				V v = (V) getRecordManager().fetch(key,valueSerializer);
+				for(RecordListener<Long,V> l:listeners)
+					l.recordInserted(key, v);
+			}
+
+			public void recordRemoved(Long key, String value) throws IOException {
+				//store reference to value, it is needed to notify listeners
+				V deletedValue = (V) getRecordManager().fetch(key,valueSerializer);
+				
+				for(RecordListener<Long,V> l:listeners)
+					l.recordRemoved(key, deletedValue);
+				
+				//dispose old reference
+				getRecordManager().delete(key);
+			}
+
+			public void recordUpdated(Long key, String oldValue, String newValue) throws IOException {				
+				throw new InternalError("should not be here");
+			}});
+	}
+
+	public Long putValue(V v) {
+
+		try {
+			Long recid = getRecordManager().insert(v,valueSerializer);
+			map.put(recid, "");
+			return recid;
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+
+	}	
+
+	public void addRecordListener(final RecordListener<Long, V> listener) {
+		listeners.add((RecordListener<Long, V>) listener);
+	}
+
+	public RecordManager getRecordManager() {
+		return map.getRecordManager();
+	}
+
+	public void removeRecordListener(RecordListener<Long, V> listener) {	
+		listeners.remove(listener);
+	}
+
+	public void clear() {
+		map.clear();		
+	}
+
+	public boolean containsKey(Object key) {
+		return map.containsKey(key);
+	}
+
+
+	public Set<java.util.Map.Entry<Long, V>> entrySet() {
+		return new AbstractSet<java.util.Map.Entry<Long,V>>(){
+			
+			protected java.util.Map.Entry<Long,V> newEntry(Long k,V v){
+				return new SimpleEntry<Long,V>(k,v){
+
+					public V setValue(V arg0) {
+						throw new UnsupportedOperationException();
+					};					
+				};
+			}
+
+			public boolean add(java.util.Map.Entry<Long, V> e) {
+				throw new UnsupportedOperationException();
+			
+			}
+			
+			@SuppressWarnings("unchecked")
+			public boolean contains(Object o) {
+				
+				if(o instanceof Entry){
+					Entry<Long,V> e = (java.util.Map.Entry<Long, V>) o;
+					if(e.getKey()!=null && get(e.getKey())!=null)
+						return true;
+				}
+				return false;
+			}
+
+
+			public Iterator<java.util.Map.Entry<Long, V>> iterator() {
+					
+				return new Iterator<Entry<Long,V>>(){
+					final Iterator<Long> keyIter = keySet().iterator();
+
+					public boolean hasNext() {
+						return keyIter.hasNext();
+					}
+
+					public Entry<Long, V> next() {
+						Long k = keyIter.next();
+						return newEntry(k, get(k));
+					}
+
+					public void remove() {
+						keyIter.remove();						
+					}
+					
+				};
+					
+					
+			}
+
+			@SuppressWarnings("unchecked")
+			public boolean remove(Object o) {
+				
+				if(o instanceof Entry){
+					Entry<Long,V> e = (java.util.Map.Entry<Long, V>) o;
+					
+					//check for nulls
+					if(e.getKey() == null || e.getValue() == null)
+						return false;
+					//find old value, must be same as item in entry
+					V v = get(e.getKey());
+					if(v == null || !e.getValue().equals(v))
+						return false;
+					return  PrimaryStoreMapImpl.this.remove(e.getKey())!=null;
+				}
+				return false;
+
+			}
+
+
+
+			public int size() {
+				return PrimaryStoreMapImpl.this.size();
+			}
+
+		};
+	}
+
+	public V get(Object key) {
+		if(!map.containsKey(key))
+			return null;
+		try {
+			return getRecordManager().fetch((Long)key,valueSerializer);
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+	}
+
+
+	public Set<Long> keySet() {
+		return map.keySet();
+	}
+
+	public V put(Long key, V value) {
+		if(containsKey(key)){			
+			try {
+				V oldVal= getRecordManager().fetch(key,valueSerializer,true);
+				getRecordManager().update(key, value,valueSerializer);
+				//fire listeners, recid tree map did not change, so they would not be notified
+				for(RecordListener<Long, V> listener: listeners)
+					listener.recordUpdated(key, oldVal, value);
+				return oldVal;
+			} catch (IOException e) {
+				throw new IOError(e);
+			}
+			
+		}else{			
+			throw new UnsupportedOperationException("Can not update, key not found, use putValue(val) instead.");
+		}
+	}
+
+	public V remove(Object key) {
+		
+		if(!map.containsKey(key))
+			return null;
+		try{
+			V v = getRecordManager().fetch((Long)key,valueSerializer);
+			map.remove(key);		
+			return v;
+		}catch (IOException e){
+			throw new IOError(e);
+		}
+	}
+
+	public int size() {
+		return map.size();
+	}
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/RecordManagerImpl.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/RecordManagerImpl.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,155 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.IOError;
+import java.io.IOException;
+import java.util.Comparator;
+
+import jdbm.PrimaryHashMap;
+import jdbm.PrimaryStoreMap;
+import jdbm.PrimaryTreeMap;
+import jdbm.RecordManager;
+import jdbm.Serializer;
+import jdbm.btree.BTree;
+import jdbm.htree.HTree;
+
+/**
+ * Abstract class for record manager which implements most of stuff
+ * 
+ * @author Jan Kotek
+ *
+ */
+public abstract class RecordManagerImpl implements RecordManager{
+	
+	
+	public <K, V> PrimaryHashMap<K, V> hashMap(String name) {
+        return hashMap(name,null,null);
+    }
+
+    public <K, V> PrimaryHashMap<K, V> hashMap(String name, Serializer<K> keySerializer) {
+        return hashMap(name,keySerializer,null);
+    }
+
+	public synchronized <K, V> PrimaryHashMap<K, V> hashMap(String name, Serializer<K> keySerializer,  Serializer<V> valueSerializer) {
+		try{
+			HTree<K, V> tree = null;
+        
+			long recid = getNamedObject( name);
+			if ( recid != 0 ) {
+				tree = HTree.load( this, recid, keySerializer, valueSerializer);
+			} else {
+				tree = HTree.createInstance(this, keySerializer, valueSerializer);
+				setNamedObject( name, tree.getRecid() );
+			}
+			return tree.asMap();
+		}catch(IOException  e){
+			throw new IOError(e);
+		}
+	}
+
+	@SuppressWarnings("unchecked")
+	public <K extends Comparable, V> PrimaryTreeMap<K, V> treeMap(String name) {
+		return treeMap(name, ComparableComparator.INSTANCE);
+	}
+
+
+	@SuppressWarnings("unchecked")
+	public <K extends Comparable, V> PrimaryTreeMap<K, V> treeMap(String name, Serializer<V> valueSerializer) {
+		return treeMap(name, ComparableComparator.INSTANCE, valueSerializer);
+	}
+	
+	@SuppressWarnings("unchecked")
+	public <K extends Comparable, V> PrimaryTreeMap<K, V> treeMap(String name, Serializer<V> valueSerializer, Serializer<K> keySerializer) {	
+		return treeMap(name, ComparableComparator.INSTANCE, valueSerializer,keySerializer);
+	}
+
+
+	public <K, V> PrimaryTreeMap<K, V> treeMap(String name, Comparator<K> keyComparator) {
+		return treeMap(name, keyComparator, null);
+	}
+	
+
+
+	public <K, V> PrimaryTreeMap<K, V> treeMap(String name,
+		Comparator<K> keyComparator, Serializer<V> valueSerializer) {
+		return treeMap(name,keyComparator,valueSerializer,null);
+	}
+
+	public synchronized <K, V> PrimaryTreeMap<K, V> treeMap(String name,
+			Comparator<K> keyComparator, Serializer<V> valueSerializer, Serializer<K> keySerializer) {
+		try{
+			BTree<K,V> tree = null;
+        
+			// create or load 
+			long recid = getNamedObject( name);
+			if ( recid != 0 ) {
+				tree = BTree.load( this, recid );
+			} else {
+				tree = BTree.createInstance(this,keyComparator);
+				setNamedObject( name, tree.getRecid() );
+			}
+			tree.setKeySerializer(keySerializer);
+			tree.setValueSerializer(valueSerializer);
+			
+			return tree.asMap();
+		}catch(IOException  e){
+			throw new IOError(e);
+		}	
+	}
+
+	public synchronized <V> PrimaryStoreMap<Long, V> storeMap(String name,
+				Serializer<V> valueSerializer) {
+		try{
+			BTree<Long,String> tree = null;
+        
+			// create or load
+			long recid = getNamedObject( name);
+			if ( recid != 0 ) {
+				tree = BTree.load( this, recid );
+			} else {
+				tree = BTree.createInstance(this);
+				setNamedObject( name, tree.getRecid() );
+			}
+			return new PrimaryStoreMapImpl<Long, V>(tree.asMap(),valueSerializer);
+		}catch(IOException  e){
+			throw new IOError(e);
+		}	
+	}
+	
+
+	@SuppressWarnings("unchecked")
+	public <V> PrimaryStoreMap<Long, V> storeMap(String name){
+		return storeMap(name,(Serializer<V>)DefaultSerializer.INSTANCE);
+	}
+
+
+
+    public void update( long recid, Object obj ) throws IOException{
+    	update( recid, obj, DefaultSerializer.INSTANCE );
+    }
+    
+    public Object fetch( long recid ) throws IOException{
+    	return fetch( recid, DefaultSerializer.INSTANCE );
+    }
+
+    public long insert( Object obj )throws IOException{
+    	return insert( obj, DefaultSerializer.INSTANCE );
+    }
+
+
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/SecondaryKeyHelper.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/SecondaryKeyHelper.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,455 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.IOError;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+
+import jdbm.*;
+import jdbm.btree.BTree;
+import jdbm.btree.BTreeSecondarySortedMap;
+import jdbm.htree.HTree;
+import jdbm.htree.HTreeSecondaryMap;
+
+
+/**
+ * Utilities related to Secondary Maps
+ * 
+ * @author Jan Kotek
+ *
+ */
+final public class SecondaryKeyHelper {
+
+	   
+    static public <A,K,V> BTree<A,Iterable<K>>  secondaryBTree(String objectName, 
+    		final SecondaryKeyExtractor<A,K,V> keyExtractor, Comparator<A> comparator, JdbmBase<K,V> b) 
+    		throws IOException{
+    	BTree<A,Iterable<K>> secIndex = null;
+        long recid = b.getRecordManager().getNamedObject( objectName );
+        if ( recid != 0 ) {
+            secIndex = BTree.load(b.getRecordManager(), recid );
+        } else {
+            secIndex = BTree.createInstance( b.getRecordManager(), comparator );
+            b.getRecordManager().setNamedObject( objectName, secIndex.getRecid() );
+        }
+        
+        //second final variable so it can be accesed from listener
+        final BTree<A,Iterable<K>> secIndex2 = secIndex;
+        
+        b.addRecordListener(new RecordListener<K, V>() {
+
+			public void recordInserted(K key, V value) throws IOException {
+				A secKey = keyExtractor.extractSecondaryKey(key,value);
+				if(secKey == null)
+					return;
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) kk = new ArrayList<K>();
+				kk.add(key);
+				secIndex2.insert(secKey, kk, true);
+			}
+
+			public void recordRemoved(K key, V value) throws IOException {
+				A secKey = keyExtractor.extractSecondaryKey(key,value);
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) return;
+				kk.remove(key);
+				if(kk.isEmpty())
+					secIndex2.remove(secKey);
+				else
+					secIndex2.insert(secKey, kk, true);				
+			}
+
+			public void recordUpdated(K key, V oldValue, V newValue)
+					throws IOException {
+				A oldSecKey = keyExtractor.extractSecondaryKey(key, oldValue);
+				A newSecKey = keyExtractor.extractSecondaryKey(key, newValue);
+				if(oldSecKey==null && newSecKey == null)
+					return;
+				
+				if(oldSecKey==null && newSecKey!=null){
+					//insert new record
+					recordInserted(key, newValue);
+					return;
+				}
+				if(oldSecKey!=null && newSecKey==null){
+					//delete old record
+					recordRemoved(key, oldValue);
+					return;
+				}
+				
+				if(oldSecKey.equals(newSecKey))
+					//both keys are equal, nothing
+					return;
+				
+				//remove old key
+				recordRemoved(key, oldValue);
+				//insert new key
+				recordInserted(key,newValue);				
+			}
+		});
+
+        return secIndex;
+    }
+
+    static public <A,K,V> HTree<A,Iterable<K>>  secondaryHTree(String objectName, 
+    		final SecondaryKeyExtractor<A,K,V> keyExtractor, JdbmBase<K,V> b,Serializer<A> secondaryKeySerializer)
+    		throws IOException{
+    	HTree<A,Iterable<K>> secIndex = null;
+        long recid = b.getRecordManager().getNamedObject( objectName );
+        if ( recid != 0 ) {
+            secIndex = HTree.load(b.getRecordManager(), recid,secondaryKeySerializer,null );
+        } else {
+            secIndex = HTree.createInstance( b.getRecordManager(),secondaryKeySerializer,null);
+            b.getRecordManager().setNamedObject( objectName, secIndex.getRecid() );
+        }
+        
+        //second final variable so it can be accesed from listener
+        final HTree<A,Iterable<K>> secIndex2 = secIndex;
+        
+        b.addRecordListener(new RecordListener<K, V>() {
+
+			public void recordInserted(K key, V value) throws IOException {
+				A secKey = keyExtractor.extractSecondaryKey(key,value);
+				if(secKey == null)
+					return;
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) kk = new ArrayList<K>();
+				kk.add(key);
+				secIndex2.put(secKey, kk);
+			}
+
+			public void recordRemoved(K key, V value) throws IOException {
+				A secKey = keyExtractor.extractSecondaryKey(key,value);
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) return;
+				kk.remove(key);
+				if(kk.isEmpty())
+					secIndex2.remove(secKey);
+				else
+					secIndex2.put(secKey, kk);				
+			}
+
+			public void recordUpdated(K key, V oldValue, V newValue)
+					throws IOException {
+				A oldSecKey = keyExtractor.extractSecondaryKey(key,oldValue);
+				A newSecKey = keyExtractor.extractSecondaryKey(key,newValue);
+				if(oldSecKey==null && newSecKey == null)
+					return;
+				
+				if(oldSecKey==null && newSecKey!=null){
+					//insert new record
+					recordInserted(key, newValue);
+					return;
+				}
+				if(oldSecKey!=null && newSecKey==null){
+					//delete old record
+					recordRemoved(key, oldValue);
+					return;
+				}
+				
+				if(oldSecKey.equals(newSecKey))
+					//both keys are equal, nothing
+					return;
+				
+				//remove old key
+				recordRemoved(key, oldValue);
+				//insert new key
+				recordInserted(key,newValue);				
+			}
+		});
+
+        return secIndex;
+    }
+    
+    
+    static public <A,K,V> BTree<A,Iterable<K>>  secondaryBTreeManyToOne(String objectName, 
+    		final SecondaryKeyExtractor<Iterable<A>,K,V> keyExtractor, Comparator<A> comparator, JdbmBase<K,V> b) 
+    		throws IOException{
+    	BTree<A,Iterable<K>> secIndex = null;
+        long recid = b.getRecordManager().getNamedObject( objectName );
+        if ( recid != 0 ) {
+            secIndex = BTree.load(b.getRecordManager(), recid );
+        } else {
+            secIndex = BTree.createInstance( b.getRecordManager(), comparator );
+            b.getRecordManager().setNamedObject( objectName, secIndex.getRecid() );
+        }
+        
+        //second final variable so it can be accesed from listener
+        final BTree<A,Iterable<K>> secIndex2 = secIndex;
+        
+        b.addRecordListener(new RecordListener<K, V>() {
+
+			public void recordInserted(K key, V value) throws IOException {
+				for(A secKey : keyExtractor.extractSecondaryKey(key,value)){
+				if(secKey == null)
+					return;
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) kk = new ArrayList<K>();
+				kk.add(key);
+				secIndex2.insert(secKey, kk, true);
+				}
+			}
+
+			public void recordRemoved(K key, V value) throws IOException {
+				for(A secKey : keyExtractor.extractSecondaryKey(key,value)){
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) return;
+				kk.remove(key);
+				if(kk.isEmpty())
+					secIndex2.remove(secKey);
+				else
+					secIndex2.insert(secKey, kk, true);
+				}
+			}
+
+			public void recordUpdated(K key, V oldValue, V newValue)
+					throws IOException {
+				Iterable<A> oldSecKey = keyExtractor.extractSecondaryKey(key, oldValue);
+				Iterable<A> newSecKey = keyExtractor.extractSecondaryKey(key, newValue);
+				if(oldSecKey==null && newSecKey == null)
+					return;
+				
+				if(oldSecKey==null && newSecKey!=null){
+					//insert new record
+					recordInserted(key, newValue);
+					return;
+				}
+				if(oldSecKey!=null && newSecKey==null){
+					//delete old record
+					recordRemoved(key, oldValue);
+					return;
+				}
+				
+				if(oldSecKey.equals(newSecKey))
+					//both keys are equal, nothing
+					return;
+				
+				//remove old key
+				recordRemoved(key, oldValue);
+				//insert new key
+				recordInserted(key,newValue);				
+			}
+		});
+
+        return secIndex;
+    }
+
+    static public <A,K,V> HTree<A,Iterable<K>>  secondaryHTreeManyToOne(String objectName, 
+    		final SecondaryKeyExtractor<Iterable<A>,K,V> keyExtractor, JdbmBase<K,V> b,Serializer<A> secondaryKeySerializer)
+    		throws IOException{
+    	HTree<A,Iterable<K>> secIndex = null;
+        long recid = b.getRecordManager().getNamedObject( objectName );
+        if ( recid != 0 ) {
+            secIndex = HTree.load(b.getRecordManager(), recid,secondaryKeySerializer,null );
+        } else {
+            secIndex = HTree.createInstance( b.getRecordManager(),secondaryKeySerializer,null);
+            b.getRecordManager().setNamedObject( objectName, secIndex.getRecid() );
+        }
+        
+        //second final variable so it can be accesed from listener
+        final HTree<A,Iterable<K>> secIndex2 = secIndex;
+        
+        b.addRecordListener(new RecordListener<K, V>() {
+
+			public void recordInserted(K key, V value) throws IOException {
+				for(A secKey : keyExtractor.extractSecondaryKey(key,value)){
+				if(secKey == null)
+					return;
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) kk = new ArrayList<K>();
+				kk.add(key);
+				secIndex2.put(secKey, kk);
+				}
+			}
+
+			public void recordRemoved(K key, V value) throws IOException {
+				for(A secKey : keyExtractor.extractSecondaryKey(key,value)){
+				List<K> kk = (List<K>) secIndex2.find(secKey);
+				if(kk == null) return;
+				kk.remove(key);
+				if(kk.isEmpty())
+					secIndex2.remove(secKey);
+				else
+					secIndex2.put(secKey, kk);
+				}
+			}
+
+			public void recordUpdated(K key, V oldValue, V newValue)
+					throws IOException {
+				Iterable<A> oldSecKey = keyExtractor.extractSecondaryKey(key,oldValue);
+				Iterable<A> newSecKey = keyExtractor.extractSecondaryKey(key,newValue);
+				if(oldSecKey==null && newSecKey == null)
+					return;
+				
+				if(oldSecKey==null && newSecKey!=null){
+					//insert new record
+					recordInserted(key, newValue);
+					return;
+				}
+				if(oldSecKey!=null && newSecKey==null){
+					//delete old record
+					recordRemoved(key, oldValue);
+					return;
+				}
+				
+				if(oldSecKey.equals(newSecKey))
+					//both keys are equal, nothing
+					return;
+				
+				//remove old key
+				recordRemoved(key, oldValue);
+				//insert new key
+				recordInserted(key,newValue);				
+			}
+		});
+
+        return secIndex;
+    }
+
+
+    public static <A,K,V> SecondaryHashMap<A,K,V> secondaryHashMap( 
+    		String objectName, SecondaryKeyExtractor<A, K, V> secKeyExtractor, JdbmBase<K,V> b,
+            Serializer<A> secondaryKeySerializer){
+    	try{
+    		HTree<A,Iterable<K>> secTree = secondaryHTree(objectName, secKeyExtractor, b,secondaryKeySerializer);
+    		HTreeSecondaryMap<A, K, V> ret = new HTreeSecondaryMap<A, K, V>(secTree, b);
+    		return ret;
+    	}catch (IOException e){
+    		throw new IOError(e);
+    	}
+    }
+
+    public static <A,K,V> SecondaryTreeMap<A,K,V> secondaryTreeMap( 
+    		String objectName, SecondaryKeyExtractor<A, K, V> secKeyExtractor, 
+    		Comparator<A> comparator, JdbmBase<K,V> b,
+            Serializer<A> secondaryKeySerializer){
+    	try{
+    		BTree<A,Iterable<K>> secTree = secondaryBTree(objectName, secKeyExtractor, comparator,b);
+            if(secondaryKeySerializer!=null)
+                secTree.setKeySerializer(secondaryKeySerializer);
+    		BTreeSecondarySortedMap<A, K, V> ret = new BTreeSecondarySortedMap<A, K, V>(secTree, b);
+    		return ret;
+    	}catch (IOException e){
+    		throw new IOError(e);
+    	}
+    }
+    
+
+    public static <A,K,V> SecondaryHashMap<A,K,V> secondaryHashMapManyToOne( 
+    		String objectName, SecondaryKeyExtractor<Iterable<A>, K, V> secKeyExtractor, JdbmBase<K,V> b,
+            Serializer<A> secondaryKeySerializer){
+    	try{
+    		HTree<A,Iterable<K>> secTree = secondaryHTreeManyToOne(objectName, secKeyExtractor, b,secondaryKeySerializer);
+    		HTreeSecondaryMap<A, K, V> ret = new HTreeSecondaryMap<A, K, V>(secTree, b);
+    		return ret;
+    	}catch (IOException e){
+    		throw new IOError(e);
+    	}
+    }
+
+    public static <A,K,V> SecondaryTreeMap<A,K,V> secondarySortedMapManyToOne( 
+    		String objectName, SecondaryKeyExtractor<Iterable<A>, K, V> secKeyExtractor, 
+    		Comparator<A> comparator, JdbmBase<K,V> b,Serializer<A> secondaryKeySerializer){
+    	try{
+    		BTree<A,Iterable<K>> secTree = secondaryBTreeManyToOne(objectName, secKeyExtractor, comparator,b);
+            if(secondaryKeySerializer!=null)
+                secTree.setKeySerializer(secondaryKeySerializer);
+    		BTreeSecondarySortedMap<A, K, V> ret = new BTreeSecondarySortedMap<A, K, V>(secTree, b);
+    		return ret;
+    	}catch (IOException e){
+    		throw new IOError(e);
+    	}
+    }
+
+    
+    @SuppressWarnings("unchecked")
+	public static <K,V> InverseHashView<K, V> inverseHashView(JdbmBase<K,V> base, String recordName){
+    	SecondaryKeyExtractor<Integer,K,V> hashExtractor = new SecondaryKeyExtractor<Integer, K, V>() {
+			long hashEqualsIdentityCounter=0;
+			public Integer extractSecondaryKey(K key, V value) {
+				int hashCode = value.hashCode();
+				//little check to protect from hashCode not being overriden
+				int identityHashCode = System.identityHashCode(value);
+				if(hashCode == identityHashCode) 
+					hashEqualsIdentityCounter++;
+				else if(hashEqualsIdentityCounter>0) 
+					hashEqualsIdentityCounter--;
+				//fail if too many objects had hash equal to identityHashCode
+				if(hashEqualsIdentityCounter>50) 
+					throw new IllegalArgumentException("Object does not implement hashCode() correctly: "+value.getClass());
+				return new Integer(hashCode);
+			}
+		};
+		final SecondaryTreeMap<Integer, K, V> inverseMap = secondaryTreeMap(recordName,hashExtractor,ComparableComparator.INSTANCE,base,null);
+		
+		return new InverseHashView<K, V>() {
+			public K findKeyForValue(V val) {
+				Iterable<K> keys = inverseMap.get(new Integer(val.hashCode()));
+				if(keys == null) return null;
+				for(K k:keys){
+					if(val.equals(inverseMap.getPrimaryValue(k)))
+						return k;
+				}
+				return null;
+			}
+
+			public Iterable<K> findKeysForValue(V val) {
+				Iterable<K> keys = inverseMap.get(new Integer(val.hashCode()));
+				List<K> ret = new ArrayList<K>();
+				if(keys == null) return null;
+				for(K k:keys){
+					if(val.equals(inverseMap.getPrimaryValue(k)))
+						ret.add(k);
+				}
+				return ret;
+			}
+		};
+    }
+    
+    public static <K,V> Iterable<V> translateIterable(final JdbmBase<K, V> b, final Iterable<K> keys){
+    	if(keys==null)
+    		return new ArrayList<V>();
+    	return new Iterable<V>(){
+
+			public Iterator<V> iterator() {
+				return new Iterator<V>(){
+					
+					Iterator<K> iter = keys.iterator();
+
+					public boolean hasNext() {
+						return iter.hasNext();
+					}
+
+					public V next() {
+						try {
+							return b.find(iter.next());
+						} catch (IOException e) {
+							throw new IOError(e);
+						}
+					}
+
+					public void remove() {
+						iter.remove();						
+					}};
+			}
+    		
+    	};
+    }
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/Serialization.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/Serialization.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,1334 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.Properties;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import java.util.Vector;
+
+import jdbm.recman.BlockIo;
+
+/**
+ * Serialization util. It reduces serialized data size for most common java types. 
+ * <p>
+ * Common pattern is one byte header which identifies data type, then size is written (if required) and 
+ * data. 
+ * <p>
+ * On unknown types normal java serialization is used
+ * 
+ * <p>
+ * Header byte values bellow 180 are reserved by author for future use. If you want to customize
+ * this class, use values over 180, to be compatible with future updates.
+ * 
+ * 
+ * @author Jan Kotek
+ */
+ at SuppressWarnings("unchecked")
+public final class Serialization
+{
+	
+	public static final byte END_OF_NORMAL_SERIALIZATION = 111; 
+	
+	/** print statistics to STDOUT */
+	public static final boolean DEBUG = false;
+	
+	/** if set to true, debug informations will be saved to store to make it more robust */
+	public static final boolean DEBUGSTORE = false;
+	
+	private static final int DEBUGSTORE_DUMMY_START = 456456567;
+	private static final int DEBUGSTORE_DUMMY_END = 1234456;
+	
+	public final static int NULL 			=   0;
+	public final static int NORMAL 			=   1;
+	public final static int BOOLEAN_TRUE 	=   2;
+	public final static int BOOLEAN_FALSE 	=   3;
+	public final static int INTEGER_MINUS_1 =   4;
+	public final static int INTEGER_0 		=   5;
+	public final static int INTEGER_1 		=   6;
+	public final static int INTEGER_2 		=   7;
+	public final static int INTEGER_3 		=   8;
+	public final static int INTEGER_4 		=   9;
+	public final static int INTEGER_5 		=  10;
+	public final static int INTEGER_6 		=  11;
+	public final static int INTEGER_7 		=  12;
+	public final static int INTEGER_8 		=  13;
+	public final static int INTEGER_255		=  14;	
+	public final static int INTEGER_PACK_NEG=  15;
+	public final static int INTEGER_PACK 	=  16;
+	public final static int LONG_MINUS_1 	=  17;
+	public final static int LONG_0 			=  18;
+	public final static int LONG_1 			=  19;
+	public final static int LONG_2 			=  20;
+	public final static int LONG_3 			=  21;
+	public final static int LONG_4 			=  22;
+	public final static int LONG_5 			=  23;
+	public final static int LONG_6 			=  24;
+	public final static int LONG_7 			=  25;
+	public final static int LONG_8 			=  26;
+	public final static int LONG_PACK_NEG	=  27;
+	public final static int LONG_PACK 		=  28;
+	public final static int LONG_255 		=  29;
+	public final static int LONG_MINUS_MAX	=  30;
+	public final static int SHORT_MINUS_1 	=  31;
+	public final static int SHORT_0 		=  32;
+	public final static int SHORT_1 		=  33;
+	public final static int SHORT_255 		=  34;
+	public final static int SHORT_FULL		=  35;	
+	public final static int BYTE_MINUS_1 	=  36;
+	public final static int BYTE_0 			=  37;
+	public final static int BYTE_1 			=  38;
+	public final static int BYTE_FULL		=  39;	
+	public final static int CHAR			=  40;
+	public final static int FLOAT_MINUS_1 	=  41;
+	public final static int FLOAT_0 		=  42;
+	public final static int FLOAT_1 		=  43;
+	public final static int FLOAT_255		=  44;
+	public final static int FLOAT_SHORT		=  45;		
+	public final static int FLOAT_FULL		=  46;	
+	public final static int DOUBLE_MINUS_1 	=  47;
+	public final static int DOUBLE_0 		=  48;
+	public final static int DOUBLE_1 		=  49;
+	public final static int DOUBLE_255		=  50;
+	public final static int DOUBLE_SHORT	=  51;	
+	public final static int DOUBLE_FULL		=  52;
+	//TODO serialization for bigdecimal and biginteger
+	public final static int BIGDECIMAL_255	=  53;
+	public final static int BIGDECIMAL		=  54;
+	public final static int BIGINTEGER_255	=  55;
+	public final static int BIGINTEGER		=  56;
+	public final static int INTEGER_MINUS_MAX=  57;	
+ 	
+
+	
+	public final static int ARRAY_INT_B_255		=  60;
+	public final static int ARRAY_INT_B_INT		=  61;
+	public final static int ARRAY_INT_S			=  62;
+	public final static int ARRAY_INT_I			=  63;
+	public final static int ARRAY_INT_PACKED	=  64;
+	
+	public final static int ARRAY_LONG_B		=  65;
+	public final static int ARRAY_LONG_S		=  66;
+	public final static int ARRAY_LONG_I		=  67;
+	public final static int ARRAY_LONG_L		=  68;
+	public final static int ARRAY_LONG_PACKED	=  69;
+
+	public final static int ARRAY_BYTE_255		=  70;
+	public final static int ARRAY_BYTE_INT		=  71;
+	
+	public final static int ARRAY_OBJECT_255	=  72;
+	public final static int ARRAY_OBJECT		=  73;
+	//special cases for BTree values which stores references
+	public final static int ARRAY_OBJECT_PACKED_LONG =  74;
+	public final static int ARRAYLIST_PACKED_LONG =  75;
+	
+	public final static int STRING_EMPTY		= 101;
+	public final static int STRING_255			= 102;
+	public final static int STRING				= 103;
+	public final static int ARRAYLIST_255		= 104;
+	public final static int ARRAYLIST			= 105;
+	
+	public final static int TREEMAP_255			= 106;
+	public final static int TREEMAP				= 107;
+	public final static int HASHMAP_255			= 108;
+	public final static int HASHMAP				= 109;
+	public final static int LINKEDHASHMAP_255	= 110;
+	public final static int LINKEDHASHMAP		= 111;
+	
+	public final static int TREESET_255			= 112;
+	public final static int TREESET				= 113;
+	public final static int HASHSET_255			= 114;
+	public final static int HASHSET				= 115;
+	public final static int LINKEDHASHSET_255	= 116;
+	public final static int LINKEDHASHSET		= 117;
+	public final static int LINKEDLIST_255		= 118;
+	public final static int LINKEDLIST			= 119;
+	
+
+	public final static int VECTOR_255			= 120;
+	public final static int VECTOR				= 121;
+	public final static int HASHTABLE_255		= 122;
+	public final static int HASHTABLE			= 123;
+	public final static int PROPERTIES_255		= 124;
+	public final static int PROPERTIES			= 125;
+	
+	public final static int CLASS				= 126;	
+	
+	public final static int STOREREFERENCE		= 160;
+	public final static int BLOCKIO				= 161;
+
+	public static final int BPAGE_LEAF 			= 162;
+	public static final int BPAGE_NONLEAF 		= 163;
+	public static final int HTREE_BUCKET 		= 164;
+	public static final int HTREE_DIRECTORY 	= 165;
+	public static final int JAVA_SERIALIZATION 	= 172;
+	
+	
+    /**
+     * Serialize the object into a byte array.
+     */
+    public static byte[] serialize( Object obj )
+        throws IOException
+    {
+    	ByteArrayOutputStream ba = new ByteArrayOutputStream();
+    	DataOutputStream da = new DataOutputStream(ba); 
+    	writeObject(da,obj);
+    	
+    	da.close();
+    	return ba.toByteArray();
+    }
+    
+    
+    
+	public static void writeObject(final DataOutputStream out, final Object obj) throws IOException {
+    	final int written = DEBUG?out.size():0;
+
+    	final Class clazz = obj!=null?obj.getClass():null;
+    	if(DEBUGSTORE){
+    		out.writeInt(DEBUGSTORE_DUMMY_START);
+    	}
+    	if(obj == null){
+    		out.write(NULL);    		
+    	}else if (clazz ==  Boolean.class){
+    		if(((Boolean)obj).booleanValue())
+    			out.write(BOOLEAN_TRUE);
+    		else
+    			out.write(BOOLEAN_FALSE);    		
+    	}else if (clazz ==  Integer.class){
+    		final int val = (Integer) obj;
+    		writeInteger(out, val);
+		}else if (clazz ==  Double.class){
+			double v = (Double) obj;
+			if(v == -1d)
+				out.write(DOUBLE_MINUS_1);
+			else if(v == 0d)
+				out.write(DOUBLE_0);
+			else if(v == 1d)
+				out.write(DOUBLE_1);
+			else if(v >= 0&& v<=255 && (int)v == v){
+				out.write(DOUBLE_255);
+				out.write((int) v);						
+			}else if(v >= Short.MIN_VALUE&& v<=Short.MAX_VALUE && (short)v == v){
+				out.write(DOUBLE_SHORT);
+				out.writeShort((int) v);			
+			}else{
+				out.write(DOUBLE_FULL);
+				out.writeDouble(v);
+			}
+		}else if (clazz ==  Float.class){
+			float v = (Float) obj;
+			if(v == -1f)
+				out.write(FLOAT_MINUS_1);
+			else if(v == 0f)
+				out.write(FLOAT_0);
+			else if(v == 1f)
+				out.write(FLOAT_1);
+			else if(v >= 0&& v<=255 && (int)v == v){
+				out.write(FLOAT_255);
+				out.write((int) v);						
+			}else if(v >= Short.MIN_VALUE&& v<=Short.MAX_VALUE && (short)v == v){
+				out.write(FLOAT_SHORT);
+				out.writeShort((int) v);			
+			
+			}else{
+				out.write(FLOAT_FULL);
+				out.writeFloat(v);
+			}		
+		}else if (clazz ==  Long.class){
+			final long val = (Long) obj;
+    		writeLong(out, val);
+		}else if (clazz ==  Short.class){
+			short val = (Short)obj;
+			if(val == -1)
+				out.write(SHORT_MINUS_1);
+			else if(val == 0)
+				out.write(SHORT_0);
+			else if(val == 1)
+				out.write(SHORT_1);
+			else if(val > 0 && val<255){
+				out.write(SHORT_255);
+				out.write(val);
+			}else{
+				out.write(SHORT_FULL);
+				out.writeShort(val);
+			}					
+		}else if (clazz ==  Byte.class){
+			byte val = (Byte)obj;
+			if(val == -1)
+				out.write(BYTE_MINUS_1);
+			else if(val == 0)
+				out.write(BYTE_0);
+			else if(val == 1)
+				out.write(BYTE_1);
+			else{
+				out.write(SHORT_FULL);
+				out.writeByte(val);
+			}
+    	}else if (clazz ==  Character.class){
+    		out.write(CHAR);
+    		out.writeChar((Character)obj);
+		}else if (clazz ==  BlockIo.class){
+			out.write(BLOCKIO);
+			((BlockIo)obj).writeExternal(out);
+		}else if (clazz ==  StoreReference.class){
+			out.write(STOREREFERENCE);
+			((StoreReference)obj).writeExternal(out);			
+		}else if(clazz == String.class){
+			byte[] s = ((String)obj).getBytes();
+			if(s.length==0){
+				out.write(STRING_EMPTY);
+			}else if(s.length<255){
+				out.write(STRING_255);
+				out.write(s.length);
+			}else{
+				out.write(STRING);
+				LongPacker.packInt(out, s.length);
+			}
+			out.write(s);
+		}else if(obj instanceof Class){
+			out.write(CLASS);
+			writeObject(out, ((Class)obj).getName());
+		}else if(obj instanceof int[]){
+			writeIntArray(out,(int[])obj);
+		}else if(obj instanceof long[]){
+			writeLongArray(out,(long[])obj);		
+		}else if(obj instanceof byte[]){
+			byte[] b = (byte[]) obj;
+			if(b.length<=255){
+				out.write(ARRAY_BYTE_255);
+				out.write(b.length);
+			}else{
+				out.write(ARRAY_BYTE_INT);
+				LongPacker.packInt(out,b.length);
+			}
+			out.write(b);
+
+		}else if(obj instanceof Object[]){
+			Object[] b = (Object[]) obj;
+			if(b.length<=255){
+				//check if it contains packable longs
+				boolean packableLongs = true;
+				for(Object o:b){
+					if(o!=null && (o.getClass() != Long.class || (((Long)o).longValue()<0 && ((Long)o).longValue()!=Long.MAX_VALUE))){
+						packableLongs = false;
+						break;
+					}					
+				}
+				if(packableLongs){
+					out.write(ARRAY_OBJECT_PACKED_LONG);
+					out.write(b.length);
+					for(Object o : b){
+						if(o == null)
+							LongPacker.packLong(out,0);
+						else
+							LongPacker.packLong(out,((Long)o).longValue()+1);
+					}
+
+				}else{				
+					out.write(ARRAY_OBJECT_255);
+					out.write(b.length);
+					for(Object o : b)
+						writeObject(out,o);
+				}
+
+			}else{
+				out.write(ARRAY_OBJECT);
+				LongPacker.packInt(out,b.length);
+				for(Object o : b)
+					writeObject(out,o);
+
+			}
+			
+		}else if(clazz ==  ArrayList.class){
+			ArrayList l = (ArrayList) obj;
+			if(l.size()<255){
+				//check if it contains packable longs
+				boolean packableLongs = true;
+				for(Object o:l){
+					if(o!=null && (o.getClass() != Long.class || (((Long)o).longValue()<0 && ((Long)o).longValue()!=Long.MAX_VALUE))){
+						packableLongs = false;
+						break;
+					}					
+				}
+				if(packableLongs){
+					out.write(ARRAYLIST_PACKED_LONG);
+					out.write(l.size());
+					for(Object o : l){
+						if(o == null)
+							LongPacker.packLong(out,0);
+						else
+							LongPacker.packLong(out,((Long)o).longValue()+1);
+					}
+				}else{
+					out.write(ARRAYLIST_255);
+					out.write(l.size());
+					for(Object o:l)
+						writeObject(out, o);					
+				}
+
+			}else{
+				out.write(ARRAYLIST);
+				LongPacker.packInt(out,l.size());
+				for(Object o:l)
+					writeObject(out, o);
+			}
+
+		}else if(clazz ==  LinkedList.class){
+			LinkedList l = (LinkedList) obj;
+			if(l.size()<255){
+				out.write(LINKEDLIST_255);
+				out.write(l.size());
+			}else{
+				out.write(LINKEDLIST);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l)
+				writeObject(out, o);
+		}else if(clazz ==  Vector.class){
+			Vector l = (Vector) obj;
+			if(l.size()<255){
+				out.write(VECTOR_255);
+				out.write(l.size());
+			}else{
+				out.write(VECTOR);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l)
+				writeObject(out, o);
+		}else if(clazz ==  TreeSet.class){
+			TreeSet l = (TreeSet) obj;
+			if(l.size()<255){
+				out.write(TREESET_255);
+				out.write(l.size());
+			}else{
+				out.write(TREESET);
+				LongPacker.packInt(out,l.size());
+			}
+			writeObject(out,l.comparator());
+
+			for(Object o:l)
+				writeObject(out, o);
+		}else if(clazz ==  HashSet.class){
+			HashSet l = (HashSet) obj;
+			if(l.size()<255){
+				out.write(HASHSET_255);
+				out.write(l.size());
+			}else{
+				out.write(HASHSET);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l)
+				writeObject(out, o);
+		}else if(clazz ==  LinkedHashSet.class){
+			LinkedHashSet l = (LinkedHashSet) obj;
+			if(l.size()<255){
+				out.write(LINKEDHASHSET_255);
+				out.write(l.size());
+			}else{
+				out.write(LINKEDHASHSET);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l)
+				writeObject(out, o);
+		}else if(clazz ==  TreeMap.class){
+			TreeMap l = (TreeMap) obj;
+			if(l.size()<255){
+				out.write(TREEMAP_255);
+				out.write(l.size());
+			}else{
+				out.write(TREEMAP);
+				LongPacker.packInt(out,l.size());
+			}
+
+			writeObject(out, l.comparator());
+			for(Object o:l.keySet()){
+				writeObject(out, o);
+				writeObject(out, l.get(o));
+			}
+		}else if(clazz ==  HashMap.class){
+			HashMap l = (HashMap) obj;
+			if(l.size()<255){
+				out.write(HASHMAP_255);
+				out.write(l.size());
+			}else{
+				out.write(HASHMAP);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l.keySet()){
+				writeObject(out, o);
+				writeObject(out, l.get(o));
+			}			
+		}else if(clazz ==  LinkedHashMap.class){
+			LinkedHashMap l = (LinkedHashMap) obj;
+			if(l.size()<255){
+				out.write(LINKEDHASHMAP_255);
+				out.write(l.size());
+			}else{
+				out.write(LINKEDHASHMAP);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l.keySet()){
+				writeObject(out, o);
+				writeObject(out, l.get(o));
+			}					
+		}else if(clazz ==  Hashtable.class){
+			Hashtable l = (Hashtable) obj;
+			if(l.size()<255){
+				out.write(HASHTABLE_255);
+				out.write(l.size());
+			}else{
+				out.write(HASHTABLE);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l.keySet()){
+				writeObject(out, o);
+				writeObject(out, l.get(o));
+			}					
+			
+		}else if(clazz ==  Properties.class){
+			Properties l = (Properties) obj;
+			if(l.size()<255){
+				out.write(PROPERTIES_255);
+				out.write(l.size());
+			}else{
+				out.write(PROPERTIES);
+				LongPacker.packInt(out,l.size());
+			}
+
+			for(Object o:l.keySet()){
+				writeObject(out, o);
+				writeObject(out, l.get(o));
+			}					
+			
+		}else{
+			out.write(serializeNormal(obj));
+			out.writeByte(END_OF_NORMAL_SERIALIZATION);
+		}
+    	
+    	if(DEBUGSTORE){
+    		out.writeInt(DEBUGSTORE_DUMMY_END);
+    	}
+
+    	if(DEBUG){
+    		System.out.println("SERIAL write object: "+(clazz!=null?clazz.getSimpleName():"null")+ " - " +(out.size() - written)+"B - "+obj);
+    	}
+	}
+
+
+	private static void writeLongArray(DataOutputStream da, long[] obj) throws IOException {
+		long max = Long.MIN_VALUE;
+		long min = Long.MAX_VALUE;
+		for(long i:obj){
+			max = Math.max(max, i);
+			min = Math.min(min, i);
+		}
+
+		if(0>=min && max<=255){
+			da.write(ARRAY_LONG_B);
+			LongPacker.packInt(da,obj.length);
+			for(long l : obj)
+				da.write((int) l);
+		}else if(0>=min && max<=Long.MAX_VALUE){
+			da.write(ARRAY_LONG_PACKED);
+			LongPacker.packInt(da,obj.length);
+			for(long l : obj)
+				LongPacker.packLong(da, l);			
+		}else if(Short.MIN_VALUE>=min && max<=Short.MAX_VALUE){
+			da.write(ARRAY_LONG_S);
+			LongPacker.packInt(da,obj.length);
+			for(long l : obj)
+				da.writeShort((short) l);			
+		}else if(Integer.MIN_VALUE>=min && max<=Integer.MAX_VALUE){
+			da.write(ARRAY_LONG_I);
+			LongPacker.packInt(da,obj.length);
+			for(long l : obj)
+				da.writeInt((int) l);			
+		}else{
+			da.write(ARRAY_LONG_L);
+			LongPacker.packInt(da,obj.length);
+			for(long l : obj)
+				da.writeLong(l);
+		}
+		
+	}
+
+
+	private static void writeIntArray(DataOutputStream da, int[] obj) throws IOException {
+		int max = Integer.MIN_VALUE;
+		int min = Integer.MAX_VALUE;
+		for(int i:obj){
+			max = Math.max(max, i);
+			min = Math.min(min, i);
+		}
+		
+		boolean fitsInByte = 0>=min && max<=255;
+		boolean fitsInShort = Short.MIN_VALUE>=min && max<=Short.MAX_VALUE;
+
+
+		if(obj.length<=255 && fitsInByte){
+			da.write(ARRAY_INT_B_255);
+			da.write(obj.length);
+			for(int i:obj)				
+				da.write(i);
+		}else if(fitsInByte){
+			da.write(ARRAY_INT_B_INT);
+			LongPacker.packInt(da,obj.length);
+			for(int i:obj)
+				da.write(i);
+		}else if(0>=min && max<=Integer.MAX_VALUE){
+			da.write(ARRAY_INT_PACKED);
+			LongPacker.packInt(da,obj.length);
+			for(int l : obj)
+				LongPacker.packInt(da, l);			
+		} else if(fitsInShort){
+			da.write(ARRAY_INT_S);
+			LongPacker.packInt(da,obj.length);
+			for(int i:obj)
+				da.writeShort(i);
+		}else{
+			da.write(ARRAY_INT_S);
+			LongPacker.packInt(da,obj.length);
+			for(int i:obj)
+				da.writeInt(i);									
+		}
+				
+	}
+
+
+	private static void writeInteger(DataOutputStream da, final int val) throws IOException {
+		if(val == -1)
+			da.write(INTEGER_MINUS_1);
+		else if (val == 0)
+			da.write(INTEGER_0);
+		else if (val == 1)
+			da.write(INTEGER_1);
+		else if (val == 2)
+			da.write(INTEGER_2);
+		else if (val == 3)
+			da.write(INTEGER_3);
+		else if (val == 4)
+			da.write(INTEGER_4);
+		else if (val == 5)
+			da.write(INTEGER_5);
+		else if (val == 6)
+			da.write(INTEGER_6);
+		else if (val == 7)
+			da.write(INTEGER_7);
+		else if (val == 8)
+			da.write(INTEGER_8);
+		else if (val == Integer.MIN_VALUE)
+			da.write(INTEGER_MINUS_MAX);		
+		else if(val >0 && val<255){
+			da.write(INTEGER_255);
+			da.write(val);
+		}else if(val <0){
+			da.write(INTEGER_PACK_NEG);
+			LongPacker.packInt(da, -val);
+		}else{
+			da.write(INTEGER_PACK);
+			LongPacker.packInt(da, val);
+		}
+	}
+
+	private static void writeLong(DataOutputStream da, final long val) throws IOException {
+		if(val == -1)
+			da.write(LONG_MINUS_1);
+		else if (val == 0)
+			da.write(LONG_0);
+		else if (val == 1)
+			da.write(LONG_1);
+		else if (val == 2)
+			da.write(LONG_2);
+		else if (val == 3)
+			da.write(LONG_3);
+		else if (val == 4)
+			da.write(LONG_4);
+		else if (val == 5)
+			da.write(LONG_5);
+		else if (val == 6)
+			da.write(LONG_6);
+		else if (val == 7)
+			da.write(LONG_7);
+		else if (val == 8)
+			da.write(LONG_8);
+		else if (val == Long.MIN_VALUE)
+			da.write(LONG_MINUS_MAX);		
+		else if(val >0 && val<255){
+			da.write(LONG_255);
+			da.write((int) val);
+		}else if(val <0){
+			da.write(LONG_PACK_NEG);
+			LongPacker.packLong(da, -val);
+		}else{
+			da.write(LONG_PACK);
+			LongPacker.packLong(da, val);
+		}
+	}
+
+
+	/**
+     * Deserialize an object from a byte array
+     * @throws IOException 
+     * @throws ClassNotFoundException 
+     */
+    public static Object deserialize( byte[] buf ) throws ClassNotFoundException, IOException{
+    	ByteArrayInputStream bs =  new ByteArrayInputStream(buf);
+    	DataInputStream das = new DataInputStream(bs);
+    	Object ret = readObject(das);
+		if(bs.available()!=0)
+			throw new InternalError("bytes left: "+bs.available());
+
+    	return ret;
+    }
+
+    
+    private static String deserializeString(DataInputStream buf) throws IOException {
+    	int len  = LongPacker.unpackInt(buf);
+    	byte[] b=  new byte[len];
+    	buf.readFully(b);
+    	return new String(b);
+	}
+
+	private static String deserializeString256Smaller(DataInputStream buf) throws IOException {
+    	int len  = buf.read();
+    	if (len < 0)
+    	    throw new EOFException();
+
+    	byte[] b=  new byte[len];
+    	buf.readFully(b);
+    	return new String(b);    	
+}
+	/**
+     * Serialize the object into a byte array.
+     */
+    protected static byte[] serializeNormal( Object obj )
+        throws IOException
+    {
+    	
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        baos.write(NORMAL);
+        ObjectOutputStream oos = new ObjectOutputStream( baos );
+        oos.writeObject( obj );
+        oos.close();
+        
+        
+        return baos.toByteArray();
+    }
+
+
+    /**
+     * Deserialize an object from a byte array
+     */
+    protected static Object deserializeNormal(DataInputStream buf )
+        throws ClassNotFoundException, IOException
+    {
+
+        ObjectInputStream ois = new ObjectInputStream( buf );
+        Object ret =  ois.readObject();
+        if(buf.readByte()!=END_OF_NORMAL_SERIALIZATION)
+        	throw new IOException("Wrong magic after serialization, maybe is Externalizable and wrong amount of bytes was read?");
+        return ret;
+    }
+
+    public static Object readObject(DataInputStream is) throws IOException, ClassNotFoundException{
+    	final int available = DEBUG?is.available():0;
+
+    	Object ret = null;
+    	
+    	if(DEBUGSTORE && is.readInt()!=DEBUGSTORE_DUMMY_START){    		
+    		throw new InternalError("Wrong offset");
+    	}    	
+    	
+    	int head = is.read();
+
+    	switch(head){
+    		case NULL:ret=  null;break;
+			case NORMAL:ret= deserializeNormal(is);break;
+			case BOOLEAN_TRUE:ret= true;break;
+			case BOOLEAN_FALSE:ret= false;break;
+			case INTEGER_MINUS_1:ret= Integer.valueOf(-1);break;
+			case INTEGER_0:ret= Integer.valueOf(0);break;
+			case INTEGER_1:ret= Integer.valueOf(1);break;
+			case INTEGER_2:ret= Integer.valueOf(2);break;
+			case INTEGER_3:ret= Integer.valueOf(3);break;
+			case INTEGER_4:ret= Integer.valueOf(4);break;
+			case INTEGER_5:ret= Integer.valueOf(5);break;
+			case INTEGER_6:ret= Integer.valueOf(6);break;
+			case INTEGER_7:ret= Integer.valueOf(7);break;
+			case INTEGER_8:ret= Integer.valueOf(8);break;
+			case INTEGER_MINUS_MAX:ret=  Integer.valueOf(Integer.MIN_VALUE);break;
+			case INTEGER_255:ret= Integer.valueOf(is.read());break;
+			case INTEGER_PACK_NEG:ret=  Integer.valueOf(-LongPacker.unpackInt(is));break;
+			case INTEGER_PACK:ret=  Integer.valueOf(LongPacker.unpackInt(is));break;
+			case LONG_MINUS_1:ret= Long.valueOf(-1);break;
+			case LONG_0:ret= Long.valueOf(0);break;
+			case LONG_1:ret= Long.valueOf(1);break;
+			case LONG_2:ret= Long.valueOf(2);break;
+			case LONG_3:ret= Long.valueOf(3);break;
+			case LONG_4:ret= Long.valueOf(4);break;
+			case LONG_5:ret= Long.valueOf(5);break;
+			case LONG_6:ret= Long.valueOf(6);break;
+			case LONG_7:ret= Long.valueOf(7);break;
+			case LONG_8:ret= Long.valueOf(8);break;
+			case LONG_255:ret= Long.valueOf(is.read());break;
+			case LONG_PACK_NEG:ret=  Long.valueOf(-LongPacker.unpackLong(is));break;
+			case LONG_PACK:ret=  Long.valueOf(LongPacker.unpackLong(is));break;
+			case LONG_MINUS_MAX:ret=  Long.valueOf(Long.MIN_VALUE);break;
+			case SHORT_MINUS_1:ret= Short.valueOf((short)-1);break;
+			case SHORT_0:ret= Short.valueOf((short)0);break;
+			case SHORT_1:ret= Short.valueOf((short)1);break;
+			case SHORT_255:ret= Short.valueOf((short)is.read());break;
+			case SHORT_FULL:ret= Short.valueOf(is.readShort());break;
+			case BYTE_MINUS_1:ret= Byte.valueOf((byte)-1);break;
+			case BYTE_0:ret= Byte.valueOf((byte)0);break;
+			case BYTE_1:ret= Byte.valueOf((byte)1);break;
+			case BYTE_FULL:ret= Byte.valueOf(is.readByte());break;
+			case CHAR:ret= Character.valueOf(is.readChar());break;
+			case FLOAT_MINUS_1:ret= Float.valueOf(-1);break;
+			case FLOAT_0:ret= Float.valueOf(0);break;
+			case FLOAT_1:ret= Float.valueOf(1);break;
+			case FLOAT_255:ret= Float.valueOf(is.read());break;
+			case FLOAT_SHORT:ret=  Float.valueOf(is.readShort());break;
+			case FLOAT_FULL:ret= Float.valueOf(is.readFloat());break;
+			case DOUBLE_MINUS_1:ret= Double.valueOf(-1);break;
+			case DOUBLE_0:ret= Double.valueOf(0);break;
+			case DOUBLE_1:ret= Double.valueOf(1);break;
+			case DOUBLE_255:ret= Double.valueOf(is.read());break;
+			case DOUBLE_SHORT:ret= Double.valueOf(is.readShort());break;
+			case DOUBLE_FULL:ret= Double.valueOf(is.readDouble());break;			
+			case BLOCKIO:ret= deserializeBlockIo(is);break;
+			case STOREREFERENCE:ret= deserializeStoreReference(is);break;
+			case STRING_255:ret= deserializeString256Smaller(is);break;
+			case STRING:ret= deserializeString(is);break;
+			case STRING_EMPTY:ret= "";break;
+			case ARRAYLIST_255:ret= deserializeArrayList256Smaller(is);break;
+			case ARRAYLIST:ret= deserializeArrayList(is);break;
+			case ARRAYLIST_PACKED_LONG:ret= deserializeArrayListPackedLong(is);break;
+			case ARRAY_OBJECT_255:ret= deserializeArrayObject256Smaller(is);break;
+			case ARRAY_OBJECT:ret= deserializeArrayObject(is);break;
+			case ARRAY_OBJECT_PACKED_LONG:ret= deserializeArrayObjectPackedLong(is);break;
+			case LINKEDLIST_255:ret= deserializeLinkedList256Smaller(is);break;
+			case LINKEDLIST:ret= deserializeLinkedList(is);break;
+			case TREESET_255:ret= deserializeTreeSet256Smaller(is);break;
+			case TREESET:ret= deserializeTreeSet(is);break;
+			case HASHSET_255:ret= deserializeHashSet256Smaller(is);break;
+			case HASHSET:ret= deserializeHashSet(is);break;
+			case LINKEDHASHSET_255:ret= deserializeLinkedHashSet256Smaller(is);break;
+			case LINKEDHASHSET:ret= deserializeLinkedHashSet(is);break;
+			case VECTOR_255:ret= deserializeVector256Smaller(is);break;
+			case VECTOR:ret= deserializeVector(is);break;
+			case TREEMAP_255:ret= deserializeTreeMap256Smaller(is);break;
+			case TREEMAP:ret= deserializeTreeMap(is);break;
+			case HASHMAP_255:ret= deserializeHashMap256Smaller(is);break;
+			case HASHMAP:ret= deserializeHashMap(is);break;
+			case LINKEDHASHMAP_255:ret= deserializeLinkedHashMap256Smaller(is);break;
+			case LINKEDHASHMAP:ret= deserializeLinkedHashMap(is);break;
+			case HASHTABLE_255:ret= deserializeHashtable256Smaller(is);break;
+			case HASHTABLE:ret= deserializeHashtable(is);break;
+			case PROPERTIES_255:ret= deserializeProperties256Smaller(is);break;
+			case PROPERTIES:ret= deserializeProperties(is);break;
+			case CLASS:ret= deserializeClass(is);break;
+			
+			
+			case ARRAY_INT_B_255: ret= deserializeArrayIntB255(is);break;
+			case ARRAY_INT_B_INT: ret= deserializeArrayIntBInt(is);break;
+			case ARRAY_INT_S: ret= deserializeArrayIntSInt(is);break;
+			case ARRAY_INT_I: ret= deserializeArrayIntIInt(is);break;
+			case ARRAY_INT_PACKED: ret= deserializeArrayIntPack(is);break;
+			case ARRAY_LONG_B: ret= deserializeArrayLongB(is);break;
+			case ARRAY_LONG_S: ret= deserializeArrayLongS(is);break;
+			case ARRAY_LONG_I: ret= deserializeArrayLongI(is);break;
+			case ARRAY_LONG_L: ret= deserializeArrayLongL(is);break;
+			case ARRAY_LONG_PACKED: ret= deserializeArrayLongPack(is);break;
+			case ARRAY_BYTE_255: ret= deserializeArrayByte255(is);break;
+			case ARRAY_BYTE_INT: ret= deserializeArrayByteInt(is);break;
+			case BPAGE_LEAF: throw new InternalError("BPage header, wrong serializer used");
+			case BPAGE_NONLEAF: throw new InternalError("BPage header, wrong serializer used");
+			case JAVA_SERIALIZATION: throw new InternalError("Wrong header, data were propably serialized with OutputStream, not with JDBM serialization");
+			
+			case -1: throw new EOFException();
+			
+			default: throw new InternalError("Unknown serialization header: "+head);
+    	}
+        	    	
+    	if(DEBUG){
+    		System.out.println("SERIAL read object: "+ret.getClass().getSimpleName()+" - "+(available-is.available())+"B - "+ ret);
+    	}
+
+    	if(DEBUGSTORE && is.readInt()!=DEBUGSTORE_DUMMY_END){
+    		throw new InternalError("Wrong offset '"+ret+ "' - "+ret.getClass());
+    	}
+
+    
+    	return ret;
+	}
+
+
+	private static Class deserializeClass(DataInputStream is) throws IOException, ClassNotFoundException {
+		String className = (String) readObject(is);
+		Class cls = Class.forName(className);
+		return cls;
+	}
+
+
+
+	private static StoreReference deserializeStoreReference(DataInputStream is) throws IOException {
+		StoreReference r = new StoreReference();
+		r.readExternal(is);
+		return r;
+	}
+
+
+
+	private static byte[] deserializeArrayByteInt(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		byte[] b = new byte[size];
+		is.readFully(b);
+		return b;
+	}
+
+
+	private static byte[] deserializeArrayByte255(DataInputStream is) throws IOException {
+		int size = is.read();
+    	if (size < 0)
+    	    throw new EOFException();
+
+		byte[] b = new byte[size];
+		is.readFully(b);
+		return b;
+
+	}
+
+
+	private static long[] deserializeArrayLongL(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		long[] ret = new long[size];
+		for(int i=0;i<size;i++)
+			ret[i] = is.readLong();
+		return ret;	
+	}
+
+
+	private static long[] deserializeArrayLongI(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		long[] ret = new long[size];
+		for(int i=0;i<size;i++)
+			ret[i] = is.readInt();
+		return ret;	
+	}
+
+
+	private static long[] deserializeArrayLongS(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		long[] ret = new long[size];
+		for(int i=0;i<size;i++)
+			ret[i] = is.readShort();
+		return ret;	
+	}
+
+
+	private static long[] deserializeArrayLongB(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		long[] ret = new long[size];
+		for(int i=0;i<size;i++){
+			ret[i] = is.read();
+			if(ret[i] <0)
+	    	    throw new EOFException();
+		}
+		return ret;
+	}
+
+
+	private static int[] deserializeArrayIntIInt(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		int[] ret = new int[size];
+		for(int i=0;i<size;i++)
+			ret[i] = is.readInt();
+		return ret;
+	}
+
+
+	private static int[] deserializeArrayIntSInt(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		int[] ret = new int[size];
+		for(int i=0;i<size;i++)
+			ret[i] = is.readShort();
+		return ret;
+	}
+
+
+
+	private static int[] deserializeArrayIntBInt(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+		int[] ret = new int[size];
+		for(int i=0;i<size;i++){
+			ret[i] = is.read();
+			if(ret[i] <0)
+	    	    throw new EOFException();
+		}
+		return ret;	}
+
+
+	private static int[] deserializeArrayIntPack(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+    	if (size < 0)
+    	    throw new EOFException();
+
+		int[] ret = new int[size];
+		for(int i=0;i<size;i++){
+			ret[i] = LongPacker.unpackInt(is);
+		}
+		return ret;	
+	}
+	
+	private static long[] deserializeArrayLongPack(DataInputStream is) throws IOException {
+		int size = LongPacker.unpackInt(is);
+    	if (size < 0)
+    	    throw new EOFException();
+
+		long[] ret = new long[size];
+		for(int i=0;i<size;i++){
+			ret[i] = LongPacker.unpackLong(is);
+		}
+		return ret;	
+	}
+
+	private static int[] deserializeArrayIntB255(DataInputStream is) throws IOException {
+		int size = is.read();
+    	if (size < 0)
+    	    throw new EOFException();
+
+		int[] ret = new int[size];
+		for(int i=0;i<size;i++){
+			ret[i] = is.read();
+			if(ret[i] <0)
+	    	    throw new EOFException();
+		}
+		return ret;	}
+
+
+	private static BlockIo deserializeBlockIo(DataInputStream is) throws IOException, ClassNotFoundException {
+		BlockIo b = new BlockIo();
+		b.readExternal(is);
+		return b;
+	}
+	
+	private static Object[] deserializeArrayObject(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size =LongPacker.unpackInt(is);
+		Object[] s = new Object[size];
+		for(int i = 0; i<size;i++)
+			s[i] = readObject(is);
+		return s;
+	}
+	
+	private static Object[] deserializeArrayObjectPackedLong(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		Object[] s = new Object[size];
+		for(int i = 0; i<size;i++){
+			long l = LongPacker.unpackLong(is);
+			if(l == 0)
+				s[i] = null;
+			else
+				s[i] = Long.valueOf(l-1);			
+		}
+		return s;
+	}
+
+
+	private static Object[] deserializeArrayObject256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		Object[] s = new Object[size];
+		for(int i = 0; i<size;i++)
+			s[i] = readObject(is);
+		return s;
+	}
+
+	private static ArrayList<Object> deserializeArrayList(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);
+		ArrayList<Object> s = new ArrayList<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+	
+	private static ArrayList<Object> deserializeArrayListPackedLong(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		ArrayList<Object> s = new ArrayList<Object>(size);
+		for(int i = 0; i<size;i++){
+			long l = LongPacker.unpackLong(is);
+			if(l == 0)
+				s.add(null);
+			else
+				s.add( Long.valueOf(l-1));			
+		}
+		return s;
+	}
+
+	private static ArrayList<Object> deserializeArrayList256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		ArrayList<Object> s = new ArrayList<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	private static LinkedList<Object> deserializeLinkedList(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);
+		LinkedList<Object> s = new LinkedList<Object>();
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	private static LinkedList<Object> deserializeLinkedList256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		LinkedList<Object> s = new LinkedList<Object>();
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+	
+	private static Vector<Object> deserializeVector(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);
+		Vector<Object> s = new Vector<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	private static Vector<Object> deserializeVector256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		Vector<Object> s = new Vector<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+	
+	private static HashSet<Object> deserializeHashSet(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);
+		HashSet<Object> s = new HashSet<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	private static HashSet<Object> deserializeHashSet256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		HashSet<Object> s = new HashSet<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	private static LinkedHashSet<Object> deserializeLinkedHashSet(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);
+		LinkedHashSet<Object> s = new LinkedHashSet<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	private static LinkedHashSet<Object> deserializeLinkedHashSet256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		LinkedHashSet<Object> s = new LinkedHashSet<Object>(size);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+	
+	
+	private static TreeSet<Object> deserializeTreeSet(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);		
+		TreeSet<Object> s = new TreeSet<Object>();
+		Comparator comparator = (Comparator) readObject(is);
+		if(comparator!=null)
+			s = new TreeSet<Object>(comparator);
+		
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	private static TreeSet<Object> deserializeTreeSet256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		TreeSet<Object> s = new TreeSet<Object>();
+		Object obj = readObject(is);
+		Comparator comparator = (Comparator) obj;
+		if(comparator!=null)
+			s = new TreeSet<Object>(comparator);
+		for(int i = 0; i<size;i++)
+			s.add(readObject(is));
+		return s;
+	}
+
+	
+	private static TreeMap<Object,Object> deserializeTreeMap(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);		
+
+		TreeMap<Object,Object> s = new TreeMap<Object,Object>();
+		Comparator comparator = (Comparator) readObject(is);
+		if(comparator!=null)
+			s = new TreeMap<Object,Object>(comparator);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+
+	private static TreeMap<Object,Object> deserializeTreeMap256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		TreeMap<Object,Object> s = new TreeMap<Object,Object>();
+		Comparator comparator = (Comparator) readObject(is);
+		if(comparator!=null)
+			s = new TreeMap<Object,Object>(comparator);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+
+	
+	private static HashMap<Object,Object> deserializeHashMap(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);		
+
+		HashMap<Object,Object> s = new HashMap<Object,Object>(size);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+
+	private static HashMap<Object,Object> deserializeHashMap256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		HashMap<Object,Object> s = new HashMap<Object,Object>(size);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+	
+	
+	private static LinkedHashMap<Object,Object> deserializeLinkedHashMap(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);		
+
+		LinkedHashMap<Object,Object> s = new LinkedHashMap<Object,Object>(size);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+
+	private static LinkedHashMap<Object,Object> deserializeLinkedHashMap256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		LinkedHashMap<Object,Object> s = new LinkedHashMap<Object,Object>(size);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+
+	
+	private static Hashtable<Object,Object> deserializeHashtable(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);		
+
+		Hashtable<Object,Object> s = new Hashtable<Object,Object>(size);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+
+	private static Hashtable<Object,Object> deserializeHashtable256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		Hashtable<Object,Object> s = new Hashtable<Object,Object>(size);
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+	
+	
+	private static Properties deserializeProperties(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = LongPacker.unpackInt(is);		
+
+		Properties s = new Properties();
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}
+
+	private static Properties deserializeProperties256Smaller(DataInputStream is) throws IOException, ClassNotFoundException {
+		int size = is.read();
+		if(size <0)
+    	    throw new EOFException();
+
+		Properties s = new Properties();
+		for(int i = 0; i<size;i++)
+			s.put(readObject(is),readObject(is));
+		return s;
+	}	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/StoreReference.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/StoreReference.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,102 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.helper;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOError;
+import java.io.IOException;
+
+import jdbm.RecordManager;
+import jdbm.Serializer;
+
+public class StoreReference<E> {
+
+	private long recid = -1;
+
+	/** this constructor is package private, and is used by Serialization */
+	StoreReference(){
+	}
+	
+	/** Public constructor which takes value and RecordManager */
+	public StoreReference(RecordManager recman, E val,Serializer<E> serializer){
+		if(recman == null)
+			throw new IllegalArgumentException("RecordManager is null");
+		if(serializer == null)
+			throw new IllegalArgumentException("Serializer is null");
+		
+		if(val == null)
+			throw new IllegalArgumentException("Can not store null value");
+		if(val instanceof StoreReference)
+			throw new IllegalArgumentException("Can not store other reference");
+		
+		try {
+			recid = recman.insert(val, serializer);
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+	}
+	
+	public StoreReference(RecordManager recman, E val){
+		this(recman,val,(Serializer<E>) DefaultSerializer.INSTANCE);
+	}
+	
+	
+	public E get(RecordManager recman2, Serializer<E> serializer2){
+//		if(val!=null)
+//			return val;
+		if(recid!=-1)try{			
+			return recman2.fetch(recid,serializer2);
+		}catch(IOException e){
+			throw new IOError(e);
+		}
+		throw new IllegalStateException("Should not be here");			
+	}
+	
+	public E get(RecordManager recman2){
+		return get(recman2,(Serializer<E>) DefaultSerializer.INSTANCE);
+	}
+	
+	void writeExternal(DataOutputStream d) throws IOException{
+		if(recid==-1)
+			throw new IllegalStateException("not initialized");
+			
+		
+		d.writeLong(recid);
+	}
+	
+	void readExternal(DataInputStream d) throws IOException{
+		if(recid!=-1)
+			throw new IllegalStateException("already initialized");
+		recid = d.readLong();
+	}
+
+	public long getRecId() {
+		return recid;
+	}
+
+	public void remove(RecordManager recordManager) {
+		if(recid==-1)
+			throw new IllegalStateException("alread removed");
+
+		try {
+			recordManager.delete(recid);
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+	}
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/Tuple.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/Tuple.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,91 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.helper;
+
+
+/**
+ * Tuple consisting of a key-value pair.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @version $Id: Tuple.java,v 1.2 2001/05/19 14:02:00 boisvert Exp $
+ */
+public final class Tuple<K,V> {
+
+    /**
+     * Key
+     */
+    private K _key;
+
+
+    /**
+     * Value
+     */
+    private V _value;
+
+
+    /**
+     * Construct an empty Tuple.
+     */
+    public Tuple() {
+        // empty
+    }
+
+
+    /**
+     * Construct a Tuple.
+     *
+     * @param key The key.
+     * @param value The value.
+     */
+    public Tuple( K key, V value ) {
+        _key = key;
+        _value = value;
+    }
+
+
+    /**
+     * Get the key.
+     */
+    public K getKey() {
+        return _key;
+    }
+
+
+    /**
+     * Set the key.
+     */
+    public void setKey( K key ) {
+        _key = key;
+    }
+
+
+    /**
+     * Get the value.
+     */
+    public V getValue() {
+        return _value;
+    }
+
+
+    /**
+     * Set the value.
+     */
+    public void setValue( V value ) {
+        _value = value;
+    }
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/TupleBrowser.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/TupleBrowser.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,51 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.helper;
+
+import java.io.IOException;
+
+/**
+ * Browser to traverse a collection of tuples.  The browser allows for
+ * forward and reverse order traversal.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @version $Id: TupleBrowser.java,v 1.2 2001/05/19 14:02:00 boisvert Exp $
+ */
+public interface  TupleBrowser<K,V> {
+
+    /**
+     * Get the next tuple.
+     *
+     * @param tuple Tuple into which values are copied.
+     * @return True if values have been copied in tuple, or false if there is
+     *         no next tuple.
+     */
+    public abstract boolean getNext( Tuple<K,V> tuple )
+        throws IOException;
+
+
+    /**
+     * Get the previous tuple.
+     *
+     * @param tuple Tuple into which values are copied.
+     * @return True if values have been copied in tuple, or false if there is
+     *         no previous tuple.
+     */
+    public abstract boolean getPrevious( Tuple<K,V> tuple )
+        throws IOException;
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/package.html
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/package.html	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,12 @@
+<!-- $Id: package.html,v 1.1 2001/05/19 16:01:33 boisvert Exp $ -->
+<html>
+  <body>
+    <p>Miscelaneous utility classes and interfaces.</p>
+
+    <dl>
+      <dt><b>Version: </b></dt><dd>$Revision: 1.1 $ $Date: 2001/05/19 16:01:33 $</dd>
+      <dt><b>Author: </b></dt><dd><a href="mailto:boisvert at intalio.com">Alex Boisvert</a></dd>
+    </dl>
+
+  </body>
+</html>

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTree.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTree.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,308 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.htree;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import jdbm.*;
+import jdbm.helper.JdbmBase;
+import jdbm.helper.Serialization;
+
+/**
+ *  Persistent hashtable implementation for PageManager.
+ *  Implemented as an H*Tree structure.
+ *
+ *  WARNING!  If this instance is used in a transactional context, it
+ *            *must* be discarded after a rollback.
+ *
+ *  @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ *  @version $Id: HTree.java,v 1.3 2005/06/25 23:12:32 doomdark Exp $
+ */
+public class HTree<K,V> implements JdbmBase<K,V>
+{
+
+    final Serializer SERIALIZER = new Serializer<HashNode>() {
+
+        public HashNode deserialize(SerializerInput ds) throws IOException {
+            try{
+                int i = ds.read();
+                if(i == Serialization.HTREE_BUCKET){ //is HashBucket?
+                    HashBucket ret = new HashBucket(HTree.this);
+                    ret.readExternal(ds);
+                    if(ds.available()!=0 && ds.read()!=-1) // -1 is fix for compression, not sure what is happening
+                        throw new InternalError("bytes left: "+ds.available());
+                    return ret;
+                }else if( i == Serialization.HTREE_DIRECTORY){
+                    HashDirectory ret = new HashDirectory(HTree.this);
+                    ret.readExternal(ds);
+                    if(ds.available()!=0 && ds.read()!=-1) // -1 is fix for compression, not sure what is happening
+                        throw new InternalError("bytes left: "+ds.available());
+                    return ret;
+                }else {
+                    throw new InternalError("Wrong HTree header: "+i);
+                }
+            }catch(ClassNotFoundException e){
+                throw new IOException(e);
+            }
+
+        }
+        public void serialize(SerializerOutput out, HashNode obj) throws IOException {
+            if(obj.getClass() ==  HashBucket.class){
+                out.write(Serialization.HTREE_BUCKET);
+                HashBucket b = (HashBucket) obj;
+                b.writeExternal(out);
+            }else{
+                out.write(Serialization.HTREE_DIRECTORY);
+                HashDirectory n = (HashDirectory) obj;
+                n.writeExternal(out);
+            }
+        }
+    };
+
+
+    /**
+     * Root hash directory.
+     */
+    private HashDirectory<K,V> _root;
+
+
+    /**
+     * Listeners which are notified about changes in records
+     */
+    protected List<RecordListener<K,V>> recordListeners = new ArrayList<RecordListener<K,V>>();
+
+ /**
+     * Serializer used to serialize index keys (optional)
+     */
+    protected Serializer<K> keySerializer;
+
+
+    /**
+     * Serializer used to serialize index values (optional)
+     */
+    protected Serializer<V> valueSerializer;
+
+
+    public Serializer<K> getKeySerializer() {
+		return keySerializer;
+	}
+
+	public Serializer<V> getValueSerializer() {
+		return valueSerializer;
+	}
+
+
+    HTree() {
+    }
+
+
+    /**
+     * Create a persistent hashtable.
+     *
+     * @param recman Record manager used for persistence.
+     */
+    public static <K,V> HTree<K,V> createInstance( RecordManager recman )
+        throws IOException
+    {
+        return createInstance(recman, null, null);
+    }
+
+    /**
+     * Create a persistent hashtable.
+     *
+     * @param recman Record manager used for persistence.
+     */
+    public static <K,V> HTree<K,V> createInstance( RecordManager recman,
+                                                   Serializer<K> keySerializer,
+                                                   Serializer<V> valueSerializer )
+        throws IOException
+    {
+        HashDirectory<K,V>  root;
+        long           recid;
+
+        HTree<K,V> tree = new HTree<K,V>();
+        tree.keySerializer = keySerializer;
+        tree.valueSerializer = valueSerializer;
+
+        tree._root = new HashDirectory<K,V>( tree, (byte) 0 );
+        recid = recman.insert( tree._root, tree.SERIALIZER );
+        tree._root.setPersistenceContext(recman, recid);
+
+        return tree;
+    }
+
+
+    /**
+     * Load a persistent hashtable
+     *
+     * @param recman RecordManager used to store the persistent hashtable
+     * @param root_recid Record id of the root directory of the HTree
+     */
+    public static <K,V>  HTree<K,V> load( RecordManager recman,
+                                          long root_recid)
+    throws IOException
+    {
+        return load(recman, root_recid, null, null);
+    }
+    /**
+     * Load a persistent hashtable
+     *
+     * @param recman RecordManager used to store the persistent hashtable
+     * @param root_recid Record id of the root directory of the HTree
+     */
+    public static <K,V>  HTree<K,V> load( RecordManager recman,
+                                          long root_recid,
+                                          Serializer<K> keySerializer,
+                                          Serializer<V> valueSerializer )
+        throws IOException
+    {
+        HashDirectory<K,V> root;
+
+        HTree<K,V> tree = new HTree<K,V>();
+        tree.keySerializer = keySerializer;
+        tree.valueSerializer = valueSerializer;
+
+        tree._root = (HashDirectory<K,V>) recman.fetch( root_recid, tree.SERIALIZER  );
+        tree._root.setPersistenceContext( recman, root_recid );
+
+        return tree;
+    }
+
+    transient long hashEqualsIdentityCounter=0;
+    
+    /**
+     * Associates the specified value with the specified key.
+     *
+     * @param key key with which the specified value is to be assocated.
+     * @param value value to be associated with the specified key.
+     */
+    public synchronized void put(K key, V value)
+        throws IOException
+    {
+    	V oldVal = null;
+    	if(!recordListeners.isEmpty())
+    		oldVal = find(key);
+    	
+        _root.put(key, value);
+        
+        if(oldVal == null){
+        	for(RecordListener<K,V> r : recordListeners)
+        		r.recordInserted(key,value);
+        }else{
+        	for(RecordListener<K,V> r : recordListeners)
+        		r.recordUpdated(key,oldVal,value);
+        }        	
+    }
+
+
+    /**
+     * Returns the value which is associated with the given key. Returns
+     * <code>null</code> if there is not association for this key.
+     *
+     * @param key key whose associated value is to be returned
+     */
+    public synchronized V find(K key)
+        throws IOException
+    {
+        return _root.get(key);
+    }
+
+
+    /**
+     * Remove the value which is associated with the given key.  If the
+     * key does not exist, this method simply ignores the operation.
+     *
+     * @param key key whose associated value is to be removed
+     */
+    public synchronized void remove(K key)
+        throws IOException
+    {
+    	V val = null;
+    	if(!recordListeners.isEmpty())
+    		val = find(key);
+
+        _root.remove(key);
+    	if(val!=null)
+    		for(RecordListener<K,V> r : recordListeners)
+    			r.recordRemoved(key,val);
+
+    }
+
+
+    /**
+     * Returns an enumeration of the keys contained in this
+     */
+    public synchronized Iterator<K> keys()
+        throws IOException
+    {
+        return _root.keys();
+    }
+
+
+    /**
+     * Returns an enumeration of the values contained in this
+     */
+    public synchronized Iterator<V> values()
+        throws IOException
+    {
+        return _root.values();
+    }
+
+
+    /**
+     * Get the record identifier used to load this hashtable.
+     */
+    public long getRecid()
+    {
+        return _root.getRecid();
+    }
+    
+    public HTreeMap<K,V> asMap(){
+    	return new HTreeMap<K,V>(this,false);
+    }
+    
+    
+    /**
+     * add RecordListener which is notified about record changes
+     * @param listener
+     */
+    public void addRecordListener(RecordListener<K,V> listener){
+    	recordListeners.add(listener);
+    }
+
+    /**
+     * remove RecordListener which is notified about record changes
+     * @param listener
+     */
+    public void removeRecordListener(RecordListener<K,V> listener){
+    	recordListeners.remove(listener);
+    }
+
+
+	public RecordManager getRecordManager() {
+		return _root.getRecordManager();
+	}
+
+
+    
+
+
+}
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTreeMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTreeMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,279 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.htree;
+
+import java.io.IOError;
+import java.io.IOException;
+import java.util.AbstractSet;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import jdbm.PrimaryHashMap;
+import jdbm.RecordListener;
+import jdbm.RecordManager;
+import jdbm.helper.AbstractPrimaryMap;
+
+
+public class HTreeMap<K,V> extends AbstractPrimaryMap<K,V> implements PrimaryHashMap<K,V>{
+	
+	protected final HTree<K,V> tree;
+	protected final  boolean readonly;
+	
+	public HTreeMap(HTree<K,V> tree, boolean readonly){
+		this.tree = tree;
+		this.readonly = readonly;
+	}
+
+	@Override
+	public Set<java.util.Map.Entry<K, V>> entrySet() {
+		return new AbstractSet<Entry<K,V>>(){
+			
+			protected Entry<K,V> newEntry(K k,V v){
+				return new SimpleEntry<K,V>(k,v){
+					private static final long serialVersionUID = 978651696969194154L;
+
+					public V setValue(V arg0) {
+						HTreeMap.this.put(getKey(), arg0);
+						return super.setValue(arg0);
+					};
+					
+				};
+			}
+
+			public boolean add(java.util.Map.Entry<K, V> e) {
+				if(readonly)
+					throw new UnsupportedOperationException("readonly");
+
+				try {
+					if(e.getKey() == null)
+						throw new NullPointerException("Can not add null key");
+					if(e.getValue().equals(tree.find(e.getKey())))
+							return false;
+					tree.put(e.getKey(), e.getValue());
+					return true;
+				} catch (IOException e1) {
+					throw new IOError(e1);
+				}
+			}
+
+			@SuppressWarnings("unchecked")
+			public boolean contains(Object o) {
+				if(o instanceof Entry){
+					Entry<K,V> e = (java.util.Map.Entry<K, V>) o;
+					try {
+						if(e.getKey()!=null && tree.find(e.getKey())!=null)
+							return true;
+					} catch (IOException e1) {
+						throw new IOError(e1);
+					}
+				}
+				return false;
+			}
+
+
+			public Iterator<java.util.Map.Entry<K, V>> iterator() {
+				try {
+					final Iterator<K> br = tree.keys();				
+				return new Iterator<Entry<K,V>>(){
+					
+					private Entry<K,V> next;
+					private K lastKey;
+					void ensureNext(){
+						try{
+							if(br.hasNext()){
+								K k = br.next();
+								next = newEntry(k,tree.find(k));
+							}else
+								next = null;
+						}catch (IOException e){
+							throw new IOError(e);
+						}
+					}
+					{
+						ensureNext();
+					}
+					
+					
+
+					public boolean hasNext() {
+						return next!=null;
+					}
+
+					public java.util.Map.Entry<K, V> next() {
+						if(next == null)
+							throw new NoSuchElementException();
+						Entry<K,V> ret = next;
+						lastKey = ret.getKey();
+						//move to next position
+						ensureNext();
+						return ret;
+					}
+
+					public void remove() {
+						if(readonly)
+							throw new UnsupportedOperationException("readonly");
+						if(lastKey == null)
+							throw new IllegalStateException();
+
+							HTreeMap.this.remove(lastKey);
+							lastKey = null;
+					}};
+					
+				} catch (IOException e) {
+					throw new IOError(e);
+				}
+					
+			}
+
+			@SuppressWarnings("unchecked")
+			public boolean remove(Object o) {
+				if(readonly)
+					throw new UnsupportedOperationException("readonly");
+				
+				if(o instanceof Entry){
+					Entry<K,V> e = (java.util.Map.Entry<K, V>) o;
+					try {
+						//check for nulls
+						if(e.getKey() == null || e.getValue() == null)
+							return false;
+						//find old value, must be same as item in entry
+						V v = get(e.getKey());
+						if(v == null || !e.getValue().equals(v))
+							return false;
+						tree.remove(e.getKey());
+						return true;
+					} catch (IOException e1) {
+						throw new IOError(e1);
+					}
+				}
+				return false;
+
+			}
+
+			@Override
+			public int size() {
+				try{
+					int counter = 0;
+					Iterator<K> it = tree.keys();
+					while(it.hasNext()){
+						it.next();
+						counter ++;
+					}
+					return counter;
+				}catch (IOException e){
+					throw new IOError(e);
+				}
+					
+			}
+
+		};
+	}
+	
+	@SuppressWarnings("unchecked")
+	@Override
+	public V get(Object key) {
+		try{
+			if(key == null)
+				return null;
+			return tree.find((K) key);
+		}catch (ClassCastException e){
+			return null;
+		}catch (IOException e){
+			throw new IOError(e);
+		}
+	}
+	
+	@SuppressWarnings("unchecked")
+	@Override
+	public V remove(Object key) {
+		if(readonly)
+			throw new UnsupportedOperationException("readonly");
+		
+		try{
+			if(key == null)
+				return null;
+			V oldVal = tree.find((K) key);
+			if(oldVal!=null)
+				tree.remove((K) key);
+			return oldVal;
+		}catch (ClassCastException e){
+			return null;
+		}catch (IOException e){
+			throw new IOError(e);
+		}
+	}
+	
+	public V put(K key, V value) {
+		if(readonly)
+			throw new UnsupportedOperationException("readonly");
+
+		try {
+			if(key == null || value == null)
+				throw new NullPointerException("Null key or value");
+			V oldVal = tree.find(key);			
+			tree.put(key, value);
+			return oldVal;
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+	};
+	
+	@SuppressWarnings("unchecked")
+	@Override
+	public boolean containsKey(Object key) {
+		if(key == null)
+			return false;
+		try {
+			V v = tree.find((K) key);
+			return v!=null;
+		} catch (IOException e) {
+			throw new IOError(e);
+		} catch (ClassCastException e){
+			return false;
+		}
+	}
+
+	public HTree<K, V> getTree() {
+		return tree;
+	}
+
+	
+	public void addRecordListener(RecordListener<K, V> listener) {
+		tree.addRecordListener(listener);
+	}
+
+	public RecordManager getRecordManager() {
+		return tree.getRecordManager();
+	}
+
+	public void removeRecordListener(RecordListener<K, V> listener) {
+		tree.removeRecordListener(listener);		
+	}
+
+
+    public void clear(){
+        try{
+            Iterator<K> keyIter = tree.keys();
+            while(keyIter.hasNext())
+                tree.remove(keyIter.next());
+        }catch(IOException e){
+            throw new IOError(e);
+        }
+    }
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTreeSecondaryMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HTreeSecondaryMap.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,45 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package jdbm.htree;
+
+import java.io.IOError;
+import java.io.IOException;
+
+import jdbm.SecondaryHashMap;
+import jdbm.helper.JdbmBase;
+import jdbm.helper.SecondaryKeyHelper;
+
+public class HTreeSecondaryMap<A,K,V> extends HTreeMap<A,Iterable<K>> implements SecondaryHashMap<A,K,V>{
+
+	protected final JdbmBase<K,V > b;
+	public HTreeSecondaryMap(HTree<A, Iterable<K>> tree, JdbmBase<K,V> b) {
+		super(tree, true);
+		this.b = b;
+	}
+	
+	public V getPrimaryValue(K k) {		
+		try {
+			return b.find(k);
+		} catch (IOException e) {
+			throw new IOError(e);
+		}
+	}
+
+	public Iterable<V> getPrimaryValues(A a) {
+		return SecondaryKeyHelper.translateIterable(b, get(a));
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashBucket.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashBucket.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,317 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.htree;
+
+import java.awt.image.Kernel;
+import java.io.*;
+import java.util.ArrayList;
+
+import jdbm.SerializerInput;
+import jdbm.SerializerOutput;
+import jdbm.btree.BPage;
+import jdbm.helper.LongPacker;
+import jdbm.helper.Serialization;
+
+/**
+ * A bucket is a placeholder for multiple (key, value) pairs.  Buckets
+ * are used to store collisions (same hash value) at all levels of an
+ * H*tree.
+ *
+ * There are two types of buckets: leaf and non-leaf.
+ *
+ * Non-leaf buckets are buckets which hold collisions which happen
+ * when the H*tree is not fully expanded.   Keys in a non-leaf buckets
+ * can have different hash codes.  Non-leaf buckets are limited to an
+ * arbitrary size.  When this limit is reached, the H*tree should create
+ * a new Directory page and distribute keys of the non-leaf buckets into
+ * the newly created Directory.
+ *
+ * A leaf bucket is a bucket which contains keys which all have
+ * the same <code>hashCode()</code>.  Leaf buckets stand at the
+ * bottom of an H*tree because the hashing algorithm cannot further
+ * discriminate between different keys based on their hash code.
+ *
+ *  @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ *  @version $Id: HashBucket.java,v 1.2 2005/06/25 23:12:32 doomdark Exp $
+ */
+final class HashBucket<K,V>
+    extends HashNode<K,V>
+{
+
+    final static long serialVersionUID = 1L;
+
+    /**
+     * The maximum number of elements (key, value) a non-leaf bucket
+     * can contain.
+     */
+    public static final int OVERFLOW_SIZE = 8;
+
+
+    /**
+     * Depth of this bucket.
+     */
+    private int _depth;
+
+
+    /**
+     * Keys in this bucket.  Keys are ordered to match their respective
+     * value in <code>_values</code>.
+     */
+    private ArrayList<K> _keys;
+
+
+    /**
+     * Values in this bucket.  Values are ordered to match their respective
+     * key in <code>_keys</code>.
+     */
+    private ArrayList<V> _values;
+
+
+    /**
+     * Public constructor for serialization.
+     */
+    public HashBucket(HTree<K,V> tree) {
+        super(tree);
+    }
+
+
+    /**
+     * Construct a bucket with a given depth level.  Depth level is the
+     * number of <code>HashDirectory</code> above this bucket.
+     */
+    public HashBucket(HTree<K,V> tree, int level )
+    {
+        super(tree);
+        if ( level > HashDirectory.MAX_DEPTH+1 ) {
+            throw new IllegalArgumentException(
+                            "Cannot create bucket with depth > MAX_DEPTH+1. "
+                            + "Depth=" + level );
+        }
+        _depth = level;
+        _keys = new ArrayList<K>( OVERFLOW_SIZE );
+        _values = new ArrayList<V>( OVERFLOW_SIZE );
+    }
+
+
+    /**
+     * Returns the number of elements contained in this bucket.
+     */
+    public int getElementCount()
+    {
+        return _keys.size();
+    }
+
+
+    /**
+     * Returns whether or not this bucket is a "leaf bucket".
+     */
+    public boolean isLeaf()
+    {
+        return ( _depth > HashDirectory.MAX_DEPTH );
+    }
+
+
+    /**
+     * Returns true if bucket can accept at least one more element.
+     */
+    public boolean hasRoom()
+    {
+        if ( isLeaf() ) {
+            return true;  // leaf buckets are never full
+        } else {
+            // non-leaf bucket
+            return ( _keys.size() < OVERFLOW_SIZE );
+        }
+    }
+
+
+    /**
+     * Add an element (key, value) to this bucket.  If an existing element
+     * has the same key, it is replaced silently.
+     *
+     * @return Object which was previously associated with the given key
+     *          or <code>null</code> if no association existed.
+     */
+    public V addElement( K key, V value )
+    {
+        int existing = _keys.indexOf(key);
+        if ( existing != -1 ) {
+            // replace existing element
+            V before = _values.get( existing );
+            _values.set( existing, value );
+            return before;
+        } else {
+            // add new (key, value) pair
+            _keys.add( key );
+            _values.add( value );
+            return null;
+        }
+    }
+
+
+    /**
+     * Remove an element, given a specific key.
+     *
+     * @param key Key of the element to remove
+     *
+     * @return Removed element value, or <code>null</code> if not found
+     */
+    public V removeElement( K key )
+    {
+        int existing = _keys.indexOf(key);
+        if ( existing != -1 ) {
+            V obj = _values.get( existing );
+            _keys.remove( existing );
+            _values.remove( existing );
+            return obj;
+        } else {
+            // not found
+            return null;
+        }
+    }
+
+
+    /**
+     * Returns the value associated with a given key.  If the given key
+     * is not found in this bucket, returns <code>null</code>.
+     */
+    public V getValue( K key )
+    {
+        int existing = _keys.indexOf(key);
+        if ( existing != -1 ) {
+            return _values.get( existing );
+        } else {
+            // key not found
+            return null;
+        }
+    }
+
+
+    /**
+     * Obtain keys contained in this buckets.  Keys are ordered to match
+     * their values, which be be obtained by calling <code>getValues()</code>.
+     *
+     * As an optimization, the Vector returned is the instance member
+     * of this class.  Please don't modify outside the scope of this class.
+     */
+    ArrayList<K> getKeys()
+    {
+        return this._keys;
+    }
+
+
+    /**
+     * Obtain values contained in this buckets.  Values are ordered to match
+     * their keys, which be be obtained by calling <code>getKeys()</code>.
+     *
+     * As an optimization, the Vector returned is the instance member
+     * of this class.  Please don't modify outside the scope of this class.
+     */
+    ArrayList<V> getValues()
+    {
+        return this._values;
+    }
+
+
+    /**
+     * Implement Externalizable interface.
+     */
+    public void writeExternal( SerializerOutput out )
+        throws IOException
+    {
+
+    	LongPacker.packInt(out, _depth);
+
+        ArrayList keys = _keys;
+        //write keys
+        if(tree.keySerializer!=null){
+            for(int i = 0;i<_keys.size();i++){
+                if(keys.get(i)==null)  continue;
+                //transform to byte array
+                ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                tree.keySerializer.serialize(new SerializerOutput(baos), (K) keys.get(i));
+                keys.set(i, baos.toByteArray());
+
+            }
+
+        }
+        Serialization.writeObject(out, keys);
+
+        //write values
+        for(int i = 0;i<_keys.size();i++){
+        	if(_keys.get(i) == null)
+        		continue;
+            if(tree.valueSerializer==null)
+        	    Serialization.writeObject(out, _values.get(i));
+            else{
+                ByteArrayOutputStream baos = new ByteArrayOutputStream();
+		        tree.valueSerializer.serialize(new SerializerOutput(baos), _values.get(i));
+		        BPage.writeByteArray(out, baos.toByteArray());
+            }
+        }
+        
+    }
+
+
+    /**
+     * Implement Externalizable interface.
+     */
+    public void readExternal(SerializerInput in)
+    throws IOException, ClassNotFoundException {
+        _depth = LongPacker.unpackInt(in);
+
+        //read keys
+        ArrayList keys = (ArrayList) Serialization.readObject(in);
+        if(tree.keySerializer!=null){
+            //deserialize from byte array
+            for(int i =0; i<keys.size(); i++){
+                byte[] serialized = (byte[]) keys.get(i);
+                if(serialized == null)  continue;
+                K key = tree.keySerializer.deserialize(new SerializerInput(new ByteArrayInputStream(serialized)));
+                keys.set(i, key);
+            }
+        }
+        _keys = keys;
+
+         //read values
+        _values = new ArrayList<V>(_keys.size());
+        for(int i = 0;i<_keys.size();i++){
+        	if(_keys.get(i) == null)
+        		_values.add(null);
+        	else if(tree.valueSerializer==null)
+        		_values.add((V) Serialization.readObject(in));
+            else{
+  		          byte[] serialized = BPage.readByteArray( in );
+                  V val = tree.valueSerializer.deserialize(new SerializerInput(new ByteArrayInputStream(serialized)));
+		          _values.add(val);
+            }
+        }
+
+    }
+
+    public String toString() {
+        StringBuffer buf = new StringBuffer();
+        buf.append("HashBucket {depth=");
+        buf.append(_depth);
+        buf.append(", keys=");
+        buf.append(_keys);
+        buf.append(", values=");
+        buf.append(_values);
+        buf.append("}");
+        return buf.toString();
+    }
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashDirectory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashDirectory.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,579 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.htree;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOError;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+import jdbm.RecordManager;
+import jdbm.helper.LongPacker;
+
+/**
+ *  Hashtable directory page.
+ *
+ *  @author <a href="mailto:boisvert at exoffice.com">Alex Boisvert</a>
+ *  @version $Id: HashDirectory.java,v 1.5 2005/06/25 23:12:32 doomdark Exp $
+ */
+final class HashDirectory <K,V>
+    extends HashNode<K,V>
+{
+
+    static final long serialVersionUID = 1L;
+
+
+    /**
+     * Maximum number of children in a directory.
+     *
+     * (Must be a power of 2 -- if you update this value, you must also
+     *  update BIT_SIZE and MAX_DEPTH.)
+     *  
+     *  !!!! do not change this, it affects storage format, there are also magic numbers which relies on 255 !!!
+     */
+    static final int MAX_CHILDREN = 256;
+
+
+    /**
+     * Number of significant bits per directory level.
+     */
+    static final int BIT_SIZE = 8; // log2(256) = 8
+
+
+    /**
+     * Maximum number of levels (zero-based)
+     *
+     * (4 * 8 bits = 32 bits, which is the size of an "int", and as
+     *  you know, hashcodes in Java are "ints")
+     */
+    static final int MAX_DEPTH = 3; // 4 levels
+
+
+    /**
+     * Record ids of children pages.
+     */
+    private long[] _children;
+
+
+    /**
+     * Depth of this directory page, zero-based
+     */
+    private byte _depth;
+
+
+    /**
+     * PageManager used to persist changes in directory and buckets
+     */
+    private transient RecordManager _recman;
+
+
+    /**
+     * This directory's record ID in the PageManager.  (transient)
+     */
+    private transient long _recid;
+
+
+    /**
+     * Public constructor used by serialization
+     */
+    public HashDirectory(HTree<K,V> tree) {
+        super(tree);
+    }
+
+    /**
+     * Construct a HashDirectory
+     *
+     * @param depth Depth of this directory page.
+     */
+    HashDirectory(HTree<K,V> tree, byte depth) {
+        super(tree);
+        _depth = depth;
+        _children = new long[MAX_CHILDREN];
+    }
+
+
+    /**
+     * Sets persistence context.  This method must be called before any
+     * persistence-related operation.
+     *
+     * @param recman RecordManager which stores this directory
+     * @param recid Record id of this directory.
+     */
+    void setPersistenceContext( RecordManager recman, long recid )
+    {
+        this._recman = recman;
+        this._recid = recid;
+    }
+
+
+    /**
+     * Get the record identifier used to load this hashtable.
+     */
+    long getRecid() {
+        return _recid;
+    }
+
+
+    /**
+     * Returns whether or not this directory is empty.  A directory
+     * is empty when it no longer contains buckets or sub-directories.
+     */
+    boolean isEmpty() {
+        for (int i=0; i<_children.length; i++) {
+            if (_children[i] != 0) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns the value which is associated with the given key. Returns
+     * <code>null</code> if there is not association for this key.
+     *
+     * @param key key whose associated value is to be returned
+     */
+    V get(K key)
+        throws IOException
+    {
+        int hash = hashCode( key );
+        long child_recid = _children[ hash ];
+        if ( child_recid == 0 ) {
+            // not bucket/page --> not found
+            return null;
+        } else {
+            HashNode<K,V> node = (HashNode<K,V>) _recman.fetch( child_recid, tree.SERIALIZER );
+            // System.out.println("HashDirectory.get() child is : "+node);
+
+            if ( node instanceof HashDirectory ) {
+                // recurse into next directory level
+                HashDirectory<K,V> dir = (HashDirectory<K,V>) node;
+                dir.setPersistenceContext( _recman, child_recid );
+                return dir.get( key );
+            } else {
+                // node is a bucket
+                HashBucket<K,V> bucket = (HashBucket) node;
+                return bucket.getValue( key );
+            }
+        }
+    }
+
+
+    /**
+     * Associates the specified value with the specified key.
+     *
+     * @param key key with which the specified value is to be assocated.
+     * @param value value to be associated with the specified key.
+     * @return object which was previously associated with the given key,
+     *          or <code>null</code> if no association existed.
+     */
+    Object put(Object key, Object value)
+    throws IOException {
+        if (value == null) {
+            return remove(key);
+        }
+        int hash = hashCode(key);
+        long child_recid = _children[hash];
+        if (child_recid == 0) {
+            // no bucket/page here yet, let's create a bucket
+            HashBucket bucket = new HashBucket(tree, _depth+1);
+
+            // insert (key,value) pair in bucket
+            Object existing = bucket.addElement(key, value);
+
+            long b_recid = _recman.insert(bucket,tree.SERIALIZER );
+            _children[hash] = b_recid;
+
+            _recman.update(_recid, this,tree.SERIALIZER );
+
+            // System.out.println("Added: "+bucket);
+            return existing;
+        } else {
+            HashNode node = (HashNode) _recman.fetch( child_recid,tree.SERIALIZER  );
+
+            if ( node instanceof HashDirectory ) {
+                // recursive insert in next directory level
+                HashDirectory dir = (HashDirectory) node;
+                dir.setPersistenceContext( _recman, child_recid );
+                return dir.put( key, value );
+            } else {
+                // node is a bucket
+                HashBucket bucket = (HashBucket)node;
+                if (bucket.hasRoom()) {
+                    Object existing = bucket.addElement(key, value);
+                    _recman.update(child_recid, bucket,tree.SERIALIZER );
+                    // System.out.println("Added: "+bucket);
+                    return existing;
+                } else {
+                    // overflow, so create a new directory
+                    if (_depth == MAX_DEPTH) {
+                        throw new RuntimeException( "Cannot create deeper directory. "
+                                                    + "Depth=" + _depth );
+                    }
+                    HashDirectory dir = new HashDirectory(tree, (byte) (_depth+1) );
+                    long dir_recid = _recman.insert( dir ,tree.SERIALIZER );
+                    dir.setPersistenceContext( _recman, dir_recid );
+
+                    _children[hash] = dir_recid;
+                    _recman.update( _recid, this,tree.SERIALIZER  );
+
+                    // discard overflown bucket
+                    _recman.delete( child_recid );
+
+                    // migrate existing bucket elements
+                    ArrayList keys = bucket.getKeys();
+                    ArrayList values = bucket.getValues();
+                    int entries = keys.size();
+                    for ( int i=0; i<entries; i++ ) {
+                        dir.put( keys.get( i ), values.get( i ) );
+                    }
+
+                    // (finally!) insert new element
+                    return dir.put( key, value );
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Remove the value which is associated with the given key.  If the
+     * key does not exist, this method simply ignores the operation.
+     *
+     * @param key key whose associated value is to be removed
+     * @return object which was associated with the given key, or
+     *          <code>null</code> if no association existed with given key.
+     */
+    Object remove(Object key) throws IOException {
+        int hash = hashCode(key);
+        long child_recid = _children[hash];
+        if (child_recid == 0) {
+            // not bucket/page --> not found
+            return null;
+        } else {
+            HashNode node = (HashNode) _recman.fetch( child_recid,tree.SERIALIZER  );
+            // System.out.println("HashDirectory.remove() child is : "+node);
+
+            if (node instanceof HashDirectory) {
+                // recurse into next directory level
+                HashDirectory dir = (HashDirectory)node;
+                dir.setPersistenceContext( _recman, child_recid );
+                Object existing = dir.remove(key);
+                if (existing != null) {
+                    if (dir.isEmpty()) {
+                        // delete empty directory
+                        _recman.delete(child_recid);
+                        _children[hash] = 0;
+                        _recman.update(_recid, this,tree.SERIALIZER );
+                    }
+                }
+                return existing;
+            } else {
+                // node is a bucket
+                HashBucket bucket = (HashBucket)node;
+                Object existing = bucket.removeElement(key);
+                if (existing != null) {
+                    if (bucket.getElementCount() >= 1) {
+                        _recman.update(child_recid, bucket,tree.SERIALIZER );
+                    } else {
+                        // delete bucket, it's empty
+                        _recman.delete(child_recid);
+                        _children[hash] = 0;
+                        _recman.update(_recid, this,tree.SERIALIZER );
+                    }
+                }
+                return existing;
+            }
+        }
+    }
+
+    /**
+     * Calculates the hashcode of a key, based on the current directory
+     * depth.
+     */
+    private int hashCode(Object key) {
+        int hashMask = hashMask();
+        int hash = key.hashCode();
+        hash = hash & hashMask;
+        hash = hash >>> ((MAX_DEPTH - _depth) * BIT_SIZE);
+        hash = hash % MAX_CHILDREN;
+        /*
+        System.out.println("HashDirectory.hashCode() is: 0x"
+                           +Integer.toHexString(hash)
+                           +" for object hashCode() 0x"
+                           +Integer.toHexString(key.hashCode()));
+        */
+        return hash;
+    }
+
+    /**
+     * Calculates the hashmask of this directory.  The hashmask is the
+     * bit mask applied to a hashcode to retain only bits that are
+     * relevant to this directory level.
+     */
+    int hashMask() {
+        int bits = MAX_CHILDREN-1;
+        int hashMask = bits << ((MAX_DEPTH - _depth) * BIT_SIZE);
+        /*
+        System.out.println("HashDirectory.hashMask() is: 0x"
+                           +Integer.toHexString(hashMask));
+        */
+        return hashMask;
+    }
+
+    /**
+     * Returns an enumeration of the keys contained in this
+     */
+    Iterator<K> keys()
+        throws IOException
+    {
+        return new HDIterator( true );
+    }
+
+    /**
+     * Returns an enumeration of the values contained in this
+     */
+    Iterator<V> values()
+        throws IOException
+    {
+        return new HDIterator( false );
+    }
+
+
+    /**
+     * Implement Externalizable interface
+     */
+    public void writeExternal(DataOutputStream out)
+    throws IOException {
+        out.writeByte(_depth);
+
+        int zeroStart = 0;
+        for(int i = 0; i<MAX_CHILDREN;i++){	
+        	if(_children[i]!=0){
+        		zeroStart = i;
+        		break;
+        	}
+        }
+        
+        out.write(zeroStart);
+        if(zeroStart== MAX_CHILDREN)
+        	return;
+
+        int zeroEnd = 0;
+        for(int i = MAX_CHILDREN-1; i>=0;i--){	
+        	if(_children[i]!=0){
+        		zeroEnd = i;
+        		break;
+        	}
+        }                
+        out.write(zeroEnd);
+        
+        for(int i = zeroStart; i<=zeroEnd;i++){	
+        	LongPacker.packLong(out,_children[i]);
+        }
+    }
+
+
+    /**
+     * Implement Externalizable interface
+     */
+    public synchronized void readExternal(DataInputStream in)
+    throws IOException, ClassNotFoundException {
+        _depth = in.readByte();
+        _children = new long[MAX_CHILDREN];
+        int zeroStart = in.read();
+        int zeroEnd = in.read();
+
+        for(int i = zeroStart; i<=zeroEnd;i++){        	
+        	_children[i] = LongPacker.unpackLong(in);
+        }
+
+    }
+
+
+    ////////////////////////////////////////////////////////////////////////
+    // INNER CLASS
+    ////////////////////////////////////////////////////////////////////////
+
+    /**
+     * Utility class to enumerate keys/values in a HTree
+     */
+    public class HDIterator<A> implements Iterator<A>
+    {
+
+        /**
+         * True if we're iterating on keys, False if enumerating on values.
+         */
+        private boolean _iterateKeys;
+
+        /**
+         * Stacks of directories & last enumerated child position
+         */
+        private ArrayList _dirStack;
+        private ArrayList _childStack;
+
+        /**
+         * Current HashDirectory in the hierarchy
+         */
+        private HashDirectory _dir;
+
+        /**
+         * Current child position
+         */
+        private int _child;
+
+        /**
+         * Current bucket iterator
+         */
+        private Iterator<A> _iter;
+
+        A next;
+
+        /**
+         * Construct an iterator on this directory.
+         *
+         * @param iterateKeys True if iteration supplies keys, False
+         *                  if iterateKeys supplies values.
+         */
+        HDIterator( boolean iterateKeys )
+            throws IOException
+        {
+            _dirStack = new ArrayList();
+            _childStack = new ArrayList();
+            _dir = HashDirectory.this;
+            _child = -1;
+            _iterateKeys = iterateKeys;
+
+            prepareNext();
+            next = next2();            
+        }
+
+
+        
+        
+        /**
+         * Returns the next object.
+         */
+        public A next2()
+        {   
+            A next = null;      
+            if( _iter != null && _iter.hasNext() ) {
+              next = _iter.next();
+            } else {
+              try {
+                prepareNext();
+              } catch ( IOException except ) {
+                throw new IOError( except );
+              }
+              if ( _iter != null && _iter.hasNext() ) {
+                return next2();
+              }
+            }
+            return next;         
+        }
+
+
+        /**
+         * Prepare internal state so we can answer <code>hasMoreElements</code>
+         *
+         * Actually, this code prepares an Enumeration on the next
+         * Bucket to enumerate.   If no following bucket is found,
+         * the next Enumeration is set to <code>null</code>.
+         */
+        private void prepareNext() throws IOException {
+            long child_recid = 0;
+
+            // find next bucket/directory to enumerate
+            do {
+                _child++;
+                if (_child >= MAX_CHILDREN) {
+
+                    if (_dirStack.isEmpty()) {
+                        // no more directory in the stack, we're finished
+                        return;
+                    }
+
+                    // try next page
+                    _dir = (HashDirectory) _dirStack.remove( _dirStack.size()-1 );
+                    _child = ( (Integer) _childStack.remove( _childStack.size()-1 ) ).intValue();
+                    continue;
+                }
+                child_recid = _dir._children[_child];
+            } while (child_recid == 0);
+
+            if (child_recid == 0) {
+                throw new Error("child_recid cannot be 0");
+            }
+
+            HashNode node = (HashNode) _recman.fetch( child_recid,tree.SERIALIZER  );
+            // System.out.println("HDEnumeration.get() child is : "+node);
+ 
+            if ( node instanceof HashDirectory ) {
+                // save current position
+                _dirStack.add( _dir );
+                _childStack.add( new Integer( _child ) );
+
+                _dir = (HashDirectory)node;
+                _child = -1;
+
+                // recurse into
+                _dir.setPersistenceContext( _recman, child_recid );
+                prepareNext();
+            } else {
+                // node is a bucket
+                HashBucket bucket = (HashBucket)node;
+                if ( _iterateKeys ) {
+                     ArrayList keys2 = (ArrayList) bucket.getKeys().clone();
+                    _iter = keys2.iterator();
+                } else {
+                    _iter = bucket.getValues().iterator();
+                }
+            }
+        }
+
+
+
+
+		public boolean hasNext() {
+			return next!=null;
+		}
+
+
+
+
+		public A next() {
+			if(next == null) throw new NoSuchElementException();
+			A ret = next;
+			next = next2();
+			return ret;
+		}
+
+
+		public void remove() {
+			throw new UnsupportedOperationException();
+			
+		}
+    }
+
+    public RecordManager getRecordManager(){
+    	return _recman;
+    }
+}
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashNode.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/HashNode.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,43 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.htree;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import jdbm.Serializer;
+import jdbm.SerializerInput;
+import jdbm.SerializerOutput;
+import jdbm.helper.Serialization;
+
+/**
+ *  Abstract class for Hashtable directory nodes
+ *
+ *  @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ *  @version $Id: HashNode.java,v 1.2 2003/03/21 02:54:58 boisvert Exp $
+ */
+ at SuppressWarnings("unchecked")
+class HashNode<K,V> //implements Serializable, Serializer<HashNode>
+{
+    protected final HTree<K, V> tree;
+
+    public HashNode(HTree<K,V> tree) {
+        this.tree = tree;
+    }
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/package.html
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/htree/package.html	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,12 @@
+<!-- $Id: package.html,v 1.1 2002/05/31 06:33:20 boisvert Exp $ -->
+<html>
+  <body>
+    <p>HTree (scalable persistent hashtable) data structure implementation.</p>
+
+    <dl>
+      <dt><b>Version: </b></dt><dd>$Revision: 1.1 $ $Date: 2002/05/31 06:33:20 $</dd>
+      <dt><b>Author: </b></dt><dd><a href="mailto:boisvert at intalio.com">Alex Boisvert</a></dd>
+    </dl>
+
+  </body>
+</html>

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/package.html
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/package.html	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,95 @@
+<html>
+  <body>
+    <p>This package contains public API and introduction</p>
+	
+	<h2>JDBM intro</h2>
+	Key-Value databases have got a lot of attention recently, but their history is much older. GDBM (predecessor of JDBM) started 
+	in 1970 and was called 'pre rational' database. JDBM is under development since 2000. Version 1.0 was in production 
+	since 2005 with only a few bugs reported. Version 2.0 adds some features on top of JDBM (most importantly <code>java.util.Map</code> views)
+	<p/>
+	JDBM 2.0 goal is to provide simple and fast persistence. It is very simple to use, it has minimal overhead and standalone 
+	JAR takes only 130KB. It is excelent choice for Swing application or Android phone. JDBM also handles huge datasets well
+	and can be used for data processing (author is using it to process astronomical data). 
+	The source code is not complicated; it is well readabable and can also be used for teaching.
+	On the other hand, it does not have some important features (concurrent scalability, multiple transaction, annotations,
+	clustering...), which is the reason why it is so simple and small. For example, multiple transaction would introduce a new dimension  of problems, such as concurrent updates, optimistic/pesimistic record locking, etc.
+	JDBM does not try to replicate Valdemort, HBase or other more advanced Key Value databases. 
+	<p/>
+	<h2>JDBM2 is </h2>
+	
+	<p/><b>Not a SQL database</b><br/>
+	JDBM2 is more low level. With this comes great power (speed, resource usage, no ORM) 
+	but also big responsibility. You are responsible for data integrity, partioning, typing etc... 
+	Excelent embedded SQL database is <a href="http://www.h2database.com">H2</a> (in fact it is faster than JDBM2 in many cases). 
+	
+	<p/><b>Not an Object database</b><br/>
+	The fact that JDBM2 uses serialization may give you a false sense of security. It does not 
+	magically split a huge object graph into smaller pieces, nor does it handle duplicates. 
+	With JDBM you may easily end up with single instance being persisted in several copies over a datastore.
+	An object database would do this magic for you as it traverses object graph references and 
+	makes sure there are no duplicates in a datastore. Have look at 
+	<a href="http://www.neodatis.org/">NeoDatis</a> or <a href="http://www.db4o.com/">DB4o</a>
+	
+	<p/><b>Not at enterprise level</b><br/>
+	JDBM2 codebase is propably very good and without bugs, but it is a community project. You may easily endup without 
+	support. For something more enterprisey have a look at 
+	<a href="http://www.oracle.com/database/berkeley-db/je/index.html ">Berkley DB Java Edition</a> from Oracle. BDB has more  
+	features, it is more robust, it has better documentation, bigger overhead and comes with a pricetag.
+	
+	<p/><b>Not distributed</b><br/>
+	Key Value databases are associated with distributed stores, map reduce etc. JDBM is not distributed, it runs on single computer only. 
+	It does not even have a network interface and can not act as a server. 
+	You would be propably looking for <a href="http://project-voldemort.com/">Valdemort</a>. 
+	
+	<h2>JDBM2 overview</h2>
+	JDBM2 has some helpfull features to make it easier to use. It also brings it closer to SQL and helps with data 
+	integrity checks and data queries. 
+	<p/><b>Low level page store</b><br/>
+	This is Key-Value database in its literal mean. Key is a record identifier number (recid) which points to a location in file. 
+	Since recid is a physical pointer, new key values must be assgned by store (wherever the free space is found).
+	Value can be any object, serializable to a byte[] array. Page store also provides transaction and cache.  
+	<p/><b>Named objects</b><br/>
+	Number as an identifier is not very practical. So there is a table that translates Strings to recid. This is recommended 
+	approach for persisting singletons. 
+	<p/><b>Primary maps</b><br/>	
+	{@link jdbm.PrimaryStoreMap}, 	{@link jdbm.PrimaryTreeMap} and {@link jdbm.PrimaryHashMap} implements <code>java.util.map</code> interface
+	from Java Collections. But they use page store for persistence. So you can create HashMap with bilions of items and worry only about the commits.
+	<p/><b>Secondary maps</b><br/>	
+	Secondary maps (indexes) provide side information and associations for the primary map. For example, if there is a Person class persisted in the primary map, 
+	the secondary maps can provide fast lookup by name, address, age... The secondary maps are 'views' to the primary map and are readonly. 
+	They are updated by the primary map automatically. 
+	<p/><b>Cache</b><br/>	
+	JDBM has object instance cache. This reduces the serialization time and disk IO. By default JDBM uses SoftReference cache. If JVM have 
+	less then 50MB heap space available, MRU (Most Recently Used) fixed size cache is used instead.
+	<p/><b>Transactions</b><br/>	
+	JDBM provides transactions with commit and rollback. The transaction mechanism is safe and tested (in usage for the last 5 years). JDBM allows only
+	single concurrent transactions and there are no problems with concurrent updates and locking. 
+    
+    <h1>10 things to keep in mind</h1>
+	<ul> 
+	<li>Uncommited data are stored in memory, and if you get <code>OutOfMemoryException</code> you have to make commits more
+		frequently.
+	<li>Keys and values are stored as part of the index nodes. They are instanciated each time the index is searched.
+		If you have larger values (>512 bytes), these may hurt performance and cause <code>OutOfMemoryException</code>
+		In this case use  {@link jdbm.helper.StoreReference} or {@link jdbm.PrimaryStoreMap} to store values outside of the index.
+	<li>If you run into performance problems, use the profiler rather then asking for it over the internet.	
+	<li>JDBM caches returned object instances. If you modify an object (like set new name on a person),
+		next time RecordManager may return the object with this modification. 
+	<li>Iteration over Maps is not guaranteed if there are changes 
+		(for example adding a new entry while iterating). There is no fail fast policy yet. 
+		So all iterations over Maps should be synchronized on RecordManager.
+	<li>More memory means better performance; use <code>-Xmx000m</code> generously. JDBM has good SoftReference cache.
+	<li>SoftReference cache may be blocking some memory for other tasks. The memory is released automatically, but it may take longer then you expect.
+		Consider clearing the cache manually with <code>RecordManager.clearCache()</code> before starting a new type 
+		of task. 	
+	<li>It is safe not to close the db before exiting, but if you that there will be a long cleanup upon the next start.
+	<li>JDBM may have problem reclaiming free space after many records are delete/updated. You may want to run
+		<code>RecordManager.defrag()</code> from time to time.
+	<li>A Key-Value db does not support N-M relations easily. It takes a lot of care to handle them correctly. 
+	</ul>
+
+    <dl>
+    </dl>
+
+  </body>
+</html>

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BaseRecordManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BaseRecordManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,839 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOError;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.nio.channels.FileLock;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.Deflater;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.Inflater;
+import java.util.zip.InflaterInputStream;
+
+import jdbm.RecordManager;
+import jdbm.Serializer;
+import jdbm.SerializerInput;
+import jdbm.SerializerOutput;
+import jdbm.helper.OpenByteArrayInputStream;
+import jdbm.helper.OpenByteArrayOutputStream;
+import jdbm.helper.RecordManagerImpl;
+
+/**
+ *  This class manages records, which are uninterpreted blobs of data. The
+ *  set of operations is simple and straightforward: you communicate with
+ *  the class using long "rowids" and byte[] data blocks. Rowids are returned
+ *  on inserts and you can stash them away someplace safe to be able to get
+ *  back to them. Data blocks can be as long as you wish, and may have
+ *  lengths different from the original when updating.
+ *  <p>
+ *  Operations are synchronized, so that only one of them will happen
+ *  concurrently even if you hammer away from multiple threads. Operations
+ *  are made atomic by keeping a transaction log which is recovered after
+ *  a crash, so the operations specified by this interface all have ACID
+ *  properties.
+ *  <p>
+ *  You identify a file by just the name. The package attaches <tt>.db</tt>
+ *  for the database file, and <tt>.lg</tt> for the transaction log. The
+ *  transaction log is synchronized regularly and then restarted, so don't
+ *  worry if you see the size going up and down.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @author <a href="cg at cdegroot.com">Cees de Groot</a>
+ * @version $Id: BaseRecordManager.java,v 1.8 2005/06/25 23:12:32 doomdark Exp $
+ */
+public final class BaseRecordManager
+    extends RecordManagerImpl
+{
+
+	private static final String IDR = ".idr";
+	private static final String IDF = ".idf";
+	private static final String DBR = ".dbr";
+	private static final String DBF = ".dbf";
+	static final int DATA_BLOCK_SIZE = 1024 * 8 ;
+	static final int TRANS_BLOCK_SIZE = 1024 * 2;
+	static final int FREE_BLOCK_SIZE = 1024;
+
+	private String _indexDirRelativePathString = new String();
+    
+    /**
+	 * Version of storage. It should be safe to open lower versions, but engine should throw exception
+	 * while opening new versions (as it contains unsupported features or serialization)
+	 */
+	static final long STORE_FORMAT_VERSION = 1L;
+
+    /**
+     * Underlying file for store records.
+     */
+    private RecordFile _physFile;
+
+    /**
+     * Page manager for physical manager.
+     */
+    private PageManager _physPageman;
+    
+    /**
+     * Physical row identifier manager.
+     */
+    private PhysicalRowIdManager _physMgr;
+
+
+    /** if true, new records always saved to end of file
+     * and free space is not reclaimed.
+     * This may speed up some operations which involves lot of
+     * updates and inserts (batch creation);
+     * You need to reopen store to apply effect
+     */
+    public boolean isAppendToEnd() {
+        return appendToEnd;
+    }
+    /** if true, new records alwayes saved to end of file
+     * and free space is not reclaimed.
+     * This may speed up some operations which involves lot of
+     * updates and inserts (batch creation);
+     *
+     * You need to reopen store to apply effect
+     */
+    public void setAppendToEnd(boolean appendToEnd) {
+        this.appendToEnd = appendToEnd;
+    }
+
+    
+    /** if true, new records alwayes saved to end of file
+     * and free space is not reclaimed.
+     * This may speed up some operations which involves lot of
+     * updates and inserts (batch creation);
+      */
+    private boolean appendToEnd = false;
+
+    /**
+     * Underlying file for store records.
+     * Traces free records
+     */
+    private RecordFile _physFileFree;
+
+    /**
+     * Page manager for physical manager.
+     * Traces free records
+     */
+    private PageManager _physPagemanFree;
+
+    /**
+     * Underlying file for logical records.
+     */
+    private RecordFile _logicFile;
+
+    /**
+     * Page manager for logical manager.
+     */
+    private PageManager _logicPageman;
+
+
+    /**
+     * Logical to Physical row identifier manager.
+     */
+    private LogicalRowIdManager _logicMgr;
+
+    /**
+     * Underlying file for logical records.
+     * Traces free records
+     */
+    private RecordFile _logicFileFree;
+
+
+
+    /**
+     * Page manager for logical manager.
+     * Traces free records
+     */
+    private PageManager _logicPagemanFree;
+
+
+
+
+    /**
+     * Static debugging flag
+     */
+    public static final boolean DEBUG = false;
+
+    
+    /**
+     * Directory of named JDBMHashtables.  This directory is a persistent
+     * directory, stored as a Hashtable.  It can be retrived by using
+     * the NAME_DIRECTORY_ROOT.
+     */
+    private Map<String,Long> _nameDirectory;
+
+    /**
+     * Reserved slot for name directory.
+     */
+    public static final int NAME_DIRECTORY_ROOT = 0;
+
+
+    /**
+     * Reserved slot for version number
+     */
+    public static final int STORE_VERSION_NUMBER_ROOT = 1;
+
+
+
+
+    /** is Inflate compression on */
+	private boolean compress = false;
+
+	/** deflater used to compress data if needed*/
+	private Deflater deflater;
+	/** inflater used to decompress data if needed*/
+	private Inflater inflater;
+	
+	private static final int BUFFER_SIZE = 4096 * 2;
+	
+	private final byte[] _insertBuffer = new byte[BUFFER_SIZE];
+	private final OpenByteArrayOutputStream _insertBAO = new OpenByteArrayOutputStream(_insertBuffer);
+	private final SerializerOutput _insertOut = new SerializerOutput(_insertBAO);
+	private final OpenByteArrayInputStream _insertBAI = new OpenByteArrayInputStream(_insertBuffer);
+	private final SerializerInput _insertIn = new SerializerInput(_insertBAI);
+
+	volatile private boolean bufferInUse = false;
+
+
+	private final String _filename; 
+	
+    /**
+     *  Creates a record manager for the indicated file
+     *
+     *  @throws IOException when the file cannot be opened or is not
+     *          a valid file content-wise.
+     */
+    public BaseRecordManager( String filename )
+        throws IOException
+    {
+    	// If relativeDirPath is empty, all the jbdm storage will 
+    	// created in the currently working directory.
+    	
+    	// currently it is set to .index folder
+    	this( filename , RecordManager.DEFAULT_RELATIVE_PATH_INDEX );
+    }
+    
+    
+    public BaseRecordManager( String filename , String relativeDirPath)
+    throws IOException
+    {	
+    	
+    	_indexDirRelativePathString = relativeDirPath;
+    	_filename = filename;
+    	reopen();
+    }
+
+	private void reopen() throws IOException {
+		_physFileFree = new RecordFile( _filename +  DBF, FREE_BLOCK_SIZE , _indexDirRelativePathString);
+		
+		
+    	_physPagemanFree = new PageManager(_physFileFree);    	
+        _physFile = new RecordFile( _filename + DBR, DATA_BLOCK_SIZE);
+        _physPageman = new PageManager( _physFile );
+        _physMgr = new PhysicalRowIdManager( _physFile, _physPageman, 
+        		new FreePhysicalRowIdPageManager(_physFileFree, _physPagemanFree,appendToEnd));
+        
+        _logicFileFree= new RecordFile( _filename +IDF,FREE_BLOCK_SIZE );
+        _logicPagemanFree = new PageManager( _logicFileFree );
+        if(TRANS_BLOCK_SIZE>256*8)
+        	throw new InternalError(); //to big page, slot number would not fit into page
+        _logicFile = new RecordFile( _filename +IDR,TRANS_BLOCK_SIZE );
+        _logicPageman = new PageManager( _logicFile );
+        _logicMgr = new LogicalRowIdManager( _logicFile, _logicPageman, 
+        		new FreeLogicalRowIdPageManager(_logicFileFree, _logicPagemanFree));
+
+        long versionNumber = getRoot(STORE_VERSION_NUMBER_ROOT);
+        if(versionNumber>STORE_FORMAT_VERSION)
+        	throw new IOException("Unsupported version of store. Please update JDBM. Minimal supported ver:"+STORE_FORMAT_VERSION+", store ver:"+versionNumber);
+        setRoot(STORE_VERSION_NUMBER_ROOT, STORE_FORMAT_VERSION);
+	}
+
+
+    /**
+     *  Switches off transactioning for the record manager. This means
+     *  that a) a transaction log is not kept, and b) writes aren't
+     *  synch'ed after every update. This is useful when batch inserting
+     *  into a new database.
+     *  <p>
+     *  Only call this method directly after opening the file, otherwise
+     *  the results will be undefined.
+     */
+    public synchronized void disableTransactions()
+    {
+        checkIfClosed();
+
+        _physFile.disableTransactions();
+        _logicFile.disableTransactions();
+        _physFileFree.disableTransactions();
+        _logicFileFree.disableTransactions();
+
+    }
+    
+    /**
+     * Enable or disable compression of blocks with Deflate algorithm
+     * @param b
+     */
+	public synchronized void setCompress(boolean b) {
+		checkIfClosed();
+		if(DEBUG)
+			System.out.println("Setting compression to: "+b);
+		compress = b;		
+	}
+
+
+    
+    /**
+     *  Closes the record manager.
+     *
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized void close()
+        throws IOException
+    {
+        checkIfClosed();
+
+        _physPageman.close();
+        _physPageman = null;
+
+        _physFile.close();
+        _physFile = null;
+        
+        _logicPageman.close();
+        _logicPageman = null;
+        
+        _logicFile.close();
+        _logicFile = null;
+        
+        _physPagemanFree.close();
+        _physPagemanFree = null;
+
+        _physFileFree.close();
+        _physFileFree = null;
+        
+        _logicPagemanFree.close();
+        _logicPagemanFree = null;
+        
+        _logicFileFree.close();
+        _logicFileFree = null;
+    }
+
+
+    
+    /**
+     *  Inserts a new record using a custom serializer.
+     *
+     *  @param obj the object for the new record.
+     *  @param serializer a custom serializer
+     *  @return the rowid for the new record.
+     *  @throws IOException when one of the underlying I/O operations fails.
+     */
+    public synchronized <A> long insert( A obj, Serializer<A> serializer )
+        throws IOException
+    {
+                
+        checkIfClosed();
+    	if(bufferInUse){
+    		//current reusable buffer is in use, have to fallback into creating new instances
+    		byte[] buffer = new byte[1024];
+    		OpenByteArrayOutputStream bao = new OpenByteArrayOutputStream(buffer);
+    		SerializerOutput out = new SerializerOutput(bao);
+    		return insert2(obj,serializer,buffer,bao,out);
+    	}
+
+        try{
+        		
+        	bufferInUse = true;
+                _insertOut.__resetWrittenCounter();
+        	return insert2(obj, serializer,_insertBuffer,_insertBAO,_insertOut);
+        }finally{
+        	bufferInUse = false;
+        }
+    }
+
+
+	private <A> long insert2(A obj, Serializer<A> serializer, byte[] insertBuffer, OpenByteArrayOutputStream insertBAO, SerializerOutput insertOut)
+			throws IOException {
+		insertBAO.reset(insertBuffer);
+      
+		serializer.serialize(insertOut, obj);
+		if(compress){
+			byte[] data = compress(insertBAO.getBuf(),insertBAO.size());
+			insertBAO.reset(insertBuffer);
+			insertBAO.write(data);
+		}
+		long physRowId = _physMgr.insert( insertBAO.getBuf(), 0, insertBAO.size() );
+		long recid = _logicMgr.insert( physRowId );
+		if ( DEBUG ) {
+			System.out.println( "BaseRecordManager.insert() recid " + recid + " length " + insertBAO.size() ) ;
+		}
+		return compressRecid(recid);
+	}
+
+    private synchronized byte[] compress(byte[] data, int length) throws IOException {
+    	if(!compress )
+    		return data;
+    	if(deflater == null){
+    		deflater = new Deflater();    		
+    	}else{
+    		deflater.reset();
+    	}
+    	ByteArrayOutputStream b = new ByteArrayOutputStream(0);
+    	OutputStream d = new DeflaterOutputStream(b,deflater);
+    	
+    	d.write(data,0,length);
+    	d.close();
+		return b.toByteArray();
+	}
+
+    private synchronized  SerializerInput decompress(SerializerInput data) throws IOException {
+    	if(!compress)
+    		return data;
+    	
+    	if(inflater == null){
+    		inflater = new Inflater();       	
+    	}else{
+    		inflater.reset();
+    	}
+    	
+    	return new SerializerInput(new InflaterInputStream(data,inflater));
+	}
+
+    public synchronized void delete( long logRowId )
+        throws IOException
+    {
+    	
+        checkIfClosed();
+        if ( logRowId <= 0 ) {
+            throw new IllegalArgumentException( "Argument 'recid' is invalid: "
+                                                + logRowId );
+        }
+
+        if ( DEBUG ) {
+            System.out.println( "BaseRecordManager.delete() recid " + logRowId ) ;
+        }
+
+        logRowId = decompressRecid(logRowId);
+        
+        long physRowId = _logicMgr.fetch(logRowId);
+        _physMgr.delete( physRowId );
+        _logicMgr.delete( logRowId );
+    }
+
+
+
+    public synchronized  <A> void update( long recid, A obj, Serializer<A> serializer )
+        throws IOException
+    {
+        checkIfClosed();
+        if ( recid <= 0 ) {
+            throw new IllegalArgumentException( "Argument 'recid' is invalid: "
+                                                + recid );
+        }
+    	if(bufferInUse){
+    		//current reusable buffer is in use, have to create new instances
+    		byte[] buffer = new byte[1024];
+    		OpenByteArrayOutputStream bao = new OpenByteArrayOutputStream(buffer);
+    		SerializerOutput out = new SerializerOutput(bao);
+    		update2(recid,obj,serializer,buffer,bao,out);
+    		return;
+    	}
+
+        try{        
+        	bufferInUse = true;
+        	_insertOut.__resetWrittenCounter();
+        	update2(recid, obj, serializer,_insertBuffer, _insertBAO, _insertOut);
+        }finally{
+        	bufferInUse = false;
+        }
+    }
+
+
+	private <A> void update2(long logRecid, A obj, Serializer<A> serializer,byte[] insertBuffer, OpenByteArrayOutputStream insertBAO, SerializerOutput insertOut)
+			throws IOException {
+		logRecid = decompressRecid(logRecid);
+		long physRecid = _logicMgr.fetch( logRecid );
+		if(physRecid == 0)
+			throw new IOException("Can not update, recid does not exist: "+logRecid);
+		insertBAO.reset(insertBuffer);
+		serializer.serialize(insertOut, obj );
+
+		if(compress){
+			byte[] data = compress(insertBAO.getBuf(),insertBAO.size());
+			insertBAO.reset(insertBuffer);
+			insertBAO.write(data);
+		}
+		
+		if ( DEBUG ) {
+			System.out.println( "BaseRecordManager.update() recid " + logRecid + " length " + insertBAO.size() ) ;
+		}
+
+		long newRecid = _physMgr.update( physRecid, insertBAO.getBuf(), 0, insertBAO.size() );
+		
+		_logicMgr.update( logRecid, newRecid );
+		
+	}
+
+
+
+
+    public synchronized <A> A fetch( long recid, Serializer<A> serializer )
+        throws IOException
+    {        
+
+        checkIfClosed();
+        if ( recid <= 0 ) {
+            throw new IllegalArgumentException( "Argument 'recid' is invalid: "
+                                                + recid );
+        }
+        
+    	if(bufferInUse){
+    		//current reusable buffer is in use, have to create new instances
+    		byte[] buffer = new byte[1024];
+    		OpenByteArrayOutputStream bao = new OpenByteArrayOutputStream(buffer);
+    		SerializerOutput out = new SerializerOutput(bao);
+    		OpenByteArrayInputStream bai = new OpenByteArrayInputStream(buffer);
+    		SerializerInput in = new SerializerInput(bai);
+    		return fetch2(recid,serializer,buffer,bao,out, bai,in);
+    	}
+        try{
+        	bufferInUse = true;
+                _insertOut.__resetWrittenCounter();
+        	return fetch2(recid, serializer,_insertBuffer,_insertBAO,_insertOut,_insertBAI, _insertIn);
+        }finally{
+        	bufferInUse = false;
+        }
+    }
+
+    public synchronized <A> A fetch( long recid, Serializer<A> serializer, boolean disableCache ) throws IOException{
+    	//we dont have any cache, so can ignore disableCache parameter
+    	return fetch(recid, serializer);
+    }
+
+
+
+	private <A> A fetch2(long recid, Serializer<A> serializer,byte[] insertBuffer, 
+				OpenByteArrayOutputStream insertBAO, SerializerOutput insertOut,
+				OpenByteArrayInputStream insertBAI, SerializerInput insertIn)
+			throws IOException {
+
+		recid = decompressRecid(recid);
+		
+		insertBAO.reset(insertBuffer);		
+		long physLocation = _logicMgr.fetch(recid);
+		if(physLocation == 0){
+			//throw new IOException("Record not found, recid: "+recid);
+			return null;
+		}
+		_physMgr.fetch(insertBAO, physLocation);
+
+		if ( DEBUG ) {
+			System.out.println( "BaseRecordManager.fetch() recid " + recid + " length " + insertBAO.size() ) ;
+		}
+		insertBAI.reset(insertBAO.getBuf(), insertBAO.size());
+		try{
+			if(compress)
+				return serializer.deserialize(decompress( insertIn ));
+			else
+				return serializer.deserialize( insertIn );
+		}catch(ClassNotFoundException e){
+			throw new IOError(e);
+		}
+	}
+
+
+    public int getRootCount()
+    {
+        return FileHeader.NROOTS;
+    }
+
+    public synchronized long getRoot( int id )
+        throws IOException
+    {
+        checkIfClosed();
+
+        return _physPageman.getFileHeader().getRoot( id );
+    }
+
+
+    public synchronized void setRoot( int id, long rowid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        _physPageman.getFileHeader().setRoot( id, rowid );
+    }
+
+
+    public long getNamedObject( String name )
+        throws IOException
+    {
+        checkIfClosed();
+
+        Map<String,Long> nameDirectory = getNameDirectory();
+        Long recid = (Long) nameDirectory.get( name );
+        if ( recid == null ) {
+            return 0;
+        }
+        return recid.longValue();
+    }
+
+    public void setNamedObject( String name, long recid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        Map<String,Long> nameDirectory = getNameDirectory();
+        if ( recid == 0 ) {
+            // remove from hashtable
+            nameDirectory.remove( name );
+        } else {
+            nameDirectory.put( name, new Long( recid ) );
+        }
+        saveNameDirectory( nameDirectory );
+    }
+
+
+    public synchronized void commit()
+        throws IOException
+    {
+        checkIfClosed();
+        /** flush free phys rows into pages*/
+        _physMgr.commit();
+        _logicMgr.commit();
+
+        /**commit pages */
+        _physPageman.commit();
+        _physPagemanFree.commit();
+        _logicPageman.commit();
+        _logicPagemanFree.commit();
+    }
+
+
+    public synchronized void rollback()
+        throws IOException
+    {
+        checkIfClosed();
+        _physMgr.commit();
+        _logicMgr.commit();
+
+
+        _physPageman.rollback();
+        _physPagemanFree.rollback();
+        _logicPageman.rollback();
+        _logicPagemanFree.rollback();
+    }
+
+
+    /**
+     * Load name directory
+     */
+    @SuppressWarnings("unchecked")
+	private Map<String,Long> getNameDirectory()
+        throws IOException
+    {
+        // retrieve directory of named hashtable
+        long nameDirectory_recid = getRoot( NAME_DIRECTORY_ROOT );
+        if ( nameDirectory_recid == 0 ) {
+            _nameDirectory = new HashMap<String,Long>();
+            nameDirectory_recid = insert( _nameDirectory );
+            setRoot( NAME_DIRECTORY_ROOT, nameDirectory_recid );
+        } else {
+            _nameDirectory = (Map<String,Long>) fetch( nameDirectory_recid );
+        }
+        return _nameDirectory;
+    }
+
+
+    private void saveNameDirectory( Map<String,Long> directory )
+        throws IOException
+    {
+        long recid = getRoot(NAME_DIRECTORY_ROOT);
+        if ( recid == 0 ) {
+            throw new IOException( "Name directory must exist" );
+        }
+        update(recid, _nameDirectory);
+    }
+
+
+    /**
+     * Check if RecordManager has been closed.  If so, throw an
+     * IllegalStateException.
+     */
+    private void checkIfClosed()
+        throws IllegalStateException
+    {
+        if ( _physFile == null ) {
+            throw new IllegalStateException( "RecordManager has been closed" );
+        }
+    }
+
+
+	public synchronized void clearCache() throws IOException {
+		//no cache		
+	}
+
+
+	public synchronized void defrag() throws IOException {
+		checkIfClosed();
+		commit();
+		final String filename2 = _filename+"_defrag"+System.currentTimeMillis();
+		final String filename1 = _filename; 
+		BaseRecordManager recman2 = new BaseRecordManager(filename2);
+		recman2.disableTransactions();
+	
+		PageCursor logicalCur = new PageCursor(_logicPageman, Magic.TRANSLATION_PAGE);
+		List<Long> logicalPages = new ArrayList<Long>();		
+		long last = logicalCur.next();;
+		while(last!=0){
+			logicalPages.add(last);
+			last = logicalCur.next();			
+		}
+		for(long pageid:logicalPages){			
+			BlockIo io = _logicFile.get(pageid); 
+			TranslationPage xlatPage = TranslationPage.getTranslationPageView(io,TRANS_BLOCK_SIZE);
+		
+			for(int i = 0;i<_logicMgr.ELEMS_PER_PAGE;i+=1){
+				int pos = TranslationPage.O_TRANS + i* TranslationPage.PhysicalRowId_SIZE;
+				if(pos>Short.MAX_VALUE)
+					throw new Error();
+				long logicalRowId = Location.toLong(pageid,(short)pos);
+
+
+				//find physical location
+				long physRowId = Location.toLong(
+						xlatPage.getLocationBlock((short)pos),
+						xlatPage.getLocationOffset((short)pos));
+				if(physRowId == 0)
+					continue;
+
+				//read from physical location
+				ByteArrayOutputStream b = new ByteArrayOutputStream();
+				_physMgr.fetch(b, physRowId);
+				byte[] bb = b.toByteArray();
+				//write to new file
+				recman2.forceInsert(logicalRowId, bb);
+				
+			}
+			_logicFile.release(io);
+			recman2.commit();
+			
+		}
+		recman2.setRoot(NAME_DIRECTORY_ROOT,getRoot(NAME_DIRECTORY_ROOT));
+		recman2.commit();
+		
+		recman2.close();
+		close();
+		List<File> filesToDelete = new ArrayList<File>();
+		//now rename old files 
+		String[] exts = {IDF, IDR, DBF, DBR};
+		for(String ext:exts){
+			String f1 = filename1+ext;			
+			String f2 = filename2+"_OLD"+ext;
+			
+			//first rename transaction log
+			File f1t = new File(f1+TransactionManager.extension);
+			File f2t = new File(f2+TransactionManager.extension);
+			f1t.renameTo(f2t);
+			filesToDelete.add(f2t);
+			
+			//rename data files, iterate until file exist
+			for(int i=0;;i++){
+				File f1d = new File(f1+"."+i);
+				if(!f1d.exists()) break;
+				File f2d = new File(f2+"."+i);
+				f1d.renameTo(f2d);
+				filesToDelete.add(f2d);
+			}
+		}
+		
+		//rename new files 
+		for(String ext:exts){
+			String f1 = filename2+ext;			
+			String f2 = filename1+ext;
+			
+			//first rename transaction log
+			File f1t = new File(f1+TransactionManager.extension);
+			File f2t = new File(f2+TransactionManager.extension);
+			f1t.renameTo(f2t);
+			
+			//rename data files, iterate until file exist
+			for(int i=0;;i++){
+				File f1d = new File(f1+"."+i);
+				if(!f1d.exists()) break;
+				File f2d = new File(f2+"."+i);
+				f1d.renameTo(f2d);			
+			}
+		}
+		
+		for(File d:filesToDelete){
+			d.delete();
+		}
+		
+		
+		reopen();
+	}
+	
+	/**
+	 * Insert data at forced logicalRowId, use only for defragmentation !! 
+	 * @param logicalRowId 
+	 * @param data
+	 * @throws IOException 
+	 */
+	private void forceInsert(long logicalRowId, byte[] data) throws IOException {
+		long physLoc = _physMgr.insert(data, 0, data.length);
+		_logicMgr.forceInsert(logicalRowId, physLoc);
+	}
+
+	
+	/**
+	 * Compress recid from physical form (block - offset) to (block - slot). 
+	 * This way resulting number is smaller and can be easyer packed with LongPacker  
+	 */
+	static long compressRecid(long recid){
+		long block = Location.getBlock(recid);
+		short offset=  Location.getOffset(recid);
+
+		offset = (short) (offset - TranslationPage.O_TRANS);
+		if(offset%8!=0)
+			throw new InternalError("not 8");
+		long slot = offset /8;
+		if(slot<0||slot>255)
+			throw new InternalError("too big slot: "+slot);
+			
+		return (block << 8) + (long) slot;
+
+	}
+	
+	static long decompressRecid(long recid){
+		long block = recid >>8;
+        short offset = (short) (((recid & 0xff) ) * 8+TranslationPage.O_TRANS);
+		return Location.toLong(block, offset);
+	}
+
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BlockIo.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BlockIo.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,348 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+
+import jdbm.helper.LongPacker;
+
+/**
+ *  This class wraps a page-sized byte array and provides methods
+ *  to read and write data to and from it. The readers and writers
+ *  are just the ones that the rest of the toolkit needs, nothing else.
+ *  Values written are compatible with java.io routines.
+ *
+ *  @see java.io.DataInput
+ *  @see java.io.DataOutput
+ */
+public final class BlockIo {
+
+    private long blockId;
+
+    private byte[] data; // work area
+    transient private BlockView view = null;
+    private boolean dirty = false;
+    private int transactionCount = 0;
+
+    /**
+     * Default constructor for serialization
+     */
+    public BlockIo() {
+        // empty
+    }
+
+    /**
+     *  Constructs a new BlockIo instance working on the indicated
+     *  buffer.
+     */
+    BlockIo(long blockId, byte[] data) {
+        this.blockId = blockId;
+        this.data = data;
+    }
+
+    /**
+     *  Returns the underlying array
+     */
+    byte[] getData() {
+        return data;
+    }
+
+    /**
+     *  Sets the block number. Should only be called by RecordFile.
+     */
+    void setBlockId(long id) {
+        if (isInTransaction())
+            throw new Error("BlockId assigned for transaction block");
+        blockId = id;
+    }
+
+    /**
+     *  Returns the block number.
+     */
+    long getBlockId() {
+        return blockId;
+    }
+
+    /**
+     *  Returns the current view of the block.
+     */
+    public BlockView getView() {
+        return view;
+    }
+
+    /**
+     *  Sets the current view of the block.
+     */
+    public void setView(BlockView view) {
+        this.view = view;
+    }
+
+    /**
+     *  Sets the dirty flag
+     */
+    void setDirty() {
+        dirty = true;
+    }
+
+    /**
+     *  Clears the dirty flag
+     */
+    void setClean() {
+        dirty = false;
+    }
+
+    /**
+     *  Returns true if the dirty flag is set.
+     */
+    boolean isDirty() {
+        return dirty;
+    }
+
+    /**
+     *  Returns true if the block is still dirty with respect to the
+     *  transaction log.
+     */
+    boolean isInTransaction() {
+        return transactionCount != 0;
+    }
+
+    /**
+     *  Increments transaction count for this block, to signal that this
+     *  block is in the log but not yet in the data file. The method also
+     *  takes a snapshot so that the data may be modified in new transactions.
+     */
+    synchronized void incrementTransactionCount() {
+        transactionCount++;
+        // @fixme(alex)
+        setClean();
+    }
+
+    /**
+     *  Decrements transaction count for this block, to signal that this
+     *  block has been written from the log to the data file.
+     */
+    synchronized void decrementTransactionCount() {
+        transactionCount--;
+        if (transactionCount < 0)
+            throw new Error("transaction count on block "
+                            + getBlockId() + " below zero!");
+
+    }
+
+    /**
+     *  Reads a byte from the indicated position
+     */
+    public byte readByte(int pos) {
+        return data[pos];
+    }
+
+    /**
+     *  Writes a byte to the indicated position
+     */
+    public void writeByte(int pos, byte value) {
+        data[pos] = value;
+        setDirty();
+    }
+
+    /**
+     *  Reads a short from the indicated position
+     */
+    public short readShort(int pos) {
+        return (short)
+            (((short) (data[pos+0] & 0xff) << 8) |
+             ((short) (data[pos+1] & 0xff) << 0));
+    }
+
+    /**
+     *  Writes a short to the indicated position
+     */
+    public void writeShort(int pos, short value) {
+        data[pos+0] = (byte)(0xff & (value >> 8));
+        data[pos+1] = (byte)(0xff & (value >> 0));
+        setDirty();
+    }
+
+    /**
+     *  Reads an int from the indicated position
+     */
+    public int readInt(int pos) {
+        return
+            (((int)(data[pos+0] & 0xff) << 24) |
+             ((int)(data[pos+1] & 0xff) << 16) |
+             ((int)(data[pos+2] & 0xff) <<  8) |
+             ((int)(data[pos+3] & 0xff) <<  0));
+    }
+
+    /**
+     *  Writes an int to the indicated position
+     */
+    public void writeInt(int pos, int value) {
+        data[pos+0] = (byte)(0xff & (value >> 24));
+        data[pos+1] = (byte)(0xff & (value >> 16));
+        data[pos+2] = (byte)(0xff & (value >>  8));
+        data[pos+3] = (byte)(0xff & (value >>  0));
+        setDirty();
+    }
+    
+    static final int ThreeByteInt_MAX = 256 * 256 * 256 -1;
+    
+    /**
+     *  Reads an int from the indicated position
+     */
+    public int readThreeByteInt(int pos) {
+        return
+            (
+             ((int)(data[pos+0] & 0xff) << 16) |
+             ((int)(data[pos+1] & 0xff) <<  8) |
+             ((int)(data[pos+2] & 0xff) <<  0));
+    }
+
+    /**
+     *  Writes an int to the indicated position
+     */
+    public void writeThreeByteInt(int pos, int value) {
+    	if(value<0 || value>ThreeByteInt_MAX)
+    		throw new IllegalArgumentException("out of range: "+value);
+        data[pos+0] = (byte)(0xff & (value >> 16));
+        data[pos+1] = (byte)(0xff & (value >>  8));
+        data[pos+2] = (byte)(0xff & (value >>  0));
+        setDirty();
+    }
+
+    /**
+     *  Reads a long from the indicated position
+     */
+    public long readLong( int pos )
+    {
+        // Contributed by Erwin Bolwidt <ejb at klomp.org>
+        // Gives about 15% performance improvement
+        return
+            ( (long)( ((data[pos+0] & 0xff) << 24) |
+                      ((data[pos+1] & 0xff) << 16) |
+                      ((data[pos+2] & 0xff) <<  8) |
+                      ((data[pos+3] & 0xff)      ) ) << 32 ) |
+            ( (long)( ((data[pos+4] & 0xff) << 24) |
+                      ((data[pos+5] & 0xff) << 16) |
+                      ((data[pos+6] & 0xff) <<  8) |
+                      ((data[pos+7] & 0xff)      ) ) & 0xffffffff );
+        /* Original version by Alex Boisvert.  Might be faster on 64-bit JVMs.
+        return
+            (((long)(data[pos+0] & 0xff) << 56) |
+             ((long)(data[pos+1] & 0xff) << 48) |
+             ((long)(data[pos+2] & 0xff) << 40) |
+             ((long)(data[pos+3] & 0xff) << 32) |
+             ((long)(data[pos+4] & 0xff) << 24) |
+             ((long)(data[pos+5] & 0xff) << 16) |
+             ((long)(data[pos+6] & 0xff) <<  8) |
+             ((long)(data[pos+7] & 0xff) <<  0));
+        */
+    }
+
+    /**
+     *  Writes a long to the indicated position
+     */
+    public void writeLong(int pos, long value) {
+        data[pos+0] = (byte)(0xff & (value >> 56));
+        data[pos+1] = (byte)(0xff & (value >> 48));
+        data[pos+2] = (byte)(0xff & (value >> 40));
+        data[pos+3] = (byte)(0xff & (value >> 32));
+        data[pos+4] = (byte)(0xff & (value >> 24));
+        data[pos+5] = (byte)(0xff & (value >> 16));
+        data[pos+6] = (byte)(0xff & (value >>  8));
+        data[pos+7] = (byte)(0xff & (value >>  0));
+        setDirty();
+    }
+
+
+    /**
+     *  Reads a long from the indicated position
+     */
+    public long readSixByteLong( int pos )
+    {
+        return
+            (((long)(data[pos+0] & 0xff) << 40) |
+             ((long)(data[pos+1] & 0xff) << 32) |
+             ((long)(data[pos+2] & 0xff) << 24) |
+             ((long)(data[pos+3] & 0xff) << 16) |
+             ((long)(data[pos+4] & 0xff) << 8) |
+             ((long)(data[pos+5] & 0xff) << 0)); 
+        
+    }
+
+    /**
+     *  Writes a long to the indicated position
+     */
+    public void writeSixByteLong(int pos, long value) {
+//    	if(value >> (6*8)!=0)
+//    		throw new IllegalArgumentException("does not fit");
+    	
+        data[pos+0] = (byte)(0xff & (value >> 40));
+        data[pos+1] = (byte)(0xff & (value >> 32));
+        data[pos+2] = (byte)(0xff & (value >> 24));
+        data[pos+3] = (byte)(0xff & (value >> 16));
+        data[pos+4] = (byte)(0xff & (value >> 8 ));
+        data[pos+5] = (byte)(0xff & (value >> 0 ));
+        setDirty();
+    }
+
+    
+    // overrides java.lang.Object
+
+    public String toString() {
+        return "BlockIO("
+            + blockId + ","
+            + dirty + ","
+            + view + ")";
+    }
+
+    // implement externalizable interface
+    public void readExternal(DataInputStream in)
+    throws IOException, ClassNotFoundException {
+        blockId = LongPacker.unpackLong(in);
+        int length = LongPacker.unpackInt(in);
+        data = new byte[length];
+        in.readFully(data);
+    }
+
+    // implement externalizable interface
+    public void writeExternal(DataOutputStream out) throws IOException {
+    	LongPacker.packLong(out, blockId);
+    	LongPacker.packInt(out, data.length);
+        out.write(data);
+    }
+
+    static final int UNSIGNED_SHORT_MAX = 256 * 256 -1;  
+
+   
+	public void writeUnsignedShort(int pos, int value) {
+		if(value>UNSIGNED_SHORT_MAX || value<0)
+			throw new IllegalArgumentException("Out of range: "+value);
+        data[pos+0] = (byte)(0xff & (value >>  8));
+        data[pos+1] = (byte)(0xff & (value >>  0));
+        setDirty();		
+	}
+	
+	public int readUnsignedshort(int pos){
+      return 
+        (((int)(data[pos+0] & 0xff) <<  8) |
+        ((int)(data[pos+1] & 0xff) <<  0));
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BlockView.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BlockView.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,26 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+/**
+ *  This is a marker interface that is implemented by classes that
+ *  interpret blocks of data by pretending to be an overlay.
+ *
+ *  @see BlockIo#setView
+ */
+interface BlockView {
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/CacheRecordManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/CacheRecordManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,554 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+import java.io.IOException;
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
+import java.util.Iterator;
+
+import jdbm.RecordManager;
+import jdbm.Serializer;
+import jdbm.helper.LongHashMap;
+import jdbm.helper.RecordManagerImpl;
+
+/**
+ *  A RecordManager wrapping and caching another RecordManager.
+ *
+ * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
+ * @author <a href="cg at cdegroot.com">Cees de Groot</a>
+ * @version $Id: CacheRecordManager.java,v 1.9 2005/06/25 23:12:32 doomdark Exp $
+ */
+public class CacheRecordManager
+    extends RecordManagerImpl
+{
+
+    /**
+     * Wrapped RecordManager
+     */
+    protected RecordManager _recman;
+
+
+    /** Cached object hashtable */
+    protected LongHashMap<CacheEntry> _hash;
+	
+    /** If Soft Cache is enabled, this contains softly referenced clean entries. 
+     * If entry became dirty, it is moved to _hash with limited size.
+     * This map is accessed from SoftCache Disposer thread, so all access must be 
+     * synchronized  
+     */
+	protected LongHashMap<SoftCacheEntry> _softHash;
+
+	/**
+	 * Reference queue used to collect Soft Cache entries 
+	 */
+	protected ReferenceQueue<SoftCacheEntry> _refQueue;
+	
+
+    /**
+     * Maximum number of objects in the cache.
+     */
+	protected int _max;
+    
+    /**
+     * True if enable second level soft cache
+     */
+	protected boolean _softCache;
+	
+	/**
+	 * Thread in which Soft Cache references are disposed
+	 */
+	protected Thread _softRefThread;
+	
+	protected static int threadCounter = 0;
+
+    /**
+     * Beginning of linked-list of cache elements.  First entry is element
+     * which has been used least recently.
+     */
+	protected CacheEntry _first;
+
+    /**
+     * End of linked-list of cache elements.  Last entry is element
+     * which has been used most recently.
+     */
+	protected CacheEntry _last;
+	
+    /**
+     * Construct a CacheRecordManager wrapping another RecordManager and
+     * using a given cache policy.
+     *
+     * @param recman Wrapped RecordManager
+     * @param cache Cache policy
+     */
+    public CacheRecordManager( RecordManager recman, int maxRecords, boolean softCache)
+    {
+        if ( recman == null ) {
+            throw new IllegalArgumentException( "Argument 'recman' is null" );
+        }
+        _hash = new LongHashMap<CacheEntry>(maxRecords);
+        _recman = recman;
+        _max = maxRecords;
+        _softCache = softCache;
+        
+        if(softCache){
+        	_softHash = new LongHashMap<SoftCacheEntry>();
+        	_refQueue = new ReferenceQueue<SoftCacheEntry>();
+        	_softRefThread = new Thread(
+        			new SoftRunnable(this, _refQueue),
+        			"JDBM Soft Cache Disposer "+(threadCounter++));
+        	_softRefThread.setDaemon(true);
+        	_softRefThread.start();
+        }
+
+    }
+
+    
+    /**
+     * Get the underlying Record Manager.
+     *
+     * @return underlying RecordManager or null if CacheRecordManager has
+     *         been closed. 
+     */
+    public RecordManager getRecordManager()
+    {
+        return _recman;
+    }
+
+    
+    
+    public synchronized <A> long insert( A obj, Serializer<A> serializer )
+        throws IOException
+    {
+        checkIfClosed();
+        
+        long recid = _recman.insert( obj, serializer );
+        
+        //DONT use cache for inserts, it usually hurts performance on batch inserts
+//        if(_softCache) synchronized(_softHash) {
+//        	_softHash.put(recid, new SoftCacheEntry(recid, obj, serializer,_refQueue));
+//        }else {
+//        	cachePut(  recid , obj, serializer, false );
+//        }
+        return recid;
+    }
+
+    public synchronized <A> A fetch( long recid, Serializer<A> serializer, boolean disableCache ) throws IOException{
+        if(disableCache)
+             return _recman.fetch(recid, serializer,disableCache);
+        else
+            return fetch(recid,serializer);
+     }
+
+
+
+    public synchronized void delete( long recid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        _recman.delete( recid );
+        CacheEntry entry = _hash.get(recid);
+        if (entry != null) {
+            removeEntry(entry);
+            _hash.remove(entry._recid);
+        }
+        if(_softCache) synchronized(_softHash) {
+        	SoftCacheEntry e = _softHash.remove(recid);
+        	if(e!=null){
+        		e.clear();
+        	}
+        }
+
+    }
+
+    public synchronized <A> void update( long recid, A obj, 
+                                     Serializer<A> serializer )
+        throws IOException
+    {       
+        checkIfClosed();
+        if(_softCache) synchronized(_softHash) {
+        	//soft cache can not contain dirty objects
+        	SoftCacheEntry e = _softHash.remove(recid);
+        	if(e != null){
+        		e.clear();
+        	}
+        }
+        CacheEntry entry = cacheGet(recid);
+        if ( entry != null ) {
+            // reuse existing cache entry
+            entry._obj = obj;
+            entry._serializer = serializer;
+            entry._isDirty = true;
+        } else {
+            cachePut( recid, obj, serializer, true );
+        }
+    }
+
+        
+    public synchronized <A> A fetch( long recid, Serializer<A> serializer )
+        throws IOException
+    {
+        checkIfClosed();
+        if(_softCache) synchronized(_softHash){
+        	SoftCacheEntry e = _softHash.get(recid);
+        	if(e!=null){
+        		Object a = e.get();
+        		if(a!=null){
+        			return (A) a;
+                }
+        	}
+        }
+
+        CacheEntry entry = (CacheEntry) cacheGet( recid );
+        if ( entry == null ) {
+        	A value = _recman.fetch( recid, serializer );
+        	if(!_softCache)
+        	cachePut(recid,value, serializer,false);
+        	else{ //put record into soft cache
+        		synchronized(_softHash){
+        			_softHash.put(recid,new SoftCacheEntry(recid, value, _refQueue));
+        		}
+        	}
+        	return value;
+        }else{
+        	return (A) entry._obj;
+        }
+    }
+
+
+    public synchronized void close()
+        throws IOException
+    {
+        checkIfClosed();
+
+        updateCacheEntries();
+        _recman.close();
+        _recman = null;
+        _hash = null;
+        _softHash = null;
+        if(_softCache)
+        	_softRefThread.interrupt();
+    }
+
+
+
+    public synchronized void commit()
+        throws IOException
+    {
+        checkIfClosed();
+        updateCacheEntries();
+        _recman.commit();
+    }
+
+    public synchronized void rollback()
+        throws IOException
+    {
+        checkIfClosed();
+
+        _recman.rollback();
+
+        // discard all cache entries since we don't know which entries
+        // where part of the transaction
+    	_hash.clear();
+    	if(_softCache) synchronized(_softHash) {
+        	Iterator<SoftCacheEntry> iter = _softHash.valuesIterator();
+        	while(iter.hasNext()){
+        		SoftCacheEntry e = iter.next();    		
+    			e.clear();
+    		}
+    		_softHash.clear();
+    	}
+        _first = null;
+        _last = null;
+    }
+
+
+    public synchronized long getNamedObject( String name )
+        throws IOException
+    {
+        checkIfClosed();
+
+        return _recman.getNamedObject( name );
+    }
+
+
+    public synchronized void setNamedObject( String name, long recid )
+        throws IOException
+    {
+        checkIfClosed();
+
+        _recman.setNamedObject( name, recid );
+    }
+
+
+    /**
+     * Check if RecordManager has been closed.  If so, throw an
+     * IllegalStateException
+     */
+    private void checkIfClosed()
+        throws IllegalStateException
+    {
+        if ( _recman == null ) {
+            throw new IllegalStateException( "RecordManager has been closed" );
+        }
+    }
+
+    
+    /**
+     * Update all dirty cache objects to the underlying RecordManager.
+     */
+    protected void updateCacheEntries()
+        throws IOException
+    {
+    	Iterator<CacheEntry> iter = _hash.valuesIterator();
+    	while(iter.hasNext()){
+    		CacheEntry entry = iter.next();
+            if ( entry._isDirty ) {
+                _recman.update( entry._recid, entry._obj, entry._serializer );
+                entry._isDirty = false;
+            }
+    	}
+    }
+    
+    
+    /**
+     * Obtain an object in the cache
+     */
+    protected CacheEntry cacheGet(long key) {
+        CacheEntry entry = _hash.get(key);
+        if (entry != null) 
+            touchEntry(entry);
+        return entry;        
+    }
+
+
+    /**
+     * Place an object in the cache.
+     * @throws IOException 
+     */
+    protected void cachePut(long recid, Object value, Serializer serializer, boolean dirty) throws IOException {
+        CacheEntry entry = _hash.get(recid);
+        if (entry != null) {
+            entry._obj = value;
+            entry._serializer = serializer;
+            touchEntry(entry);
+        } else {
+
+            if (_hash.size() == _max) {
+                // purge and recycle entry
+                entry = purgeEntry();
+                entry._recid  = recid;
+                entry. _obj = value;
+                entry._isDirty = dirty;
+                entry._serializer = serializer;
+            } else {
+                entry = new CacheEntry(recid, value, serializer,dirty);
+            }
+            addEntry(entry);
+            _hash.put(entry._recid, entry);
+        }
+    }
+
+    /**
+     * Add a CacheEntry.  Entry goes at the end of the list.
+     */
+    protected void addEntry(CacheEntry entry) {
+        if (_first == null) {
+            _first = entry;
+            _last = entry;
+        } else {
+            _last._next = entry;
+            entry._previous = _last;
+            _last = entry;
+        }
+    }
+
+
+    /**
+     * Remove a CacheEntry from linked list
+     */
+    protected void removeEntry(CacheEntry entry) {
+        if (entry == _first) {
+            _first = entry._next;
+        }
+        if (_last == entry) {
+            _last = entry._previous;
+        }
+        CacheEntry previous = entry._previous;
+        CacheEntry next = entry._next;
+        if (previous != null) {
+            previous._next = next;
+        }
+        if (next != null) {
+            next._previous = previous;
+        }
+        entry._previous = null;
+        entry._next = null;
+    }
+
+    /**
+     * Place entry at the end of linked list -- Most Recently Used
+     */
+    protected void touchEntry(CacheEntry entry) {
+        if (_last == entry) {
+            return;
+        }
+        removeEntry(entry);
+        addEntry(entry);
+    }
+
+    /**
+     * Purge least recently used object from the cache
+     *
+     * @return recyclable CacheEntry
+     */
+    protected CacheEntry purgeEntry() throws IOException {
+        CacheEntry entry = _first;
+        if(entry == null)
+        	return new CacheEntry(-1,null,null,false);
+
+        if(entry._isDirty)
+        	_recman.update( entry._recid, entry._obj, entry._serializer );
+        removeEntry(entry);
+        _hash.remove(entry._recid);
+
+
+        entry._obj = null;
+        entry._serializer = null;
+        entry._isDirty = false;
+        return entry;
+    }
+
+
+    @SuppressWarnings("unchecked")
+    protected static final class CacheEntry
+    {
+
+        protected long _recid;
+        protected Object _obj;
+        
+		protected Serializer _serializer;
+        protected boolean _isDirty;
+        
+        protected CacheEntry _previous;
+        protected CacheEntry _next;
+
+        
+        CacheEntry( long recid, Object obj, Serializer serializer, boolean isDirty )
+        {
+            _recid = recid;
+            _obj = obj;
+            _serializer = serializer;
+            _isDirty = isDirty;
+        }
+        
+    } 
+
+    @SuppressWarnings("unchecked")
+	protected static final class SoftCacheEntry extends SoftReference
+    {
+
+        protected long _recid;
+
+        SoftCacheEntry( long recid, Object obj,  ReferenceQueue queue)
+        {
+        	super(obj,queue);
+            _recid = recid;
+        }
+        
+    }
+    
+    
+    /**
+     * Runs in separate thread and cleans SoftCache. 
+     * Runnable auto exists when CacheRecordManager is GCed
+     * 
+     * @author Jan Kotek
+     *
+     */
+    protected static final class SoftRunnable  implements Runnable{
+
+		private ReferenceQueue<SoftCacheEntry> entryQueue;
+		private WeakReference<CacheRecordManager> recman2;
+		
+		public SoftRunnable(CacheRecordManager recman, 
+				ReferenceQueue<SoftCacheEntry> entryQueue) {
+			this.recman2 = new WeakReference<CacheRecordManager>(recman);
+			this.entryQueue = entryQueue;
+		}
+
+		public void run() {
+			while(true)try{
+
+				//collect next item from cache,
+				//limit 10000 ms is to keep periodically checking if recman was GCed 
+				SoftCacheEntry e = (SoftCacheEntry) entryQueue.remove(10000);
+
+				//check if  recman was GCed, cancel in that case
+				CacheRecordManager recman = recman2.get();
+				if(recman == null) 
+					return;
+				if(e!=null){
+					synchronized(recman._softHash){
+						while(e!=null){
+							recman._softHash.remove(e._recid);
+							e = (SoftCacheEntry) entryQueue.poll();
+						}
+					}
+				}
+				
+			}catch (InterruptedException e){
+				return;
+			}catch (Throwable e){
+				//this thread must keep spinning, 
+				//otherwise SoftCacheEntries would not be disposed
+				e.printStackTrace();
+			}
+		}
+    	
+    }
+
+
+	public void clearCache() throws IOException {
+        // discard all cache entries since we don't know which entries
+        // where part of the transaction
+		while(_hash.size()>0)
+			purgeEntry();
+
+    	if(_softCache) synchronized(_softHash) {
+        	Iterator<SoftCacheEntry> iter = _softHash.valuesIterator();
+        	while(iter.hasNext()){
+        		SoftCacheEntry e = iter.next();    		
+    			e.clear();
+    		}
+    		_softHash.clear();
+    	}
+        _first = null;
+        _last = null;
+		
+	}
+
+
+	public void defrag() throws IOException {
+		commit();
+		_recman.defrag();		
+	}
+  
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/DataPage.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/DataPage.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+/**
+ * Class describing a page that holds data.
+ */
+final class DataPage extends PageHeader {
+	// offsets
+	private static final short O_FIRST = PageHeader.SIZE; // short firstrowid
+	static final short O_DATA = (short) (O_FIRST + Magic.SZ_SHORT);
+	final short DATA_PER_PAGE ;
+
+	/**
+	 * Constructs a data page view from the indicated block.
+	 */
+	DataPage(BlockIo block, int blockSize) {
+		super(block);
+		DATA_PER_PAGE = (short) (blockSize - O_DATA);
+	}
+
+	/**
+	 * Factory method to create or return a data page for the indicated block.
+	 */
+	static DataPage getDataPageView(BlockIo block, int blockSize) {
+		BlockView view = block.getView();
+		if (view != null && view instanceof DataPage)
+			return (DataPage) view;
+		else
+			return new DataPage(block, blockSize);
+	}
+
+	/** Returns the first rowid's offset */
+	short getFirst() {
+		return block.readShort(O_FIRST);
+	}
+
+	/** Sets the first rowid's offset */
+	void setFirst(short value) {
+		paranoiaMagicOk();
+		if (value > 0 && value < O_DATA)
+			throw new Error("DataPage.setFirst: offset " + value + " too small");
+		block.writeShort(O_FIRST, value);
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FileHeader.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FileHeader.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,128 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class represents a file header. It is a 1:1 representation of
+ *  the data that appears in block 0 of a file.
+ */
+class FileHeader implements BlockView {
+    // offsets
+    private static final short O_MAGIC = 0; // short magic
+    private static final short O_LISTS = Magic.SZ_SHORT; // long[2*NLISTS]
+    private static final int O_ROOTS = 
+        O_LISTS + (Magic.NLISTS * 2 * Magic.SZ_LONG);
+
+    // my block
+    private BlockIo block;
+
+    /** The number of "root" rowids available in the file. */
+    static final int NROOTS = (1024 - O_ROOTS) / Magic.SZ_LONG;
+    	//FIXME should this be dynamic
+        //(RecordFile.BLOCK_SIZE - O_ROOTS) / Magic.SZ_LONG;
+
+    /**
+     *  Constructs a FileHeader object from a block.
+     *
+     *  @param block The block that contains the file header
+     *  @param isNew If true, the file header is for a new file.
+     *  @throws IOException if the block is too short to keep the file
+     *          header.
+     */
+    FileHeader(BlockIo block, boolean isNew) {
+        this.block = block;
+        if (isNew)
+            block.writeShort(O_MAGIC, Magic.FILE_HEADER);
+        else if (!magicOk())
+            throw new Error("CRITICAL: file header magic not OK " 
+                            + block.readShort(O_MAGIC));
+    }
+
+    /** Returns true if the magic corresponds with the fileHeader magic.  */
+    private boolean magicOk() {
+        return block.readShort(O_MAGIC) == Magic.FILE_HEADER;
+    }
+
+
+    /** Returns the offset of the "first" block of the indicated list */
+    private short offsetOfFirst(int list) {
+        return (short) (O_LISTS + (2 * Magic.SZ_LONG * list));
+    }
+
+    /** Returns the offset of the "last" block of the indicated list */
+    private short offsetOfLast(int list) {
+        return (short) (offsetOfFirst(list) + Magic.SZ_LONG);
+    }
+
+    /** Returns the offset of the indicated root */
+    private short offsetOfRoot(int root) {
+        return (short) (O_ROOTS + (root * Magic.SZ_LONG));
+    }
+
+    /**
+     *  Returns the first block of the indicated list
+     */
+    long getFirstOf(int list) {
+        return block.readLong(offsetOfFirst(list));
+    }
+    
+    /**
+     *  Sets the first block of the indicated list
+     */
+    void setFirstOf(int list, long value) {
+        block.writeLong(offsetOfFirst(list), value);
+    }
+    
+    /**
+     *  Returns the last block of the indicated list
+     */
+    long getLastOf(int list) {
+        return block.readLong(offsetOfLast(list));
+    }
+    
+    /**
+     *  Sets the last block of the indicated list
+     */
+    void setLastOf(int list, long value) {
+        block.writeLong(offsetOfLast(list), value);
+    }
+
+    /**
+     *  Returns the indicated root rowid. A root rowid is a special rowid
+     *  that needs to be kept between sessions. It could conceivably be
+     *  stored in a special file, but as a large amount of space in the
+     *  block header is wasted anyway, it's more useful to store it where
+     *  it belongs.
+     *
+     *  @see #NROOTS
+     */
+    long getRoot(int root) {
+        return block.readLong(offsetOfRoot(root));
+    }
+
+    /**
+     *  Sets the indicated root rowid.
+     *
+     *  @see #getRoot
+     *  @see #NROOTS
+     */
+    void setRoot(int root, long rowid) {
+        block.writeLong(offsetOfRoot(root), rowid);
+    }
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreeLogicalRowIdPage.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreeLogicalRowIdPage.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,147 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+/**
+ *  Class describing a page that holds logical rowids that were freed. Note
+ *  that the methods have *physical* rowids in their signatures - this is
+ *  because logical and physical rowids are internally the same, only their
+ *  external representation (i.e. in the client API) differs.
+ */
+final class FreeLogicalRowIdPage extends PageHeader {
+    // offsets
+    private static final short O_COUNT = PageHeader.SIZE; // short count
+    static final short O_FREE = (short)(O_COUNT + Magic.SZ_SHORT);
+    final short ELEMS_PER_PAGE;
+
+    private int previousFoundFree = 0; // keeps track of the most recent found free slot so we can locate it again quickly 
+    private int previousFoundAllocated = 0; // keeps track of the most recent found allocated slot so we can locate it again quickly
+    
+    // slots we returned.
+    //final PhysicalRowId[] slots = new PhysicalRowId[ELEMS_PER_PAGE];
+
+    /**
+     *  Constructs a data page view from the indicated block.
+     */
+    FreeLogicalRowIdPage(BlockIo block, int blockSize) {
+        super(block);
+        ELEMS_PER_PAGE = (short) ((blockSize - O_FREE) / PhysicalRowId_SIZE);
+    }
+
+    /**
+     *  Factory method to create or return a data page for the
+     *  indicated block.
+     */
+    static FreeLogicalRowIdPage getFreeLogicalRowIdPageView(BlockIo block, int blockSize) {
+
+        BlockView view = block.getView();
+        if (view != null && view instanceof FreeLogicalRowIdPage)
+            return (FreeLogicalRowIdPage) view;
+        else
+            return new FreeLogicalRowIdPage(block,blockSize);
+    }
+
+    /** Returns the number of free rowids on this page. */
+    short getCount() {
+        return block.readShort(O_COUNT);
+    }
+
+    /** Sets the number of free rowids */
+    private void setCount(short i) {
+        block.writeShort(O_COUNT, i);
+    }
+
+    /** Frees a slot */
+    void free(int slot) {
+    	setLocationBlock(slotToOffset(slot), 0);
+        //get(slot).setBlock(0);
+        setCount((short) (getCount() - 1));
+        
+        // update previousFoundFree if the freed slot is before what we've found in the past
+        if (slot < previousFoundFree)
+            previousFoundFree = slot;
+    }
+
+    /** Allocates a slot */
+    short alloc(int slot) {
+        setCount((short) (getCount() + 1));
+        short pos = slotToOffset(slot);
+        setLocationBlock(pos, -1);
+        //get(slot).setBlock(-1);
+        
+        // update previousFoundAllocated if the newly allocated slot is before what we've found in the past
+        if (slot < previousFoundAllocated)
+            previousFoundAllocated = slot;
+        
+        return pos;
+    }
+
+    /** Returns true if a slot is allocated */
+    boolean isAllocated(int slot) {
+        //return get(slot).getBlock() > 0;
+    	return getLocationBlock(slotToOffset(slot)) > 0;
+    }
+
+    /** Returns true if a slot is free */
+    boolean isFree(int slot) {
+        return !isAllocated(slot);
+    }
+
+
+//    /** Returns the value of the indicated slot */
+//    PhysicalRowId get(int slot) {
+//        if (slots[slot] == null)
+//            slots[slot] = new PhysicalRowId(block, slotToOffset(slot));;
+//        return slots[slot];
+//    }
+//    
+
+    /** Converts slot to offset */
+    short slotToOffset(int slot) {
+        return (short) (O_FREE +
+                        (slot * PhysicalRowId_SIZE));
+    }
+
+    /**
+     *  Returns first free slot, -1 if no slots are available
+     */
+    int getFirstFree() {
+        for (; previousFoundFree < ELEMS_PER_PAGE; previousFoundFree++) {
+            if (isFree(previousFoundFree))
+                return previousFoundFree;
+        }
+        return -1;
+    }
+
+    /**
+     *  Returns first allocated slot, -1 if no slots are available.
+     */
+    int getFirstAllocated() {
+        for (; previousFoundAllocated < ELEMS_PER_PAGE; previousFoundAllocated++) {
+            if (isAllocated(previousFoundAllocated))
+                return previousFoundAllocated;
+        }
+        return -1;
+    }
+
+    public long slotToLocation(int slot) {
+		short pos = slotToOffset(slot);
+		return Location.toLong(getLocationBlock(pos),getLocationOffset(pos));
+	}
+    
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreeLogicalRowIdPageManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreeLogicalRowIdPageManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,150 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ *  This class manages free Logical rowid pages and provides methods
+ *  to free and allocate Logical rowids on a high level.
+ */
+final class FreeLogicalRowIdPageManager {
+    // our record file
+    private RecordFile file;
+    // our page manager
+    private PageManager pageman;
+	private int blockSize;
+	
+	final List<Long> freeBlocksInTransactionRowid = new ArrayList<Long>();
+
+
+    /**
+     *  Creates a new instance using the indicated record file and
+     *  page manager.
+     */
+    FreeLogicalRowIdPageManager(RecordFile file,
+                                PageManager pageman) throws IOException {
+        this.file = file;
+        this.pageman = pageman;
+        this.blockSize = file.BLOCK_SIZE;
+    }
+
+    /**
+     *  Returns a free Logical rowid, or
+     *  0 if nothing was found.
+     */
+    long get() throws IOException {
+    	if(!freeBlocksInTransactionRowid.isEmpty()){
+    		long first = freeBlocksInTransactionRowid.get(freeBlocksInTransactionRowid.size()-1);
+    		freeBlocksInTransactionRowid.remove(freeBlocksInTransactionRowid.size()-1);
+    		return first;
+    	}
+  
+        // Loop through the free Logical rowid list until we find
+        // the first rowid.
+        long retval = 0;
+        PageCursor curs = new PageCursor(pageman, Magic.FREELOGIDS_PAGE);
+        while (curs.next() != 0) {
+            FreeLogicalRowIdPage fp = FreeLogicalRowIdPage
+                .getFreeLogicalRowIdPageView(file.get(curs.getCurrent()),blockSize);
+            int slot = fp.getFirstAllocated();
+            if (slot != -1) {
+                // got one!
+                retval = fp.slotToLocation(slot);
+                    
+                fp.free(slot);
+                if (fp.getCount() == 0) {
+                    // page became empty - free it
+                    file.release(curs.getCurrent(), false);
+                    pageman.free(Magic.FREELOGIDS_PAGE, curs.getCurrent());
+                }
+                else
+                    file.release(curs.getCurrent(), true);
+                
+                return retval;
+            }
+            else {
+                // no luck, go to next page
+                file.release(curs.getCurrent(), false);
+            }     
+        }
+        return 0;
+    }
+
+    /**
+     *  Puts the indicated rowid on the free list
+     */
+    void put(long rowid)throws IOException {
+        freeBlocksInTransactionRowid.add(Long.valueOf(rowid));
+    }
+    
+
+	public void commit() throws IOException {
+		//write all uncommited free records		
+		Iterator<Long> rowidIter = freeBlocksInTransactionRowid.iterator();
+		PageCursor curs = new PageCursor(pageman, Magic.FREELOGIDS_PAGE);
+		//iterate over filled pages
+		while (curs.next() != 0) {
+			long freePage = curs.getCurrent();
+			BlockIo curBlock = file.get(freePage);
+			FreeLogicalRowIdPage fp = FreeLogicalRowIdPage.getFreeLogicalRowIdPageView(curBlock, blockSize);
+			int slot = fp.getFirstFree();
+			//iterate over free slots in page and fill them
+			while(slot!=-1 && rowidIter.hasNext()){
+				long rowid = rowidIter.next();		
+				short freePhysRowId = fp.alloc(slot);
+				fp.setLocationBlock(freePhysRowId, Location.getBlock(rowid));
+				fp.setLocationOffset(freePhysRowId, Location.getOffset(rowid));			
+				slot = fp.getFirstFree();
+			}
+			file.release(freePage, true);
+			if(!rowidIter.hasNext())
+				break;
+		}
+		
+		//now we propably filled all already allocated pages,
+		//time to start allocationg new pages
+		while(rowidIter.hasNext()){
+			//allocate new page
+			long freePage = pageman.allocate(Magic.FREELOGIDS_PAGE);
+			BlockIo curBlock = file.get(freePage);
+			FreeLogicalRowIdPage fp = FreeLogicalRowIdPage.getFreeLogicalRowIdPageView(curBlock, blockSize);
+			int slot = fp.getFirstFree();
+			//iterate over free slots in page and fill them
+			while(slot!=-1 && rowidIter.hasNext()){
+				long rowid = rowidIter.next();		
+				short freePhysRowId = fp.alloc(slot);
+				fp.setLocationBlock(freePhysRowId, Location.getBlock(rowid));
+				fp.setLocationOffset(freePhysRowId, Location.getOffset(rowid));
+				slot = fp.getFirstFree();
+			}
+			file.release(freePage, true);
+			if(!rowidIter.hasNext())
+				break;
+		}
+		
+		if(rowidIter.hasNext())
+			throw new InternalError();
+
+		freeBlocksInTransactionRowid.clear();
+		
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreePhysicalRowIdPage.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreePhysicalRowIdPage.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,229 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+/**
+ * Class describing a page that holds physical rowids that were freed.
+ */
+final class FreePhysicalRowIdPage extends PageHeader {
+	
+	static final short FreePhysicalRowId_O_SIZE = PhysicalRowId_SIZE; // int size
+	static final short FreePhysicalRowId_SIZE = FreePhysicalRowId_O_SIZE + Magic.SZ_INT;
+
+	// offsets
+	private static final short O_COUNT = PageHeader.SIZE; // short count
+	static final short O_FREE = O_COUNT + Magic.SZ_SHORT;
+	final short ELEMS_PER_PAGE;
+	
+
+
+	/**
+	 * Used to place a limit on the wasted capacity resulting in a modified first fit policy for re-allocated of free
+	 * records. This value is the maximum first fit waste that is accepted when scanning the available slots on a given
+	 * page of the free physical row page list.
+	 */
+	static public final transient int wasteMargin = 128;
+
+	/**
+	 * Used to place a limit on the wasted capacity resulting in a modified first fit policy for re-allocated of free
+	 * records. This value is the upper bound of waste that is accepted before scanning another page on the free
+	 * physical row page list. If no page can be found whose waste for the re-allocation request would be less than this
+	 * value then a new page will be allocated and the requested physical row will be allocated from that new page.
+	 */
+	static public final transient int wasteMargin2 = PageHeader.SIZE / 4;
+
+//	// slots we returned.
+//	FreePhysicalRowId[] slots = new FreePhysicalRowId[ELEMS_PER_PAGE];
+
+	final int[] sizeCache;
+	
+	/**
+	 * Constructs a data page view from the indicated block.
+	 */
+	FreePhysicalRowIdPage(BlockIo block, int blockSize) {
+		super(block);
+		ELEMS_PER_PAGE = (short) ((blockSize - O_FREE) / FreePhysicalRowId_SIZE);
+		 sizeCache = new int[ELEMS_PER_PAGE];
+		for(int i = 0;i<ELEMS_PER_PAGE;i++)
+			sizeCache[i] = -1;
+		
+	}
+
+	/**
+	 * Factory method to create or return a data page for the indicated block.
+	 */
+	static FreePhysicalRowIdPage getFreePhysicalRowIdPageView(BlockIo block,int pageSize) {
+		BlockView view = block.getView();
+		if (view != null && view instanceof FreePhysicalRowIdPage)
+			return (FreePhysicalRowIdPage) view;
+		else
+			return new FreePhysicalRowIdPage(block, pageSize);
+	}
+
+	/** Returns the number of free rowids */
+	short getCount() {
+		return block.readShort(O_COUNT);
+	}
+
+	/** Sets the number of free rowids */
+	private void setCount(short i) {
+		block.writeShort(O_COUNT, i);
+	}
+
+	/** Frees a slot */
+	void free(int slot) {
+		short pos = slotToOffset(slot);
+		FreePhysicalRowId_setSize(pos, 0);
+		//get(slot).setSize(0);
+		setCount((short) (getCount() - 1));
+	}
+
+	/** Allocates a slot */
+	short alloc(int slot) {
+		setCount((short) (getCount() + 1));
+		return slotToOffset(slot);
+	}
+
+	/** Returns true if a slot is allocated */
+	boolean isAllocated(int slot) {
+		short pos = slotToOffset(slot);
+		return FreePhysicalRowId_getSize(pos) != 0;
+	}
+
+	/** Returns true if a slot is free */
+	boolean isFree(int slot) {
+		return !isAllocated(slot);
+	}
+
+//	/** Returns the value of the indicated slot */
+//	FreePhysicalRowId get(int slot) {
+//		if (slots[slot] == null) {
+//			slots[slot] = new FreePhysicalRowId(block, slotToOffset(slot));
+//		}
+//		return slots[slot];
+//	}
+
+	/** Converts slot to offset */
+	short slotToOffset(int slot) {
+		return (short) (O_FREE + (slot * FreePhysicalRowId_SIZE));
+	}
+	
+	int offsetToSlot(short pos) {
+		int pos2 = pos;
+		return (pos2 - O_FREE)/FreePhysicalRowId_SIZE;			
+	}
+
+
+	/**
+	 * Returns first free slot, -1 if no slots are available
+	 */
+	int getFirstFree() {
+		for (int i = 0; i < ELEMS_PER_PAGE; i++) {
+			if (isFree(i))
+				return i;
+		}
+		return -1;
+	}
+
+	/**
+	 * Returns first slot with available size >= indicated size, or minus maximal size available on this page
+	 * 
+	 * @param size
+	 *            The requested allocation size.
+         *
+	 **/
+	int getFirstLargerThan(int size) {
+
+                int maxSize = 0;
+		/*
+		 * Tracks slot of the smallest available physical row on the page.
+		 */
+		int bestSlot = -1;
+		/*
+		 * Tracks size of the smallest available physical row on the page.
+		 */
+		int bestSlotSize = 0;
+		/*
+		 * Scan each slot in the page.
+		 */
+		for (int i = 0; i < ELEMS_PER_PAGE; i++) {
+			/*
+			 * When large allocations are used, the space wasted by the first fit policy can become very large (25% of
+			 * the store). The first fit policy has been modified to only accept a record with a maximum amount of
+			 * wasted capacity given the requested allocation size.
+			 */
+			// Note: isAllocated(i) is equiv to get(i).getSize() != 0
+			//long theSize = get(i).getSize(); // capacity of this free record.
+			short pos = slotToOffset(i);
+			int theSize = FreePhysicalRowId_getSize(pos); // capacity of this free record.
+                        if(theSize>maxSize) maxSize = theSize;
+			int waste = theSize - size; // when non-negative, record has suf. capacity.
+			if (waste >= 0) {
+				if (waste < wasteMargin) {
+					return i; // record has suf. capacity and not too much waste.
+				} else if (bestSlotSize >= size) {
+					/*
+					 * This slot is a better fit that any that we have seen so far on this page so we update the slot#
+					 * and available size for that slot.
+					 */
+					bestSlot = i;
+					bestSlotSize = size;
+				}
+			}
+		}
+		if (bestSlot != -1) {
+			/*
+			 * An available slot was identified that is large enough, but it exceeds the first wasted capacity limit. At
+			 * this point we check to see whether it is under our second wasted capacity limit. If it is, then we return
+			 * that slot.
+			 */
+			long waste = bestSlotSize - size; // when non-negative, record has suf. capacity.
+			if (waste >= 0 && waste < wasteMargin2) {
+				// record has suf. capacity and not too much waste.
+				return bestSlot;
+			}
+			/*
+			 * Will scan next page on the free physical row page list.
+			 */
+		}
+
+		return -maxSize;
+	}
+
+	public long slotToLocation(int slot) {
+		short pos = slotToOffset(slot);
+		return Location.toLong(getLocationBlock(pos),getLocationOffset(pos));
+	}
+	
+	/** Returns the size */
+	int FreePhysicalRowId_getSize(short pos) {
+		int slot = offsetToSlot(pos);
+		if(sizeCache[slot] == -1)
+			sizeCache[slot] =  block.readInt(pos + FreePhysicalRowId_O_SIZE);
+		return sizeCache[slot];
+	}
+
+	/** Sets the size */
+	void FreePhysicalRowId_setSize(short pos,int value) {
+		int slot = offsetToSlot(pos);
+		sizeCache[slot] = value;
+		block.writeInt(pos + FreePhysicalRowId_O_SIZE, value);
+	}
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreePhysicalRowIdPageManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/FreePhysicalRowIdPageManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,172 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+/**
+ * This class manages free physical rowid pages and provides methods to free and allocate physical rowids on a high
+ * level.
+ */
+final class FreePhysicalRowIdPageManager {
+	// our record file
+	protected RecordFile _file;
+
+	// our page manager
+	protected PageManager _pageman;
+
+	private int blockSize;
+
+        /** if true, new records are always placed to end of file, new space is not reclaimed */
+        private boolean appendToEnd = false;
+	
+	final ArrayList<Long> freeBlocksInTransactionRowid = new ArrayList<Long>();
+	final ArrayList<Integer> freeBlocksInTransactionSize = new ArrayList<Integer>();
+
+	/**
+	 * Creates a new instance using the indicated record file and page manager.
+	 */
+	FreePhysicalRowIdPageManager(RecordFile file, PageManager pageman, boolean append) throws IOException {
+		_file = file;
+		_pageman = pageman;
+		this.blockSize = file.BLOCK_SIZE;
+                this.appendToEnd = append;
+
+	}
+
+        private int lastMaxSize = -1;
+
+	/**
+	 * Returns a free physical rowid of the indicated size, or null if nothing was found. This scans the free physical
+	 * row table, which is modeled as a linked list of pages. Each page on that list has slots that are either free
+	 * (awaiting the insertion of the location of a free physical row) or available for reallocation requests. An
+	 * allocated slot is indicated by a non-zero size field in that slot and the size is the size of the available free
+	 * record in bytes.
+	 */
+	long get(int size) throws IOException {
+                //never reclaim used space
+                if(appendToEnd) return 0;
+
+                //requested record is bigger than any previously found
+                if(lastMaxSize!=-1 && size>lastMaxSize)
+                    return 0;
+
+		// Loop through the free physical rowid list until we find
+		// a rowid that's large enough.
+		long retval = 0;
+		PageCursor curs = new PageCursor(_pageman, Magic.FREEPHYSIDS_PAGE);
+                int maxSize = -1;
+		while (curs.next() != 0) {
+			FreePhysicalRowIdPage fp = FreePhysicalRowIdPage.getFreePhysicalRowIdPageView(_file.get(curs.getCurrent()), blockSize);
+			int slot = fp.getFirstLargerThan(size);
+			if (slot > 0) {
+                                //reset maximal size, as record has changed
+                                lastMaxSize = -1;
+				// got one!
+				retval = fp.slotToLocation(slot);
+
+				fp.free(slot);
+				if (fp.getCount() == 0) {
+					// page became empty - free it
+					_file.release(curs.getCurrent(), false);
+					_pageman.free(Magic.FREEPHYSIDS_PAGE, curs.getCurrent());
+				} else {
+					_file.release(curs.getCurrent(), true);
+				}
+
+				return retval;
+			} else {
+                                if(maxSize<-slot)
+                                    maxSize=-slot;
+				// no luck, go to next page
+				_file.release(curs.getCurrent(), false);
+			}
+
+		}
+                //update maximal size available
+                lastMaxSize = maxSize;
+
+		return 0;
+	}
+
+	/**
+	 * Puts the indicated rowid on the free list, which avaits for commit
+	 */
+	void put(long rowid, int size) throws IOException {
+		freeBlocksInTransactionRowid.add(Long.valueOf(rowid));
+		freeBlocksInTransactionSize.add(Integer.valueOf(size));
+	}
+
+	public void commit() throws IOException {
+		//write all uncommited free records		
+		Iterator<Long> rowidIter = freeBlocksInTransactionRowid.iterator();
+		Iterator<Integer> sizeIter = freeBlocksInTransactionSize.iterator();
+		PageCursor curs = new PageCursor(_pageman, Magic.FREEPHYSIDS_PAGE);
+		//iterate over filled pages
+		while (curs.next() != 0) {
+			long freePage = curs.getCurrent();
+			BlockIo curBlock = _file.get(freePage);
+			FreePhysicalRowIdPage fp = FreePhysicalRowIdPage.getFreePhysicalRowIdPageView(curBlock, blockSize);
+			int slot = fp.getFirstFree();
+			//iterate over free slots in page and fill them
+			while(slot!=-1 && rowidIter.hasNext()){
+				long rowid = rowidIter.next();
+				int size = sizeIter.next();		
+				short freePhysRowId = fp.alloc(slot);
+				fp.setLocationBlock(freePhysRowId, Location.getBlock(rowid));
+				fp.setLocationOffset(freePhysRowId, Location.getOffset(rowid));
+				fp.FreePhysicalRowId_setSize(freePhysRowId, size);
+				slot = fp.getFirstFree();
+			}
+			_file.release(freePage, true);
+			if(!rowidIter.hasNext())
+				break;
+		}
+		
+		//now we propably filled all already allocated pages,
+		//time to start allocationg new pages
+		while(rowidIter.hasNext()){
+			//allocate new page
+			long freePage = _pageman.allocate(Magic.FREEPHYSIDS_PAGE);
+			BlockIo curBlock = _file.get(freePage);
+			FreePhysicalRowIdPage fp = FreePhysicalRowIdPage.getFreePhysicalRowIdPageView(curBlock, blockSize);
+			int slot = fp.getFirstFree();
+			//iterate over free slots in page and fill them
+			while(slot!=-1 && rowidIter.hasNext()){
+				long rowid = rowidIter.next();
+				int size = sizeIter.next();		
+				short freePhysRowId = fp.alloc(slot);
+				fp.setLocationBlock(freePhysRowId, Location.getBlock(rowid));
+				fp.setLocationOffset(freePhysRowId, Location.getOffset(rowid));
+				fp.FreePhysicalRowId_setSize(freePhysRowId, size);
+				slot = fp.getFirstFree();
+			}
+			_file.release(freePage, true);
+			if(!rowidIter.hasNext())
+				break;
+		}
+		
+		if(rowidIter.hasNext())
+			throw new InternalError();
+
+		freeBlocksInTransactionRowid.clear();
+		freeBlocksInTransactionSize.clear();
+		
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/Location.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/Location.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,40 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+/**
+ * This class represents a location within a file. Both physical and
+ * logical rowids are based on locations internally - this version is
+ * used when there is no file block to back the location's data.
+ */
+final class Location {
+	
+	static long getBlock(long blockOffset){
+		return blockOffset >> 16;
+	}
+	
+	static short getOffset(long blockOffset){
+		return (short) (blockOffset & 0xffff);
+	}
+	
+	static long toLong(long block, short offset){
+		return (block << 16) + (long) offset;
+	}
+
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/LogicalRowIdManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/LogicalRowIdManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,155 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ * This class manages the linked lists of logical rowid pages.
+ */
+final class LogicalRowIdManager {
+	// our record file and associated page manager
+	private final RecordFile file;
+	private final PageManager pageman;
+	private final FreeLogicalRowIdPageManager freeman;
+	final short ELEMS_PER_PAGE;
+	private int blockSize; 
+
+	/**
+	 * Creates a log rowid manager using the indicated record file and page manager
+	 */
+	LogicalRowIdManager(RecordFile file, PageManager pageman,FreeLogicalRowIdPageManager freeman) throws IOException {
+		this.file = file;
+		this.pageman = pageman;
+		this.freeman = freeman;
+		this.blockSize = file.BLOCK_SIZE;
+		this.ELEMS_PER_PAGE = (short)((blockSize - TranslationPage.O_TRANS) / TranslationPage.PhysicalRowId_SIZE);
+	}
+
+	/**
+	 * Creates a new logical rowid pointing to the indicated physical id
+	 */
+	long insert(long loc) throws IOException {
+		// check whether there's a free rowid to reuse
+		long retval = freeman.get();
+		if (retval == 0) {
+			// no. This means that we bootstrap things by allocating
+			// a new translation page and freeing all the rowids on it.
+			long firstPage = pageman.allocate(Magic.TRANSLATION_PAGE);
+			short curOffset = TranslationPage.O_TRANS;
+			for (int i = 0; i < ELEMS_PER_PAGE; i++) {
+				freeman.put(Location.toLong(firstPage, curOffset));
+				curOffset += PageHeader.PhysicalRowId_SIZE;
+			}
+			
+			retval = freeman.get();
+			if (retval == 0) {
+				throw new Error("couldn't obtain free translation");
+			}
+		}
+		// write the translation.
+		update(retval, loc);
+		return retval;
+	}
+	
+	/**
+	 * Insert at forced location, use only for defragmentation !!
+	 * @param logicalRowId
+	 * @param physLoc
+	 * @throws IOException 
+	 */
+	void forceInsert(long logicalRowId, long physLoc) throws IOException {
+		//create pages until we reach requested block
+		long lastBlock  = pageman.getLast(Magic.TRANSLATION_PAGE);
+		while(lastBlock!=Location.getBlock(logicalRowId)){
+			lastBlock = pageman.allocate(Magic.TRANSLATION_PAGE);
+			if(lastBlock>Location.getBlock(logicalRowId))
+				throw new Error("outallocated");
+		}
+		if(fetch(logicalRowId) != 0)
+			throw new Error("can not forceInsert, record already exists: "+logicalRowId);		
+		
+		update(logicalRowId, physLoc);
+	}
+
+
+	/**
+	 * Releases the indicated logical rowid.
+	 */
+	void delete(long rowid) throws IOException {
+		//zero out old location, is needed for defragmentation
+		TranslationPage xlatPage = TranslationPage.getTranslationPageView(file.get(Location.getBlock(rowid)),blockSize);
+		xlatPage.setLocationBlock(Location.getOffset(rowid), 0);
+		xlatPage.setLocationOffset(Location.getOffset(rowid), (short)0);
+		file.release(Location.getBlock(rowid), true);
+		freeman.put(rowid);
+	}
+
+	/**
+	 * Updates the mapping
+	 * 
+	 * @param rowid
+	 *            The logical rowid
+	 * @param loc
+	 *            The physical rowid
+	 */
+	void update(long rowid, long loc) throws IOException {
+
+		TranslationPage xlatPage = TranslationPage.getTranslationPageView(file.get(Location.getBlock(rowid)),blockSize);
+		//make sure it is right type of page
+		
+		
+//		PhysicalRowId physid = xlatPage.get(rowid.getOffset());
+//		physid.setBlock(loc.getBlock());
+//		physid.setOffset(loc.getOffset());
+		xlatPage.setLocationBlock(Location.getOffset(rowid), Location.getBlock(loc));
+		xlatPage.setLocationOffset(Location.getOffset(rowid), Location.getOffset(loc));
+		file.release(Location.getBlock(rowid), true);
+	}
+
+	/**
+	 * Returns a mapping
+	 * 
+	 * @param rowid
+	 *            The logical rowid
+	 * @return The physical rowid, 0 if does not exist
+	 */
+	long fetch(long rowid) throws IOException {
+		final long block = Location.getBlock(rowid);
+		long last = pageman.getLast(Magic.TRANSLATION_PAGE);
+		if(last+1<block)
+			return 0;
+		
+		final short offset = Location.getOffset(rowid);
+		
+		BlockIo bio = file.get(block);
+		TranslationPage xlatPage = TranslationPage.getTranslationPageView(bio,blockSize);		
+		try {
+			long retval = Location.toLong(
+					xlatPage.getLocationBlock(offset),
+					xlatPage.getLocationOffset(offset));
+			return retval;
+		} finally {
+			file.release(block, false);
+		}
+	}
+
+	void commit() throws IOException{
+		freeman.commit();
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/Magic.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/Magic.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,65 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+/**
+ *  This interface contains magic cookies.
+ */
+interface Magic {
+    /** Magic cookie at start of file */
+    public short FILE_HEADER = 0x1350;
+
+    /** Magic for blocks. They're offset by the block type magic codes. */
+    public short BLOCK = 0x1351;
+
+    /** Magics for blocks in certain lists. Offset by baseBlockMagic */
+    short FREE_PAGE = 0;
+    short USED_PAGE = 1;
+    short TRANSLATION_PAGE = 2;
+    short FREELOGIDS_PAGE = 3;
+    short FREEPHYSIDS_PAGE = 4;
+
+    /** Number of lists in a file */
+    public short NLISTS = 5;
+
+    /**
+     *  Maximum number of blocks in a file, leaving room for a 16 bit
+     *  offset encoded within a long.
+     */
+    long MAX_BLOCKS = 0x7FFFFFFFFFFFL;
+
+    /** Magic for transaction file */
+    short LOGFILE_HEADER = 0x1360;
+
+    /** Size of an externalized byte */
+    public short SZ_BYTE = 1;
+    /** Size of an externalized short */
+    public short SZ_SHORT = 2;
+    /** Size of an externalized unsigned short */
+    public short SZ_UNSIGNED_SHORT = 2;    
+    /** Size of an externalized int */
+    public short SZ_INT = 4;
+    /** Size of an externalized long */
+    public short SZ_LONG = 8;
+
+    /** size of three byte integer */
+	public short SZ_THREE_BYTE_INT = 3;
+	
+    /** size of three byte integer */
+	public short SZ_SIX_BYTE_LONG = 6;
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageCursor.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageCursor.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+package jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class provides a cursor that can follow lists of pages
+ *  bi-directionally.
+ */
+final class PageCursor {
+    PageManager pageman;
+    long current;
+    short type;
+    
+    /**
+     *  Constructs a page cursor that starts at the indicated block.
+     */
+    PageCursor(PageManager pageman, long current) {
+        this.pageman = pageman;
+        this.current = current;
+    }
+    
+    /**
+     *  Constructs a page cursor that starts at the first block
+     *  of the indicated list.
+     */
+    PageCursor(PageManager pageman, short type) throws IOException {
+        this.pageman = pageman;
+        this.type = type;
+    }
+    
+    /**
+     *  Returns the current value of the cursor.
+     */
+    long getCurrent() throws IOException {
+        return current;
+    }
+    
+    /**
+     *  Returns the next value of the cursor
+     */
+    long next() throws IOException {
+        if (current == 0)
+            current = pageman.getFirst(type);
+        else
+            current = pageman.getNext(current);
+        return current;
+    } 
+    
+    /**
+     *  Returns the previous value of the cursor
+     */
+    long prev() throws IOException {
+        current = pageman.getPrev(current);
+        return current;
+    }
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageHeader.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageHeader.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,155 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class represents a page header. It is the common superclass for
+ *  all different page views.
+ */
+class PageHeader implements BlockView {
+    // offsets
+    private static final short O_MAGIC = 0; // short magic
+    private static final short O_NEXT = Magic.SZ_SHORT;  // long next
+    private static final short O_PREV = O_NEXT + Magic.SZ_LONG; // long prev
+    protected static final short SIZE = O_PREV + Magic.SZ_LONG;
+
+    static final short PhysicalRowId_O_BLOCK = 0; // long block
+    static final short PhysicalRowId_O_OFFSET = Magic.SZ_SIX_BYTE_LONG; // short offset
+    static final int PhysicalRowId_SIZE = PhysicalRowId_O_OFFSET + Magic.SZ_SHORT;
+
+    
+    // my block
+    protected BlockIo block;
+
+    /**
+     *  Constructs a PageHeader object from a block
+     *
+     *  @param block The block that contains the file header
+     *  @throws IOException if the block is too short to keep the file
+     *          header.
+     */
+    protected PageHeader(BlockIo block) {
+        initialize(block);
+        if (!magicOk())
+            throw new Error("CRITICAL: page header magic for block "
+                            + block.getBlockId() + " not OK "
+                            + getMagic());
+    }
+    
+    /**
+     *  Constructs a new PageHeader of the indicated type. Used for newly
+     *  created pages.
+     */
+    PageHeader(BlockIo block, short type) {
+        initialize(block);
+        setType(type);
+    }
+    
+    /**
+     *  Factory method to create or return a page header for the
+     *  indicated block.
+     */
+    static PageHeader getView(BlockIo block) {
+        BlockView view = block.getView();
+        if (view != null && view instanceof PageHeader)
+            return (PageHeader) view;
+        else
+            return new PageHeader(block);
+    }
+    
+    private void initialize(BlockIo block) {
+        this.block = block;
+        block.setView(this);
+    }
+    
+    /**
+     *  Returns true if the magic corresponds with the fileHeader magic.
+     */
+    private boolean magicOk() {
+        int magic = getMagic();
+        return magic >= Magic.BLOCK
+            && magic <= (Magic.BLOCK + Magic.FREEPHYSIDS_PAGE);
+    }
+    
+    /**
+     *  For paranoia mode
+     */
+    protected void paranoiaMagicOk() {
+        if (!magicOk())
+            throw new Error("CRITICAL: page header magic not OK "
+                            + getMagic());
+    }
+    
+    /** Returns the magic code */
+    short getMagic() {
+        return block.readShort(O_MAGIC);
+    }
+
+    /** Returns the next block. */
+    long getNext() {
+        paranoiaMagicOk();
+        return block.readLong(O_NEXT);
+    }
+    
+    /** Sets the next block. */
+    void setNext(long next) {
+        paranoiaMagicOk();
+        block.writeLong(O_NEXT, next);
+    }
+    
+    /** Returns the previous block. */
+    long getPrev() {
+        paranoiaMagicOk();
+        return block.readLong(O_PREV);
+    }
+    
+    /** Sets the previous block. */
+    void setPrev(long prev) {
+        paranoiaMagicOk();
+        block.writeLong(O_PREV, prev);
+    }
+    
+    /** Sets the type of the page header */
+    void setType(short type) {
+        block.writeShort(O_MAGIC, (short) (Magic.BLOCK + type));
+    }
+    
+    /** Returns the block number */
+    long getLocationBlock(short pos) {
+        return block.readSixByteLong(pos + PhysicalRowId_O_BLOCK);
+    }
+    
+    /** Sets the block number */
+    void setLocationBlock(short pos,long value) {
+        block.writeSixByteLong(pos + PhysicalRowId_O_BLOCK, value);
+    }
+    
+    /** Returns the offset */
+    short getLocationOffset(short pos) {
+        return block.readShort(pos + PhysicalRowId_O_OFFSET);
+    }
+    
+    /** Sets the offset */
+    void setLocationOffset(short pos,short value) {
+        block.writeShort(pos + PhysicalRowId_O_OFFSET, value);
+    }
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PageManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,242 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+import java.io.IOException;
+
+/**
+ *  This class manages the linked lists of pages that make up a file.
+ */
+final class PageManager {
+    // our record file
+    private RecordFile file;
+    // header data
+    private FileHeader header;
+    private BlockIo headerBuf;
+    
+    /**
+     *  Creates a new page manager using the indicated record file.
+     */
+    PageManager(RecordFile file) throws IOException {
+        this.file = file;
+        
+        // check the file header. If the magic is 0, we assume a new
+        // file. Note that we hold on to the file header node.
+        headerBuf = file.get(0);
+        if (headerBuf.readShort(0) == 0)
+            header = new FileHeader(headerBuf, true);
+        else
+            header = new FileHeader(headerBuf, false);
+    }
+    
+    /**
+     *  Allocates a page of the indicated type. Returns recid of the
+     *  page.
+     */
+    long allocate(short type) throws IOException {
+        
+        if (type == Magic.FREE_PAGE)
+            throw new Error("allocate of free page?");
+        
+        // do we have something on the free list?
+        long retval = header.getFirstOf(Magic.FREE_PAGE);
+        boolean isNew = false;
+        if (retval != 0) {
+            // yes. Point to it and make the next of that page the
+            // new first free page.
+            header.setFirstOf(Magic.FREE_PAGE, getNext(retval));
+        }
+        else {
+            // nope. make a new record
+            retval = header.getLastOf(Magic.FREE_PAGE);
+            if (retval == 0)
+                // very new file - allocate record #1
+                retval = 1;
+            header.setLastOf(Magic.FREE_PAGE, retval + 1);
+            isNew = true;
+        }
+        
+        // Cool. We have a record, add it to the correct list
+        BlockIo buf = file.get(retval);
+        PageHeader pageHdr = isNew ? new PageHeader(buf, type) 
+            : PageHeader.getView(buf);
+        long oldLast = header.getLastOf(type);
+        
+        // Clean data.
+        System.arraycopy(file.cleanData, 0, 
+                         buf.getData(), 0, 
+                         file.BLOCK_SIZE);
+        pageHdr.setType(type);
+        pageHdr.setPrev(oldLast);
+        pageHdr.setNext(0);
+        
+        
+        if (oldLast == 0)
+            // This was the first one of this type
+            header.setFirstOf(type, retval);
+        header.setLastOf(type, retval);
+        file.release(retval, true);
+        
+        // If there's a previous, fix up its pointer
+        if (oldLast != 0) {
+            buf = file.get(oldLast);
+            pageHdr = PageHeader.getView(buf);
+            pageHdr.setNext(retval);
+            file.release(oldLast, true);
+        }
+        
+        // remove the view, we have modified the type.
+        buf.setView(null);
+        
+        return retval;
+    }
+    
+    /**
+     *  Frees a page of the indicated type.
+     */
+    void free(short type, long recid) throws IOException {
+        if (type == Magic.FREE_PAGE)
+            throw new Error("free free page?");
+        if (recid == 0)
+            throw new Error("free header page?");
+        
+        // get the page and read next and previous pointers
+        BlockIo buf = file.get(recid);
+        PageHeader pageHdr = PageHeader.getView(buf);
+        long prev = pageHdr.getPrev();
+        long next = pageHdr.getNext();
+        
+        // put the page at the front of the free list.
+        pageHdr.setType(Magic.FREE_PAGE);
+        pageHdr.setNext(header.getFirstOf(Magic.FREE_PAGE));
+        pageHdr.setPrev(0);
+        
+        header.setFirstOf(Magic.FREE_PAGE, recid);
+        file.release(recid, true);
+        
+        // remove the page from its old list
+        if (prev != 0) {
+            buf = file.get(prev);
+            pageHdr = PageHeader.getView(buf);
+            pageHdr.setNext(next);
+            file.release(prev, true);
+        }
+        else {
+            header.setFirstOf(type, next);
+        }
+        if (next != 0) {
+            buf = file.get(next);
+            pageHdr = PageHeader.getView(buf);
+            pageHdr.setPrev(prev);
+            file.release(next, true);
+        }
+        else {
+            header.setLastOf(type, prev);
+        }
+        
+    }
+    
+    
+    /**
+     *  Returns the page following the indicated block
+     */
+    long getNext(long block) throws IOException {
+        try {
+            return PageHeader.getView(file.get(block)).getNext();
+        } finally {
+            file.release(block, false);
+        }
+    }
+    
+    /**
+     *  Returns the page before the indicated block
+     */
+    long getPrev(long block) throws IOException {
+        try {
+            return PageHeader.getView(file.get(block)).getPrev();
+        } finally {
+            file.release(block, false);
+        }
+    }
+    
+    /**
+     *  Returns the first page on the indicated list.
+     */
+    long getFirst(short type) throws IOException {
+        return header.getFirstOf(type);
+    }
+
+    /**
+     *  Returns the last page on the indicated list.
+     */
+    long getLast(short type) throws IOException {
+        return header.getLastOf(type);
+    }
+    
+    
+    /**
+     *  Commit all pending (in-memory) data by flushing the page manager.
+     *  This forces a flush of all outstanding blocks (this it's an implicit
+     *  {@link RecordFile#commit} as well).
+     */
+    void commit() throws IOException {
+        // write the header out
+        file.release(headerBuf);
+        file.commit();
+
+        // and obtain it again
+        headerBuf = file.get(0);
+        header = new FileHeader(headerBuf, false);
+    }
+
+    /**
+     *  Flushes the page manager. This forces a flush of all outstanding
+     *  blocks (this it's an implicit {@link RecordFile#commit} as well).
+     */
+    void rollback() throws IOException {
+        // release header
+        file.discard(headerBuf);
+        file.rollback();
+        // and obtain it again
+        headerBuf = file.get(0);
+        if (headerBuf.readShort(0) == 0)
+            header = new FileHeader(headerBuf, true);
+        else
+            header = new FileHeader(headerBuf, false);
+    }
+    
+    /**
+     *  Closes the page manager. This flushes the page manager and releases
+     *  the lock on the header.
+     */
+    void close() throws IOException {   
+        file.release(headerBuf);
+        file.commit();
+        headerBuf = null;
+        header = null;
+        file = null;
+    }
+    
+    /**
+     *  Returns the file header.
+     */
+    FileHeader getFileHeader() {
+        return header;
+    }
+    
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PhysicalRowIdManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/PhysicalRowIdManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,378 @@
+/**
+ * JDBM LICENSE v1.00
+ *
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain copyright
+ *    statements and notices.  Redistributions must also contain a
+ *    copy of this document.
+ *
+ * 2. Redistributions in binary form must reproduce the
+ *    above copyright notice, this list of conditions and the
+ *    following disclaimer in the documentation and/or other
+ *    materials provided with the distribution.
+ *
+ * 3. The name "JDBM" must not be used to endorse or promote
+ *    products derived from this Software without prior written
+ *    permission of Cees de Groot.  For written permission,
+ *    please contact cg at cdegroot.com.
+ *
+ * 4. Products derived from this Software may not be called "JDBM"
+ *    nor may "JDBM" appear in their names without prior written
+ *    permission of Cees de Groot.
+ *
+ * 5. Due credit should be given to the JDBM Project
+ *    (http://jdbm.sourceforge.net/).
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE JDBM PROJECT AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * CEES DE GROOT OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright 2000 (C) Cees de Groot. All Rights Reserved.
+ * Contributions are Copyright (C) 2000 by their associated contributors.
+ *
+ * $Id: PhysicalRowIdManager.java,v 1.3 2003/03/21 03:00:09 boisvert Exp $
+ */
+
+package jdbm.recman;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * This class manages physical row ids, and their data.
+ */
+final class PhysicalRowIdManager {
+
+	// The file we're talking to and the associated page manager.
+	final private RecordFile file;
+	final private PageManager pageman;
+	final private FreePhysicalRowIdPageManager freeman;
+	final private int BLOCK_SIZE;
+	final short DATA_PER_PAGE ;
+
+	/**
+	 * Creates a new rowid manager using the indicated record file. and page manager.
+	 */
+	PhysicalRowIdManager(RecordFile file, PageManager pageManager, FreePhysicalRowIdPageManager freeman) throws IOException {
+		this.file = file;
+		this.pageman = pageManager;
+		this.freeman = freeman;
+		this.BLOCK_SIZE = file.BLOCK_SIZE;
+		DATA_PER_PAGE = (short) (BLOCK_SIZE - DataPage.O_DATA);
+	}
+
+	/**
+	 * Inserts a new record. Returns the new physical rowid.
+	 */
+	long insert(byte[] data, int start, int length) throws IOException {
+		if (length < 1)
+			throw new IllegalArgumentException("Lenght is <1");
+		if (start < 0)
+			throw new IllegalArgumentException("negative start");
+
+		long retval = alloc(length);
+		write(retval, data, start, length);
+		return retval;
+	}
+
+	/**
+	 * Updates an existing record. Returns the possibly changed physical rowid.
+	 */
+	long update(long rowid, byte[] data, int start, int length) throws IOException {
+		// fetch the record header
+		BlockIo block = file.get(Location.getBlock(rowid));
+		short head = Location.getOffset(rowid);
+		int availSize = RecordHeader.getAvailableSize(block, head);
+		if (length > availSize || 
+			//difference between free and available space can be only 64KB. 
+			//if bigger, need to realocate and free block	
+			availSize - length > RecordHeader.MAX_SIZE_SPACE	
+		) {
+			// not enough space - we need to copy to a new rowid.
+			file.release(block);
+			free(rowid);
+			rowid = alloc(length);
+		} else {
+			file.release(block);
+		}
+
+		// 'nuff space, write it in and return the rowid.
+		write(rowid, data, start, length);
+		return rowid;
+	} 
+
+	/**
+	 * Deletes a record.
+	 */
+	void delete(long rowid) throws IOException {
+		free(rowid);
+	}
+
+	/**
+	 * Retrieves a record.
+	 */
+	// byte[] fetch( Location rowid )
+	// throws IOException
+	// {
+	// // fetch the record header
+	// PageCursor curs = new PageCursor( pageman, rowid.getBlock() );
+	// BlockIo block = file.get( curs.getCurrent() );
+	// RecordHeader head = new RecordHeader( block, rowid.getOffset() );
+	//
+	// // allocate a return buffer
+	// byte[] retval = new byte[ head.getCurrentSize() ];
+	// if ( retval.length == 0 ) {
+	// file.release( curs.getCurrent(), false );
+	// return retval;
+	// }
+	//
+	// // copy bytes in
+	// int offsetInBuffer = 0;
+	// int leftToRead = retval.length;
+	// short dataOffset = (short) (rowid.getOffset() + RecordHeader.SIZE);
+	// while ( leftToRead > 0 ) {
+	// // copy current page's data to return buffer
+	// int toCopy = RecordFile.BLOCK_SIZE - dataOffset;
+	// if ( leftToRead < toCopy ) {
+	// toCopy = leftToRead;
+	// }
+	// System.arraycopy( block.getData(), dataOffset,
+	// retval, offsetInBuffer,
+	// toCopy );
+	//
+	// // Go to the next block
+	// leftToRead -= toCopy;
+	// offsetInBuffer += toCopy;
+	//
+	// file.release( block );
+	//
+	// if ( leftToRead > 0 ) {
+	// block = file.get( curs.next() );
+	// dataOffset = DataPage.O_DATA;
+	// }
+	//
+	// }
+	//
+	// return retval;
+	// }
+
+	void fetch(OutputStream out, long rowid) throws IOException {
+		// fetch the record header
+		PageCursor curs = new PageCursor(pageman, Location.getBlock(rowid));
+		BlockIo block = file.get(curs.getCurrent());
+		short head = Location.getOffset(rowid);
+
+		// allocate a return buffer
+		// byte[] retval = new byte[ head.getCurrentSize() ];
+		final int size = RecordHeader.getCurrentSize(block,head);
+		if (size == 0) {
+			file.release(curs.getCurrent(), false);
+			return;
+		}
+
+		// copy bytes in
+		int offsetInBuffer = 0;
+		int leftToRead = size;
+		short dataOffset = (short) (Location.getOffset(rowid) + RecordHeader.SIZE);
+		while (leftToRead > 0) {
+			// copy current page's data to return buffer
+			int toCopy = BLOCK_SIZE - dataOffset;
+			if (leftToRead < toCopy) {
+				toCopy = leftToRead;
+			}
+			byte[] blockData = block.getData();
+			int finish = dataOffset + toCopy;
+			out.write(blockData, dataOffset, finish - dataOffset);
+
+			// Go to the next block
+			leftToRead -= toCopy;
+			offsetInBuffer += toCopy;
+			// out.flush();
+			file.release(block);
+
+			if (leftToRead > 0) {
+				block = file.get(curs.next());
+				dataOffset = DataPage.O_DATA;
+			}
+
+		}
+
+		// return retval;
+	}
+
+	/**
+	 * Allocate a new rowid with the indicated size.
+	 */
+	private long alloc(int size) throws IOException {
+		size = RecordHeader.roundAvailableSize(size);
+		long retval = freeman.get(size);
+		if (retval == 0) {
+			retval = allocNew(size, pageman.getLast(Magic.USED_PAGE));
+		}
+		return retval;
+	}
+
+	/**
+	 * Allocates a new rowid. The second parameter is there to allow for a recursive call - it indicates where the
+	 * search should start.
+	 */
+	private long allocNew(int size, long start) throws IOException {
+		BlockIo curBlock;
+		DataPage curPage;
+		if (start == 0) {
+			// we need to create a new page.
+			start = pageman.allocate(Magic.USED_PAGE);
+			curBlock = file.get(start);
+			curPage = DataPage.getDataPageView(curBlock,BLOCK_SIZE);
+			curPage.setFirst(DataPage.O_DATA);
+			RecordHeader.setAvailableSize(curBlock, DataPage.O_DATA, 0);
+			RecordHeader.setCurrentSize(curBlock, DataPage.O_DATA, 0);
+		} else {
+			curBlock = file.get(start);
+			curPage = DataPage.getDataPageView(curBlock,BLOCK_SIZE);
+		}
+
+		// follow the rowids on this page to get to the last one. We don't
+		// fall off, because this is the last page, remember?
+		short pos = curPage.getFirst();
+		if (pos == 0) {
+			// page is exactly filled by the last block of a record
+			file.release(curBlock);
+			return allocNew(size, 0);
+		}
+
+		short hdr = pos;
+		while (RecordHeader.getAvailableSize(curBlock, hdr) != 0 && pos < BLOCK_SIZE) {
+			pos += RecordHeader.getAvailableSize(curBlock, hdr) + RecordHeader.SIZE;
+			if (pos == BLOCK_SIZE) {
+				// Again, a filled page.
+				file.release(curBlock);
+				return allocNew(size, 0);
+			}
+
+			hdr = pos;
+		}
+
+		if (pos == RecordHeader.SIZE) {
+			// the last record exactly filled the page. Restart forcing
+			// a new page.
+			file.release(curBlock);
+		}
+
+		// we have the position, now tack on extra pages until we've got
+		// enough space.
+		long retval = Location.toLong(start, pos);
+		int freeHere = BLOCK_SIZE - pos - RecordHeader.SIZE;
+		if (freeHere < size) {
+			// check whether the last page would have only a small bit left.
+			// if yes, increase the allocation. A small bit is a record
+			// header plus 16 bytes.
+			int lastSize = (size - freeHere) % DATA_PER_PAGE;
+			if ((DATA_PER_PAGE - lastSize) < (RecordHeader.SIZE + 16)) {
+				size += (DATA_PER_PAGE - lastSize);
+				size = RecordHeader.roundAvailableSize(size);
+			}
+
+			// write out the header now so we don't have to come back.
+			RecordHeader.setAvailableSize(curBlock, hdr, size);
+			file.release(start, true);
+
+			int neededLeft = size - freeHere;
+			// Refactor these two blocks!
+			while (neededLeft >= DATA_PER_PAGE) {
+				start = pageman.allocate(Magic.USED_PAGE);
+				curBlock = file.get(start);
+				curPage = DataPage.getDataPageView(curBlock, BLOCK_SIZE);
+				curPage.setFirst((short) 0); // no rowids, just data
+				file.release(start, true);
+				neededLeft -= DATA_PER_PAGE;
+			}
+			if (neededLeft > 0) {
+				// done with whole chunks, allocate last fragment.
+				start = pageman.allocate(Magic.USED_PAGE);
+				curBlock = file.get(start);
+				curPage = DataPage.getDataPageView(curBlock, BLOCK_SIZE);
+				curPage.setFirst((short) (DataPage.O_DATA + neededLeft));
+				file.release(start, true);
+			}
+		} else {
+			// just update the current page. If there's less than 16 bytes
+			// left, we increase the allocation (16 bytes is an arbitrary
+			// number).
+			if (freeHere - size <= (16 + RecordHeader.SIZE)) {
+				size = freeHere;
+			}
+			RecordHeader.setAvailableSize(curBlock, hdr, size);
+			file.release(start, true);
+		}
+		return retval;
+
+	}
+
+	private void free(long id) throws IOException {
+		// get the rowid, and write a zero current size into it.
+		BlockIo curBlock = file.get(Location.getBlock(id));
+		DataPage curPage = DataPage.getDataPageView(curBlock,BLOCK_SIZE);
+
+		RecordHeader.setCurrentSize(curBlock, Location.getOffset(id), 0);
+		file.release(Location.getBlock(id), true);
+
+		// write the rowid to the free list
+		freeman.put(id, RecordHeader.getAvailableSize(curBlock, Location.getOffset(id)));	
+	}
+
+	/**
+	 * Writes out data to a rowid. Assumes that any resizing has been done.
+	 */
+	private void write(long rowid, byte[] data, int start, int length) throws IOException {
+		PageCursor curs = new PageCursor(pageman, Location.getBlock(rowid));
+		BlockIo block = file.get(curs.getCurrent());
+		short hdr = Location.getOffset(rowid);
+		RecordHeader.setCurrentSize(block, hdr, length);
+		if (length == 0) {
+			file.release(curs.getCurrent(), true);
+			return;
+		}
+
+		// copy bytes in
+		int offsetInBuffer = start;
+		int leftToWrite = length;
+		short dataOffset = (short) (Location.getOffset(rowid) + RecordHeader.SIZE);
+		while (leftToWrite > 0) {
+			// copy current page's data to return buffer
+			int toCopy = BLOCK_SIZE - dataOffset;
+
+			if (leftToWrite < toCopy) {
+				toCopy = leftToWrite;
+			}
+			System.arraycopy(data, offsetInBuffer, block.getData(), dataOffset, toCopy);
+
+			// Go to the next block
+			leftToWrite -= toCopy;
+			offsetInBuffer += toCopy;
+
+			file.release(curs.getCurrent(), true);
+
+			if (leftToWrite > 0) {
+				block = file.get(curs.next());
+				dataOffset = DataPage.O_DATA;
+			}
+		}
+	}
+
+	void commit() throws IOException {
+		freeman.commit();		
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordFile.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordFile.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,506 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.channels.OverlappingFileLockException;
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import jdbm.RecordManager;
+import jdbm.RecordManagerOptions;
+import jdbm.helper.LongHashMap;
+
+/**
+ *  This class represents a random access file as a set of fixed size
+ *  records. Each record has a physical record number, and records are
+ *  cached in order to improve access.
+ *<p>
+ *  The set of dirty records on the in-use list constitutes a transaction.
+ *  Later on, we will send these records to some recovery thingy.
+ *<p>
+ *  RecordFile is splited between more files, each with max size 1GB. 
+ */
+final class RecordFile {
+    final TransactionManager txnMgr;
+
+    // Todo: reorganize in hashes and fifos as necessary.
+    // free -> inUse -> dirty -> inTxn -> free
+    // free is a cache, thus a FIFO. The rest are hashes.
+    private final LongHashMap<BlockIo> free = new LongHashMap<BlockIo>();
+    /**
+     * Blocks currently locked for read/update ops. When released the block goes
+     * to the dirty or clean list, depending on a flag.  The file header block is
+     * normally locked plus the block that is currently being read or modified.
+     * 
+     * @see BlockIo#isDirty()
+     */
+    private final LongHashMap<BlockIo> inUse = new LongHashMap<BlockIo>();
+   
+    /**
+     * Blocks whose state is dirty.
+     */
+    private final LongHashMap<BlockIo> dirty = new LongHashMap<BlockIo>();
+    /**
+     * Blocks in a <em>historical</em> transaction(s) that have been written
+     * onto the log but which have not yet been committed to the database.
+     */
+    private final LongHashMap<BlockIo> inTxn = new LongHashMap<BlockIo>();
+    
+
+    // transactions disabled?
+    private boolean transactionsDisabled = false;
+    
+    private String indexDirRelativePath ; 
+    
+    
+    
+  
+
+	static final int DEFAULT_BLOCK_SIZE = 4096;
+
+//    /** The length of a single block. */
+    final int BLOCK_SIZE ;//= 8192;//4096;
+//    /** maximal file size not rounded to block size */
+    private final static long _FILESIZE = 1000000000l;
+    private final long MAX_FILE_SIZE;// = _FILESIZE - _FILESIZE%BLOCK_SIZE;
+
+
+    /** A block of clean data to wipe clean pages. */
+    final byte[] cleanData;
+
+    private ArrayList<FileChannel> fileChannels = new ArrayList<FileChannel>();
+    private ArrayList<RandomAccessFile> rafs = new ArrayList<RandomAccessFile>();
+    private final String fileName;
+    
+    RecordFile(String fileName) throws IOException {
+    	this(fileName,DEFAULT_BLOCK_SIZE);
+    }
+
+    /**
+     *  Creates a new object on the indicated filename. The file is
+     *  opened in read/write mode.
+     *
+     *  @param fileName the name of the file to open or create, without
+     *         an extension.
+     *  @throws IOException whenever the creation of the underlying
+     *          RandomAccessFile throws it.
+     */
+    RecordFile(String fileName, int blockSize)  throws IOException{
+    	this (fileName , blockSize, RecordManager.DEFAULT_RELATIVE_PATH_INDEX); // default relative directory is set to .index
+    }
+
+    RecordFile(String fileName, int blockSize, String relativePathStr) throws IOException 
+    {
+    	if ( relativePathStr != null && !relativePathStr.equals(new String()) )
+    		indexDirRelativePath = relativePathStr ;
+		
+		this.BLOCK_SIZE = blockSize;
+    	MAX_FILE_SIZE =  _FILESIZE - _FILESIZE%BLOCK_SIZE;
+    	cleanData = new byte[BLOCK_SIZE];
+        this.fileName = fileName;
+//        file0 = new RandomAccessFile(fileName + extension, "rw"); 
+//        file = file0.getChannel();
+        //make sure first file can be opened
+        FileChannel f0 = getChannel(0);
+        //lock it
+        try{
+        	f0.tryLock();
+        }catch(IOException e){
+        	throw new IOException("Could not lock DB file: "+fileName,e);
+        }catch(OverlappingFileLockException e){
+            throw new IOException("Could not lock DB file: "+fileName,e);
+        }
+        txnMgr = new TransactionManager(this);
+	}
+
+	FileChannel getChannel(long offset) throws IOException {
+    	int fileNumber = (int) (offset/MAX_FILE_SIZE);
+    
+   		//increase capacity of array lists if needed
+   		for(int i = fileChannels.size();i<=fileNumber;i++){
+   			fileChannels.add(null);
+   			rafs.add(null);
+    	}
+    	
+		FileChannel ret = fileChannels.get(fileNumber);
+		if(ret == null){
+			String name = fileName+"."+fileNumber;
+			RandomAccessFile f = new RandomAccessFile(getIndexDirectoryPath()+"/" + name, "rw");
+			rafs.set(fileNumber, f);
+			ret = f.getChannel();			
+			fileChannels.set(fileNumber, ret);		
+		}
+		return ret;
+	}
+
+    public String getIndexDirectoryPath() {
+		File newDirectory = new File( indexDirRelativePath  );
+    	
+    	if (!newDirectory.exists())
+    		newDirectory.mkdirs();
+    	
+		return newDirectory.getAbsolutePath();
+	}
+
+	/**
+     *  Returns the file name.
+     */
+    String getFileName() {
+        return fileName;
+    }
+
+    /**
+     *  Disables transactions: doesn't sync and doesn't use the
+     *  transaction manager.
+     */
+    void disableTransactions() {
+        transactionsDisabled = true;
+    }
+
+    /**
+     *  Gets a block from the file. The returned byte array is
+     *  the in-memory copy of the record, and thus can be written
+     *  (and subsequently released with a dirty flag in order to
+     *  write the block back).
+     *
+     *  @param blockid The record number to retrieve.
+     */
+     BlockIo get(long blockid) throws IOException {
+
+         // try in transaction list, dirty list, free list
+         BlockIo node =  inTxn.get(blockid);
+         if (node != null) {
+             inTxn.remove(blockid);
+             inUse.put(blockid, node);
+             return node;
+         }
+         node =  dirty.get(blockid);
+         if (node != null) {
+             dirty.remove(blockid);
+             inUse.put(blockid, node);
+             return node;
+         }
+         
+         BlockIo cur = free.get(blockid);
+         if(cur!=null){
+           node = cur;
+           free.remove(blockid);
+           inUse.put(blockid, node);
+           return node;        	 
+         }
+
+         // sanity check: can't be on in use list
+         if (inUse.get(blockid) != null) {
+             throw new Error("double get for block " + blockid );
+         }
+
+         // get a new node and read it from the file
+         node = getNewNode(blockid);
+         long offset = blockid * BLOCK_SIZE;
+         FileChannel file = getChannel(offset);
+//         long fileSize = file.size();
+//         if (fileSize > 0 && offset%MAX_FILE_SIZE <= fileSize) {
+//             read(file, offset%MAX_FILE_SIZE, node.getData(), BLOCK_SIZE);
+//         } else {
+//             System.arraycopy(cleanData, 0, node.getData(), 0, BLOCK_SIZE);
+//         }
+         
+         read(file, offset%MAX_FILE_SIZE, node.getData(), BLOCK_SIZE);   
+         
+         inUse.put(blockid, node);
+         node.setClean();
+         return node;
+     }
+
+     
+    /**
+     *  Releases a block.
+     *
+     *  @param blockid The record number to release.
+     *  @param isDirty If true, the block was modified since the get().
+     */
+    void release(long blockid, boolean isDirty) throws IOException {
+        BlockIo node = inUse.get(blockid);
+        if (node == null)
+            throw new IOException("bad blockid " + blockid + " on release");
+        if (!node.isDirty() && isDirty)
+            node.setDirty();
+        release(node);
+    }
+
+    /**
+     *  Releases a block.
+     *
+     *  @param block The block to release.
+     */
+    void release(BlockIo block) {
+        final long key =block.getBlockId();
+        inUse.remove(key);
+        if (block.isDirty()) {
+            // System.out.println( "Dirty: " + key + block );
+            dirty.put(key, block);
+        } else {
+            if (!transactionsDisabled && block.isInTransaction()) {
+                inTxn.put(key, block);
+            } else {
+                free.put(key,block);
+            }
+        }
+    }
+
+    /**
+     *  Discards a block (will not write the block even if it's dirty)
+     *
+     *  @param block The block to discard.
+     */
+    void discard(BlockIo block) {
+        long key = block.getBlockId();
+        inUse.remove(key);
+
+        // note: block not added to free list on purpose, because
+        //       it's considered invalid
+    }
+
+    /**
+     *  Commits the current transaction by flushing all dirty buffers
+     *  to disk.
+     */
+    void commit() throws IOException {
+        // debugging...
+        if (!inUse.isEmpty() && inUse.size() > 1) {
+            showList(inUse.valuesIterator());
+            throw new Error("in use list not empty at commit time ("
+                            + inUse.size() + ")");
+        }
+
+        //  System.out.println("committing...");
+
+        if ( dirty.size() == 0 ) {
+            // if no dirty blocks, skip commit process
+            return;
+        }
+
+        if (!transactionsDisabled) {
+            txnMgr.start();
+        }
+
+        for (Iterator<BlockIo> i = dirty.valuesIterator(); i.hasNext(); ) {
+            BlockIo node =  i.next();
+            i.remove();
+            // System.out.println("node " + node + " map size now " + dirty.size());
+            if (transactionsDisabled) {
+                long offset = node.getBlockId() * BLOCK_SIZE;
+                FileChannel file = getChannel(offset);
+                file.position(offset % MAX_FILE_SIZE);
+                file.write(ByteBuffer.wrap(node.getData()));
+                node.setClean();
+                free.put(node.getBlockId(),node);
+            }
+            else {
+                txnMgr.add(node);
+                inTxn.put(node.getBlockId(), node);
+            }
+        }
+        if (!transactionsDisabled) {
+            txnMgr.commit();
+        }
+    }
+
+    /**
+     *  Rollback the current transaction by discarding all dirty buffers
+     */
+    void rollback() throws IOException {
+        // debugging...
+        if (!inUse.isEmpty()) {
+            showList(inUse.valuesIterator());
+            throw new Error("in use list not empty at rollback time ("
+                            + inUse.size() + ")");
+        }
+        //  System.out.println("rollback...");
+        dirty.clear();
+
+        txnMgr.synchronizeLogFromDisk();
+
+        if (!inTxn.isEmpty()) {
+            showList(inTxn.valuesIterator());
+            throw new Error("in txn list not empty at rollback time ("
+                            + inTxn.size() + ")");
+        };
+    }
+
+    /**
+     *  Commits and closes file.
+     */
+    void close() throws IOException {
+        if (!dirty.isEmpty()) {
+            commit();
+        }
+        txnMgr.shutdown();
+
+        if (!inTxn.isEmpty()) {
+            showList(inTxn.valuesIterator());
+            throw new Error("In transaction not empty");
+        }
+
+        // these actually ain't that bad in a production release
+        if (!dirty.isEmpty()) {
+            System.out.println("ERROR: dirty blocks at close time");
+            showList(dirty.valuesIterator());
+            throw new Error("Dirty blocks at close time");
+        }
+        if (!inUse.isEmpty()) {
+            System.out.println("ERROR: inUse blocks at close time");
+            showList(inUse.valuesIterator());
+            throw new Error("inUse blocks at close time");
+        }
+
+        // debugging stuff to keep an eye on the free list
+        // System.out.println("Free list size:" + free.size());
+        for(FileChannel buf : fileChannels){
+        	if(buf!=null){
+        		buf.close();
+        	}
+        }
+        fileChannels = null;
+        for(RandomAccessFile f :rafs){
+        	if(f!=null)
+        		f.close();
+        }
+        rafs = null;      
+        
+    }
+
+
+    /**
+     * Force closing the file and underlying transaction manager.
+     * Used for testing purposed only.
+     */
+    void forceClose() throws IOException {
+      txnMgr.forceClose();
+      for(FileChannel buf : fileChannels){
+      	if(buf!=null)
+      		buf.close();
+      }
+      fileChannels = null;
+      for(RandomAccessFile f :rafs){
+      	if(f!=null)
+      		f.close();
+      }
+      rafs = null;  
+    }
+
+    /**
+     *  Prints contents of a list
+     */
+    private void showList(Iterator<BlockIo> i) {
+        int cnt = 0;
+        while (i.hasNext()) {
+            System.out.println("elem " + cnt + ": " + i.next());
+            cnt++;
+        }
+    }
+
+
+    /**
+     *  Returns a new node. The node is retrieved (and removed)
+     *  from the released list or created new.
+     */
+    private BlockIo getNewNode(long blockid)
+    throws IOException {
+
+        BlockIo retval = null;
+        if (!free.isEmpty()) {
+        	Iterator<BlockIo> it = free.valuesIterator();
+        	retval = it.next();
+        	it.remove();
+        }
+        if (retval == null)
+            retval = new BlockIo(0, new byte[BLOCK_SIZE]);
+
+        retval.setBlockId(blockid);
+        retval.setView(null);
+        return retval;
+    }
+
+    /**
+     *  Synchs a node to disk. This is called by the transaction manager's
+     *  synchronization code.
+     */
+    void synch(BlockIo node) throws IOException {
+        byte[] data = node.getData();
+        if (data != null) {
+            long offset = node.getBlockId() * BLOCK_SIZE;
+            FileChannel file = getChannel(offset);
+            file.position(offset % MAX_FILE_SIZE);
+            file.write(ByteBuffer.wrap(data));
+        }
+    }
+
+    /**
+     *  Releases a node from the transaction list, if it was sitting
+     *  there.
+     *
+     *  @param recycle true if block data can be reused
+     */
+    void releaseFromTransaction(BlockIo node, boolean recycle)
+    throws IOException {
+        long key = node.getBlockId();
+        if ((inTxn.remove(key) != null) && recycle) {
+            free.put(key,node);
+        }
+    }
+
+    /**
+     *  Synchronizes the file.
+     */
+    void sync() throws IOException {
+    	for(FileChannel file:fileChannels)
+    		if(file!=null)
+    			file.force(true);
+    }
+
+
+    /**
+     * Utility method: Read a block from a RandomAccessFile
+     */
+    private void read(FileChannel file, long offset,
+                             byte[] buffer, int nBytes) throws IOException {
+        file.position(offset);
+        int remaining = nBytes;
+        int pos = 0;
+        while (remaining > 0) {
+        	ByteBuffer b = ByteBuffer.wrap(buffer, pos, remaining);
+        	int read = file.read(b);
+        	while(read!=-1 && b.hasRemaining() )
+        		read = file.read(b);
+            
+            if (read == -1) {
+                System.arraycopy(cleanData, 0, buffer, pos, remaining);
+                break;
+            }
+            remaining -= read;
+            pos += read;
+        }
+    }
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordHeader.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordHeader.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,144 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+/**
+ *  The data that comes at the start of a record of data. It stores 
+ *  both the current size and the avaliable size for the record - the latter
+ *  can be bigger than the former, which allows the record to grow without
+ *  needing to be moved and which allows the system to put small records
+ *  in larger free spots.
+ */
+final class RecordHeader {
+    // offsets
+    private static final short O_CURRENTSIZE = 0; // int currentSize
+    private static final short O_AVAILABLESIZE = Magic.SZ_UNSIGNED_SHORT; // int availableSize
+    static final int SIZE = O_AVAILABLESIZE + Magic.SZ_UNSIGNED_SHORT;
+    
+    /**
+     * Maximal differnece between current and available size,
+     * Maximal value is resorved for currentSize 0, so use -1
+     */
+    static final int MAX_SIZE_SPACE = BlockIo.UNSIGNED_SHORT_MAX -1;
+    
+
+    /** Returns the current size */
+    static int getCurrentSize(final BlockIo block, final short pos) {
+    	int s = block.readUnsignedshort(pos + O_CURRENTSIZE);
+    	if(s == BlockIo.UNSIGNED_SHORT_MAX)
+    		return 0;
+        return getAvailableSize(block, pos) - s;
+    }
+    
+    /** Sets the current size */
+    static void setCurrentSize(final BlockIo block, final short pos,int value) {
+    	if(value == 0){
+    		block.writeUnsignedShort(pos + O_CURRENTSIZE, BlockIo.UNSIGNED_SHORT_MAX);
+    		return;
+    	}
+        int availSize = getAvailableSize(block,pos);
+        if(value < (availSize - MAX_SIZE_SPACE) || value>availSize)
+        	throw new IllegalArgumentException("currentSize out of bounds, need to realocate "+value+ " - "+availSize);
+    	block.writeUnsignedShort(pos + O_CURRENTSIZE, availSize - value);
+    }
+    
+    /** Returns the available size */
+    static int getAvailableSize(final BlockIo block, final short pos) {
+        int val  = block.readUnsignedshort(pos + O_AVAILABLESIZE);
+        return deconvert(val);
+    }
+    
+    /** Sets the available size */
+    static void setAvailableSize(final BlockIo block, final short pos,int value) {
+//    	if(value != roundAvailableSize(value))
+//    		throw new IllegalArgumentException("value is not rounded");
+    	int oldCurrSize = getCurrentSize(block,pos);
+        	
+        block.writeUnsignedShort(pos + O_AVAILABLESIZE, convert(value));
+        setCurrentSize(block,pos,oldCurrSize);
+    }
+    
+    private static int convert(final int value){
+    	int multiplyer = 0;
+    	int counter = 0;
+    	if(value<=base1){
+    		multiplyer = 0;
+    		counter = value / multi0;
+    	}else if(value<base2){
+    		multiplyer = 1 <<14;
+    		int val2 = value -base1;
+    		counter = val2/multi1;
+    		if(val2 %multi1 != 0)
+    			counter++;
+    	}else if(value<base3){
+    		multiplyer = 2 <<14;
+    		int val2 = value -base2;
+    		counter = val2/multi2;
+    		if(val2 %multi2 != 0)
+    			counter++;
+    	}else{
+    		multiplyer = 3 <<14;
+    		int val2 = value -base3;
+    		counter = val2/multi3;
+    		if(val2 %multi3 != 0)
+    			counter++;    	
+    	}
+    	if(counter>=(1<<14))
+    		throw new InternalError(""+value);
+    	
+    	return  multiplyer + counter;
+    }
+    
+    private static int deconvert(int val){
+        int multiplier = (val & sizeMask) >>14;
+        int counter = val - (val &sizeMask);
+        switch (multiplier){
+        	case 0: return counter * multi0;
+        	case 1: return base1 + counter * multi1;
+        	case 2: return base2 + counter * multi2;
+        	case 3: return base3 + counter * multi3;
+        	default: throw new InternalError("error deconverting: "+val);
+        }
+    }
+    
+    static final int sizeMask = 1<<15 | 1<<14;
+    static final int multi0 = 1;
+    static final int multi1 = 1<<4;
+    static final int multi2 = 1<<8;
+    static final int multi3 = 1<< 13;  
+
+    
+    static final int base0 = 0;
+    static final int base1 = base0 + multi0 * ((1<<14)-2);
+    static final int base2 = base1 + multi1 * ((1<<14)-2);
+    static final int base3 = base2 + multi2 * ((1<<14)-2);
+    static final int base4 = base3 + multi3 * (1<<14)-2;
+    
+    static final int MAX_RECORD_SIZE = roundAvailableSize(base4 - multi3 * 100);
+    
+    
+    
+    static int roundAvailableSize(int value){
+    	if(value>MAX_RECORD_SIZE && MAX_RECORD_SIZE!=0)    		
+    		new InternalError("Maximal record size ("+MAX_RECORD_SIZE+") exceeded: "+value);
+    	return deconvert(convert(value));
+    }
+    
+
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/TransactionManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/TransactionManager.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,388 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.TreeSet;
+
+import jdbm.helper.Serialization;
+
+/**
+ *  This class manages the transaction log that belongs to every
+ *  {@link RecordFile}. The transaction log is either clean, or
+ *  in progress. In the latter case, the transaction manager
+ *  takes care of a roll forward.
+ *<p>
+ *  Implementation note: this is a proof-of-concept implementation
+ *  which hasn't been optimized for speed. For instance, all sorts
+ *  of streams are created for every transaction.
+ */
+// TODO: Handle the case where we are recovering lg9 and lg0, were we
+// should start with lg9 instead of lg0!
+
+public final class TransactionManager {
+    private RecordFile owner;
+
+    // streams for transaction log.
+    private FileOutputStream fos;
+    private DataOutputStream oos;
+
+    /** 
+     * By default, we keep 10 transactions in the log file before
+     * synchronizing it with the main database file.
+     */
+    static final int DEFAULT_TXNS_IN_LOG = 1;
+
+    /** 
+     * Maximum number of transactions before the log file is
+     * synchronized with the main database file.
+     */
+    private int _maxTxns = DEFAULT_TXNS_IN_LOG;
+
+    /**
+     * In-core copy of transactions. We could read everything back from
+     * the log file, but the RecordFile needs to keep the dirty blocks in
+     * core anyway, so we might as well point to them and spare us a lot
+     * of hassle.
+     */
+    private ArrayList<BlockIo>[] txns = new ArrayList[DEFAULT_TXNS_IN_LOG];
+    private int curTxn = -1;
+
+    /** Extension of a log file. */
+    static final String extension = ".t";
+
+    /**
+     *  Instantiates a transaction manager instance. If recovery
+     *  needs to be performed, it is done.
+     *
+     *  @param owner the RecordFile instance that owns this transaction mgr.
+     */
+    TransactionManager(RecordFile owner) throws IOException {
+        this.owner = owner;
+        recover();
+        open();
+    }
+
+    
+    /**
+     * Synchronize log file data with the main database file.
+     * <p>
+     * After this call, the main database file is guaranteed to be 
+     * consistent and guaranteed to be the only file needed for 
+     * backup purposes.
+     */
+    public void synchronizeLog()
+        throws IOException
+    {
+        synchronizeLogFromMemory();
+    }
+
+    
+    /**
+     * Set the maximum number of transactions to record in
+     * the log (and keep in memory) before the log is
+     * synchronized with the main database file.
+     * <p>
+     * This method must be called while there are no
+     * pending transactions in the log.
+     */
+    public void setMaximumTransactionsInLog( int maxTxns )
+        throws IOException
+    {
+        if ( maxTxns <= 0 ) {
+            throw new IllegalArgumentException( 
+                "Argument 'maxTxns' must be greater than 0." );
+        }
+        if ( curTxn != -1 ) {
+            throw new IllegalStateException( 
+                "Cannot change setting while transactions are pending in the log" );
+        }
+        _maxTxns = maxTxns;
+        txns = new ArrayList[ maxTxns ];
+    }
+
+    
+    /** Builds logfile name  */
+    private String makeLogName() {
+        return owner.getFileName() + extension;
+    }
+
+
+    /** Synchs in-core transactions to data file and opens a fresh log */
+    private void synchronizeLogFromMemory() throws IOException {
+        close();
+
+        TreeSet<BlockIo> blockList = new TreeSet<BlockIo>( new BlockIoComparator() );
+
+        int numBlocks = 0;
+        int writtenBlocks = 0;
+        for (int i = 0; i < _maxTxns; i++) {
+            if (txns[i] == null)
+                continue;
+            // Add each block to the blockList, replacing the old copy of this
+            // block if necessary, thus avoiding writing the same block twice
+            for (Iterator<BlockIo> k = txns[i].iterator(); k.hasNext(); ) {
+                BlockIo block = k.next();
+                if ( blockList.contains( block ) ) {
+                    block.decrementTransactionCount();
+                }
+                else {
+                    writtenBlocks++;
+                    boolean result = blockList.add( block );
+                }
+                numBlocks++;
+            }
+
+            txns[i] = null;
+        }
+        // Write the blocks from the blockList to disk
+        synchronizeBlocks(blockList, true);
+
+        owner.sync();
+        open();
+    }
+
+
+    /** Opens the log file */
+    private void open() throws IOException {
+        
+    	fos = new FileOutputStream(owner.getIndexDirectoryPath()+"/"+makeLogName());
+    	
+        oos = new DataOutputStream(new BufferedOutputStream(fos));
+        oos.writeShort(Magic.LOGFILE_HEADER);
+        oos.flush();
+        curTxn = -1;
+    }
+
+    /** Startup recovery on all files */
+    private void recover() throws IOException {
+        String logName = makeLogName();
+        File logFile = new File(logName);
+        if (!logFile.exists())
+            return;
+        if (logFile.length() == 0) {
+            logFile.delete();
+            return;
+        }
+
+        FileInputStream fis = new FileInputStream(logFile);
+        DataInputStream ois = new DataInputStream(new BufferedInputStream(fis));
+
+        try {
+            if (ois.readShort() != Magic.LOGFILE_HEADER)
+                throw new Error("Bad magic on log file");
+        } catch (IOException e) {
+            // corrupted/empty logfile
+            logFile.delete();
+            return;
+        }
+
+        while (true) {
+            ArrayList<BlockIo> blocks = null;
+            try {
+                blocks = (ArrayList<BlockIo>) Serialization.readObject(ois);
+            } catch (ClassNotFoundException e) {
+                throw new Error("Unexcepted exception: " + e);
+            } catch (IOException e) {
+                // corrupted logfile, ignore rest of transactions
+                break;
+            }
+            synchronizeBlocks(blocks, false);
+
+            // ObjectInputStream must match exactly each
+            // ObjectOutputStream created during writes
+//            try {
+                ois = new DataInputStream(fis);
+//            } catch (IOException e) {
+//                // corrupted logfile, ignore rest of transactions
+//                break;
+//            }
+        }
+        owner.sync();
+        logFile.delete();
+    }
+
+    /** Synchronizes the indicated blocks with the owner. */
+    private void synchronizeBlocks(Iterable<BlockIo> blocks, boolean fromCore)
+    throws IOException {
+        // write block vector elements to the data file.
+        for(BlockIo cur:blocks){
+            owner.synch(cur);
+            if (fromCore) {
+                cur.decrementTransactionCount();
+                if (!cur.isInTransaction()) {
+                    owner.releaseFromTransaction(cur, true);
+                }
+            }
+        }
+    }
+
+
+    /** Set clean flag on the blocks. */
+    private void setClean(ArrayList<BlockIo> blocks)
+    throws IOException {
+        for (BlockIo cur : blocks) {
+            cur.setClean();
+        }
+    }
+
+    /** Discards the indicated blocks and notify the owner. */
+    private void discardBlocks(ArrayList<BlockIo> blocks)
+    throws IOException {
+        for (BlockIo cur:blocks) {
+            
+            cur.decrementTransactionCount();
+            if (!cur.isInTransaction()) {
+                owner.releaseFromTransaction(cur, false);
+            }
+        }
+    }
+
+    /**
+     *  Starts a transaction. This can block if all slots have been filled
+     *  with full transactions, waiting for the synchronization thread to
+     *  clean out slots.
+     */
+    void start() throws IOException {
+        curTxn++;
+        if (curTxn == _maxTxns) {
+            synchronizeLogFromMemory();
+            curTxn = 0;
+        }
+        txns[curTxn] = new ArrayList();
+    }
+
+    /**
+     *  Indicates the block is part of the transaction.
+     */
+    void add(BlockIo block) throws IOException {
+        block.incrementTransactionCount();
+        txns[curTxn].add(block);
+    }
+
+    /**
+     *  Commits the transaction to the log file.
+     */
+    void commit() throws IOException {
+    	Serialization.writeObject(oos, txns[curTxn]);
+        sync();
+
+        // set clean flag to indicate blocks have been written to log
+        setClean(txns[curTxn]);
+
+        // open a new ObjectOutputStream in order to store
+        // newer states of BlockIo
+        oos = new DataOutputStream(new BufferedOutputStream(fos));
+    }
+
+    /** Flushes and syncs */
+    private void sync() throws IOException {
+        oos.flush();
+        fos.flush();
+        fos.getFD().sync();
+    }
+
+    /**
+     *  Shutdowns the transaction manager. Resynchronizes outstanding
+     *  logs.
+     */
+    void shutdown() throws IOException {
+        synchronizeLogFromMemory();
+        close();
+    }
+
+    /**
+     *  Closes open files.
+     */
+    private void close() throws IOException {
+        sync();
+        oos.close();
+        fos.close();
+        oos = null;
+        fos = null;
+    }
+
+    /**
+     * Force closing the file without synchronizing pending transaction data.
+     * Used for testing purposes only.
+     */
+    void forceClose() throws IOException {
+        oos.close();
+        fos.close();
+        oos = null;
+        fos = null;
+    }
+
+    /**
+     * Use the disk-based transaction log to synchronize the data file.
+     * Outstanding memory logs are discarded because they are believed
+     * to be inconsistent.
+     */
+    void synchronizeLogFromDisk() throws IOException {
+        close();
+
+        for ( int i=0; i < _maxTxns; i++ ) {
+            if (txns[i] == null)
+                continue;
+            discardBlocks(txns[i]);
+            txns[i] = null;
+        }
+
+        recover();
+        open();
+    }
+
+
+    /** INNER CLASS.
+     *  Comparator class for use by the tree set used to store the blocks
+     *  to write for this transaction.  The BlockIo objects are ordered by
+     *  their blockIds.
+     */
+    public static class BlockIoComparator
+        implements Comparator<BlockIo>
+    {
+
+        public int compare( BlockIo block1, BlockIo block2 ) {
+
+            if ( block1.getBlockId() == block2.getBlockId() ) {
+            	return 0;
+            }
+            else if ( block1.getBlockId() < block2.getBlockId() ) {
+                return -1;
+            }
+            else {
+                return 1;
+            }
+        }
+
+        public boolean equals(Object obj) {
+            return super.equals(obj);
+        }
+    } // class BlockIOComparator
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/TranslationPage.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/TranslationPage.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,61 @@
+/*******************************************************************************
+ * Copyright 2010 Cees De Groot, Alex Boisvert, Jan Kotek
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+
+
+package jdbm.recman;
+
+/**
+ *  Class describing a page that holds translations from physical rowids
+ *  to logical rowids. In fact, the page just holds physical rowids - the
+ *  page's block is the block for the logical rowid, the offset serve
+ *  as offset for the rowids.
+ */
+final class TranslationPage extends PageHeader {
+    // offsets
+    static final short O_TRANS = PageHeader.SIZE; // short count
+    
+    
+//    // slots we returned.
+//    final PhysicalRowId[] slots = new PhysicalRowId[ELEMS_PER_PAGE];
+
+    /**
+     *  Constructs a data page view from the indicated block.
+     */
+    TranslationPage(BlockIo block, int blockSize) {
+        super(block);
+        
+    }
+
+    /**
+     *  Factory method to create or return a data page for the
+     *  indicated block.
+     */
+    static TranslationPage getTranslationPageView(BlockIo block, int blockSize) {
+        BlockView view = block.getView();
+        if (view != null && view instanceof TranslationPage)
+            return (TranslationPage) view;
+        else
+            return new TranslationPage(block, blockSize);
+    }
+
+//    /** Returns the value of the indicated rowid on the page */
+//    short get(short offset) {
+//        int slot = (offset - O_TRANS) / PhysicalRowId.SIZE;
+//        if (slots[slot] == null) 
+//            slots[slot] = new PhysicalRowId(block, offset);
+//        return slots[slot];
+//    }
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/package.html
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/package.html	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,85 @@
+<!-- $Id: package.html,v 1.1 2001/05/19 16:01:33 boisvert Exp $ -->
+<html>
+  <body>
+    <p>Core classes for managing persistent objects and processing transactions.</p>
+
+	<h1>Memory allocation</h1>
+	This document describes the memory allocation structures and
+algorithms used by jdbm.  It is based on a thread in the
+jdbm-developers mailing list.
+<p/>
+<ul>
+<li> A block is a fixed length of bytes.  Also known as a page.
+<li> A row is a variable length of bytes.  Also known as a record.
+<li> A slot is a fixed length entry in a given block/page.
+<li> A page list is a linked list of pages.  The head and tail of each
+  page list is maintained in the file header.
+</ul>
+Jdbm knows about a few page lists which are pre-defined in Magic,
+e.g., Magic.USED_PAGE.  The FREE, USED, TRANSLATION, FREELOGIDS, and
+FREEPHYSIDS page lists are used by the jdbm memory allocation policy
+and are described below.
+<p/>
+The translation list consists of a bunch of slots that can be
+available (free) or unavailable (allocated).  If a slot is available,
+then it contains junk data (it is available to map the logical row id
+associated with that slot to some physical row id).  If it is
+unavailable, then it contains the block id and offset of the header of
+a valid (non-deleted) record.  "Available" for the translation list
+is marked by a zero block id for that slot.
+<p/>
+The free logical row id list consists of a set of pages that contain
+slots.  Each slot is either available (free) or unavailable
+(allocated).  If it is unavailable, then it contains a reference to
+the location of the available slot in the translation list.  If it is
+available, then it contains junk data. "Available" slots are marked by
+a zero block id.  A count is maintained of the #of available slots
+(free row ids) on the page.
+<p/>
+As you free a logical row id, you change it's slot in the translation
+list from unavailable to available, and then *add* entries to the free
+logical row list.  Adding entries to the free logical row list is done
+by finding an available slot in the free logical row list and
+replacing the junk data in that slot with the location of the now
+available slot in the translation list.  A count is maintained of the
+#of available slots (free row ids) on the page.
+ <p/>
+Whew... now we've freed a logical row id.  But what about the physical
+row id?
+<p/> 
+Well, the free physical row id list consists of a set of pages that
+contain slots.  Each slot is either available (free) or unavailable
+(allocated).  If it is unavailable, then it contains a reference to
+the location of the newly freed row's header in the data page.  If it
+is available, then it contains junk data.  "Available" slots are
+marked by a zero block id.  A count is maintained of the #of available
+slots (free row ids) on the page. (Sound familiar?)
+<p/> 
+As you free a physical row id, you change it's header in the data page
+from inuse to free (by zeroing the size field of the record header),
+and then *add* an entry to the free physical row list.  Adding entries
+to the free physical row list consists of finding an available slot,
+and replacing the junk data in that slot with the location of the
+newly freed row's header in the data page.
+<p/>
+The translation list is used for translating in-use logical row ids
+to in-use physical row ids.  When a physical row id is freed, it is
+removed from the translation list and added to the free physical row
+id list.
+<p/> 
+This allows a complete decoupling of the logical row id from the
+physical row id, which makes it super easy to do some of the fiddling
+I'm talking about the coallescing and splitting records.
+<p/> 
+If you want to get a list of the free records, just enumerate the
+unavailable entries in the free physical row id list.  You don't even
+need to look up the record header because the length of the record is
+also stored in the free physical row id list.  As you enumerate the
+list, be sure to not include slots that are available (in the current
+incarnation of jdbm, I believe the available length is set to 0 to
+indicate available - we'll be changing that some time soon here, I'm
+sure).
+<p/>	
+
+  </body>
+</html>

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java	Sat Aug 20 08:24:59 2011	(r23230)
@@ -0,0 +1,45 @@
+/**
+ * 
+ */
+package org.spoofax.interpreter.library.language.spxlang;
+
+import static org.spoofax.interpreter.core.Tools.asJavaString;
+import static org.spoofax.interpreter.core.Tools.isTermAppl;
+import static org.spoofax.interpreter.core.Tools.isTermString;
+
+import java.net.URI;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.language.SemanticIndex;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author adil
+ *
+ */
+public class SPX_index_add_module extends AbstractPrimitive {
+
+	private static String NAME = "SPX_index_add_module";
+	
+	private final SemanticIndex index;
+	
+	public SPX_index_add_module(SemanticIndex index) {
+		super(NAME, 0, 0);
+		this.index = index;
+	}
+
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
+		if (isTermAppl(tvars[0]) && isTermString(tvars[1])) {
+			IStrategoAppl entry = (IStrategoAppl) tvars[0];
+			URI file = index.toFileURI(asJavaString(tvars[1]));
+			index.add(entry, file);
+			return true;
+		} else {
+			return false;
+		}
+	}
+}
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Sat Aug 20 10:27:31 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sat, 20 Aug 2011 08:27:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23231 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test
Message-ID: <20110820082731.B9AEB7F8003@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Sat Aug 20 08:27:31 2011
New Revision: 23231
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23231&sc=1

Log:
- JDBM Tests. demonstrating inverse view and secondary view of Map to be using in SPX index.

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld2.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HugeData.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/Persons1.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/Persons2.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/TestHashmap.java

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java	Sat Aug 20 08:27:31 2011	(r23231)
@@ -0,0 +1,92 @@
+package jdbm.test;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+
+import jdbm.PrimaryHashMap;
+import jdbm.PrimaryTreeMap;
+import jdbm.RecordManager;
+import jdbm.RecordManagerFactory;
+
+/**
+ * This program demonstrates basic JDBM usage.
+ * 
+ * @author Jan Kotek
+ *
+ */
+public class HelloWorld {
+	
+	public static void put( Map<Integer,LinkedList<String>> hashmap , int key, String value )
+	{
+		if (hashmap.containsKey(key))
+		{
+			hashmap.get(key).add(value);
+		}		
+		else
+		{
+			LinkedList<String> l = new LinkedList<String>();
+			l.add(value);
+			
+			hashmap.put(key, l);
+		}
+	}
+	
+	public static void main(String[] args) throws IOException {
+
+		/** create (or open existing) database */
+		String fileName = "helloWorld2";
+		RecordManager recMan = RecordManagerFactory.createRecordManager(fileName);
+		
+		/** Creates TreeMap which stores data in database.  
+		 *  Constructor method takes recordName (something like SQL table name)*/
+		String recordName = "firstTreeMap2";
+		Map<Integer,LinkedList<String>> hashmap = recMan.hashMap(recordName); 
+
+		hashmap.clear();
+		
+		recMan.commit();
+		
+		/** add some stuff to map*/
+		put(hashmap, 1, "One");
+		put(hashmap, 1, "Test");
+		put(hashmap, 2, "Two");
+		put(hashmap, 3, "Three");
+		put(hashmap, 3, "Four");
+		put(hashmap, 3, "Five");
+		
+		System.out.println(hashmap.keySet());
+		System.out.println(hashmap.values());
+		// > [1, 2, 3]
+		
+		/** Map changes are not persisted yet, commit them (save to disk) */
+		recMan.commit();
+		System.out.println("After committing: ");	
+		System.out.println(hashmap.keySet());
+		// > [1, 2, 3]
+
+		/** Delete one record. Changes are not commited yet, but are visible. */
+		hashmap.remove(2);
+		System.out.println("After removing 2: ");	
+		System.out.println(hashmap.keySet());
+		// > [1, 3]
+		
+		/** Did not like change. Roolback to last commit (undo record remove). */
+		recMan.rollback();
+		
+		System.out.println("After rollback: ");
+		/** Key 2 was recovered */
+		System.out.println(hashmap.keySet());
+		// > [1, 2, 3]
+		
+		/** close record manager */
+		recMan.close();
+		
+		
+	}
+	
+	
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld2.java	Sat Aug 20 08:27:31 2011	(r23231)
@@ -0,0 +1,153 @@
+package jdbm.test;
+import java.io.IOException;
+import java.io.Serializable;
+
+import jdbm.PrimaryStoreMap;
+import jdbm.RecordManager;
+import jdbm.RecordManagerFactory;
+import jdbm.SecondaryKeyExtractor;
+import jdbm.SecondaryTreeMap;
+
+
+/**
+ * More advanced example to demonstrate Map usage.
+ * 
+ * @author Jan Kotek
+ *
+ */
+public class HelloWorld2 {
+
+	static class Person implements Serializable{
+		
+		/** never forget this, very important for serialization*/
+		private static final long serialVersionUID = -3321252970661193623L;
+		final String name;		
+		final String town;
+		final String country;
+		
+		/** some data to object class bigger */
+		final byte[] balast = new byte[1024];
+
+		public Person(String name, String town, String country) {
+			this.name = name;
+			this.town = town;
+			this.country = country;			
+		}
+
+		@Override
+		public String toString() {
+			return "Person [name=" + name + ", town=" + town + ", country=" + country + "]";
+		}
+				
+		/** snip getters and setters*/
+		
+	}
+	
+
+	
+	public static void main(String[] args) throws IOException {
+		RecordManager recman = RecordManagerFactory.
+				createRecordManager("HelloWorld2");
+		/**
+		 * Create primary map which is used to store records.  
+		 * Data can be also stored in PrimaryTreeMap and PrimaryHashMap,
+		 * but this is more efficient for large objects. 
+		 */
+		PrimaryStoreMap<Long,Person> main = recman.storeMap("recman");
+		
+		/**
+		 * Create secondary index which points to Person name.
+		 * SecondaryMap is readonly, it is updated by PrimaryMap.
+		 *  
+		 * Secondary map have three types, 
+		 * first is type of secondary index (string),
+		 * second and third are copied from primary map.
+		 */
+		SecondaryTreeMap<String, Long, Person> nameIndex = main.secondaryTreeMap("nameIndex",
+						new SecondaryKeyExtractor<String, Long, Person>() {
+							public String extractSecondaryKey(Long key, Person value) {
+								return value.name;
+							}					
+						});
+		
+		/**
+		 * Another secondary map which points to town and country
+		 */
+		SecondaryTreeMap<String, Long, Person> townIndex = main.secondaryTreeMap("townIndex",
+				new SecondaryKeyExtractor<String, Long, Person>() {
+					public String extractSecondaryKey(Long key, Person value) {
+						/**
+						 * Note format of map key
+						 */
+						return value.country+"/"+value.town;
+					}					
+				});
+		
+		/**
+		 * And very simple index of Evil family members
+		 */
+		SecondaryTreeMap<Boolean, Long, Person> evilIndex = main.secondaryTreeMap("evilIndex",
+				new SecondaryKeyExtractor<Boolean, Long, Person>() {
+					public Boolean extractSecondaryKey(Long key, Person value) {
+						return value.name.contains("Evil");
+					}					
+				});
+		
+		/**
+		 * Clean up, if this example was run more times.
+		 * All secondary indexes are updated automatically. 
+		 */
+		main.clear();
+		
+		
+		/** 
+		 * Add some data. 
+		 * StoreMap does not have usuall 'put' method.
+		 * Key is generated by Store, so use 'putValue' instead 
+		 */
+		main.putValue(new Person("James Bond","London","UK"));
+		main.putValue(new Person("Austin Powers","London","UK"));
+		main.putValue(new Person("Dr Evil","Vulcano Island","Ocean"));
+		main.putValue(new Person("Scott Evil","Vulcano Island","Ocean"));		
+		main.putValue(new Person("Vanessa Kensington","London","UK"));
+		main.putValue(new Person("Alotta Fagina","Las Vegas","USA"));
+				
+		/**
+		 * Persists inserted values
+		 */
+		recman.commit();
+		
+		/**
+		 * Get persons with name Austin Powers
+		 */
+		System.out.println();
+		System.out.println("Austin Powers: ");
+		for(Person person:nameIndex.getPrimaryValues("Austin Powers")){
+			System.out.println("  "+person);
+		}
+		
+		/**
+		 * Print all Persons who lives on Vulcano Island.
+		 * First we must obtain key from primary map,
+		 * then 
+		 */
+		System.out.println();
+		System.out.println("Persons on Vulcano Island: ");
+		for(Person person:townIndex.getPrimaryValues("Ocean/Vulcano Island")){
+			System.out.println("  "+person);
+		}
+		
+
+		/**
+		 * Get everyone who is Evil
+		 */
+		System.out.println();
+		System.out.println("Evil family: ");
+		for(Person person:evilIndex.getPrimaryValues(true)){
+			System.out.println("  "+person);
+		}		
+		
+		recman.close();
+	}
+}
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HugeData.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HugeData.java	Sat Aug 20 08:27:31 2011	(r23231)
@@ -0,0 +1,40 @@
+package jdbm.test;
+import java.io.IOException;
+
+import jdbm.PrimaryTreeMap;
+import jdbm.RecordManager;
+import jdbm.RecordManagerFactory;
+
+
+/** 
+ * 
+ * This examples generates huge map of data. 
+ * It inserts 10 000 000 records, it takes about 10 minutes to finish. 
+ * 
+ * @author Jan Kotek
+ *
+ */
+public class HugeData {
+	public static void main(String[] args) throws IOException {
+
+		/** open db */
+        RecordManager recman = RecordManagerFactory.createRecordManager( "hugedata");        
+        PrimaryTreeMap<Long, String> m = recman.treeMap("hugemap");
+        
+        /** insert 1e7 records */
+        for(long i = 0;i<1e8;i++){
+        	m.put(i, "aa"+i);        
+        	if(i%1e5==0){
+        		/** Commit periodically, otherwise program would run out of memory */         		 
+        		recman.commit();
+        		System.out.println(i);        		
+        	}
+        		
+        }
+        
+        recman.commit();
+        recman.close();
+        System.out.println("DONE");
+        
+	}
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/Persons1.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/Persons1.java	Sat Aug 20 08:27:31 2011	(r23231)
@@ -0,0 +1,123 @@
+package jdbm.test;
+import java.io.IOException;
+import java.io.Serializable;
+
+import jdbm.PrimaryTreeMap;
+import jdbm.RecordManager;
+import jdbm.RecordManagerFactory;
+import jdbm.SecondaryKeyExtractor;
+import jdbm.SecondaryTreeMap;
+
+
+/**
+ * Demonstrates more advanced usage of JDBM:
+ * Secondary maps, 1:N relations.
+ * 
+ * @author Jan Kotek
+ *
+ */
+public class Persons1 {
+
+	static class Person implements Serializable{
+		/** field used for person identification (primary key)**/
+		String name;
+		/** persisted with Person (embedded field in JPA terms) **/
+		Address adress;
+		/** N:1 relation */
+		String fatherName;
+		
+		/** constructor, getters and setters are excluded for simplicity */
+		public Person(String name, Address adress,String fatherName) {
+			super();
+			this.name = name;
+			this.adress = adress;
+			this.fatherName = fatherName;
+		}
+
+		public String toString(){
+			return "Person["+name+"]";
+		}
+		
+		public int hashCode() {
+			return name == null? 0 : name.hashCode();
+		}
+
+
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null || !(obj instanceof Person))
+				return false;
+			Person other = (Person) obj;
+			if (name == null) {
+				if (other.name != null)
+					return false;
+			} else if (!name.equals(other.name))
+				return false;
+			return true;
+		}
+	
+		
+		
+	}
+	
+	static class Address implements Serializable{
+		String streetName;
+		String town;
+		String country;
+		
+		public Address(String streetName, String town, String country) {
+			super();
+			this.streetName = streetName;
+			this.town = town;
+			this.country = country;
+		}
+		
+		
+	}
+		
+	public static void main(String[] args) throws IOException {
+		//init Record Manager and dao
+		RecordManager recman = RecordManagerFactory.createRecordManager("persons1");
+
+		PrimaryTreeMap<String,Person> personsByName = recman.treeMap("personsByName");
+
+		SecondaryTreeMap<String, String, Person> personsByTown = 
+				personsByName.secondaryTreeMap("personsByTown", 
+						new SecondaryKeyExtractor<String, String, Person>() {
+							public String extractSecondaryKey(String key,Person value) {
+								return value.adress.town;
+							}
+						});
+
+		
+		//create a few persons
+		Person patrick = new Person("Patrick Moore", 
+				new Address("First street", "Athlone","Ireland"),
+				null);
+		personsByName.put(patrick.name, patrick);
+
+		Person jack = new Person("Jack Moore", 
+				new Address("First street", "Athlone","Ireland"),
+				patrick.name);	
+		personsByName.put(jack.name, jack);
+
+		Person paul = new Person("Paul Moore", 
+				new Address("Shop street", "Galway","Ireland"),
+				patrick.name);
+		personsByName.put(paul.name, paul	);
+
+		
+					
+		System.out.println("Number of persons: "+personsByName.size());
+		
+		System.out.println("Persons with name Patrick Moore: "+personsByName.get("Patrick Moore"));
+		System.out.println("Name of persons living in Galway: "+personsByTown.get("Galway"));
+		System.out.println("Father of Paul Moore: "+
+				personsByName.get(
+						personsByName.get("Paul Moore").fatherName
+					));
+
+	}
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/Persons2.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/Persons2.java	Sat Aug 20 08:27:31 2011	(r23231)
@@ -0,0 +1,230 @@
+package jdbm.test;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import jdbm.InverseHashView;
+import jdbm.PrimaryStoreMap;
+import jdbm.RecordManager;
+import jdbm.RecordManagerFactory;
+import jdbm.SecondaryKeyExtractor;
+import jdbm.SecondaryTreeMap;
+import jdbm.Serializer;
+import jdbm.SerializerInput;
+import jdbm.SerializerOutput;
+import jdbm.helper.Serialization;
+
+
+/**
+ * Demonstrates more advanced usage of JDBM:
+ * Secondary maps, 1:N relations.
+ * 
+ * @author Jan Kotek
+ *
+ */
+public class Persons2 {
+
+	static class Person implements Serializable{
+		/** field used for person identification (primary key)**/
+		String name;
+		/** persisted with Person (embedded field in JPA terms) **/
+		Address adress;
+		/** N:1 relation */
+		Person father;
+		
+		/** constructor, getters and setters are excluded for simplicity */
+		public Person(String name, Address adress,Person father) {
+			super();
+			this.name = name;
+			this.adress = adress;
+			this.father = father;
+		}
+
+		public String toString(){
+			return "Person["+name+"]";
+		}
+		
+		public int hashCode() {
+			return name == null? 0 : name.hashCode();
+		}
+
+
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null || !(obj instanceof Person))
+				return false;
+			Person other = (Person) obj;
+			if (name == null) {
+				if (other.name != null)
+					return false;
+			} else if (!name.equals(other.name))
+				return false;
+			return true;
+		}
+	
+		
+		
+	}
+	
+	static class Address implements Serializable{
+		String streetName;
+		String town;
+		String country;
+		
+		public Address(String streetName, String town, String country) {
+			super();
+			this.streetName = streetName;
+			this.town = town;
+			this.country = country;
+		}
+		
+		
+	}
+	
+	/** dao object which handles Person persistence */
+	static class PersonDao implements Serializer<Person>{
+		
+		/** 
+		 * This is map in which persons are inserted in. 
+		 * Key is number assigned by store (recordId). 
+		 * You should prefer recordId as primary index, it is more flexible.   
+		 */
+		PrimaryStoreMap<Long,Person> persons;
+		
+		/** Inverse view on person, it helps to find recordId which belongs to person */
+		InverseHashView<	Long, Person> personsInverse;
+		
+		/** 
+		 * Secondary view on persons, which identifies person by name. 
+		 * This map is readonly, it is autoupdated by JDBM as primary map changes. 
+		 * Key is name, value is recordId ( key from primary map), 
+		 * third parameter is Person (value from primary map)
+		 */
+		SecondaryTreeMap<String, Long, Person> personsByName;
+
+		/** 
+		 * Secondary view on persons, which identifies person its town 
+		 * This map is readonly, it is autoupdated by JDBM as primary map changes. 
+		 * Key is town name extracted from primary table, 
+		 * value is recordId ( key from primary map), 
+		 * third parameter is town from  (value from primary map) 
+		 */
+		SecondaryTreeMap<String, Long, Person> personsByTown;
+		
+		
+		public PersonDao(RecordManager recman) {
+			persons = recman.storeMap("persons",this);
+			personsInverse = persons.inverseHashView("personsInverse");
+			personsByName = persons.secondaryTreeMap("personsByName",
+						new SecondaryKeyExtractor<String, Long, Person>() {
+							public String extractSecondaryKey(Long key, Person value) {
+								return value.name;
+							}});
+			personsByTown = persons.secondaryTreeMap("personsByTown",
+						new SecondaryKeyExtractor<String, Long, Person>() {
+							public String extractSecondaryKey(Long key, Person value) {
+								if(value.adress == null)
+									return null;
+								return value.adress.town;
+							}});
+			
+		}
+		
+		public Person personByRecordId(Long recid){
+			return persons.get(recid);
+		}
+
+		public Person personByName(String name){
+			if(!personsByName.containsKey(name))
+				return null;
+			Iterator<Long> iter = personsByName.get(name).iterator();
+			if(iter.hasNext())
+				return personsByName.getPrimaryValue(iter.next());
+			else 
+				return null;
+		}
+		
+		public Iterable<Person> personsByTown(String name){
+			List<Person> ret = new ArrayList<Person>(); 
+			for(Long l: personsByTown.get(name)){
+				ret.add(personsByTown.getPrimaryValue(l));
+			}
+			return ret;
+		}
+
+		
+		public void insertPerson(Person person){
+			Long recid = personsInverse.findKeyForValue(person);
+			if(recid == null)
+				persons.putValue(person);
+			else
+				persons.put(recid, person);
+		}
+
+		public Person deserialize(SerializerInput in) throws IOException, ClassNotFoundException {
+			String name = in.readObject();
+			Address address = in.readObject();
+			Person father = persons.get(in.readObject());
+			Person p = new Person(name,address,father);			
+			
+			return p;
+		}
+
+		public void serialize(SerializerOutput out, Person obj)
+				throws IOException {
+			out.writeObject(obj.name);
+			out.writeObject(obj.adress);
+			out.writeObject(findOrPersistPerson(obj.father));
+		}
+		
+		protected Long findOrPersistPerson(Person person){
+			if(person == null)
+				return null;
+			Long recid = personsInverse.findKeyForValue(person);
+			if(recid == null)
+				recid = persons.putValue(person);
+			return recid;
+		}
+
+	}
+	
+	public static void main(String[] args) throws IOException {
+		//init Record Manager and dao
+		RecordManager recman = RecordManagerFactory.createRecordManager("persons2");
+		PersonDao dao = new PersonDao(recman);
+		
+		//create a few persons
+		Person patrick = new Person("Patrick Moore", 
+				new Address("First street", "Athlone","Ireland"),
+				null);
+
+		Person jack = new Person("Jack Moore", 
+				new Address("First street", "Athlone","Ireland"),
+				patrick);
+		
+
+		Person paul = new Person("Paul Moore", 
+				new Address("Shop street", "Galway","Ireland"),
+				patrick);
+
+		
+		
+		//now store all this stuff		
+		dao.insertPerson(jack);
+		dao.insertPerson(patrick);
+		dao.insertPerson(paul);
+				
+		System.out.println("Number of persons: "+dao.persons.size());
+		
+		System.out.println("Persons with name Patrick Moore: "+dao.personByName("Patrick Moore"));
+		System.out.println("Persons living in Galway: "+dao.personsByTown("Galway"));
+		System.out.println("Father of Paul Moore: "+dao.personByName("Paul Moore").father);
+
+	}
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/TestHashmap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/TestHashmap.java	Sat Aug 20 08:27:31 2011	(r23231)
@@ -0,0 +1,20 @@
+package jdbm.test;
+/**
+ * 
+ */
+
+/**
+ * @author adil
+ *
+ */
+public class TestHashmap {
+
+	/**
+	 * @param args
+	 */
+	public static void main(String[] args) {
+		// TODO Auto-generated method stub
+
+	}
+
+}

From M.A.Akhter at student.tudelft.nl  Sat Aug 20 10:49:15 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sat, 20 Aug 2011 08:49:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23232 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm:
	. recman test
Message-ID: <20110820084915.6684F2B8011@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Sat Aug 20 08:49:15 2011
New Revision: 23232
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23232&sc=1

Log:
added documentation

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BaseRecordManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordFile.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java	Sat Aug 20 08:27:31 2011	(r23231)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java	Sat Aug 20 08:49:15 2011	(r23232)
@@ -29,9 +29,14 @@
  * 
  * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
  * @author <a href="cg at cdegroot.com">Cees de Groot</a>
- * @version $Id: RecordManagerFactory.java,v 1.2 2005/06/25 23:12:31 doomdark
- *          Exp $
+ * @author <a href="adil.bd at hotmail.com">Adil Akhter</a>
+ * @version $Id: RecordManagerFactory.java,v 1.3 2011/08/19 06:33:20 $
+ *
+ *	Modified by : Adil Akhter
+ *	Configuring the RecordManger with the relative path of the index.  
+ *
  */
+
 public final class RecordManagerFactory {
 
 	/**

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java	Sat Aug 20 08:27:31 2011	(r23231)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java	Sat Aug 20 08:49:15 2011	(r23232)
@@ -21,7 +21,13 @@
  *
  * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
  * @author <a href="cg at cdegroot.com">Cees de Groot</a>
- * @version $Id: RecordManagerOptions.java,v 1.1 2002/05/31 06:33:20 boisvert Exp $
+ * @author <a href="adil.bd at hotmail.com">Adil Akhter</a>
+ * @version $Id: RecordManagerOptions.java,v 1.1 2011/08/19 06:33:20 $
+ *
+ *	Modified by : Adil Akhter
+ *
+ *	Added the following option : INDEX_DIRECTORY_RELATIVE_PATH to configure the relative path of the directory where
+ *	all the index will be stored.
  */
 public class RecordManagerOptions
 {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BaseRecordManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BaseRecordManager.java	Sat Aug 20 08:27:31 2011	(r23231)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/BaseRecordManager.java	Sat Aug 20 08:49:15 2011	(r23232)
@@ -62,7 +62,11 @@
  *
  * @author <a href="mailto:boisvert at intalio.com">Alex Boisvert</a>
  * @author <a href="cg at cdegroot.com">Cees de Groot</a>
+ * @author <a href="mailto:adil.bd at hotmail.com">Adil Akhter</a>
  * @version $Id: BaseRecordManager.java,v 1.8 2005/06/25 23:12:32 doomdark Exp $
+ * 
+ * Updates : New Parameter is added for refer to the directory of the index relative 
+ * to the current working directory.  RecordFile is configured with this extra parameter. 
  */
 public final class BaseRecordManager
     extends RecordManagerImpl

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordFile.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordFile.java	Sat Aug 20 08:27:31 2011	(r23231)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/recman/RecordFile.java	Sat Aug 20 08:49:15 2011	(r23232)
@@ -38,7 +38,12 @@
  *  The set of dirty records on the in-use list constitutes a transaction.
  *  Later on, we will send these records to some recovery thingy.
  *<p>
- *  RecordFile is splited between more files, each with max size 1GB. 
+ *  RecordFile is splited between more files, each with max size 1GB.
+ *  <P>
+ *  Updates : RecordFile can be configured with the relative path where
+ *  the files are stored. By default it is specified statically using 
+ *  RecordManager.DEFAULT_RELATIVE_PATH_INDEX.
+ *  </p> 
  */
 final class RecordFile {
     final TransactionManager txnMgr;
@@ -72,11 +77,7 @@
     
     private String indexDirRelativePath ; 
     
-    
-    
-  
-
-	static final int DEFAULT_BLOCK_SIZE = 4096;
+    static final int DEFAULT_BLOCK_SIZE = 4096;
 
 //    /** The length of a single block. */
     final int BLOCK_SIZE ;//= 8192;//4096;

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java	Sat Aug 20 08:27:31 2011	(r23231)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java	Sat Aug 20 08:49:15 2011	(r23232)
@@ -2,20 +2,16 @@
 
 import java.io.IOException;
 import java.util.LinkedList;
-import java.util.List;
 import java.util.Map;
 
-
-import jdbm.PrimaryHashMap;
-import jdbm.PrimaryTreeMap;
 import jdbm.RecordManager;
 import jdbm.RecordManagerFactory;
 
-/**
- * This program demonstrates basic JDBM usage.
+ /**
+ * This program demonstrates basic JDBM usage. Updated to support separate-chaining using PrimaryMap.
  * 
  * @author Jan Kotek
- *
+ * @author Adil Akhter
  */
 public class HelloWorld {
 	

From m.dejonge at tudelft.nl  Mon Aug 22 10:03:04 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 22 Aug 2011 08:03:04 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23233 -
	sglr-recovery/trunk/permissive-grammars/trans/make-permissive
Message-ID: <20110822080304.B662DCC063@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 22 08:03:03 2011
New Revision: 23233
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23233&sc=1

Log:
Fix: WATERTOKENSTART get an unintended ~

Modified:
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr
==============================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr	Sat Aug 20 08:49:15 2011	(r23232)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/water-sections.astr	Mon Aug 22 08:03:03 2011	(r23233)
@@ -14,7 +14,7 @@
          WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR
        
        lexical syntax
-         ~%% Water-based recovery rule set-up
+         %% Water-based recovery rule set-up
          [A-Za-z0-9\_]                  -> WATERTOKENSTART     {recover, avoid}
          WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN
          ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}

From m.dejonge at tudelft.nl  Mon Aug 22 13:36:23 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 22 Aug 2011 11:36:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23234 -
	sglr-recovery/completion-rules
Message-ID: <20110822113623.BA7E3CC06F@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 22 11:36:23 2011
New Revision: 23234
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23234&sc=1

Log:


Modified:
   sglr-recovery/completion-rules/generate-completion-rules.str

Modified: sglr-recovery/completion-rules/generate-completion-rules.str
==============================================================================
--- sglr-recovery/completion-rules/generate-completion-rules.str	Mon Aug 22 08:03:03 2011	(r23233)
+++ sglr-recovery/completion-rules/generate-completion-rules.str	Mon Aug 22 11:36:23 2011	(r23234)
@@ -1,323 +1,284 @@
 module generate-completion-rules
 
 imports
-  include/SDF
-  libstratego-gpp
+  SDF
+  libstratego-sdf
+  SDF-parenthesize
+  sdf-desugar
 
-rules //pretty-printed rules
 
-/*generate rules inclusive DUMMY productions*/
-generate-completion-rules-pp=      	  
-	generate-completion-rules;
-	pp-sdf-productions
-
-/*generate rules that preserve AST structure*/
-generate-wellformed-completion-rules-pp=      	  
-	generate-completion-rules(wellformed);
-	pp-sdf-productions
+rules //extend grammar with completion rules
 
-/*generate rules exclusive completions by inserting literals at the end
- * (which are (in most cases) already covered by INSERT recover rules)
- */
-generate-sort-completion-rules-pp=      	  
-	generate-completion-rules(sort-inserting);
-	pp-sdf-productions
-
-/*generate rules that preserve AST structure and insert a sort*/
-generate-wellformed-sort-completion-rules-pp=      	  
-	generate-completion-rules(wellformed; sort-inserting);
-	pp-sdf-productions
-
-pp-sdf-productions=
-      	  map(try(pp-sdf))
-      	; separate-by(|"\n") 
-      	; concat-strings
-
-pp-sdf =
-    ast2abox(|[<import-term(include/SDF.pp.af)>,
-               <import-term(include/SDF.generated.pp.af)>]);
-    box2text-string(|250)
-
-rules //main strategy
-
-sort-inserting=
-	where(has-custom-ast-attr)
-
-wellformed=
-	where(
-		not(
-			oncetd(?appl(unquoted("ast"), [fun(quoted(ast-string))]));
-			<is-substring(dummy-string)> ast-string
-		)
-	)
+generate-completion-grammar-top:
+	ast -> ast'
+	where
+		<store-placeholders-top> ast;
+		ast' := <
+			alltd(add-completion-syntax);
+			alltd(flatten-list)
+		> ast
 
-generate-completion-rules(prod-filter)= //TODO: save, unsave, no-lit-only
-	generate-completion-rules;
-	filter(prod-filter) //only
-		
+add-completion-syntax:
+	context-free-syntax(cf-prods) -> [context-free-syntax(cf-prods), context-free-syntax(completion-prods)]
+	where
+		completion-prods := <generate-completion-productions> cf-prods
 
-/**
- * creates recover rules based on prefixes of the lhs
- * - all prefixes that end on a sort term
- * - closing-braces literals in (removed) suffix are made optional 
- * because they may be inserted automatically by the editor
- */	
-generate-completion-rules=
-	?ast;
-	<collect-default-dummies> ast;
-	prods:=<get-cf-productions> ast;
-	recover-prods:=<
-		map(create-completion-productions); 
-		flatten-list
-	> prods;
-	<remove-superfluous-prods> (recover-prods, prods)
+generate-completion-productions-top:
+	ast -> completion-productions
+	where
+		<store-placeholders-top> ast;
+		cf-prods := <get-cf-productions> ast;
+		completion-productions := <generate-completion-productions> cf-prods
 
-rules //filter duplications
+generate-completion-productions:
+	cf-prods -> <map(add-empty-string-lexical)> completion-productions
+	where
+		completion-prods-unfiltered := <filter(make-completion-productions); flatten-list> cf-prods;
+		completion-productions := <filter-superfluous-completions(|cf-prods)> completion-prods-unfiltered
 
-/**
- * Removes duplicate and unuseful productions
- * arg (recover-prods, prods)	
- */
-remove-superfluous-prods =
-	diff(eq-completion-prod); 
-	filter-duplicates; 
-	filter(not(eq-lhs-rhs))
-
-filter-duplicates=
-	qsort(not(least-harmful-prod));  //least harmful are kept
-	mk-set(eq-completion-prod); //remove overlaps
-	reverse //starts with productions that are least harmful to the ast
+filter-superfluous-completions(|cf-prods):
+	completion-prods -> completion-prods-filtered
+	where
+		completion-prods-filtered := <
+			diff(equal-productions);
+			mk-set(equal-productions);
+			filter(not({lhs: ?prod([lhs], lhs, _)}))
+		> (completion-prods, cf-prods)
 
-mk-set(eq)=
-	foldr(![], union(eq), ![<id>])
+rules //create completion rules for context-free productions
 
-least-harmful-prod=
-	?(prod(_, _, attr-1), prod(_, _, attr-2));
-	(where(oncetd(?appl(unquoted("cons"),_)))<+
-	where(
-		<oncetd(?appl(unquoted("ast"), [fun(quoted(ast-string-1))]))> attr-1;
-		<oncetd(?appl(unquoted("ast"), [fun(quoted(ast-string-2))]))> attr-2;
-		<is-substring(dummy-string)> ast-string-2 //TODO: count dummies?
-	))
+make-completion-productions:
+	prod at prod(_, _, _) -> completion-productions
+	where
+		completion-productions := <completion-parts; map(make-completion-production)> prod
+	
+make-completion-production:
+	(lhs-prefix, lhs-suffix, rhs, attr) -> prod(<add-optional-lexicals(|lhs-suffix)> lhs-prefix, rhs, attr-completion)
+	where
+		suffix-sorts := <filter(is-sort-term)> lhs-suffix;
+		if <not(?[])> suffix-sorts then
+			constructor := <get-constructor-name> attr; 
+			prefix-sorts-count := <filter(is-sort-term); length> lhs-prefix;
+			suffix-placeholders := <map(lookup-placeholder)> suffix-sorts; 
+			ast-string := <make-ast-string>(constructor, prefix-sorts-count, suffix-placeholders); 
+			attr-completion := <replace-cons-with-ast(|ast-string); add-completion-attr> attr
+		else
+			attr-completion:= <add-completion-attr> attr
+		end
 
+add-optional-lexicals(|lhs-suffix):
+	lhs-prefix -> <conc>(lhs-prefix, optional-lexicals)
+	where
+		if <not(map(is-sort-term))> lhs-prefix then //auto-edit strategy is typically triggered by a lexical in the prefix
+			optional-lexicals := <filter(to-opt-lit)> lhs-suffix
+		else
+			optional-lexicals := []
+		end
 
+to-opt-lit = 
+	to-opt-lit-opt <+
+	to-opt-lit-iter <+
+	to-opt-lit-lit
+
+to-opt-lit-opt: opt-lit at opt(lit(_)) -> opt-lit
+to-opt-lit-iter: iter-lit at iter-star(lit(_)) -> iter-lit
+to-opt-lit-iter: iter-lit at iter-star-sep(lit(_), _) -> iter-lit	
+to-opt-lit-iter: iter(lit(l)) -> iter-star(lit(l))
+to-opt-lit-iter: iter-sep(lit(l), sep) -> iter-star-sep(lit(l), sep)	
+to-opt-lit-lit: lit(_) -> opt(<id>)		
 
-eq-lhs-rhs=
-	where(
-		?prod([lhs], rhs, _);
-		<equal>(lhs, rhs)
-	)
+make-ast-string:
+	(constructor, prefix-sorts-count, suffix-placeholders) -> $["[constructor]([arg-string])"]
+	where
+		prefix-number-strings := <upto; Tl; map(!$[<[<id>]>])> prefix-sorts-count; 
+		suffix-placeholder-strings := <map(write-to-string)> suffix-placeholders; 
+		arg-string := <conc; separate-by(|","); concat-strings>(prefix-number-strings, suffix-placeholder-strings)
 
-eq-completion-prod=
-	where(
-		?(prod(lhs-1, rhs, _), prod(lhs-2, rhs, _));
-		<equal>(
-			<reverse; drop-while(?opt(lit(_)))> lhs-1,
-			<reverse; drop-while(?opt(lit(_)))> lhs-2
-		)    		
-	)
+completion-parts:
+	prod(lhs, rhs, attr) -> completion-parts
+	where
+		lhs-completion-parts := <completion-lhs-parts> lhs;
+		completion-parts := <map(\(prefix, suffix) -> (prefix, suffix, rhs, attr)\)> lhs-completion-parts
 
+completion-lhs-parts:
+	lhs -> <completion-lhs-parts(|lhs, 1)> []
+	
+completion-lhs-parts(|lhs, n) = 
+	completion-lhs-parts-stop(|lhs, n) <+
+	completion-lhs-parts-add(|lhs, n) <+
+	completion-lhs-parts-skip(|lhs, n)
+	
+completion-lhs-parts-stop(|lhs, n):
+	lhs-tuples -> lhs-tuples
+	where
+		<gt>(n, <length> lhs)
 
-rules //prod -> [completion-recover-productions]
+completion-lhs-parts-skip(|lhs, n):
+	lhs-tuples -> <completion-lhs-parts(|lhs, <inc> n)> lhs-tuples
 
-//prod -> [completion-recover-productions]
-create-completion-productions:
-	prod at prod(lhs, rhs, attr) -> derived-completion-rules
-	where
-		(
-			<?attrs(_)> attr;
-			lhs-completions:=<try(expand-lhs); init> [lhs]; 
-			derived-completion-rules:=<map(make-completion-production(|prod))> lhs-completions
-		)<+
-		derived-completion-rules:=[]
-		
-		
-//lhs -> [lhs-compl-1, lhs-compl-2, ...lhs]
-expand-lhs: 
-	[h|t] -> <try(expand-lhs)>[h-broken,h|t]
-	where 
-		h-broken:=<at-suffix-rev(create-completion-suffix)> h 
-		
-create-completion-suffix:
-	[h|tail] -> [h|completion-tail]
+completion-lhs-parts-add(|lhs, n):
+	lhs-tuples -> <completion-lhs-parts(|lhs, <inc> n)>[(prefix, suffix)|lhs-tuples]
 	where
-		<oncetd(?sort(_))> h;
-		completion-tail:=< //tail should contain a required subterm 
-			where(
-				fetch(
-					not(
-						?opt(_) <+
-						?iter-star(_) <+
-						?iter-star-sep(_, _)
-					)<+
-					is-closing-bracket
-				)
-			); 
-			filter(is-closing-bracket; to-opt-lit)  //sorts are removed, closing literals are made optional
-		> tail
+		(prefix, suffix) := <split-at(|n)> lhs;
+		<is-lhs-completion-prefix> prefix;
+		<is-lhs-completion-suffix> suffix
+
+is-lhs-completion-prefix:
+	prefix -> prefix
+	where //prefix should end with sort term
+		<last; is-sort-term> prefix
+
+is-lhs-completion-suffix:
+	suffix -> suffix
+	where //suffix should contain a non-optional subterm
+		<not(map(?opt(_) <+ ?iter-star(_) <+ ?iter-star-sep(_, _)))> suffix
+	//where //PERFORMANCE: suffix should contain a non-lexical, otherwise insertion is sufficient
+		//<not(map(not(is-sort-term)))> suffix
+		
+rules //recursive generation of suitable placeholders for sorts
 
 /**
- * Closing brackets in removed suffix are made optional 
- * (to allow completion in case they are automatically added by the IDE)
+ * Fills lookup table that maps sorts to placeholder ast nodes
  */
-is-closing-bracket=
-	where(
-		?lit(l); 
-		<un-double-quote; (?")" <+ ?">" <+ ?"]" <+ ?"}" <+ ?"end" <+ "]|" <+ "}|")> l
-	)
+store-placeholders-top:
+	ast -> ast
+	where
+	  cf-productions := <get-cf-productions> ast;
+	  remaining-cf-prods-1 := <store-placeholders-iteratively> cf-productions;
+	  //results in bad default values, just good enough to use in completion scenarion 
+	  lexical-productions := <get-lexical-productions> ast;
+	  <filter(store-lexical-default-placeholder)> lexical-productions;
+	  remaining-cf-prods-2 := <store-placeholders-iteratively> remaining-cf-prods-1;
+	  <filter(store-cf-default-placeholder)> remaining-cf-prods-2
 
-to-opt-lit:
-	lit(_) -> opt(<id>)
+store-placeholders-iteratively:
+	cf-prods -> remaining-cf-prods
+	where
+	  remaining-cf-prods := 
+	  	<repeat({prods: ?prods; filter(not(store-placeholder)); not(?prods)})> cf-prods
+	
+store-placeholder:
+	prod(lhs, rhs, attrs) -> prod(lhs, rhs, attrs)
+	where
+		<not(lookup-placeholder)> rhs;
+		placeholder := <create-placeholder> prod(lhs, rhs, attrs); 
+		rules(LookupPlaceholder: rhs -> placeholder)
 
-to-opt-lit=
-	?opt(lit(_))
+create-placeholder:
+	prod(lhs, _, attrs) -> placeholder
+	where
+		child-placeholders := <filter(is-sort-term); map(lookup-placeholder)> lhs;
+		constructor := <get-constructor-name> attrs;
+		placeholder := constructor#(child-placeholders)
 
-// cutted lhs -> prod (recover)
-make-completion-production(|prod):
-	lhs-completion -> prod(lhs-completion, rhs, attr-completion)
-	where
-		<?prod(lhs, rhs, attr)> prod; 
-		lhs-completion-sorts:=<filter(oncetd(?sort(_)))> lhs-completion;
-		lhs-completion-sort-count:=<length> lhs-completion-sorts; //number of remaining lhs sorts
-		lhs-sorts:=<filter(oncetd(?sort(_)))> lhs;
-		dummy-sorts:=<eliminate-prefix(|lhs-completion-sorts)> lhs-sorts; //removed sorts
-		if <not(?[])> dummy-sorts then
-			dummy-terms:=<map(get-dummy-node <+ dummy-string)> dummy-sorts; 
-			cons-name:=<get-cons-name> attr; 
-			ast-string:=<make-ast-string>(cons-name, lhs-completion-sort-count, dummy-terms); 
-			attr-completion:= <oncetd(replace-cons-with-ast(|ast-string)); add-recover-attr> attr
-		else
-			attr-completion:= <add-recover-attr> attr
-		end
-		
-get-cons-name=
-	oncetd(
-		?default(appl(unquoted("cons"), [fun(quoted(<un-double-quote; ?cons-name>))]))
-	);
-	!cons-name
+create-placeholder:
+	p at prod(lhs, _, attrs) -> placeholder
+	where
+		<is-injection-production> p; 
+		placeholder := <filter(is-sort-term); ?[<lookup-placeholder>]> lhs
 
-make-ast-string:
-	(cons-name, nr-of-args, dummy-args) -> $["[cons-name]([args])"]
+store-lexical-default-placeholder:
+	p at prod(_, rhs, _) -> p
 	where
-		lhs-args:=<dec; upto; map(inc; !$[<[<id>]>])> nr-of-args;
-		args:=<conc; map(try(un-double-quote)); separate-by(|","); concat-strings>(lhs-args, dummy-args)
-		
-replace-cons-with-ast(|ast-string):
-	default(appl(unquoted("cons"), [fun(quoted(_))])) -> default(appl(unquoted("ast"), [fun(quoted(ast-string))]))
+		<not(lookup-placeholder)> rhs;
+		placeholder := <get-lexical-default-placeholder> ; 
+		rules(LookupPlaceholder: rhs -> placeholder)
 
-add-recover-attr:
-	 attrs(lst) -> attrs([term(default(fun(unquoted("recover"))))|lst])
+store-cf-default-placeholder:
+	p at prod(_, rhs, _) -> p
+	where
+		<not(lookup-placeholder)> rhs;
+		placeholder := <get-cf-default-placeholder>;
+		rules(LookupPlaceholder: rhs -> placeholder)
+	
+rules //inductively created placeholders
 
+lookup-placeholder = LookupPlaceholder
+	
+lookup-placeholder:
+	iter-star(_) -> []
+	where
+		is-sort-term
 
-eliminate-prefix(|prefix):
-	[h|tail] -> lst-suffix
+lookup-placeholder:
+	iter-star-sep(_, _) -> []	
 	where
-		<?[h|pt]> prefix;
-		lst-suffix:=<eliminate-prefix(|pt)> tail
+		is-sort-term
 
-eliminate-prefix(|prefix)=
-	is-list;
-	where(<?[]> prefix)
-		
-rules
+lookup-placeholder:
+	opt(_) -> None()
+	where
+		is-sort-term
 
-/**
- * Fills Lookup table that maps sort terms to ast nodes.
- * iter-star(-sep) -> [], opt(x) -> None(), 
- * for injections the ast-node for the lhs is taken for the rhs.
- */
-collect-default-dummies=
-	get-cf-productions; 
-	repeat(some(put-dummy-node <+ put-dummy-node-injection))
-	//REMARK: full recursion leads to artificial dummies
-	//TODO (?): Derive dummy nodes in case rhs is unique and lhs terms are known? 
-	//TODO: other heuristics?
+lookup-placeholder:
+	alt(a, b) -> <<lookup-placeholder> a <+ <lookup-placeholder> b >
 
-get-cf-productions =
-	collect-all(?context-free-syntax(<id>));
-	flatten-list
-	
-put-dummy-node=
-	?prod(lhs, rhs, attrs);
-	<?[<is-sort-term>] <+ map(has-default-node <+ is-non-alphanum-literal)> lhs; //only include "empty" values, like: ";" -> Stm {cons(EmptyStm)}
-	<not(get-dummy-node)> rhs;
-	dummy-args:=<filter(is-sort-term); map(get-dummy-node)> lhs;
-	node-name:=<get-cons-name> attrs;
-	ast-string:=<make-ast-string> (node-name, 0, dummy-args); 
-	rules(GetDummyNode: rhs -> ast-string)
-
-put-dummy-node-injection=
-	?prod(lhs, rhs, attrs); 
-	<not(get-dummy-node)> rhs;
-	<not(has-ast-attr)> attrs; // is injection
-	[trm]:=<filter(is-sort-term); map(get-dummy-node)> lhs; 
-	ast-string:= trm; 
-	rules(GetDummyNode: rhs -> ast-string) 
-
-has-default-node=
-	?iter-star(_)<+
-	?iter-star-sep(_, _) <+
-	?opt(_) <+
-	?iter(<has-default-node>) <+
-	?iter-sep(<has-default-node>, _) <+
-	(?alt(x, y); where(<has-default-node>x <+ <has-default-node>y))	
+lookup-placeholder:
+	iter(srt) -> [<lookup-placeholder> srt]
 
-is-non-alphanum-literal=
-	?lit(<not(un-double-quote; string-as-chars(map(is-alphanum)))>)
+lookup-placeholder:
+	iter-sep(srt, _) -> [<lookup-placeholder> srt]
 
+get-lexical-default-placeholder = !"MISSING_LEXICAL"
 
-has-ast-attr=
-	where(
-		oncetd(
-			?default(appl(unquoted("ast"),_))<+
-			?default(appl(unquoted("cons"),_))
-		)
-	)
+get-cf-default-placeholder = !MISSING()
+
+signature constructors
+	MISSING : Missing
 
-has-custom-ast-attr=
+
+rules //helpers
+	
+is-sort-term = where(oncetd(?sort(_)))
+
+is-injection-production:
+	p at prod(lhs, _, attrs) -> p
+	where
+		<not(has-ast-attr)> attrs;
+		<filter(is-sort-term); ?[_]> lhs
+
+has-ast-attr =
 	where(
 		oncetd(
-			?default(appl(unquoted("ast"),_))
+			?default(appl(unquoted("ast"),_)) <+
+			?default(appl(unquoted("cons"),_))
 		)
 	)
 
-is-sort-term =
-	where(
-		oncetd(?sort(_))
-	)
-
-get-dummy-node=
-	GetDummyNode
-
-get-dummy-node:
-	iter-star(_) -> "[]"
+get-constructor-name:
+	attrs -> cons-name
 	where
-		is-sort-term
+	  oncetd(
+		?default(appl(unquoted("cons"), [fun(quoted(<un-double-quote; ?cons-name>))]))
+	  )
 
-get-dummy-node:
-	iter-star-sep(_, _) -> "[]"	
-	where
-		is-sort-term
+get-cf-productions =
+	collect-all(?context-free-syntax(<id>));
+	flatten-list
 
-get-dummy-node:
-	opt(_) -> "None()"
-	where
-		is-sort-term
+get-lexical-productions =
+	collect-all(?lexical-syntax(<id>));
+	flatten-list
 
-get-dummy-node:
-	alt(a, b) -> <<get-dummy-node> a <+ <get-dummy-node> b >
+add-completion-attr:
+	 attrs(lst) -> attrs([term(default(fun(unquoted("completion"))))|lst])
 
-get-dummy-node:
-	iter(srt) -> <map(try(un-double-quote)); concat-strings>  ["[", <get-dummy-node> srt, "]"]
+replace-cons-with-ast(|ast-string) = 
+	oncetd(replace-cons-attr-with-ast-attr(|ast-string))
 
-get-dummy-node:
-	iter-sep(srt, _) -> <map(try(un-double-quote)); concat-strings> ["[", <get-dummy-node> srt, "]"]
-	
-dummy-string=
-	!"DUMMY()"
+replace-cons-attr-with-ast-attr(|ast-string) :
+	default(appl(unquoted("cons"), [fun(quoted(_))])) -> default(appl(unquoted("ast"), [fun(quoted(ast-string))]))
 
+pretty-print-sdf = 
+	sdf-desugar; 
+	parenthesize-SDFX; 
+	pp-sdf-string
 
-//TODO: completion attribute?
-//TODO: completions only in cursor region?
-//TODO: interaction WATER, INSERT, COMPLETION
+equal-productions:
+	prod-pair@(prod(lhs, rhs, _), prod(lhs, rhs, _)) -> prod-pair
+
+mk-set(eq)=
+	foldr(![], union(eq), ![<id>])
 
+add-empty-string-lexical:
+	prod(lhs, rhs, attr) -> prod([lit("\"@#$\"")|lhs], rhs, attr)
\ No newline at end of file

From L.C.L.Kats at tudelft.nl  Mon Aug 22 14:48:03 2011
From: L.C.L.Kats at tudelft.nl (Lennart Kats)
Date: Mon, 22 Aug 2011 12:48:03 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23235 -
	spoofax-imp/trunk/org.strategoxt.imp.generator/lib
Message-ID: <20110822124803.94C857F8018@mx1.tudelft.nl>

Author: LennartKats
Date: Mon Aug 22 12:48:03 2011
New Revision: 23235
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23235&sc=1

Log:
updated make_permissive.jar with r23233 WATERTOKENSTART fix

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.generator/lib/make_permissive.jar

Modified: spoofax-imp/trunk/org.strategoxt.imp.generator/lib/make_permissive.jar
==============================================================================
Binary file (source and/or target). No diff available.

From m.dejonge at tudelft.nl  Tue Aug 23 10:39:39 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 23 Aug 2011 08:39:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23236 -
	sglr-recovery/completion-rules
Message-ID: <20110823083939.AB9277F8035@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug 23 08:39:39 2011
New Revision: 23236
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23236&sc=1

Log:
-> "@#$" {completion}: trick to obtain acceptable non-error performance

Modified:
   sglr-recovery/completion-rules/generate-completion-rules.str

Modified: sglr-recovery/completion-rules/generate-completion-rules.str
==============================================================================
--- sglr-recovery/completion-rules/generate-completion-rules.str	Mon Aug 22 12:48:03 2011	(r23235)
+++ sglr-recovery/completion-rules/generate-completion-rules.str	Tue Aug 23 08:39:39 2011	(r23236)
@@ -15,8 +15,12 @@
 		<store-placeholders-top> ast;
 		ast' := <
 			alltd(add-completion-syntax);
+			oncetd(add-completion-start-rule);
 			alltd(flatten-list)
 		> ast
+		
+add-completion-start-rule:
+	lexical-syntax(l-prods) -> [lexical-syntax(l-prods), lexical-syntax([<start-lexical-production>])]
 
 add-completion-syntax:
 	context-free-syntax(cf-prods) -> [context-free-syntax(cf-prods), context-free-syntax(completion-prods)]
@@ -31,7 +35,7 @@
 		completion-productions := <generate-completion-productions> cf-prods
 
 generate-completion-productions:
-	cf-prods -> <map(add-empty-string-lexical)> completion-productions
+	cf-prods -> <map(add-start-lexical)> completion-productions
 	where
 		completion-prods-unfiltered := <filter(make-completion-productions); flatten-list> cf-prods;
 		completion-productions := <filter-superfluous-completions(|cf-prods)> completion-prods-unfiltered
@@ -280,5 +284,14 @@
 mk-set(eq)=
 	foldr(![], union(eq), ![<id>])
 
-add-empty-string-lexical:
-	prod(lhs, rhs, attr) -> prod([lit("\"@#$\"")|lhs], rhs, attr)
\ No newline at end of file
+add-start-lexical:
+	prod(lhs, rhs, attr) -> prod([<start-lexical>|lhs], rhs, attr)
+
+start-lexical-production =
+	!prod(
+	      []
+	    , <start-lexical>
+	    , attrs([term(default(fun(unquoted("completion"))))])
+	    )
+
+start-lexical = !lit("\"@#$\"")
\ No newline at end of file

From m.dejonge at tudelft.nl  Tue Aug 23 11:30:58 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 23 Aug 2011 09:30:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23237 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110823093058.7E1D77F8049@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug 23 09:30:57 2011
New Revision: 23237
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23237&sc=1

Log:
bugfixes/finetuning find during evaluation runs

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Tue Aug 23 08:39:39 2011	(r23236)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Tue Aug 23 09:30:57 2011	(r23237)
@@ -5,7 +5,8 @@
 
 public class FineGrainedOnRegion {
 
-    private static final int MAX_NR_OF_EXPLORED_LINES = 75;
+    private static final int MAX_NUMBER_OF_RECOVER_BRANCHES = 1000;
+	private static final int MAX_NR_OF_EXPLORED_LINES = 75;
 	private int acceptRecoveryPosition;
     private int regionEndPosition;
     private ArrayList<BacktrackPosition> choicePoints;
@@ -115,6 +116,8 @@
      * Explores permissive branches, and collects derived branches with higher recover count
      */
     private ArrayList<RecoverNode> recoverParse(ArrayList<RecoverNode> candidates, int endRecoverSearchPos) {
+    	if(candidates.size() > MAX_NUMBER_OF_RECOVER_BRANCHES)
+    		candidates = new ArrayList<RecoverNode>(candidates.subList(0, MAX_NUMBER_OF_RECOVER_BRANCHES/2)); //too much stacks causes problems for performance while they probably contain multiple solutions
     	mySGLR.setFineGrainedOnRegion(true);
         ArrayList<RecoverNode> newCandidates=new ArrayList<RecoverNode>();
         int curTokIndex;

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Tue Aug 23 08:39:39 2011	(r23236)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Tue Aug 23 09:30:57 2011	(r23237)
@@ -53,9 +53,6 @@
         if(onlyFineGrained){
             mySGLR.getPerformanceMeasuring().startFG();
             boolean fg=tryFineGrainedRepair();
-            if(fg){
-            	System.out.println("FG-only Succeeded");
-            }
             mySGLR.getPerformanceMeasuring().endFG(fg);
             return;
         }
@@ -89,7 +86,7 @@
             boolean FGSucceeded=tryFineGrainedRepair();
             mySGLR.getPerformanceMeasuring().endFG(FGSucceeded);
             if(FGSucceeded){ //FG succeeded  
-                addSkipOption(skipSucceeded);
+                //addSkipOption(skipSucceeded);
                 //System.out.println("FG-Succeeded");
                 return;
             }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Tue Aug 23 08:39:39 2011	(r23236)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Tue Aug 23 09:30:57 2011	(r23237)
@@ -262,6 +262,7 @@
 		initParseVariables(input, filename);
 		startTime = System.currentTimeMillis();
 		initParseTimer();
+		getPerformanceMeasuring().startParse();
         Object result = sglrParse(startSymbol);
         return result;
 	}
@@ -269,7 +270,6 @@
 	private Object sglrParse(String startSymbol)
 	throws BadTokenException, TokenExpectedException,
 	ParseException, SGLRException {
-		getPerformanceMeasuring().startParse();
 		try {
 			do {
 				readNextToken();

From m.dejonge at tudelft.nl  Wed Aug 24 09:08:46 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 24 Aug 2011 07:08:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23238 - in
	sglr-recovery/trunk/Evaluate/src: evaluation_runs fileprocessing
Message-ID: <20110824070846.958F5CC049@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug 24 07:08:46 2011
New Revision: 23238
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23238&sc=1

Log:
Scalability and Completion TestRuns

Added:
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/Completion.java   (contents, props changed)
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/Scalability.java   (contents, props changed)
Modified:
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunBigTestset.java
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunCombinedRecoveries.java
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunErrorCategories.java
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunPermissiveGrammars.java
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java

Added: sglr-recovery/trunk/Evaluate/src/evaluation_runs/Completion.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/Completion.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -0,0 +1,53 @@
+package evaluation_runs;
+
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+import fileprocessing.Directories;
+import fileprocessing.FilenameFilters;
+import fileprocessing.TestRun;
+import fileprocessing.TestRun.Permissive;
+import fileprocessing.TestRun.Technique;
+
+public class Completion {
+	
+	private static final String TESTRUN_NAME = null; //name of result files, default is <technique>_<grammar>
+	private static final String TESTSUITE = "stratego-java-completions";
+	//private static final Permissive GRAMMAR = Permissive.WC_COMPLETIONS;
+	//private static final Permissive GRAMMAR = Permissive.COMPLETIONS;
+	//private static final Permissive GRAMMAR = Permissive.NoRecovery;
+	private static final Permissive GRAMMAR = Permissive.WC_COMPLETIONS;
+	//private static final Technique TECHNIQUE = Technique.RS;
+	private static final Technique TECHNIQUE = Technique.NO_RECOVERY_SUPPORT;
+	//private static final Technique TECHNIQUE = Technique.RS_FG; // Technique.RS_BP; // Technique.RS_BP_FG;  
+	//private static final Technique TECHNIQUE = Technique.FG; // Technique.RS_BP; // Technique.RS_BP_FG;  
+
+	@Test
+	public void test_StrategoJava() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException {
+		//TestRun run=new TestRun("webdsl");
+		TestRun run=new TestRun(TESTSUITE);
+		processFiles(run);
+	}
+
+	private void processFiles(TestRun run) throws IOException,
+			InvalidParseTableException, InterruptedException,
+			TokenExpectedException, BadTokenException, ParseException,
+			SGLRException, FileNotFoundException {
+		//run.correctInputFiles();
+		Directories.clearAllDirectories();
+		run.setTechnique(TECHNIQUE);
+		run.setPermissive(GRAMMAR);
+		run.setSuiteName(TESTRUN_NAME);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("RDef"));
+		run.warmup();
+		run.processFilesCompletion(0, null);
+	}
+}

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunBigTestset.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunBigTestset.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunBigTestset.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -50,6 +50,7 @@
 			SGLRException, FileNotFoundException {
 		run.correctInputFiles();
 		Directories.clearAllDirectories();
+		//run.setTechnique(Technique.RS_BP_FG);
 		run.setTechnique(Technique.RS_FG);
 		run.setPermissive(Permissive.WC);
 		run.processErrorFiles(60, null);

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunCombinedRecoveries.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunCombinedRecoveries.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunCombinedRecoveries.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -22,8 +22,8 @@
 
 public class RunCombinedRecoveries extends TestCase {
 	
-	private static TestRun run=new TestRun("stratego-java-test");
-	//private TestRun run=new TestRun("stratego-java-details");
+	//private static TestRun run=new TestRun("stratego-java-test");
+	private static TestRun run = new TestRun("stratego-java-details");
 
 	
 	@BeforeClass

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunErrorCategories.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunErrorCategories.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunErrorCategories.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -17,8 +17,8 @@
 
 public class RunErrorCategories {
 	
-	private static TestRun run=new TestRun("stratego-java-test");
-	//private TestRun run=new TestRun("stratego-java-details");
+	//private static TestRun run=new TestRun("stratego-java-test");
+	private static TestRun run=new TestRun("stratego-java-details");
 	
 	@BeforeClass
 	public static void setUpBeforeClass() throws Exception {

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunPermissiveGrammars.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunPermissiveGrammars.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunPermissiveGrammars.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -11,6 +11,7 @@
 import org.spoofax.jsglr.shared.SGLRException;
 
 import fileprocessing.Directories;
+import fileprocessing.FilenameFilters;
 import fileprocessing.TestRun;
 import fileprocessing.TestRun.Permissive;
 import fileprocessing.TestRun.Technique;
@@ -18,14 +19,15 @@
 
 public class RunPermissiveGrammars extends TestCase {
 
-	private static TestRun run=new TestRun("stratego-java-test");
-	//private TestRun run=new TestRun("stratego-java-details");
+	//private static TestRun run=new TestRun("stratego-java-test");
+	private static TestRun run=new TestRun("stratego-java-details");
 	
 	@BeforeClass
 	public static void setUpBeforeClass() throws Exception {
 		run.correctInputFiles();
 		Directories.clearAllDirectories();
 		run.setTechnique(Technique.RS_FG);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter(".62.sj"));
 		run.warmup();
 	}
 
@@ -59,6 +61,7 @@
 	public void test_GrammarCO() throws FileNotFoundException,  IOException, InvalidParseTableException, SGLRException, InterruptedException, org.spoofax.jsglr.InvalidParseTableException, org.spoofax.jsglr.SGLRException{
 		run.setSuiteName("Permissive_CO");
 		run.setPermissive(Permissive.CO);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("missing.188"));
 		run.processErrorFiles(0, null);
 		Directories.clearAllDirectories();
 	}
@@ -77,5 +80,5 @@
 		run.setPermissive(Permissive.WC_CUST);
 		run.processErrorFiles(0, null);
 		Directories.clearAllDirectories();
-	}	
+	}
 }
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluate/src/evaluation_runs/Scalability.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/Scalability.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -0,0 +1,49 @@
+package evaluation_runs;
+
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.junit.Test;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+import fileprocessing.Directories;
+import fileprocessing.FilenameFilters;
+import fileprocessing.TestRun;
+import fileprocessing.TestRun.Permissive;
+import fileprocessing.TestRun.Technique;
+
+public class Scalability {
+	
+	private static final String TESTRUN_NAME = null; //name of result files, default is <technique>_<grammar>
+	private static final String TESTSUITE = "stratego-java-scalability";
+	private static final Permissive GRAMMAR = Permissive.WC;
+	//private static final Permissive GRAMMAR = Permissive.COMPLETIONS;
+	//private static final Permissive GRAMMAR = Permissive.WC_COMPLETIONS;
+	private static final Technique TECHNIQUE = Technique.RS_FG;
+
+	@Test
+	public void test_StrategoJavaScalability() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException {
+		//TestRun run=new TestRun("webdsl");
+		TestRun run=new TestRun(TESTSUITE);
+		processFiles(run);
+	}
+
+	private void processFiles(TestRun run) throws IOException,
+			InvalidParseTableException, InterruptedException,
+			TokenExpectedException, BadTokenException, ParseException,
+			SGLRException, FileNotFoundException {
+		//run.correctInputFiles();
+		Directories.clearAllDirectories();
+		run.setTechnique(TECHNIQUE);
+		run.setPermissive(GRAMMAR);
+		run.setSuiteName(TESTRUN_NAME);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("err0"));
+		run.warmup();
+		run.processErrorFiles(10, null);
+	}
+}

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/Testing.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -20,7 +20,7 @@
 public class Testing {
 	
 	private static final String TESTRUN_NAME = null; //name of result files, default is <technique>_<grammar>
-	private static final String TESTSUITE = "webdsl"; //"stratego-java-test";
+	private static final String TESTSUITE = "stratego-java-test";
 	private static final Permissive GRAMMAR = Permissive.WC;
 	private static final Technique TECHNIQUE = Technique.RS_FG; // Technique.RS_BP; // Technique.RS_BP_FG;  
 
@@ -40,7 +40,7 @@
 		run.setTechnique(TECHNIQUE);
 		run.setPermissive(GRAMMAR);
 		run.setSuiteName(TESTRUN_NAME);
-		run.setFilenameFilter(FilenameFilters.getNameFilter("project.auto_incomplete.290.org"));
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("project.auto_incomplete.290.org"));
 		run.processErrorFiles(0, null);
 	}
 }

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -49,6 +49,9 @@
 		sglr.setUseStructureRecovery(false);
 	}
 	
+	public void setCompletionParse(int cursorLocation){
+		sglr.setCompletionParse(true, cursorLocation);
+	}
 	
 	public void setSGLR(String parseTableLocation, String tokenParseTable, IRecoveryParser recoveryParser) throws FileNotFoundException, IOException, InvalidParseTableException{		
 		final TermFactory factory = new TermFactory();
@@ -98,22 +101,15 @@
 			throws FileNotFoundException, IOException,
 			InvalidParseTableException,
 			InterruptedException, TokenExpectedException, BadTokenException, ParseException, SGLRException {
+		System.gc();
+		createRecoveredAst(test);	
 		String tempFilePath=Directories.TEMP_DIR+ File.separator+test.getFilename();
-		IStrategoTerm recoveredAST = writeParseTree(test.getPathToErrorFile(), tempFilePath+".err.ast");
-		test.setRecoveredAST(recoveredAST);
-		test.setParsetimeError(sglr.getPerformanceMeasuring().getParseTime());
-		test.setRecoverySucceeded(sglr.getPerformanceMeasuring().isParseSucceeded());
-		try {
-			//implodeAsfix(tempFilePath+".err.pt", tempFilePath+".err.ast");
-			pp_aterm(tempFilePath+".err.ast", test.getPathToErrorAST());
-		} catch (Exception e) {
-			System.err.println("Error during implode: "+test.getPathToErrorFile());
-			e.printStackTrace();
-		}	
 		if (!new File(test.getPathToIntendedAST()).exists()) {
+			sglr.setCompletionParse(false, -1);
 			IStrategoTerm intendedAST = writeParseTree(test.getPathToIntendedFile(), tempFilePath + ".intended.ast");
 			test.setIntendedAST(intendedAST);
 		} else {
+			sglr.setCompletionParse(false, -1);
 			IStrategoTerm intendedAST = parseNoOutput(test, test.getPathToIntendedFile());
 			test.setIntendedAST(intendedAST);
 		}
@@ -129,9 +125,10 @@
 		
 		if(test.isRecoverySucceeded() && new File(test.getPathToErrorAST()).exists()){
 			diff(test.getPathToErrorAST(), test.getPathToIntendedAST(), test.getPathToASTDiff());
-			/* EMMA*/System.out.println("Starting tree distance check");
-			int treeDistance = compareTrees(test.getIntendedAST(), test.getRecoveredAST());
-			/* EMMA*/System.out.println("Tree edit distance: " + treeDistance);
+			int treeDistance = -1;
+			///* EMMA*/System.out.println("Starting tree distance check");
+			// treeDistance = compareTrees(test.getIntendedAST(), test.getRecoveredAST());
+			///* EMMA*/System.out.println("Tree edit distance: " + treeDistance);
 			test.setTreeDistance(treeDistance);
 			test.setAstDiffLines(Results.getLineCount(test.getPathToASTDiff()));
 			if(ppTable!=null && new File(ppTable).exists()){
@@ -141,6 +138,23 @@
 			}
 		}
 	}
+
+	public void createRecoveredAst(TestFile test)
+			throws FileNotFoundException, IOException,
+			InvalidParseTableException {
+		String tempFilePath=Directories.TEMP_DIR+ File.separator+test.getFilename();
+		IStrategoTerm recoveredAST = writeParseTree(test.getPathToErrorFile(), tempFilePath+".err.ast");
+		test.setRecoveredAST(recoveredAST);
+		test.setParsetimeError(sglr.getPerformanceMeasuring().getParseTime());
+		test.setRecoverySucceeded(sglr.getPerformanceMeasuring().isParseSucceeded());
+		try {
+			//implodeAsfix(tempFilePath+".err.pt", tempFilePath+".err.ast");
+			pp_aterm(tempFilePath+".err.ast", test.getPathToErrorAST());
+		} catch (Exception e) {
+			System.err.println("Error during implode: "+test.getPathToErrorFile());
+			e.printStackTrace();
+		}
+	}
 	
 	protected CostFunction costFunction = new StrategoCostFunction();
 	protected int compareTrees(IStrategoTerm org, IStrategoTerm broken) {
@@ -241,6 +255,5 @@
 		while (System.currentTimeMillis() < time + warmup * 1000) {
 			sglr.parse(inputChars, fname, null);
 		}
-		System.gc();
 	}
 }

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/Results.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -95,7 +95,16 @@
 		LineNumberReader lineCounter = new LineNumberReader(
 				new InputStreamReader(new FileInputStream(filePath)));
 		while ((lineCounter.readLine()) != null) {}
+		assert lineCounter.getLineNumber()>=0;
 		return lineCounter.getLineNumber();
 	}
+	
+	public static void writeParseTimes(ArrayList<TestFile> testfiles, PrintStream prs) {
+		prs.println("Parse times in milli-seconds: ");
+		for (TestFile test : testfiles) {
+			prs.println(test.getFilename() + ": " + test.getParsetimeError());
+		}
+	}
+
 
 }

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/TestFile.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -1,6 +1,11 @@
 package fileprocessing;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
 
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
@@ -51,6 +56,8 @@
 	}
 
 	public long getParsetimeError() {
+		if(!this.recoverySucceeded)
+			return Integer.MAX_VALUE;
 		return parsetimeError;
 	}
 	
@@ -58,7 +65,7 @@
 		if(!recoverySucceeded){
 			return PARSE_FAILURE;
 		}
-		if (parsetimeError>parsetimeIntended)
+		if (parsetimeError > parsetimeIntended)
 			return (int)(parsetimeError-parsetimeIntended);
 		return 0;
 	}
@@ -134,4 +141,31 @@
 		return intendedAST;
 	}
 
+	public int getCursorLocation() {
+		String content = "";
+		try {
+			// Read the entire contents of sample.txt
+			content = readFile(getPathToErrorFile());
+		} catch (IOException e) {
+			e.printStackTrace();
+			return Integer.MAX_VALUE;
+		}
+		int startIndex = content.indexOf("xxxCOMPLETION");
+		System.out.println("completion at: " + startIndex);
+		return startIndex + "xxxCOMPLETION".length() - 1;
+	}
+	
+	private static String readFile(String path) throws IOException {
+		FileInputStream stream = new FileInputStream(new File(path));
+		try {
+			FileChannel fc = stream.getChannel();
+			MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0,
+					fc.size());
+			/* Instead of using default, pass in a decoder. */
+			return Charset.defaultCharset().decode(bb).toString();
+		} finally {
+			stream.close();
+		}
+	}
+
 }

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Tue Aug 23 09:30:57 2011	(r23237)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Wed Aug 24 07:08:46 2011	(r23238)
@@ -6,9 +6,11 @@
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.omg.CORBA.ContextList;
 import org.spoofax.jsglr.client.IRecoveryParser;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseException;
@@ -68,6 +70,7 @@
 		parseTableBaseNames.put("stratego-java-details", "StrategoJava");
 		parseTableBaseNames.put("stratego-java-test", "StrategoJava");
 		parseTableBaseNames.put("stratego-java-completions", "StrategoJava");
+		parseTableBaseNames.put("stratego-java-scalability", "StrategoJava");
 		parseTableBaseNames.put("java", "Java-15");
 		parseTableBaseNames.put("java-sql", "Java-SQL");
 		parseTableBaseNames.put("webdsl", "WebDSL");
@@ -179,7 +182,9 @@
         if(!dir.exists())
         	throw new IOException("Directory: "+dir + "does not exist");
         String[] children = dir.list(filter);
-        for (int i = 0; i < children.length; i++) {
+        Arrays.sort(children);
+        for (int i = children.length-1; i >= 0; i--) {
+        //for (int i = 0; i < children.length; i++) {
         	String fileName=children[i];
         	String errorFile=getDirErrorFiles()+File.separator+fileName;
         	String intendedFile=getDirIntendedFiles()+File.separator+fileName;
@@ -208,9 +213,11 @@
 			if(test.isRecoverySucceeded()){
 				new File(test.getPathToErrorFile()).delete();
 			}
-			fp.parseNoOutput(test, test.getPathToIntendedFile());
-			if(!test.isRecoverySucceeded()){
-				System.err.println(test.getPathToIntendedFile()+" unexpectedly contains errors!");
+			if(new File(test.getPathToIntendedFile()).exists()){
+				fp.parseNoOutput(test, test.getPathToIntendedFile());
+				if(!test.isRecoverySucceeded()){
+					System.err.println(test.getPathToIntendedFile()+" unexpectedly contains errors!");
+				}
 			}
 		}
 		//intended files must be error free
@@ -227,7 +234,7 @@
 	}
 	
 	public void processErrorFiles(int warmup, String ppTable) throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
-		ArrayList<TestFile> testcases=getErrorFileList();
+		ArrayList<TestFile> testcases = getErrorFileList();
 		FileProcessing fp = getFileProcessing();
 		if(testcases.size()>0)
 			fp.warmup(testcases.get(0).getPathToIntendedFile(),warmup);
@@ -242,17 +249,104 @@
 				catch (Error e)
 			    {
 					System.err.println("Error while parsing: "+currentFile.getFilename());
-					System.err.println(e.getMessage());
+					//System.err.println(e.getMessage());
 			        e.printStackTrace(); 
 					//Log error
 			    }
 			}
 		PrintStream prsDiff=new PrintStream(getDirSuite()+"results" +File.separator+"quality"+File.separator+getTestRunName());
 		Results.writeDiffStats(testcases, prsDiff);
-		Results.writeDistanceStats(testcases, prsDiff);
-		PrintStream prsTime=new PrintStream(getDirSuite()+"results" +File.separator+"performance"+File.separator+getTestRunName());
+		//Results.writeDistanceStats(testcases, prsDiff);
+		printPerformanceResults(testcases);
+		printParseTimeResults(testcases);		
+	}
+
+	public void processFilesCompletion(int warmup, String ppTable) throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, SGLRException{
+		ArrayList<TestFile> testcases = getErrorFileList();
+		FileProcessing fp = getFileProcessing();
+		if(testcases.size()>0)
+			fp.warmup(testcases.get(0).getPathToErrorFile(),warmup);
+		TestFile currentFile=null;		
+		for (TestFile test : testcases) {
+			currentFile=test;
+			try{
+				fp.setCompletionParse(test.getCursorLocation());
+				//fp.createRecoveredAst(test);
+				fp.processErrorFile(test);
+				//System.out.println(currentFile.getFilename());
+			}
+			catch (Error e)
+		    {
+				System.err.println("Error while parsing: "+currentFile.getFilename());
+				//System.err.println(e.getMessage());
+		        e.printStackTrace(); 
+				//Log error
+		    }
+		}
+		printCompletionQualityResults(testcases);		
+		PrintStream prsDiff=new PrintStream(getDirSuite()+"results" +File.separator+"quality"+File.separator+getTestRunName());
+		Results.writeDiffStats(testcases, prsDiff);
+		//Results.writeDistanceStats(testcases, prsDiff);
+		printPerformanceResults(testcases);
+		printParseTimeResults(testcases);		
+	}
+
+	private void printPerformanceResults(ArrayList<TestFile> testcases)
+			throws FileNotFoundException {
+		PrintStream prsTime = new PrintStream(getDirSuite() + "results"
+				+ File.separator + "performance" + File.separator
+				+ getTestRunName());
 		Results.writeTimeStats(testcases, prsTime);
-		
+	}
+
+	private void printParseTimeResults(ArrayList<TestFile> testcases)
+			throws FileNotFoundException {
+		String prsTimeDirPath = getDirSuite() + "results" + File.separator
+				+ "parsetimes";
+		File prsTimeDir = new File(prsTimeDirPath);
+		if (!prsTimeDir.exists())
+			prsTimeDir.mkdir();
+		PrintStream prsParseTimes = new PrintStream(prsTimeDirPath
+				+ File.separator + getTestRunName());
+		Results.writeParseTimes(testcases, prsParseTimes);
+	}
+
+	private void printCompletionQualityResults(ArrayList<TestFile> testcases)
+			throws FileNotFoundException {
+		PrintStream prs = new PrintStream(getDirSuite()+"results" + File.separator+"quality-context"+File.separator+getTestRunName());
+		int contextPreservedWellFormed = 0;
+		int contextPreservedMalFormed = 0;
+		int contextLost = 0;
+		int parsingFailed = 0;
+		for (TestFile test : testcases) {
+			String astString = "";
+			if(test.isRecoverySucceeded()){
+				if(test.getRecoveredAST() != null)
+					astString = test.getRecoveredAST().toString();
+				else {
+					parsingFailed ++;
+					prs.println("no recovered ast: " + test.getFilename());
+				}
+			}
+			else{
+				parsingFailed ++;
+				prs.println("parsing-failed: " + test.getFilename());
+			}
+			if(astString.contains("COMPLETION")){
+				if(astString.contains("DUMMY") || astString.contains("MISSING_LEXICAL"))
+					contextPreservedMalFormed ++;
+				else
+					contextPreservedWellFormed ++;
+			}
+			else if (test.isRecoverySucceeded()){
+				contextLost++;
+				prs.println("context lost: " + test.getFilename());
+			}			
+		}
+		prs.println("wellformed context: "+ contextPreservedWellFormed);
+		prs.println("malformed context: "+ contextPreservedMalFormed);
+		prs.println("context lost: "+ contextLost);
+		prs.println("parsing failed: "+ parsingFailed);
 	}
 
 	private String getTestRunName() {

From m.dejonge at tudelft.nl  Wed Aug 24 09:10:15 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Wed, 24 Aug 2011 07:10:15 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23239 -
	sglr-recovery/trunk/Evaluate/grammars-completion
Message-ID: <20110824071015.EADBB108C029@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Wed Aug 24 07:10:15 2011
New Revision: 23239
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23239&sc=1

Log:
CompletionGrammars

Added:
   sglr-recovery/trunk/Evaluate/grammars-completion/StrategoJava-Completions.def
   sglr-recovery/trunk/Evaluate/grammars-completion/StrategoJava-WC-Completions.def
Modified:
   sglr-recovery/trunk/Evaluate/grammars-completion/   (props changed)

Added: sglr-recovery/trunk/Evaluate/grammars-completion/StrategoJava-Completions.def
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/grammars-completion/StrategoJava-Completions.def	Wed Aug 24 07:10:15 2011	(r23239)
@@ -0,0 +1,3000 @@
+definition
+
+module languages/java-15/expressions/Priorities
+imports languages/java-15/lexical/Identifiers languages/java-15/expressions/Main
+
+exports
+  context-free priorities
+    Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
+     >
+    {right:
+      Expr "++" -> Expr 
+      Expr "--" -> Expr 
+    }
+
+  context-free priorities
+    {right:
+      Expr "++" -> Expr 
+      Expr "--" -> Expr 
+    } >
+    { "(" PrimType ")" Expr -> Expr 
+      "(" RefType ")" Expr -> Expr  }
+
+  context-free priorities
+    "(" PrimType ")" Expr -> Expr  >
+    {left:
+      Expr "*" Expr -> Expr 
+      Expr "/" Expr -> Expr 
+      Expr "%" Expr -> Expr 
+    }
+
+  context-free priorities
+    "(" RefType ")" Expr -> Expr  >
+    { "++" Expr -> Expr 
+      "--" Expr -> Expr 
+      "+" Expr -> Expr 
+      "-" Expr -> Expr  }
+
+  context-free priorities
+    { Expr ArraySubscript -> ArrayAccess 
+      Expr "." Id -> FieldAccess 
+      Expr "." TypeArgs? Id -> MethodSpec  } >
+    {right:
+      Expr "++" -> Expr 
+      Expr "--" -> Expr 
+    } >
+    { "++" Expr -> Expr 
+      "--" Expr -> Expr 
+      "+" Expr -> Expr 
+      "-" Expr -> Expr 
+      "~" Expr -> Expr 
+      "!" Expr -> Expr  } >
+    {left:
+      Expr "*" Expr -> Expr 
+      Expr "/" Expr -> Expr 
+      Expr "%" Expr -> Expr 
+    } >
+    {left:
+      Expr "+" Expr -> Expr 
+      Expr "-" Expr -> Expr 
+    } >
+    {left:
+      Expr "<<" Expr -> Expr 
+      Expr ">>" Expr -> Expr 
+      Expr ">>>" Expr -> Expr 
+    } >
+    {left:
+      Expr "instanceof" RefType -> Expr 
+      Expr "<" Expr -> Expr 
+      Expr ">" Expr -> Expr 
+      Expr "<=" Expr -> Expr 
+      Expr ">=" Expr -> Expr 
+    } >
+    {left:
+      Expr "==" Expr -> Expr 
+      Expr "!=" Expr -> Expr 
+    } >
+    Expr "&" Expr -> Expr  >
+    Expr "^" Expr -> Expr  >
+    Expr "|" Expr -> Expr  >
+    Expr "&&" Expr -> Expr  >
+    Expr "||" Expr -> Expr  >
+    Expr CondMid Expr -> Expr  >
+    {right:
+      LHS "=" Expr -> Expr 
+      LHS "*=" Expr -> Expr 
+      LHS "/=" Expr -> Expr 
+      LHS "%=" Expr -> Expr 
+      LHS "+=" Expr -> Expr 
+      LHS "-=" Expr -> Expr 
+      LHS "<<=" Expr -> Expr 
+      LHS ">>=" Expr -> Expr 
+      LHS ">>>=" Expr -> Expr 
+      LHS "&=" Expr -> Expr 
+      LHS "^=" Expr -> Expr 
+      LHS "|=" Expr -> Expr 
+    }
+
+module languages/java-15/expressions/Restrictions
+exports
+  lexical restrictions
+    "+" -/- [\+]
+    "-" -/- [\-]
+    "/" -/- [\/]
+
+module languages/java-15/expressions/AssignmentOperators
+imports languages/java-15/expressions/Main
+
+exports
+  sorts LHS
+
+  context-free syntax
+    LHS "=" Expr    -> Expr {cons("Assign")}
+    LHS "*=" Expr   -> Expr {cons("AssignMul")}
+    LHS "/=" Expr   -> Expr {cons("AssignDiv")}
+    LHS "%=" Expr   -> Expr {cons("AssignRemain")}
+    LHS "+=" Expr   -> Expr {cons("AssignPlus")}
+    LHS "-=" Expr   -> Expr {cons("AssignMinus")}
+    LHS "<<=" Expr  -> Expr {cons("AssignLeftShift")}
+    LHS ">>=" Expr  -> Expr {cons("AssignRightShift")}
+    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
+    LHS "&=" Expr   -> Expr {cons("AssignAnd")}
+    LHS "^=" Expr   -> Expr {cons("AssignExcOr")}
+    LHS "|=" Expr   -> Expr {cons("AssignOr")}
+    ExprName        -> LHS  
+    FieldAccess     -> LHS  
+    ArrayAccess     -> LHS  
+
+  context-free syntax
+    "@#$" LHS -> Expr {completion, ast("AssignOr(<1>,This)")}
+
+module languages/java-15/expressions/BinaryOperators
+imports languages/java-15/expressions/Main languages/java-15/types/Main
+
+exports
+  sorts CondMid
+
+  context-free syntax
+    Expr "instanceof" RefType -> Expr    {cons("InstanceOf")}
+    Expr "*" Expr             -> Expr    {left, cons("Mul")}
+    Expr "/" Expr             -> Expr    {left, cons("Div")}
+    Expr "%" Expr             -> Expr    {left, cons("Remain")}
+    Expr "+" Expr             -> Expr    {left, cons("Plus")}
+    Expr "-" Expr             -> Expr    {left, cons("Minus")}
+    Expr "<<" Expr            -> Expr    {left, cons("LeftShift")}
+    Expr ">>" Expr            -> Expr    {left, cons("RightShift")}
+    Expr ">>>" Expr           -> Expr    {left, cons("URightShift")}
+    Expr "<" Expr             -> Expr    {left, cons("Lt")}
+    Expr ">" Expr             -> Expr    {left, cons("Gt")}
+    Expr "<=" Expr            -> Expr    {left, cons("LtEq")}
+    Expr ">=" Expr            -> Expr    {left, cons("GtEq")}
+    Expr "==" Expr            -> Expr    {left, cons("Eq")}
+    Expr "!=" Expr            -> Expr    {left, cons("NotEq")}
+    Expr "&&" Expr            -> Expr    {left, cons("LazyAnd")}
+    Expr "||" Expr            -> Expr    {left, cons("LazyOr")}
+    Expr "&" Expr             -> Expr    {left, cons("And")}
+    Expr "^" Expr             -> Expr    {left, cons("ExcOr")}
+    Expr "|" Expr             -> Expr    {left, cons("Or")}
+    Expr CondMid Expr         -> Expr    {right, cons("Cond")}
+    "?" Expr ":"              -> CondMid {bracket}
+
+  context-free syntax
+    "@#$" Expr CondMid  -> Expr    {completion, right, ast("Cond(<1>,<2>,This)")}
+    "@#$" "?" Expr ":"? -> CondMid {completion, bracket}
+
+module languages/java-15/expressions/UnaryOperators
+imports languages/java-15/expressions/Main
+
+exports
+  context-free syntax
+    "+" Expr              -> Expr {cons("Plus")}
+    "-" Expr              -> Expr {cons("Minus")}
+    "++" Expr             -> Expr {cons("PreIncr")}
+    "--" Expr             -> Expr {cons("PreDecr")}
+    "~" Expr              -> Expr {cons("Complement")}
+    "!" Expr              -> Expr {cons("Not")}
+    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
+    "(" RefType ")" Expr  -> Expr {cons("CastRef")}
+
+  context-free syntax
+    "@#$" "(" PrimType ")"? -> Expr {completion, ast("CastPrim(<1>,This)")}
+    "@#$" "(" RefType ")"?  -> Expr {completion, ast("CastRef(<1>,This)")}
+
+module languages/java-15/expressions/Postfix
+imports languages/java-15/expressions/Main
+
+exports
+  context-free syntax
+    ExprName  -> Expr 
+    Expr "++" -> Expr {cons("PostIncr")}
+    Expr "--" -> Expr {cons("PostDecr")}
+
+  context-free syntax
+    
+
+module languages/java-15/expressions/MethodInvocation
+imports languages/java-15/expressions/Main
+
+exports
+  sorts MethodSpec
+
+  context-free syntax
+    MethodSpec "(" {Expr ","}* ")"        -> Expr       {cons("Invoke")}
+    MethodName                            -> MethodSpec {cons("Method")}
+    Expr "." TypeArgs? Id                 -> MethodSpec {cons("Method")}
+    "super" "." TypeArgs? Id              -> MethodSpec {cons("SuperMethod")}
+    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
+    AmbName "." TypeArgs Id               -> MethodSpec {cons("GenericMethod")}
+
+  context-free syntax
+    "@#$" MethodSpec "(" {Expr ","}* ")"?    -> Expr       {completion, cons("Invoke")}
+    "@#$" MethodSpec                         -> Expr       {completion, ast("Invoke(<1>,[])")}
+    "@#$" Expr "." TypeArgs?                 -> MethodSpec {completion, ast("Method(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" Expr                               -> MethodSpec {completion, ast("Method(<1>,None,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" "super" "." TypeArgs?              -> MethodSpec {completion, ast("SuperMethod(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" TypeName "." "super" "." TypeArgs? -> MethodSpec {completion, ast("QSuperMethod(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" TypeName                           -> MethodSpec {completion, ast("QSuperMethod(<1>,None,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName "." TypeArgs               -> MethodSpec {completion, ast("GenericMethod(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName                            -> MethodSpec {completion, ast("GenericMethod(<1>,TypeArgs([Wildcard(None)]),FromMetaExpr(ToMetaExpr(This)))")}
+
+  context-free priorities
+    Expr "." TypeArgs? Id -> MethodSpec  >
+    ExprName -> Expr 
+
+module languages/java-15/expressions/ArrayAccess
+imports languages/java-15/expressions/Main
+
+exports
+  sorts ArrayAccess ArraySubscript
+
+  context-free syntax
+    ArrayAccess                      -> Expr           
+    Expr ArraySubscript              -> ArrayAccess    {cons("ArrayAccess")}
+    "[" Expr "]"                     -> ArraySubscript {bracket}
+    ArrayCreationExpr ArraySubscript -> ArrayAccess    {reject}
+
+  context-free syntax
+    "@#$" Expr          -> ArrayAccess    {completion, ast("ArrayAccess(<1>,This)")}
+    "@#$" "[" Expr "]"? -> ArraySubscript {completion, bracket}
+
+module languages/java-15/expressions/FieldAccess
+imports languages/java-15/expressions/Main
+
+exports
+  sorts FieldAccess
+
+  context-free syntax
+    FieldAccess -> Expr 
+
+  context-free syntax
+    
+
+  context-free syntax
+    Expr "." Id                 -> FieldAccess {cons("Field")}
+    ExprName "." Id             -> FieldAccess {reject}
+    "super" "." Id              -> FieldAccess {cons("SuperField")}
+    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}
+
+  context-free syntax
+    "@#$" Expr     -> FieldAccess {completion, ast("Field(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" TypeName -> FieldAccess {completion, ast("QSuperField(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+
+module languages/java-15/expressions/ArrayCreation
+imports languages/java-15/expressions/Main
+
+exports
+  sorts ArrayCreationExpr ArrayBaseType Dim DimExpr
+
+  context-free syntax
+    ArrayCreationExpr                  -> Expr              
+    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
+    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}
+    PrimType                           -> ArrayBaseType     
+    TypeName                           -> ArrayBaseType     
+    TypeName "<" "?" ">"               -> ArrayBaseType     {cons("UnboundWld")}
+    "[" Expr "]"                       -> DimExpr           {cons("Dim")}
+    "[" "]"                            -> Dim               {cons("Dim")}
+
+  context-free syntax
+    "@#$" "new" ArrayBaseType Dim+ -> ArrayCreationExpr {completion, ast("NewArray(<1>,<2>,ArrayInit([]))")}
+    "@#$" "new" ArrayBaseType      -> ArrayCreationExpr {completion, ast("NewArray(<1>,[Dim],ArrayInit([]))")}
+    "@#$" "[" Expr "]"?            -> DimExpr           {completion, cons("Dim")}
+
+module languages/java-15/expressions/ClassInstanceCreation
+imports languages/java-15/expressions/Main
+        languages/java-15/classes/ClassDeclarations
+
+exports
+  context-free syntax
+    "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody?  -> Expr {cons("NewInstance")}
+    Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}
+
+  context-free syntax
+    "@#$" "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")"?  -> Expr {completion, ast("NewInstance(<1>,<2>,<3>,None)")}
+    "@#$" "new" TypeArgs? ClassOrInterfaceType "("? ")"?             -> Expr {completion, ast("NewInstance(<1>,<2>,[],None)")}
+    "@#$" "new" TypeArgs? "("? ")"?                                  -> Expr {completion, ast("NewInstance(<1>,ClassOrInterfaceType(TypeName(FromMetaExpr(ToMetaExpr(This))),None),[],None)")}
+    "@#$" Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")"? -> Expr {completion, ast("QNewInstance(<1>,<2>,<3>,<4>,<5>,None)")}
+    "@#$" Expr "." "new" TypeArgs? Id TypeArgs? "("? ")"?            -> Expr {completion, ast("QNewInstance(<1>,<2>,<3>,<4>,[],None)")}
+    "@#$" Expr "." "new" TypeArgs? Id "("? ")"?                      -> Expr {completion, ast("QNewInstance(<1>,<2>,<3>,None,[],None)")}
+    "@#$" Expr "." "new" TypeArgs? "("? ")"?                         -> Expr {completion, ast("QNewInstance(<1>,<2>,FromMetaExpr(ToMetaExpr(This)),None,[],None)")}
+
+module languages/java-15/expressions/Primary
+imports languages/java-15/lexical/literals/Main languages/java-15/names/Main
+        languages/java-15/expressions/Main
+
+exports
+  sorts Literal
+
+  context-free syntax
+    Literal       -> Expr    {cons("Lit")}
+    IntLiteral    -> Literal 
+    FloatLiteral  -> Literal 
+    BoolLiteral   -> Literal 
+    CharLiteral   -> Literal 
+    StringLiteral -> Literal 
+    NullLiteral   -> Literal 
+
+  context-free syntax
+    
+
+  sorts ClassLiteral
+
+  context-free syntax
+    ClassLiteral       -> Literal      
+    Type "." "class"   -> ClassLiteral {cons("Class")}
+    "void" "." "class" -> ClassLiteral {cons("VoidClass")}
+
+  context-free syntax
+    "@#$" Type -> ClassLiteral {completion, cons("Class")}
+
+  context-free syntax
+    "this"              -> Expr {cons("This")}
+    TypeName "." "this" -> Expr {cons("QThis")}
+
+  context-free syntax
+    "@#$" TypeName -> Expr {completion, cons("QThis")}
+
+  context-free syntax
+    "(" Expr ")" -> Expr {bracket}
+
+  context-free syntax
+    "@#$" "(" Expr ")"? -> Expr {completion, bracket}
+
+module languages/java-15/expressions/Main
+imports languages/java-15/expressions/Primary
+        languages/java-15/expressions/ClassInstanceCreation
+        languages/java-15/expressions/ArrayCreation
+        languages/java-15/expressions/FieldAccess
+        languages/java-15/expressions/ArrayAccess
+        languages/java-15/expressions/MethodInvocation
+        languages/java-15/expressions/Postfix
+        languages/java-15/expressions/UnaryOperators
+        languages/java-15/expressions/BinaryOperators
+        languages/java-15/expressions/AssignmentOperators
+        languages/java-15/expressions/Restrictions
+        languages/java-15/expressions/Priorities
+
+exports
+  sorts Expr
+
+module languages/java-15/statements/Main
+imports languages/java-15/statements/Blocks
+        languages/java-15/statements/LocalVariableDeclarations
+        languages/java-15/statements/Statements
+
+module languages/java-15/arrays/Main
+imports languages/java-15/arrays/ArrayInitializers
+
+module languages/java-15/interfaces/Main
+imports languages/java-15/interfaces/InterfaceDeclarations
+        languages/java-15/interfaces/AbstractMethodDeclarations
+        languages/java-15/interfaces/AnnotationTypes
+        languages/java-15/interfaces/Annotations
+
+module languages/java-15/classes/Main
+imports languages/java-15/classes/ClassDeclarations
+        languages/java-15/classes/EnumDeclarations
+
+module languages/java-15/packages/PackageDeclarations
+imports languages/java-15/names/Main languages/java-15/interfaces/Annotations
+
+exports
+  sorts PackageDec
+
+  context-free syntax
+    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}
+
+  context-free syntax
+    "@#$" Anno* "package" PackageName ";"? -> PackageDec {completion, cons("PackageDec")}
+    "@#$" Anno*                            -> PackageDec {completion, ast("PackageDec(<1>,PackageName([FromMetaExpr(ToMetaExpr(This))]))")}
+
+module languages/java-15/packages/ImportDeclarations
+imports languages/java-15/lexical/Identifiers languages/java-15/names/Main
+
+exports
+  sorts ImportDec
+
+  context-free syntax
+    "import" TypeName ";"                  -> ImportDec {cons("TypeImportDec")}
+    "import" PackageName "." "*" ";"       -> ImportDec {cons("TypeImportOnDemandDec")}
+    "import" "static" TypeName "." Id ";"  -> ImportDec {cons("StaticImportDec")}
+    "import" "static" TypeName "." "*" ";" -> ImportDec {cons("StaticImportOnDemandDec")}
+
+  context-free syntax
+    "@#$" "import" TypeName ";"?                    -> ImportDec {completion, cons("TypeImportDec")}
+    "@#$" "import" PackageName "."? "*"? ";"?       -> ImportDec {completion, cons("TypeImportOnDemandDec")}
+    "@#$" "import" "static" TypeName "." Id ";"?    -> ImportDec {completion, cons("StaticImportDec")}
+    "@#$" "import" "static" TypeName "."? ";"?      -> ImportDec {completion, ast("StaticImportDec(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" "import" "static" TypeName "."? "*"? ";"? -> ImportDec {completion, cons("StaticImportOnDemandDec")}
+
+module languages/java-15/interfaces/AnnotationTypes
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/classes/ClassDeclarations
+        languages/java-15/classes/EnumDeclarations
+        languages/java-15/interfaces/InterfaceDeclarations
+        languages/java-15/interfaces/AbstractMethodDeclarations
+        languages/java-15/interfaces/ConstantDeclarations
+        languages/java-15/interfaces/Annotations
+
+exports
+  sorts AnnoDec AnnoDecHead
+
+  context-free syntax
+    AnnoDecHead "{" AnnoElemDec* "}"            -> AnnoDec     {cons("AnnoDec")}
+    ( Anno | InterfaceMod )* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}
+
+  context-free syntax
+    "@#$" AnnoDecHead "{" AnnoElemDec* "}"? -> AnnoDec     {completion, cons("AnnoDec")}
+    "@#$" AnnoDecHead                       -> AnnoDec     {completion, ast("AnnoDec(<1>,[])")}
+    "@#$" ( Anno | InterfaceMod )*          -> AnnoDecHead {completion, ast("AnnoDecHead(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+
+  sorts AnnoElemDec DefaultVal
+
+  context-free syntax
+    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}
+    ConstantDec                                        -> AnnoElemDec 
+    ClassDec                                           -> AnnoElemDec 
+    InterfaceDec                                       -> AnnoElemDec 
+    EnumDec                                            -> AnnoElemDec 
+    AnnoDec                                            -> AnnoElemDec 
+    ";"                                                -> AnnoElemDec {cons("Semicolon")}
+    "default" ElemVal                                  -> DefaultVal  {cons("DefaultVal")}
+
+  context-free syntax
+    "@#$" AbstractMethodMod* Type Id "(" ")" DefaultVal? ";"? -> AnnoElemDec {completion, cons("AnnoMethodDec")}
+    "@#$" AbstractMethodMod* Type Id                          -> AnnoElemDec {completion, ast("AnnoMethodDec(<1>,<2>,<3>,None)")}
+    "@#$" AbstractMethodMod* Type                             -> AnnoElemDec {completion, ast("AnnoMethodDec(<1>,<2>,FromMetaExpr(ToMetaExpr(This)),None)")}
+    "@#$" AbstractMethodMod*                                  -> AnnoElemDec {completion, ast("AnnoMethodDec(<1>,Boolean,FromMetaExpr(ToMetaExpr(This)),None)")}
+
+module languages/java-15/interfaces/AbstractMethodDeclarations
+imports languages/java-15/lexical/Modifiers languages/java-15/names/Main
+        languages/java-15/types/Main
+        languages/java-15/classes/MethodDeclarations
+
+exports
+  sorts AbstractMethodDec AbstractMethodMod
+
+  context-free syntax
+    ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";"      -> AbstractMethodDec {cons("AbstractMethodDec")}
+    ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}
+    Public                                                                                              -> AbstractMethodMod 
+    Abstract                                                                                            -> AbstractMethodMod 
+
+  context-free syntax
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";"?      -> AbstractMethodDec {completion, cons("AbstractMethodDec")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";"? -> AbstractMethodDec {completion, cons("DeprAbstractMethodDec")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ ";"?         -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,<4>,<5>,<6>,None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")"? ";"?             -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,<4>,<5>,[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id                                              -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,<4>,[],[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType                                                 -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams?                                                            -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )*                                                                        -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,None,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+
+module languages/java-15/interfaces/ConstantDeclarations
+imports languages/java-15/lexical/Modifiers languages/java-15/types/Main
+        languages/java-15/classes/MethodDeclarations
+        languages/java-15/interfaces/Annotations
+
+exports
+  sorts ConstantDec ConstantMod
+
+  context-free syntax
+    ( Anno | ConstantMod )* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}
+    Public                                         -> ConstantMod 
+    Static                                         -> ConstantMod 
+    Final                                          -> ConstantMod 
+
+  context-free syntax
+    "@#$" ( Anno | ConstantMod )* Type {VarDec ","}+ -> ConstantDec {completion, cons("ConstantDec")}
+    "@#$" ( Anno | ConstantMod )* Type               -> ConstantDec {completion, ast("ConstantDec(<1>,<2>,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+    "@#$" ( Anno | ConstantMod )*                    -> ConstantDec {completion, ast("ConstantDec(<1>,Boolean,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+
+module languages/java-15/interfaces/InterfaceDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers languages/java-15/names/Main
+        languages/java-15/types/Main languages/java-15/classes/ClassDeclarations
+        languages/java-15/classes/MethodDeclarations
+        languages/java-15/interfaces/ConstantDeclarations
+        languages/java-15/interfaces/AbstractMethodDeclarations
+        languages/java-15/interfaces/AnnotationTypes
+        languages/java-15/interfaces/Annotations
+
+exports
+  sorts InterfaceDec InterfaceDecHead ExtendsInterfaces InterfaceMemberDec
+        InterfaceMod
+
+  context-free syntax
+    AnnoDec                                                                -> InterfaceDec      
+    InterfaceDecHead "{" InterfaceMemberDec* "}"                           -> InterfaceDec      {cons("InterfaceDec")}
+    ( Anno | InterfaceMod )* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead  {cons("InterfaceDecHead")}
+    "extends" {InterfaceType ","}+                                         -> ExtendsInterfaces {cons("ExtendsInterfaces")}
+
+  context-free syntax
+    "@#$" InterfaceDecHead "{" InterfaceMemberDec* "}"? -> InterfaceDec     {completion, cons("InterfaceDec")}
+    "@#$" InterfaceDecHead                              -> InterfaceDec     {completion, ast("InterfaceDec(<1>,[])")}
+    "@#$" ( Anno | InterfaceMod )*                      -> InterfaceDecHead {completion, ast("InterfaceDecHead(<1>,FromMetaExpr(ToMetaExpr(This)),None,None)")}
+
+  context-free syntax
+    ConstantDec       -> InterfaceMemberDec 
+    AbstractMethodDec -> InterfaceMemberDec 
+    ClassDec          -> InterfaceMemberDec 
+    InterfaceDec      -> InterfaceMemberDec 
+    ";"               -> InterfaceMemberDec {cons("Semicolon")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    Public    -> InterfaceMod 
+    Protected -> InterfaceMod 
+    Private   -> InterfaceMod 
+    Abstract  -> InterfaceMod 
+    Static    -> InterfaceMod 
+    StrictFP  -> InterfaceMod 
+
+  context-free syntax
+    
+
+module languages/java-15/classes/EnumDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/classes/ClassDeclarations
+
+exports
+  sorts EnumDec EnumDecHead EnumBody EnumConst EnumConstArgs EnumBodyDecs
+
+  context-free syntax
+    EnumDecHead EnumBody                       -> EnumDec       {cons("EnumDec")}
+    ( Anno | ClassMod )* "enum" Id Interfaces? -> EnumDecHead   {cons("EnumDecHead")}
+    "{" {EnumConst ","}* EnumBodyDecs? "}"     -> EnumBody      {cons("EnumBody")}
+    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody      {cons("EnumBody")}
+    Id EnumConstArgs? ClassBody?               -> EnumConst     {cons("EnumConst")}
+    "(" {Expr ","}* ")"                        -> EnumConstArgs {bracket}
+    ";" ClassBodyDec*                          -> EnumBodyDecs  {cons("EnumBodyDecs")}
+
+  context-free syntax
+    "@#$" EnumDecHead                                 -> EnumDec       {completion, ast("EnumDec(<1>,EnumBody([],None))")}
+    "@#$" ( Anno | ClassMod )*                        -> EnumDecHead   {completion, ast("EnumDecHead(<1>,FromMetaExpr(ToMetaExpr(This)),None)")}
+    "@#$" "{" {EnumConst ","}* EnumBodyDecs? "}"?     -> EnumBody      {completion, cons("EnumBody")}
+    "@#$" "{" {EnumConst ","}* "}"?                   -> EnumBody      {completion, ast("EnumBody(<1>,None)")}
+    "@#$" "{" {EnumConst ","}* "," EnumBodyDecs? "}"? -> EnumBody      {completion, cons("EnumBody")}
+    "@#$" "{" {EnumConst ","}* ","? "}"?              -> EnumBody      {completion, ast("EnumBody(<1>,None)")}
+    "@#$" "(" {Expr ","}* ")"?                        -> EnumConstArgs {completion, bracket}
+
+module languages/java-15/classes/ConstructorDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers
+        languages/java-15/interfaces/Annotations
+        languages/java-15/statements/Main languages/java-15/expressions/Main
+
+exports
+  sorts ConstrDec ConstrBody ConstrHead ConstrInv
+
+  context-free syntax
+    ConstrHead ConstrBody                                                   -> ConstrDec  {cons("ConstrDec")}
+    ( Anno | ConstrMod )* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}
+    "{" ConstrInv? BlockStm* "}"                                            -> ConstrBody {cons("ConstrBody")}
+    TypeArgs? "this" "(" {Expr ","}* ")" ";"                                -> ConstrInv  {cons("AltConstrInv")}
+    TypeArgs? "super" "(" {Expr ","}* ")" ";"                               -> ConstrInv  {cons("SuperConstrInv")}
+    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";"                      -> ConstrInv  {cons("QSuperConstrInv")}
+
+  context-free syntax
+    "@#$" ConstrHead                                                       -> ConstrDec  {completion, ast("ConstrDec(<1>,ConstrBody(None,[]))")}
+    "@#$" ( Anno | ConstrMod )* TypeParams? Id "(" {FormalParam ","}* ")"? -> ConstrHead {completion, ast("ConstrDecHead(<1>,<2>,<3>,<4>,None)")}
+    "@#$" ( Anno | ConstrMod )* TypeParams? Id                             -> ConstrHead {completion, ast("ConstrDecHead(<1>,<2>,<3>,[],None)")}
+    "@#$" ( Anno | ConstrMod )* TypeParams?                                -> ConstrHead {completion, ast("ConstrDecHead(<1>,<2>,FromMetaExpr(ToMetaExpr(This)),[],None)")}
+    "@#$" ( Anno | ConstrMod )*                                            -> ConstrHead {completion, ast("ConstrDecHead(<1>,None,FromMetaExpr(ToMetaExpr(This)),[],None)")}
+    "@#$" "{" ConstrInv? BlockStm* "}"?                                    -> ConstrBody {completion, cons("ConstrBody")}
+    "@#$" "{" ConstrInv? "}"?                                              -> ConstrBody {completion, ast("ConstrBody(<1>,[])")}
+    "@#$" TypeArgs? "this" "(" {Expr ","}* ")"? ";"?                       -> ConstrInv  {completion, cons("AltConstrInv")}
+    "@#$" TypeArgs? "super" "(" {Expr ","}* ")"? ";"?                      -> ConstrInv  {completion, cons("SuperConstrInv")}
+    "@#$" TypeArgs?                                                        -> ConstrInv  {completion, ast("SuperConstrInv(<1>,[])")}
+    "@#$" Expr "." TypeArgs? "super" "(" {Expr ","}* ")"? ";"?             -> ConstrInv  {completion, cons("QSuperConstrInv")}
+    "@#$" Expr "." TypeArgs? "super"? "("? ")"? ";"?                       -> ConstrInv  {completion, ast("QSuperConstrInv(<1>,<2>,[])")}
+    "@#$" Expr                                                             -> ConstrInv  {completion, ast("QSuperConstrInv(<1>,None,[])")}
+
+  sorts ConstrMod
+
+  context-free syntax
+    Public    -> ConstrMod 
+    Protected -> ConstrMod 
+    Private   -> ConstrMod 
+
+  context-free syntax
+    
+
+module languages/java-15/classes/StaticInitializers
+imports languages/java-15/statements/Blocks
+
+exports
+  sorts StaticInit
+
+  context-free syntax
+    "static" Block -> StaticInit {cons("StaticInit")}
+
+  context-free syntax
+    
+
+module languages/java-15/classes/InstanceInitializers
+imports languages/java-15/statements/Blocks
+
+exports
+  sorts InstanceInit
+
+  context-free syntax
+    Block -> InstanceInit {cons("InstanceInit")}
+
+  context-free syntax
+    
+
+module languages/java-15/statements/Statements
+imports languages/java-15/statements/LocalVariableDeclarations
+        languages/java-15/statements/Blocks languages/java-15/expressions/Main
+
+exports
+  sorts Stm ExprStm
+
+  context-free syntax
+    Block -> Stm 
+
+  context-free syntax
+    
+
+  context-free syntax
+    ";" -> Stm {cons("Empty")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    Id ":" Stm -> Stm {cons("Labeled")}
+
+  context-free syntax
+    "@#$" Id -> Stm {completion, ast("Labeled(<1>,Empty)")}
+
+  context-free syntax
+    Expr ";" -> ExprStm {cons("ExprStm")}
+    ExprStm  -> Stm     
+
+  context-free syntax
+    "@#$" Expr -> ExprStm {completion, cons("ExprStm")}
+
+  context-free syntax
+    "if" "(" Expr ")" Stm            -> Stm {prefer, cons("If")}
+    "if" "(" Expr ")" Stm "else" Stm -> Stm {cons("If")}
+
+  context-free syntax
+    "@#$" "if" "(" Expr ")"?            -> Stm {completion, prefer, ast("If(<1>,Empty)")}
+    "@#$" "if" "(" Expr ")" Stm "else"? -> Stm {completion, ast("If(<1>,<2>,Empty)")}
+    "@#$" "if" "(" Expr ")"? "else"?    -> Stm {completion, ast("If(<1>,Empty,Empty)")}
+
+  context-free syntax
+    "assert" Expr ";"          -> Stm {cons("AssertStm")}
+    "assert" Expr ":" Expr ";" -> Stm {cons("AssertStm")}
+
+  context-free syntax
+    "@#$" "assert" Expr ";"?          -> Stm {completion, cons("AssertStm")}
+    "@#$" "assert" Expr ":" Expr ";"? -> Stm {completion, cons("AssertStm")}
+    "@#$" "assert" Expr ":"? ";"?     -> Stm {completion, ast("AssertStm(<1>,This)")}
+
+  sorts SwitchBlock SwitchGroup SwitchLabel
+
+  context-free syntax
+    "switch" "(" Expr ")" SwitchBlock -> Stm         {cons("Switch")}
+    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
+    SwitchLabel+ BlockStm+            -> SwitchGroup {cons("SwitchGroup")}
+    "case" Expr ":"                   -> SwitchLabel {cons("Case")}
+    "default" ":"                     -> SwitchLabel {cons("Default")}
+
+  context-free syntax
+    "@#$" "switch" "(" Expr ")"?             -> Stm         {completion, ast("Switch(<1>,SwitchBlock([],[]))")}
+    "@#$" "{" SwitchGroup* SwitchLabel* "}"? -> SwitchBlock {completion, cons("SwitchBlock")}
+    "@#$" "{" SwitchGroup* "}"?              -> SwitchBlock {completion, ast("SwitchBlock(<1>,[])")}
+    "@#$" SwitchLabel+                       -> SwitchGroup {completion, ast("SwitchGroup(<1>,[Empty])")}
+    "@#$" "case" Expr ":"?                   -> SwitchLabel {completion, cons("Case")}
+
+  context-free syntax
+    "while" "(" Expr ")" Stm -> Stm {cons("While")}
+
+  context-free syntax
+    "@#$" "while" "(" Expr ")"? -> Stm {completion, ast("While(<1>,Empty)")}
+
+  context-free syntax
+    "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}
+
+  context-free syntax
+    "@#$" "do" Stm "while" "(" Expr ")"? ";"? -> Stm {completion, cons("DoWhile")}
+    "@#$" "do" Stm "while"? "("? ")"? ";"?    -> Stm {completion, ast("DoWhile(<1>,This)")}
+
+  context-free syntax
+    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+    "for" "(" FormalParam ":" Expr ")" Stm                  -> Stm {cons("ForEach")}
+
+  context-free syntax
+    "@#$" "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")"? -> Stm {completion, ast("For(<1>,<2>,<3>,Empty)")}
+    "@#$" "for" "(" LocalVarDec ";" Expr? ";"? ")"?            -> Stm {completion, ast("For(<1>,<2>,[],Empty)")}
+    "@#$" "for" "(" LocalVarDec ";"? ";"? ")"?                 -> Stm {completion, ast("For(<1>,None,[],Empty)")}
+    "@#$" "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")"? -> Stm {completion, ast("For(<1>,<2>,<3>,Empty)")}
+    "@#$" "for" "(" {Expr ","}* ";" Expr? ";"? ")"?            -> Stm {completion, ast("For(<1>,<2>,[],Empty)")}
+    "@#$" "for" "(" {Expr ","}* ";"? ";"? ")"?                 -> Stm {completion, ast("For(<1>,None,[],Empty)")}
+    "@#$" "for" "(" FormalParam ":" Expr ")"?                  -> Stm {completion, ast("ForEach(<1>,<2>,Empty)")}
+    "@#$" "for" "(" FormalParam ":"? ")"?                      -> Stm {completion, ast("ForEach(<1>,This,Empty)")}
+
+  context-free syntax
+    "break" Id? ";" -> Stm {cons("Break")}
+
+  context-free syntax
+    "@#$" "break" Id? ";"? -> Stm {completion, cons("Break")}
+
+  context-free syntax
+    "continue" Id? ";" -> Stm {cons("Continue")}
+
+  context-free syntax
+    "@#$" "continue" Id? ";"? -> Stm {completion, cons("Continue")}
+
+  context-free syntax
+    "return" Expr? ";" -> Stm {cons("Return")}
+
+  context-free syntax
+    "@#$" "return" Expr? ";"? -> Stm {completion, cons("Return")}
+
+  context-free syntax
+    "throw" Expr ";" -> Stm {cons("Throw")}
+
+  context-free syntax
+    "@#$" "throw" Expr ";"? -> Stm {completion, cons("Throw")}
+
+  context-free syntax
+    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}
+
+  context-free syntax
+    "@#$" "synchronized" "(" Expr ")"? -> Stm {completion, ast("Synchronized(<1>,Block([]))")}
+
+  sorts CatchClause
+
+  context-free syntax
+    "try" Block CatchClause+                 -> Stm         {cons("Try")}
+    "try" Block CatchClause* "finally" Block -> Stm         {cons("Try")}
+    "catch" "(" FormalParam ")" Block        -> CatchClause {cons("Catch")}
+
+  context-free syntax
+    "@#$" "try" Block                         -> Stm         {completion, ast("Try(<1>,[Catch(FromMetaExpr(ToMetaExpr(This)),Block([]))])")}
+    "@#$" "try" Block CatchClause* "finally"? -> Stm         {completion, ast("Try(<1>,<2>,Block([]))")}
+    "@#$" "try" Block "finally"?              -> Stm         {completion, ast("Try(<1>,[],Block([]))")}
+    "@#$" "catch" "(" FormalParam ")"?        -> CatchClause {completion, ast("Catch(<1>,Block([]))")}
+
+module languages/java-15/statements/LocalVariableDeclarations
+imports languages/java-15/classes/MethodDeclarations
+        languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts LocalVarDecStm LocalVarDec
+
+  context-free syntax
+    LocalVarDec ";"                       -> LocalVarDecStm {cons("LocalVarDecStm")}
+    ( Anno | VarMod )* Type {VarDec ","}+ -> LocalVarDec    {cons("LocalVarDec")}
+    Expr "<" Expr ">" Expr ";"            -> ExprStm        {reject}
+
+  context-free syntax
+    "@#$" LocalVarDec             -> LocalVarDecStm {completion, cons("LocalVarDecStm")}
+    "@#$" ( Anno | VarMod )* Type -> LocalVarDec    {completion, ast("LocalVarDec(<1>,<2>,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+    "@#$" ( Anno | VarMod )*      -> LocalVarDec    {completion, ast("LocalVarDec(<1>,Boolean,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+
+module languages/java-15/statements/Blocks
+imports languages/java-15/classes/ClassDeclarations
+        languages/java-15/statements/LocalVariableDeclarations
+        languages/java-15/statements/Statements
+
+exports
+  sorts BlockStm Block
+
+  context-free syntax
+    "{" BlockStm* "}" -> Block    {cons("Block")}
+    LocalVarDecStm    -> BlockStm 
+    ClassDec          -> BlockStm {cons("ClassDecStm")}
+    Stm               -> BlockStm 
+
+  context-free syntax
+    "@#$" "{" BlockStm* "}"? -> Block {completion, cons("Block")}
+
+module languages/java-15/classes/MethodDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers languages/java-15/types/Main
+        languages/java-15/classes/FieldDeclarations
+        languages/java-15/interfaces/Annotations
+        languages/java-15/statements/Blocks
+
+exports
+  sorts MethodDec MethodDecHead ResultType
+
+  context-free syntax
+    MethodDecHead MethodBody                                                                -> MethodDec     {cons("MethodDec")}
+    ( Anno | MethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
+    ( Anno | MethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}
+    Type                                                                                    -> ResultType    
+    "void"                                                                                  -> ResultType    {cons("Void")}
+
+  context-free syntax
+    "@#$" MethodDecHead                                                               -> MethodDec     {completion, ast("MethodDec(<1>,Block([]))")}
+    "@#$" ( Anno | MethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")"? -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,<3>,<4>,<5>,[Dim],None)")}
+    "@#$" ( Anno | MethodMod )* TypeParams? ResultType Id                             -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,<3>,<4>,[],[Dim],None)")}
+    "@#$" ( Anno | MethodMod )* TypeParams? ResultType                                -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,<3>,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | MethodMod )* TypeParams?                                           -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | MethodMod )*                                                       -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,None,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+
+  sorts FormalParam
+
+  context-free syntax
+    ( Anno | VarMod )* Type VarDecId       -> FormalParam {cons("Param")}
+    ( Anno | VarMod )* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}
+
+  context-free syntax
+    "@#$" ( Anno | VarMod )* Type -> FormalParam {completion, ast("VarArityParam(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" ( Anno | VarMod )*      -> FormalParam {completion, ast("VarArityParam(<1>,Boolean,FromMetaExpr(ToMetaExpr(This)))")}
+
+  sorts VarMod
+
+  context-free syntax
+    Final -> VarMod 
+
+  context-free syntax
+    
+
+  sorts MethodMod
+
+  context-free syntax
+    Public       -> MethodMod 
+    Protected    -> MethodMod 
+    Private      -> MethodMod 
+    Abstract     -> MethodMod 
+    Static       -> MethodMod 
+    Final        -> MethodMod 
+    Synchronized -> MethodMod 
+    Native       -> MethodMod 
+    StrictFP     -> MethodMod 
+
+  context-free syntax
+    
+
+  sorts Throws ExceptionType
+
+  context-free syntax
+    "throws" {ExceptionType ","}+ -> Throws        {cons("ThrowsDec")}
+    ClassType                     -> ExceptionType 
+
+  context-free syntax
+    
+
+  sorts MethodBody
+
+  context-free syntax
+    Block -> MethodBody 
+    ";"   -> MethodBody {cons("NoMethodBody")}
+
+  context-free syntax
+    
+
+module languages/java-15/arrays/ArrayInitializers
+imports languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts ArrayInit
+
+  context-free syntax
+    "{" {VarInit ","}* "}"     -> ArrayInit {cons("ArrayInit")}
+    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}
+
+  context-free syntax
+    "@#$" "{" {VarInit ","}* "}"?      -> ArrayInit {completion, cons("ArrayInit")}
+    "@#$" "{" {VarInit ","}* ","? "}"? -> ArrayInit {completion, cons("ArrayInit")}
+
+module languages/java-15/interfaces/Annotations
+imports languages/java-15/lexical/Identifiers languages/java-15/names/Main
+        languages/java-15/expressions/Main
+
+exports
+  sorts Anno ElemVal ElemValPair
+
+  context-free syntax
+    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
+    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
+    "@" TypeName                            -> Anno {cons("MarkerAnno")}
+
+  context-free syntax
+    "@#$" "@" TypeName "(" {ElemValPair ","}* ")"? -> Anno {completion, cons("Anno")}
+    "@#$" "@" TypeName "(" ElemVal ")"?            -> Anno {completion, cons("SingleElemAnno")}
+    "@#$" "@" TypeName "("? ")"?                   -> Anno {completion, ast("SingleElemAnno(<1>,This)")}
+
+  context-free syntax
+    Id "=" ElemVal             -> ElemValPair {cons("ElemValPair")}
+    Expr                       -> ElemVal     
+    Anno                       -> ElemVal     
+    "{" {ElemVal ","}* "}"     -> ElemVal     {cons("ElemValArrayInit")}
+    "{" {ElemVal ","}* "," "}" -> ElemVal     {cons("ElemValArrayInit")}
+    LHS "=" Expr               -> ElemVal     {reject}
+
+  context-free syntax
+    "@#$" Id                           -> ElemValPair {completion, ast("ElemValPair(<1>,This)")}
+    "@#$" "{" {ElemVal ","}* "}"?      -> ElemVal     {completion, cons("ElemValArrayInit")}
+    "@#$" "{" {ElemVal ","}* ","? "}"? -> ElemVal     {completion, cons("ElemValArrayInit")}
+
+module languages/java-15/classes/FieldDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers languages/java-15/types/Main
+        languages/java-15/interfaces/Annotations
+        languages/java-15/arrays/ArrayInitializers
+        languages/java-15/expressions/Main
+
+exports
+  sorts FieldDec VarDec VarDecId Dim VarInit
+
+  context-free syntax
+    ( Anno | FieldMod )* Type {VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}
+    VarDecId                                    -> VarDec   {cons("VarDec")}
+    VarDecId "=" VarInit                        -> VarDec   {cons("VarDec")}
+    Id                                          -> VarDecId 
+    Id Dim+                                     -> VarDecId {cons("ArrayVarDecId")}
+    "[" "]"                                     -> Dim      {cons("Dim")}
+    Expr                                        -> VarInit  
+    ArrayInit                                   -> VarInit  
+
+  context-free syntax
+    "@#$" ( Anno | FieldMod )* Type {VarDec ","}+ -> FieldDec {completion, cons("FieldDec")}
+    "@#$" ( Anno | FieldMod )* Type               -> FieldDec {completion, ast("FieldDec(<1>,<2>,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+    "@#$" ( Anno | FieldMod )*                    -> FieldDec {completion, ast("FieldDec(<1>,Boolean,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+
+  sorts FieldMod
+
+  context-free syntax
+    Public    -> FieldMod 
+    Protected -> FieldMod 
+    Private   -> FieldMod 
+    Static    -> FieldMod 
+    Final     -> FieldMod 
+    Transient -> FieldMod 
+    Volatile  -> FieldMod 
+
+  context-free syntax
+    
+
+module languages/java-15/classes/ClassDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers
+        languages/java-15/types/ReferenceTypes
+        languages/java-15/types/TypeVariables
+        languages/java-15/classes/FieldDeclarations
+        languages/java-15/classes/MethodDeclarations
+        languages/java-15/classes/InstanceInitializers
+        languages/java-15/classes/StaticInitializers
+        languages/java-15/classes/ConstructorDeclarations
+        languages/java-15/classes/EnumDeclarations
+        languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts ClassDec ClassBody ClassDecHead
+
+  context-free syntax
+    EnumDec                                                        -> ClassDec     
+    ClassDecHead ClassBody                                         -> ClassDec     {cons("ClassDec")}
+    "{" ClassBodyDec* "}"                                          -> ClassBody    {cons("ClassBody")}
+    ( Anno | ClassMod )* "class" Id TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}
+
+  context-free syntax
+    "@#$" ClassDecHead           -> ClassDec     {completion, ast("ClassDec(<1>,ClassBody([]))")}
+    "@#$" "{" ClassBodyDec* "}"? -> ClassBody    {completion, cons("ClassBody")}
+    "@#$" ( Anno | ClassMod )*   -> ClassDecHead {completion, ast("ClassDecHead(<1>,FromMetaExpr(ToMetaExpr(This)),None,None,None)")}
+
+  sorts ClassMod
+
+  context-free syntax
+    Abstract  -> ClassMod 
+    Public    -> ClassMod 
+    Protected -> ClassMod 
+    Private   -> ClassMod 
+    Static    -> ClassMod 
+    Final     -> ClassMod 
+    StrictFP  -> ClassMod 
+
+  context-free syntax
+    
+
+  sorts Super
+
+  context-free syntax
+    "extends" ClassType -> Super {cons("SuperDec")}
+
+  context-free syntax
+    
+
+  sorts Interfaces
+
+  context-free syntax
+    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}
+
+  context-free syntax
+    
+
+  sorts ClassBodyDec ClassMemberDec
+
+  context-free syntax
+    ClassMemberDec -> ClassBodyDec 
+    InstanceInit   -> ClassBodyDec 
+    StaticInit     -> ClassBodyDec 
+    ConstrDec      -> ClassBodyDec 
+
+  context-free syntax
+    
+
+  context-free syntax
+    FieldDec     -> ClassMemberDec 
+    MethodDec    -> ClassMemberDec 
+    ClassDec     -> ClassMemberDec 
+    InterfaceDec -> ClassMemberDec 
+    ";"          -> ClassMemberDec {cons("Semicolon")}
+
+  context-free syntax
+    
+
+module languages/java-15/packages/TypeDeclarations
+imports languages/java-15/classes/ClassDeclarations
+        languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts TypeDec
+
+  context-free syntax
+    ClassDec     -> TypeDec 
+    InterfaceDec -> TypeDec 
+    ";"          -> TypeDec {cons("Semicolon")}
+
+  context-free syntax
+    
+
+module languages/java-15/packages/CompilationUnits
+imports languages/java-15/packages/PackageDeclarations
+        languages/java-15/packages/ImportDeclarations
+        languages/java-15/packages/TypeDeclarations
+
+exports
+  sorts CompilationUnit
+
+  context-free syntax
+    PackageDec? ImportDec* TypeDec+ -> CompilationUnit {cons("CompilationUnit")}
+
+  context-free syntax
+    "@#$" PackageDec? ImportDec* -> CompilationUnit {completion, ast("CompilationUnit(<1>,<2>,[Semicolon])")}
+    "@#$" PackageDec?            -> CompilationUnit {completion, ast("CompilationUnit(<1>,[],[Semicolon])")}
+
+module languages/java-15/packages/Main
+imports languages/java-15/packages/CompilationUnits
+        languages/java-15/packages/ImportDeclarations
+        languages/java-15/packages/PackageDeclarations
+
+module languages/java-15/names/Main
+imports languages/java-15/lexical/Identifiers
+
+exports
+  sorts PackageName
+
+  context-free syntax
+    {Id "."}+ -> PackageName {cons("PackageName")}
+
+  context-free syntax
+    
+
+  sorts TypeName ExprName MethodName PackageOrTypeName AmbName
+
+  context-free syntax
+    Id                       -> AmbName           {cons("AmbName")}
+    AmbName "." Id           -> AmbName           {cons("AmbName")}
+    Id                       -> TypeName          {cons("TypeName")}
+    PackageOrTypeName "." Id -> TypeName          {cons("TypeName")}
+    Id                       -> ExprName          {cons("ExprName")}
+    AmbName "." Id           -> ExprName          {cons("ExprName")}
+    Id                       -> MethodName        {cons("MethodName")}
+    AmbName "." Id           -> MethodName        {cons("MethodName")}
+    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
+    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}
+
+  context-free syntax
+    "@#$" PackageOrTypeName -> TypeName   {completion, ast("TypeName(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName           -> ExprName   {completion, ast("ExprName(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName           -> MethodName {completion, ast("MethodName(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+
+module languages/java-15/types/ParameterizedTypes
+imports languages/java-15/types/ReferenceTypes
+
+exports
+  sorts TypeArgs ActualTypeArg WildcardBound
+
+  context-free syntax
+    "<" {ActualTypeArg ","}+ ">" -> TypeArgs      {cons("TypeArgs")}
+    Type                         -> ActualTypeArg 
+    "?" WildcardBound?           -> ActualTypeArg {cons("Wildcard")}
+    "extends" RefType            -> WildcardBound {cons("WildcardUpperBound")}
+    "super" RefType              -> WildcardBound {cons("WildcardLowerBound")}
+
+  context-free syntax
+    "@#$" "<" {ActualTypeArg ","}+ ">"? -> TypeArgs {completion, cons("TypeArgs")}
+
+module languages/java-15/types/TypeVariables
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/types/ReferenceTypes
+
+exports
+  sorts TypeParams TypeParam TypeBound TypeVarId
+
+  context-free syntax
+    TypeVarId TypeBound?                  -> TypeParam  {cons("TypeParam")}
+    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound  {cons("TypeBound")}
+    "<" {TypeParam ","}+ ">"              -> TypeParams {cons("TypeParams")}
+    Id                                    -> TypeVarId  
+
+  context-free syntax
+    "@#$" "<" {TypeParam ","}+ ">"? -> TypeParams {completion, cons("TypeParams")}
+
+module languages/java-15/types/ReferenceTypes
+imports languages/java-15/lexical/Identifiers languages/java-15/names/Main
+        languages/java-15/types/Main languages/java-15/types/ParameterizedTypes
+        languages/java-15/types/TypeVariables
+
+exports
+  sorts RefType ClassOrInterfaceType ClassType InterfaceType TypeDecSpec
+        ArrayType TypeVar
+
+  context-free syntax
+    ClassOrInterfaceType -> RefType 
+    ArrayType            -> RefType 
+
+  context-free syntax
+    
+
+  context-free syntax
+    TypeDecSpec TypeArgs?       -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
+    TypeDecSpec TypeArgs?       -> ClassType            {cons("ClassType")}
+    TypeDecSpec TypeArgs?       -> InterfaceType        {cons("InterfaceType")}
+    TypeName                    -> TypeDecSpec          
+    TypeDecSpec TypeArgs "." Id -> TypeDecSpec          {cons("Member")}
+
+  context-free syntax
+    "@#$" TypeDecSpec TypeArgs -> TypeDecSpec {completion, ast("Member(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+
+  context-free syntax
+    TypeVarId -> TypeVar {cons("TypeVar")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    Type "[" "]" -> ArrayType {cons("ArrayType")}
+
+  context-free syntax
+    "@#$" Type -> ArrayType {completion, cons("ArrayType")}
+
+module languages/java-15/types/PrimitiveTypes
+exports
+  sorts PrimType NumType IntType FloatType
+
+  context-free syntax
+    NumType   -> PrimType  
+    "boolean" -> PrimType  {cons("Boolean")}
+    IntType   -> NumType   
+    FloatType -> NumType   
+    "byte"    -> IntType   {cons("Byte")}
+    "short"   -> IntType   {cons("Short")}
+    "int"     -> IntType   {cons("Int")}
+    "long"    -> IntType   {cons("Long")}
+    "char"    -> IntType   {cons("Char")}
+    "float"   -> FloatType {cons("Float")}
+    "double"  -> FloatType {cons("Double")}
+
+  context-free syntax
+    
+
+module languages/java-15/types/Main
+imports languages/java-15/types/PrimitiveTypes
+        languages/java-15/types/ReferenceTypes
+        languages/java-15/types/TypeVariables
+        languages/java-15/types/ParameterizedTypes
+
+exports
+  sorts Type
+
+  context-free syntax
+    PrimType -> Type 
+    RefType  -> Type 
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/literals/NullLiteral
+exports
+  sorts NullLiteral
+
+  context-free syntax
+    "null" -> NullLiteral {cons("Null")}
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/literals/StringLiterals
+imports languages/java-15/lexical/literals/EscapeSequences
+        languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts StringLiteral StringPart StringChars FooStringChars
+
+  syntax
+    StringLiteral         -> <StringLiteral-CF>   
+    "\"" StringPart* "\"" -> StringLiteral        {cons("String")}
+    StringChars           -> StringPart           {cons("Chars")}
+    UnicodeEscape         -> StringPart           
+    EscapeSeq             -> StringPart           
+    <FooStringChars-LEX>  -> StringChars          
+    ~[\"\\\n\13]+         -> <FooStringChars-LEX> 
+
+  restrictions
+    StringChars -/- ~[\"\\\n\13]
+
+module languages/java-15/lexical/literals/EscapeSequences
+imports 
+
+exports
+  sorts EscapeSeq NamedEscape OctaEscape LastOcta
+
+  syntax
+    OctaEscape             -> EscapeSeq   
+    NamedEscape            -> EscapeSeq   
+    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
+    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
+    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}
+    [0-7]                  -> LastOcta    
+
+  restrictions
+    LastOcta -/- [0-7]
+
+module languages/java-15/lexical/literals/CharacterLiterals
+imports languages/java-15/lexical/literals/EscapeSequences
+        languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts CharLiteral CharContent SingleChar
+
+  syntax
+    CharLiteral         -> <CharLiteral-CF> 
+    "'" CharContent "'" -> CharLiteral      {cons("Char")}
+    SingleChar          -> CharContent      {cons("Single")}
+    UnicodeEscape       -> CharContent      
+    EscapeSeq           -> CharContent      
+    ~[\r\n\'\\]         -> SingleChar       
+
+module languages/java-15/lexical/literals/BooleanLiterals
+exports
+  sorts Bool BoolLiteral
+
+  context-free syntax
+    Bool    -> BoolLiteral {cons("Bool")}
+    "true"  -> Bool        {cons("True")}
+    "false" -> Bool        {cons("False")}
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/literals/FloatingPointLiterals
+exports
+  sorts FloatLiteral DeciFloatLiteral HexaFloatLiteral
+
+  context-free syntax
+    DeciFloatLiteral -> FloatLiteral {cons("Float")}
+    HexaFloatLiteral -> FloatLiteral {cons("Float")}
+
+  context-free syntax
+    
+
+  lexical syntax
+    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral 
+    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral 
+    [0-9]+                   -> DeciFloatLiteral {reject}
+
+  lexical syntax
+     -> "@#$" {completion}
+
+  lexical restrictions
+    DeciFloatLiteral -/- [fFdD]
+    HexaFloatLiteral -/- [fFdD]
+
+  sorts DeciFloatNumeral DeciFloatDigits DeciFloatExponentPart
+
+  lexical syntax
+    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral      
+    [0-9]* "." [0-9]*                      -> DeciFloatDigits       
+    "."                                    -> DeciFloatDigits       {reject}
+    [0-9]+                                 -> DeciFloatDigits       
+    [eE] SignedInteger                     -> DeciFloatExponentPart 
+    [\+\-]? [0-9]+                         -> SignedInteger         
+
+  lexical restrictions
+    DeciFloatDigits -/- [0-9]
+    DeciFloatExponentPart -/- [0-9]
+
+  sorts HexaFloatNumeral HexaSignificand BinaryExponent SignedInteger
+
+  lexical syntax
+    HexaSignificand BinaryExponent         -> HexaFloatNumeral 
+    [0] [xX] [0-9a-fA-F]+                  -> HexaSignificand  
+    [0] [xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand  
+    [0] [xX] "."                           -> HexaSignificand  {reject}
+    [pP] SignedInteger                     -> BinaryExponent   
+
+  lexical restrictions
+    HexaSignificand -/- [0-9a-fA-F]
+    SignedInteger -/- [0-9]
+
+module languages/java-15/lexical/literals/IntegerLiterals
+exports
+  sorts IntLiteral DeciLiteral HexaLiteral OctaLiteral DeciNumeral HexaNumeral
+        OctaNumeral
+
+  context-free syntax
+    DeciLiteral -> IntLiteral {cons("Deci")}
+    HexaLiteral -> IntLiteral {cons("Hexa")}
+    OctaLiteral -> IntLiteral {cons("Octa")}
+
+  context-free syntax
+    
+
+  lexical syntax
+    DeciNumeral [lL]?     -> DeciLiteral 
+    HexaNumeral [lL]?     -> HexaLiteral 
+    OctaNumeral [lL]?     -> OctaLiteral 
+    "0"                   -> DeciNumeral 
+    [1-9] [0-9]*          -> DeciNumeral 
+    [0] [xX] [0-9a-fA-F]+ -> HexaNumeral 
+    [0] [0-7]+            -> OctaNumeral 
+
+  lexical restrictions
+    DeciNumeral -/- [0-9\.fFdD]
+    HexaNumeral -/- [0-9a-fA-F]
+    OctaNumeral -/- [0-7]
+    DeciLiteral -/- [lL]
+    HexaLiteral -/- [lL]
+    OctaLiteral -/- [lL]
+
+module languages/java-15/lexical/literals/Main
+imports languages/java-15/lexical/literals/IntegerLiterals
+        languages/java-15/lexical/literals/FloatingPointLiterals
+        languages/java-15/lexical/literals/BooleanLiterals
+        languages/java-15/lexical/literals/CharacterLiterals
+        languages/java-15/lexical/literals/StringLiterals
+        languages/java-15/lexical/literals/NullLiteral
+
+module languages/java-15/lexical/Modifiers
+exports
+  sorts Public Private Protected Abstract Final Static Native Transient Volatile
+        Synchronized StrictFP Modifier
+
+  context-free syntax
+    "public"       -> Public       {cons("Public")}
+    "private"      -> Private      {cons("Private")}
+    "protected"    -> Protected    {cons("Protected")}
+    "abstract"     -> Abstract     {cons("Abstract")}
+    "final"        -> Final        {cons("Final")}
+    "static"       -> Static       {cons("Static")}
+    "native"       -> Native       {cons("Native")}
+    "transient"    -> Transient    {cons("Transient")}
+    "volatile"     -> Volatile     {cons("Volatile")}
+    "synchronized" -> Synchronized {cons("Synchronized")}
+    "strictfp"     -> StrictFP     {cons("StrictFP")}
+    Public         -> Modifier     
+    Private        -> Modifier     
+    Protected      -> Modifier     
+    Abstract       -> Modifier     
+    Final          -> Modifier     
+    Static         -> Modifier     
+    Native         -> Modifier     
+    Transient      -> Modifier     
+    Volatile       -> Modifier     
+    Synchronized   -> Modifier     
+    StrictFP       -> Modifier     
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/Keywords
+exports
+  sorts Keyword
+
+  lexical syntax
+    "abstract"     -> Keyword 
+    "assert"       -> Keyword 
+    "boolean"      -> Keyword 
+    "break"        -> Keyword 
+    "byte"         -> Keyword 
+    "case"         -> Keyword 
+    "catch"        -> Keyword 
+    "char"         -> Keyword 
+    "class"        -> Keyword 
+    "const"        -> Keyword 
+    "continue"     -> Keyword 
+    "default"      -> Keyword 
+    "do"           -> Keyword 
+    "double"       -> Keyword 
+    "else"         -> Keyword 
+    "enum"         -> Keyword 
+    "extends"      -> Keyword 
+    "final"        -> Keyword 
+    "finally"      -> Keyword 
+    "float"        -> Keyword 
+    "for"          -> Keyword 
+    "goto"         -> Keyword 
+    "if"           -> Keyword 
+    "implements"   -> Keyword 
+    "import"       -> Keyword 
+    "instanceof"   -> Keyword 
+    "int"          -> Keyword 
+    "interface"    -> Keyword 
+    "long"         -> Keyword 
+    "native"       -> Keyword 
+    "new"          -> Keyword 
+    "package"      -> Keyword 
+    "private"      -> Keyword 
+    "protected"    -> Keyword 
+    "public"       -> Keyword 
+    "return"       -> Keyword 
+    "short"        -> Keyword 
+    "static"       -> Keyword 
+    "strictfp"     -> Keyword 
+    "super"        -> Keyword 
+    "switch"       -> Keyword 
+    "synchronized" -> Keyword 
+    "this"         -> Keyword 
+    "throw"        -> Keyword 
+    "throws"       -> Keyword 
+    "transient"    -> Keyword 
+    "try"          -> Keyword 
+    "void"         -> Keyword 
+    "volatile"     -> Keyword 
+    "while"        -> Keyword 
+
+  lexical restrictions
+    "abstract" "assert" "boolean" "break" "byte" "case" "catch" "char" "class"
+    "const" "continue" "default" "do" "double" "else" "enum" "extends" "final"
+    "finally" "float" "for" "goto" "if" "implements" "import" "instanceof" "int"
+    "interface" "long" "native" "new" "package" "private" "protected" "public"
+    "return" "short" "static" "strictfp" "super" "switch" "synchronized" "this"
+    "throw" "throws" "transient" "try" "void" "volatile" "while"
+    -/- [A-Za-z0-9\_\$]
+
+module languages/java-15/lexical/Identifiers
+imports languages/java-15/lexical/Keywords
+
+exports
+  sorts Id ID
+
+  context-free syntax
+    ID -> Id {cons("Id")}
+
+  context-free syntax
+    
+
+  lexical syntax
+    [A-Za-z\_\$] [A-Za-z0-9\_\$]* -> ID 
+    Keyword                       -> ID {reject}
+    "true"                        -> ID {reject}
+    "false"                       -> ID {reject}
+    "null"                        -> ID {reject}
+
+  lexical restrictions
+    ID -/- [a-zA-Z0-9\_\$]
+
+module languages/java-15/lexical/Comments
+imports languages/java-15/lexical/LineTerminators
+
+exports
+  sorts Comment EOLCommentChars CommentPart UnicodeEscape BlockCommentChars
+        Asterisk EscEscChar EscChar
+
+  lexical syntax
+    Comment                                                   -> LAYOUT            
+    "//" EOLCommentChars LineTerminator                       -> Comment           
+    ~[\n\r]*                                                  -> EOLCommentChars   
+    "/*" CommentPart* "*/"                                    -> Comment           
+    "/**" CommentPart* "*/"                                   -> Comment           
+    "/**/"                                                    -> Comment           
+    BlockCommentChars                                         -> CommentPart       
+    EscChar                                                   -> CommentPart       
+    EscEscChar                                                -> CommentPart       
+    Asterisk                                                  -> CommentPart       
+    UnicodeEscape                                             -> CommentPart       
+    ~[\*\\]+                                                  -> BlockCommentChars 
+    "*"                                                       -> Asterisk          
+    "\\\\"                                                    -> EscEscChar        
+    "\\"                                                      -> EscChar           
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape     
+
+  lexical restrictions
+    "/**" -/- [\/]
+    "/*" -/- [\*]
+    Asterisk -/- [\/]
+    EscChar -/- [\\u]
+    BlockCommentChars -/- ~[\*\\]
+    EOLCommentChars -/- ~[\n\13]
+
+  context-free restrictions
+    LAYOUT? -/- [\/] . [\*]
+    LAYOUT? -/- [\/] . [\/]
+
+module languages/java-15/lexical/WhiteSpace
+exports
+  lexical syntax
+    [\ \t\12\r\n] -> LAYOUT 
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\12\n\r]
+
+module languages/java-15/lexical/LineTerminators
+exports
+  sorts LineTerminator CarriageReturn EndOfFile
+
+  lexical syntax
+    [\n]           -> LineTerminator 
+    [\r] [\n]      -> LineTerminator 
+    CarriageReturn -> LineTerminator 
+    EndOfFile      -> LineTerminator 
+    [\r]           -> CarriageReturn 
+
+  lexical restrictions
+    CarriageReturn -/- [\n]
+
+  lexical syntax
+     -> EndOfFile 
+
+  lexical restrictions
+    EndOfFile -/- ~[]
+
+module languages/java-15/lexical/UnicodeEscapes
+exports
+  sorts UnicodeEscape
+
+  syntax
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}
+
+module languages/java-15/lexical/Main
+imports languages/java-15/lexical/UnicodeEscapes
+        languages/java-15/lexical/LineTerminators
+        languages/java-15/lexical/WhiteSpace languages/java-15/lexical/Comments
+        languages/java-15/lexical/Identifiers languages/java-15/lexical/Keywords
+        languages/java-15/lexical/Modifiers
+        languages/java-15/lexical/literals/Main
+
+module languages/java-15/Main
+imports languages/java-15/lexical/Main languages/java-15/types/Main
+        languages/java-15/names/Main languages/java-15/packages/Main
+        languages/java-15/classes/Main languages/java-15/interfaces/Main
+        languages/java-15/arrays/Main languages/java-15/statements/Main
+        languages/java-15/expressions/Main
+
+module languages/java/EmbeddedJava[E]
+imports languages/java-15/Main
+
+exports
+  variables
+    [ij] [0-9\']*             -> DeciLiteral {prefer}
+    [ij] [\_] [a-zA-Z0-9\']*  -> DeciLiteral {prefer}
+    [xyz] [0-9\']*            -> ID          {prefer}
+    [xyz] [\_] [a-zA-Z0-9\']* -> ID          {prefer}
+
+  context-free restrictions
+    ID -/- [\_a-zA-Z0-9\']
+
+exports
+  variables
+    "e" [0-9\']*            -> Expr           {prefer}
+    "e_" [a-zA-Z0-9\']*     -> Expr           {prefer}
+    "e" [0-9\']* "*"        -> {VarInit ","}* {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {VarInit ","}* {prefer}
+    "e" [0-9\']* "*"        -> {Expr ","}*    {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {Expr ","}*    {prefer}
+
+  lexical syntax
+    "e" [0-9\']*        -> ID {reject}
+    "e_" [a-zA-Z0-9\']* -> ID {reject}
+
+  context-free syntax
+    "e" "|[" Expr "]|"           -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "expr" "|[" Expr "]|"        -> E {cons("ToMetaExpr")}
+    "java" "|[" Expr "]|"        -> E {cons("ToMetaExpr")}
+    "|[" Expr "]|"               -> E {cons("ToMetaExpr")}
+    "var-init" "|[" VarInit "]|" -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "e" "|[" Expr "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:expr" "|[" Expr "]|"?   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "expr" "|[" Expr "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" Expr "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" Expr "]|"?               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "var-init" "|[" VarInit "]|"? -> E {completion, cons("ToMetaExpr")}
+
+exports
+  variables
+    "stm" [0-9\']*             -> Stm       {prefer}
+    "stm_" [a-zA-Z0-9\']*      -> Stm       {prefer}
+    "bstm" [0-9\']*            -> BlockStm  {prefer}
+    "bstm_" [a-zA-Z0-9\']*     -> BlockStm  {prefer}
+    "bstm" [0-9\']* "*"        -> BlockStm* {prefer}
+    "bstm_" [a-zA-Z0-9\']* "*" -> BlockStm* {prefer}
+
+  context-free syntax
+    "java:bstm" "|[" BlockStm "]|"            -> E {cons("ToMetaExpr")}
+    "bstm" "|[" BlockStm "]|"                 -> E {cons("ToMetaExpr")}
+    "java" "|[" BlockStm "]|"                 -> E {cons("ToMetaExpr")}
+    "|[" BlockStm "]|"                        -> E {cons("ToMetaExpr")}
+    "java:bstm*" "|[" BlockStm* "]|"          -> E {cons("ToMetaListExpr")}
+    "bstm*" "|[" BlockStm* "]|"               -> E {cons("ToMetaListExpr")}
+    "java:block-stm" "|[" BlockStm "]|"       -> E {cons("ToMetaExpr")}
+    "block-stm" "|[" BlockStm "]|"            -> E {cons("ToMetaExpr")}
+    "java" "|[" BlockStm "]|"                 -> E {cons("ToMetaExpr")}
+    "|[" BlockStm "]|"                        -> E {cons("ToMetaExpr")}
+    "java:block-stm*" "|[" BlockStm* "]|"     -> E {cons("ToMetaListExpr")}
+    "block-stm*" "|[" BlockStm* "]|"          -> E {cons("ToMetaListExpr")}
+    "java:stm" "|[" Stm "]|"                  -> E {cons("ToMetaExpr")}
+    "stm" "|[" Stm "]|"                       -> E {cons("ToMetaExpr")}
+    "switch-group" "|[" SwitchGroup "]|"      -> E {cons("ToMetaListExpr")}
+    "java:switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}
+
+  context-free syntax
+    "@#$" "java:bstm" "|[" BlockStm "]|"?            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "bstm" "|[" BlockStm "]|"?                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:bstm*" "|[" BlockStm* "]|"?          -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "bstm*" "|[" BlockStm* "]|"?               -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:block-stm" "|[" BlockStm "]|"?       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "block-stm" "|[" BlockStm "]|"?            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" BlockStm "]|"?                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" BlockStm "]|"?                        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:block-stm*" "|[" BlockStm* "]|"?     -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "block-stm*" "|[" BlockStm* "]|"?          -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:stm" "|[" Stm "]|"?                  -> E {completion, cons("ToMetaExpr")}
+    "@#$" "stm" "|[" Stm "]|"?                       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "switch-group" "|[" SwitchGroup "]|"?      -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:switch-group" "|[" SwitchGroup "]|"? -> E {completion, cons("ToMetaListExpr")}
+
+  context-free syntax
+    "~" E               -> BlockStm     {cons("FromMetaExpr")}
+    "~bstm:" E          -> BlockStm     {cons("FromMetaExpr")}
+    "~*" E              -> BlockStm*    {cons("FromMetaExpr")}
+    "~bstm*:" E         -> BlockStm*    {cons("FromMetaExpr")}
+    "~stm:" E           -> Stm          {cons("FromMetaExpr"), prefer}
+    "~" E               -> Stm          {cons("FromMetaExpr")}
+    "~*" E              -> SwitchGroup* {cons("FromMetaExpr")}
+    "~switch-group*:" E -> SwitchGroup* {cons("FromMetaExpr")}
+    "~" E               -> SwitchGroup  {cons("FromMetaExpr")}
+    "~switch-group:" E  -> SwitchGroup  {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+  variables
+    "lvdec" [0-9]*           -> LocalVarDec   {prefer}
+    "lvdec_" [a-zA-Z0-9]*    -> LocalVarDec   {prefer}
+    "vdec" [0-9]*            -> VarDec        {prefer}
+    "vdec_" [a-zA-Z0-9]*     -> VarDec        {prefer}
+    "vdec" [0-9]* "*"        -> {VarDec ","}+ {prefer}
+    "vdec_" [a-zA-Z0-9]* "*" -> {VarDec ","}+ {prefer}
+
+  lexical syntax
+    "lvdec"               -> ID {reject}
+    "lvdec_" [a-zA-Z0-9]* -> ID {reject}
+    "vdec"                -> ID {reject}
+    "vdec_" [a-zA-Z0-9]*  -> ID {reject}
+
+  context-free syntax
+    "java:lvdec" "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
+    "lvdec" "|[" LocalVarDec "]|"      -> E {cons("ToMetaExpr")}
+    "java:vdec" "|[" VarDec "]|"       -> E {cons("ToMetaExpr")}
+    "vdec" "|[" VarDec "]|"            -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "java:lvdec" "|[" LocalVarDec "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "lvdec" "|[" LocalVarDec "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:vdec" "|[" VarDec "]|"?       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "vdec" "|[" VarDec "]|"?            -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    
+
+exports
+  variables
+    "lhs" [0-9\']* -> LHS {prefer}
+    "e" [0-9\']*   -> LHS {prefer}
+
+  lexical syntax
+    "lhs" [0-9\']* -> ID {reject}
+
+exports
+  variables
+    MetaTypeVar     -> Type     {prefer}
+    MetaPrimTypeVar -> PrimType {prefer}
+    MetaRefTypeVar  -> RefType  {prefer}
+
+  lexical syntax
+    "t" [0-9\']*           -> MetaTypeVar     
+    "t_" [a-zA-Z0-9\']*    -> MetaTypeVar     
+    "ty" [0-9]*            -> MetaTypeVar     
+    "ty_" [a-zA-Z0-9\']*   -> MetaTypeVar     
+    "primt" [0-9]*         -> MetaPrimTypeVar 
+    "primt_" [a-zA-Z0-9]*  -> MetaPrimTypeVar 
+    "primty" [0-9]*        -> MetaPrimTypeVar 
+    "primty_" [a-zA-Z0-9]* -> MetaPrimTypeVar 
+    "reft" [0-9]*          -> MetaRefTypeVar  
+    "reft_" [a-zA-Z0-9]*   -> MetaRefTypeVar  
+    "refty" [0-9]*         -> MetaRefTypeVar  
+    "refty_" [a-zA-Z0-9]*  -> MetaRefTypeVar  
+    "t" [0-9\']*           -> ID              {reject}
+    "t_" [a-zA-Z0-9]*      -> ID              {reject}
+    "ty" [0-9]*            -> ID              {reject}
+    "ty_" [a-zA-Z0-9]*     -> ID              {reject}
+    "primt" [0-9]*         -> ID              {reject}
+    "primt_" [a-zA-Z0-9]*  -> ID              {reject}
+    "primty" [0-9]*        -> ID              {reject}
+    "primty_" [a-zA-Z0-9]* -> ID              {reject}
+    "reft" [0-9]*          -> ID              {reject}
+    "reft_" [a-zA-Z0-9]*   -> ID              {reject}
+    "refty" [0-9]*         -> ID              {reject}
+    "refty_" [a-zA-Z0-9]*  -> ID              {reject}
+
+  lexical restrictions
+    MetaTypeVar -/- [a-zA-Z0-9\_\$\']
+
+  context-free syntax
+    "t" "|[" Type "]|"         -> E {cons("ToMetaExpr")}
+    "ty" "|[" Type "]|"        -> E {cons("ToMetaExpr")}
+    "java:type" "|[" Type "]|" -> E {cons("ToMetaExpr")}
+    "type" "|[" Type "]|"      -> E {cons("ToMetaExpr")}
+    "java" "|[" Type "]|"      -> E {cons("ToMetaExpr")}
+    "|[" Type "]|"             -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "t" "|[" Type "]|"?         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "ty" "|[" Type "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:type" "|[" Type "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "type" "|[" Type "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" Type "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" Type "]|"?             -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~" E      -> Type {cons("FromMetaExpr")}
+    "~type:" E -> Type {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  variables
+    "ambname" [0-9]*         -> AmbName           {prefer}
+    "ambname_" [a-zA-Z0-9]*  -> AmbName           {prefer}
+    "ename" [0-9]*           -> ExprName          {prefer}
+    "ename_" [a-zA-Z0-9]*    -> ExprName          {prefer}
+    "fname" [0-9]*           -> MethodName        {prefer}
+    "fname_" [a-zA-Z0-9]*    -> MethodName        {prefer}
+    "tname" [0-9]*           -> TypeName          {prefer}
+    "tname_" [a-zA-Z0-9]*    -> TypeName          {prefer}
+    "pkgtname" [0-9]*        -> PackageOrTypeName {prefer}
+    "pkgtname_" [a-zA-Z0-9]* -> PackageOrTypeName {prefer}
+    "pkgname" [0-9]*         -> PackageName       {prefer}
+    "pkgname_" [a-zA-Z0-9]*  -> PackageName       {prefer}
+
+  context-free syntax
+    "ambname" "|[" AmbName "]|"            -> E {cons("ToMetaExpr")}
+    "ename" "|[" ExprName "]|"             -> E {cons("ToMetaExpr")}
+    "fname" "|[" MethodName "]|"           -> E {cons("ToMetaExpr")}
+    "tname" "|[" TypeName "]|"             -> E {cons("ToMetaExpr")}
+    "pkgtname" "|[" PackageOrTypeName "]|" -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "ambname" "|[" AmbName "]|"?            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "ename" "|[" ExprName "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "fname" "|[" MethodName "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "tname" "|[" TypeName "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "pkgtname" "|[" PackageOrTypeName "]|"? -> E {completion, cons("ToMetaExpr")}
+
+exports
+  variables
+    "mod" [0-9]*            -> MethodMod             {prefer}
+    "mod_" [a-zA-Z0-9]*     -> MethodMod             {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | MethodMod )* {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | MethodMod )* {prefer}
+    "mod" [0-9]*            -> ClassMod              {prefer}
+    "mod_" [a-zA-Z0-9]*     -> ClassMod              {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | ClassMod )*  {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | ClassMod )*  {prefer}
+    "mod" [0-9]*            -> ConstrMod             {prefer}
+    "mod_" [a-zA-Z0-9]*     -> ConstrMod             {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | ConstrMod )* {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | ConstrMod )* {prefer}
+    "mod" [0-9]*            -> VarMod                {prefer}
+    "mod_" [a-zA-Z0-9]*     -> VarMod                {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | VarMod )*    {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | VarMod )*    {prefer}
+    "mod" [0-9]*            -> FieldMod              {prefer}
+    "mod_" [a-zA-Z0-9]*     -> FieldMod              {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | FieldMod )*  {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | FieldMod )*  {prefer}
+
+  context-free syntax
+    "|[" Modifier "]|"       -> E {cons("ToMetaExpr")}
+    "mod" "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
+    "anno" "|[" Anno "]|"    -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "|[" Modifier "]|"?       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "mod" "|[" Modifier "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "anno" "|[" Anno "]|"?    -> E {completion, cons("ToMetaExpr")}
+
+exports
+  variables
+    "param" [0-9]*            -> FormalParam        {prefer}
+    "param_" [a-zA-Z0-9]*     -> FormalParam        {prefer}
+    "param" [0-9]* "*"        -> {FormalParam ","}* {prefer}
+    "param_" [a-zA-Z0-9]* "*" -> {FormalParam ","}* {prefer}
+
+  context-free syntax
+    "param" "|[" FormalParam "]|"                     -> E {cons("ToMetaExpr")}
+    "java:param" "|[" FormalParam "]|"                -> E {cons("ToMetaExpr")}
+    "param*" "|[" {FormalParam ","}* "]|"             -> E {cons("ToMetaExpr")}
+    "java:param*" "|[" {FormalParam ","}* "]|"        -> E {cons("ToMetaExpr")}
+    "java:formal-param" "|[" FormalParam "]|"         -> E {cons("ToMetaExpr")}
+    "formal-param" "|[" FormalParam "]|"              -> E {cons("ToMetaExpr")}
+    "java" "|[" FormalParam "]|"                      -> E {cons("ToMetaExpr")}
+    "|[" FormalParam "]|"                             -> E {cons("ToMetaExpr")}
+    "java:formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+    "formal-param*" "|[" {FormalParam ","}* "]|"      -> E {cons("ToMetaExpr")}
+    "java" "|[" {FormalParam ","}* "]|"               -> E {cons("ToMetaExpr")}
+    "|[" {FormalParam ","}* "]|"                      -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "param" "|[" FormalParam "]|"?                     -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:param" "|[" FormalParam "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "param*" "|[" {FormalParam ","}* "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:param*" "|[" {FormalParam ","}* "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:formal-param" "|[" FormalParam "]|"?         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "formal-param" "|[" FormalParam "]|"?              -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" FormalParam "]|"?                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" FormalParam "]|"?                             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:formal-param*" "|[" {FormalParam ","}* "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "formal-param*" "|[" {FormalParam ","}* "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" {FormalParam ","}* "]|"?               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" {FormalParam ","}* "]|"?                      -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~" E  -> FormalParam        {cons("FromMetaExpr")}
+    "~*" E -> {FormalParam ","}* {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  context-free syntax
+    "java:package-dec" "|[" PackageDec "]|"   -> E {cons("ToMetaExpr")}
+    "package-dec" "|[" PackageDec "]|"        -> E {cons("ToMetaExpr")}
+    "|[" PackageDec "]|"                      -> E {cons("ToMetaExpr")}
+    "java:package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
+    "package-dec?" "|[" PackageDec? "]|"      -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "java:package-dec" "|[" PackageDec "]|"?   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "package-dec" "|[" PackageDec "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" PackageDec "]|"?                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:package-dec?" "|[" PackageDec? "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "package-dec?" "|[" PackageDec? "]|"?      -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~package-dec:" E  -> PackageDec  {cons("FromMetaExpr")}
+    "~package-dec?:" E -> PackageDec? {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  context-free syntax
+    "java:import-dec" "|[" ImportDec "]|"   -> E {cons("ToMetaExpr")}
+    "import-dec" "|[" ImportDec "]|"        -> E {cons("ToMetaExpr")}
+    "|[" ImportDec "]|"                     -> E {cons("ToMetaExpr")}
+    "java:import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
+    "import-dec*" "|[" ImportDec* "]|"      -> E {cons("ToMetaListExpr")}
+
+  context-free syntax
+    "@#$" "java:import-dec" "|[" ImportDec "]|"?   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "import-dec" "|[" ImportDec "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" ImportDec "]|"?                     -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:import-dec*" "|[" ImportDec* "]|"? -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "import-dec*" "|[" ImportDec* "]|"?      -> E {completion, cons("ToMetaListExpr")}
+
+  context-free syntax
+    "~import-dec:" E  -> ImportDec  {cons("FromMetaExpr")}
+    "~import-dec*:" E -> ImportDec* {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  context-free syntax
+    "e" "|[" Expr "]|"                                       -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"                               -> E {cons("ToMetaExpr")}
+    "expr" "|[" Expr "]|"                                    -> E {cons("ToMetaExpr")}
+    "java" "|[" Expr "]|"                                    -> E {cons("ToMetaExpr")}
+    "|[" Expr "]|"                                           -> E {cons("ToMetaExpr")}
+    "java:compilation-unit" "|[" CompilationUnit "]|"        -> E {cons("ToMetaExpr")}
+    "compilation-unit" "|[" CompilationUnit "]|"             -> E {cons("ToMetaExpr")}
+    "java" "|[" CompilationUnit "]|"                         -> E {cons("ToMetaExpr")}
+    "|[" CompilationUnit "]|"                                -> E {cons("ToMetaExpr")}
+    "java:importdecl" "|[" ImportDec "]|"                    -> E {cons("ToMetaExpr")}
+    "importdecl" "|[" ImportDec "]|"                         -> E {cons("ToMetaExpr")}
+    "java" "|[" ImportDec "]|"                               -> E {cons("ToMetaExpr")}
+    "java:type-dec" "|[" TypeDec "]|"                        -> E {cons("ToMetaExpr")}
+    "type-dec" "|[" TypeDec "]|"                             -> E {cons("ToMetaExpr")}
+    "java" "|[" TypeDec "]|"                                 -> E {cons("ToMetaExpr")}
+    "|[" TypeDec "]|"                                        -> E {cons("ToMetaExpr")}
+    "java:class-body-dec" "|[" ClassBodyDec "]|"             -> E {cons("ToMetaExpr")}
+    "class-body-dec" "|[" ClassBodyDec "]|"                  -> E {cons("ToMetaExpr")}
+    "java" "|[" ClassBodyDec "]|"                            -> E {cons("ToMetaExpr")}
+    "|[" ClassBodyDec "]|"                                   -> E {cons("ToMetaExpr")}
+    "java:interface-member-dec" "|[" InterfaceMemberDec "]|" -> E {cons("ToMetaExpr")}
+    "interface-member-dec" "|[" InterfaceMemberDec "]|"      -> E {cons("ToMetaExpr")}
+    "java:constant-dec" "|[" ConstantDec "]|"                -> E {cons("ToMetaExpr")}
+    "constant-dec" "|[" ConstantDec "]|"                     -> E {cons("ToMetaExpr")}
+    "java:class-body-dec*" "|[" ClassBodyDec* "]|"           -> E {cons("ToMetaExpr")}
+    "class-body-dec*" "|[" ClassBodyDec* "]|"                -> E {cons("ToMetaExpr")}
+    "java" "|[" ClassBodyDec* "]|"                           -> E {cons("ToMetaExpr")}
+    "|[" ClassBodyDec* "]|"                                  -> E {cons("ToMetaListExpr")}
+    "java:stm" "|[" Stm "]|"                                 -> E {cons("ToMetaExpr")}
+    "stm" "|[" Stm "]|"                                      -> E {cons("ToMetaExpr")}
+    "java:imember-dec" "|[" AbstractMethodDec "]|"           -> E {cons("ToMetaExpr")}
+    "imember-dec" "|[" AbstractMethodDec "]|"                -> E {cons("ToMetaExpr")}
+    "java" "|[" AbstractMethodDec "]|"                       -> E {cons("ToMetaExpr")}
+    "|[" AbstractMethodDec "]|"                              -> E {cons("ToMetaExpr")}
+    "java:imember-dec*" "|[" AbstractMethodDec* "]|"         -> E {cons("ToMetaExpr")}
+    "imember-dec*" "|[" AbstractMethodDec* "]|"              -> E {cons("ToMetaExpr")}
+    "java" "|[" AbstractMethodDec* "]|"                      -> E {cons("ToMetaExpr")}
+    "|[" AbstractMethodDec* "]|"                             -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "e" "|[" Expr "]|"?                                       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:expr" "|[" Expr "]|"?                               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "expr" "|[" Expr "]|"?                                    -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" Expr "]|"?                                    -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" Expr "]|"?                                           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:compilation-unit" "|[" CompilationUnit "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "compilation-unit" "|[" CompilationUnit "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" CompilationUnit "]|"?                         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" CompilationUnit "]|"?                                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:importdecl" "|[" ImportDec "]|"?                    -> E {completion, cons("ToMetaExpr")}
+    "@#$" "importdecl" "|[" ImportDec "]|"?                         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" ImportDec "]|"?                               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:type-dec" "|[" TypeDec "]|"?                        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "type-dec" "|[" TypeDec "]|"?                             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" TypeDec "]|"?                                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" TypeDec "]|"?                                        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:class-body-dec" "|[" ClassBodyDec "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "class-body-dec" "|[" ClassBodyDec "]|"?                  -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" ClassBodyDec "]|"?                            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" ClassBodyDec "]|"?                                   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:interface-member-dec" "|[" InterfaceMemberDec "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "interface-member-dec" "|[" InterfaceMemberDec "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:constant-dec" "|[" ConstantDec "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "constant-dec" "|[" ConstantDec "]|"?                     -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:class-body-dec*" "|[" ClassBodyDec* "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "class-body-dec*" "|[" ClassBodyDec* "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" ClassBodyDec* "]|"?                           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" ClassBodyDec* "]|"?                                  -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:stm" "|[" Stm "]|"?                                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "stm" "|[" Stm "]|"?                                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:imember-dec" "|[" AbstractMethodDec "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "imember-dec" "|[" AbstractMethodDec "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" AbstractMethodDec "]|"?                       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" AbstractMethodDec "]|"?                              -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:imember-dec*" "|[" AbstractMethodDec* "]|"?         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "imember-dec*" "|[" AbstractMethodDec* "]|"?              -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" AbstractMethodDec* "]|"?                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" AbstractMethodDec* "]|"?                             -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~" E         -> Name                 {cons("FromMetaExpr")}
+    "~name:" E    -> Name                 {cons("FromMetaExpr")}
+    "~*:" E       -> Name                 {cons("FromMetaExpr")}
+    "~" E         -> Id                   {cons("FromMetaExpr")}
+    "~id:" E      -> Id                   {cons("FromMetaExpr")}
+    "~idd:" E ":" -> Id                   {cons("FromMetaExpr")}
+    "~x:" E       -> ID                   {cons("FromMetaExpr")}
+    "~" E         -> TypeParam            {cons("FromMetaExpr")}
+    "~*" E        -> {TypeParam ","}+     {cons("FromMetaExpr")}
+    "~*" E        -> {ExceptionType ","}* {cons("FromMetaExpr")}
+    "~" E         -> Expr                 {cons("FromMetaExpr")}
+    "~e:" E       -> Expr                 {prefer, cons("FromMetaExpr")}
+    "~expr:" E    -> Expr                 {prefer, cons("FromMetaExpr")}
+    "~*" E        -> {Expr ","}*          {cons("FromMetaExpr")}
+    "~*" E        -> {VarInit ","}*       {cons("FromMetaExpr")}
+    "~" E         -> TypeDec              {cons("FromMetaExpr")}
+    "~*" E        -> TypeDec*             {cons("FromMetaExpr")}
+    "~" E         -> ClassBodyDec         {cons("FromMetaExpr")}
+    "~*" E        -> ClassBodyDec*        {cons("FromMetaExpr")}
+    "~" E         -> InterfaceMemberDec   {cons("FromMetaExpr")}
+    "~*" E        -> InterfaceMemberDec*  {cons("FromMetaExpr")}
+    "~i:" E       -> DeciLiteral          {cons("FromMetaExpr")}
+    "~deci:" E    -> DeciLiteral          {cons("FromMetaExpr")}
+    "~hexa:" E    -> HexaLiteral          {cons("FromMetaExpr")}
+    "~octa:" E    -> OctaLiteral          {cons("FromMetaExpr")}
+    "~float:" E   -> FloatLiteral         {cons("FromMetaExpr")}
+    "~string:" E  -> StringLiteral        {cons("FromMetaExpr")}
+    "~char:" E    -> CharLiteral          {cons("FromMetaExpr")}
+
+  context-free syntax
+    "@#$" "~idd:" E ":"? -> Id {completion, cons("FromMetaExpr")}
+
+  syntax
+    "~" <E-CF>              -> StringChars {cons("FromMetaExpr"), prefer}
+    "~" <E-CF> <LAYOUT?-CF> -> SingleChar  {cons("FromMetaExpr"), prefer}
+
+module languages/java/EmbeddedJavaMix[Ctx0 E]
+imports languages/java/EmbeddedJava[E]
+          [ Name                  => Name[[Ctx0]]
+            MetaRefTypeVar        => MetaRefTypeVar[[Ctx0]]
+            MetaPrimTypeVar       => MetaPrimTypeVar[[Ctx0]]
+            MetaTypeVar           => MetaTypeVar[[Ctx0]]
+            CompilationUnit       => CompilationUnit[[Ctx0]]
+            TypeDec               => TypeDec[[Ctx0]]
+            ImportDec             => ImportDec[[Ctx0]]
+            PackageDec            => PackageDec[[Ctx0]]
+            ElemVal               => ElemVal[[Ctx0]]
+            ElemValPair           => ElemValPair[[Ctx0]]
+            Anno                  => Anno[[Ctx0]]
+            LHS                   => LHS[[Ctx0]]
+            CondMid               => CondMid[[Ctx0]]
+            ArraySubscript        => ArraySubscript[[Ctx0]]
+            DimExpr               => DimExpr[[Ctx0]]
+            ArrayBaseType         => ArrayBaseType[[Ctx0]]
+            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
+            ClassMemberDec        => ClassMemberDec[[Ctx0]]
+            ClassBodyDec          => ClassBodyDec[[Ctx0]]
+            Interfaces            => Interfaces[[Ctx0]]
+            Super                 => Super[[Ctx0]]
+            ClassMod              => ClassMod[[Ctx0]]
+            ClassDecHead          => ClassDecHead[[Ctx0]]
+            ClassBody             => ClassBody[[Ctx0]]
+            ClassDec              => ClassDec[[Ctx0]]
+            InterfaceMod          => InterfaceMod[[Ctx0]]
+            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
+            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
+            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
+            InterfaceDec          => InterfaceDec[[Ctx0]]
+            DefaultVal            => DefaultVal[[Ctx0]]
+            AnnoElemDec           => AnnoElemDec[[Ctx0]]
+            AnnoDecHead           => AnnoDecHead[[Ctx0]]
+            AnnoDec               => AnnoDec[[Ctx0]]
+            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
+            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
+            ConstantMod           => ConstantMod[[Ctx0]]
+            ConstantDec           => ConstantDec[[Ctx0]]
+            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
+            EnumConstArgs         => EnumConstArgs[[Ctx0]]
+            EnumConst             => EnumConst[[Ctx0]]
+            EnumBody              => EnumBody[[Ctx0]]
+            EnumDecHead           => EnumDecHead[[Ctx0]]
+            EnumDec               => EnumDec[[Ctx0]]
+            ConstrMod             => ConstrMod[[Ctx0]]
+            ConstrInv             => ConstrInv[[Ctx0]]
+            ConstrBody            => ConstrBody[[Ctx0]]
+            ConstrHead            => ConstrHead[[Ctx0]]
+            ConstrDec             => ConstrDec[[Ctx0]]
+            StaticInit            => StaticInit[[Ctx0]]
+            InstanceInit          => InstanceInit[[Ctx0]]
+            MethodBody            => MethodBody[[Ctx0]]
+            ExceptionType         => ExceptionType[[Ctx0]]
+            Throws                => Throws[[Ctx0]]
+            MethodMod             => MethodMod[[Ctx0]]
+            VarMod                => VarMod[[Ctx0]]
+            FormalParam           => FormalParam[[Ctx0]]
+            ResultType            => ResultType[[Ctx0]]
+            MethodDecHead         => MethodDecHead[[Ctx0]]
+            MethodDec             => MethodDec[[Ctx0]]
+            BlockStm              => BlockStm[[Ctx0]]
+            Block                 => Block[[Ctx0]]
+            CatchClause           => CatchClause[[Ctx0]]
+            SwitchLabel           => SwitchLabel[[Ctx0]]
+            SwitchGroup           => SwitchGroup[[Ctx0]]
+            SwitchBlock           => SwitchBlock[[Ctx0]]
+            Stm                   => Stm[[Ctx0]]
+            ExprStm               => ExprStm[[Ctx0]]
+            LocalVarDec           => LocalVarDec[[Ctx0]]
+            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
+            FieldMod              => FieldMod[[Ctx0]]
+            VarInit               => VarInit[[Ctx0]]
+            Dim                   => Dim[[Ctx0]]
+            VarDecId              => VarDecId[[Ctx0]]
+            VarDec                => VarDec[[Ctx0]]
+            FieldDec              => FieldDec[[Ctx0]]
+            ArrayInit             => ArrayInit[[Ctx0]]
+            ClassLiteral          => ClassLiteral[[Ctx0]]
+            Literal               => Literal[[Ctx0]]
+            Type                  => Type[[Ctx0]]
+            ArrayType             => ArrayType[[Ctx0]]
+            TypeVar               => TypeVar[[Ctx0]]
+            TypeDecSpec           => TypeDecSpec[[Ctx0]]
+            InterfaceType         => InterfaceType[[Ctx0]]
+            ClassType             => ClassType[[Ctx0]]
+            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
+            RefType               => RefType[[Ctx0]]
+            TypeVarId             => TypeVarId[[Ctx0]]
+            TypeParams            => TypeParams[[Ctx0]]
+            TypeBound             => TypeBound[[Ctx0]]
+            TypeParam             => TypeParam[[Ctx0]]
+            WildcardBound         => WildcardBound[[Ctx0]]
+            ActualTypeArg         => ActualTypeArg[[Ctx0]]
+            TypeArgs              => TypeArgs[[Ctx0]]
+            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
+            MethodName            => MethodName[[Ctx0]]
+            ExprName              => ExprName[[Ctx0]]
+            TypeName              => TypeName[[Ctx0]]
+            AmbName               => AmbName[[Ctx0]]
+            PackageName           => PackageName[[Ctx0]]
+            FloatType             => FloatType[[Ctx0]]
+            IntType               => IntType[[Ctx0]]
+            NumType               => NumType[[Ctx0]]
+            PrimType              => PrimType[[Ctx0]]
+            NullLiteral           => NullLiteral[[Ctx0]]
+            FooStringChars        => FooStringChars[[Ctx0]]
+            StringChars           => StringChars[[Ctx0]]
+            StringPart            => StringPart[[Ctx0]]
+            StringLiteral         => StringLiteral[[Ctx0]]
+            SingleChar            => SingleChar[[Ctx0]]
+            CharContent           => CharContent[[Ctx0]]
+            CharLiteral           => CharLiteral[[Ctx0]]
+            LastOcta              => LastOcta[[Ctx0]]
+            OctaEscape            => OctaEscape[[Ctx0]]
+            NamedEscape           => NamedEscape[[Ctx0]]
+            EscapeSeq             => EscapeSeq[[Ctx0]]
+            Bool                  => Bool[[Ctx0]]
+            BoolLiteral           => BoolLiteral[[Ctx0]]
+            BinaryExponent        => BinaryExponent[[Ctx0]]
+            HexaSignificand       => HexaSignificand[[Ctx0]]
+            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
+            SignedInteger         => SignedInteger[[Ctx0]]
+            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
+            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
+            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
+            FloatLiteral          => FloatLiteral[[Ctx0]]
+            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
+            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
+            IntLiteral            => IntLiteral[[Ctx0]]
+            OctaNumeral           => OctaNumeral[[Ctx0]]
+            HexaNumeral           => HexaNumeral[[Ctx0]]
+            DeciNumeral           => DeciNumeral[[Ctx0]]
+            OctaLiteral           => OctaLiteral[[Ctx0]]
+            HexaLiteral           => HexaLiteral[[Ctx0]]
+            DeciLiteral           => DeciLiteral[[Ctx0]]
+            Modifier              => Modifier[[Ctx0]]
+            StrictFP              => StrictFP[[Ctx0]]
+            Synchronized          => Synchronized[[Ctx0]]
+            Volatile              => Volatile[[Ctx0]]
+            Transient             => Transient[[Ctx0]]
+            Native                => Native[[Ctx0]]
+            Static                => Static[[Ctx0]]
+            Final                 => Final[[Ctx0]]
+            Abstract              => Abstract[[Ctx0]]
+            Protected             => Protected[[Ctx0]]
+            Private               => Private[[Ctx0]]
+            Public                => Public[[Ctx0]]
+            Id                    => Id[[Ctx0]]
+            ID                    => ID[[Ctx0]]
+            Keyword               => Keyword[[Ctx0]]
+            ArrayAccess           => ArrayAccess[[Ctx0]]
+            FieldAccess           => FieldAccess[[Ctx0]]
+            MethodSpec            => MethodSpec[[Ctx0]]
+            Expr                  => Expr[[Ctx0]] ]
+
+module Stratego-Sugar-Overlays
+imports Stratego-Core-Identifiers Stratego-Sugar-Terms
+
+exports
+  sorts Overlay
+
+  context-free syntax
+    Id "=" Term                   -> Overlay {cons("OverlayNoArgs")}
+    Id "(" {Id ","}* ")" "=" Term -> Overlay {cons("Overlay")}
+
+  context-free syntax
+    "@#$" Id "(" {Id ","}* ")"? "="? -> Overlay {completion, ast("Overlay(<1>,<2>,RootApp(GenDynRules([])))")}
+    "@#$" Id                         -> Overlay {completion, ast("Overlay(<1>,[],RootApp(GenDynRules([])))")}
+
+module Stratego-Sugar-DynamicRules
+imports Stratego-Core-Identifiers Stratego-Sugar-Strategies Stratego-Sugar-Rules
+
+exports
+  sorts ScopeLabels
+
+  context-free syntax
+    "{|" ScopeLabels ":" Strategy "|}" -> Strategy    {cons("DynRuleScope")}
+    {DynRuleScopeId ","}*              -> ScopeLabels {cons("ScopeLabels")}
+    "~" Term                           -> ScopeLabels {cons("ScopeLabels")}
+
+  context-free syntax
+    "@#$" "{|" ScopeLabels ":" Strategy "|}"? -> Strategy {completion, cons("DynRuleScope")}
+    "@#$" "{|" ScopeLabels ":"? "|}"?         -> Strategy {completion, ast("DynRuleScope(<1>,GenDynRules([]))")}
+
+  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
+
+  context-free syntax
+    "rules" "(" DynRuleDef* ")"            -> Strategy       {cons("GenDynRules")}
+    Id "+" Term                            -> DynRuleDef     {cons("AddScopeLabel")}
+    DynRuleId ":-" Term                    -> DynRuleDef     {cons("UndefineDynRule")}
+    DynRuleId ":" Rule                     -> DynRuleDef     {cons("SetDynRule")}
+    DynRuleId ":+" Rule                    -> DynRuleDef     {cons("AddDynRule")}
+    DynRuleId ":" Term                     -> DynRuleDef     {cons("SetDynRuleMatch")}
+    DynRuleId ":=" Term                    -> DynRuleDef     {cons("DynRuleAssign")}
+    DynRuleId ":+=" Term                   -> DynRuleDef     {cons("DynRuleAssignAdd")}
+    DynRuleId ":" Rule "depends" "on" Term -> DynRuleDef     {cons("SetDynRuleDepends")}
+    RuleDec "." Term                       -> DynRuleId      {cons("LabeledDynRuleId")}
+    RuleDec "+" Term                       -> DynRuleId      {cons("AddLabelDynRuleId")}
+    RuleDec                                -> DynRuleId      {cons("DynRuleId")}
+    Id "." Term                            -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
+    Id                                     -> DynRuleScopeId {cons("DynRuleScopeId")}
+
+  context-free syntax
+    "@#$" "rules" "(" DynRuleDef* ")"?        -> Strategy   {completion, cons("GenDynRules")}
+    "@#$" Id                                  -> DynRuleDef {completion, ast("AddScopeLabel(<1>,RootApp(GenDynRules([])))")}
+    "@#$" DynRuleId ":" Rule "depends"? "on"? -> DynRuleDef {completion, ast("SetDynRuleDepends(<1>,<2>,RootApp(GenDynRules([])))")}
+    "@#$" DynRuleId                           -> DynRuleDef {completion, ast("SetDynRuleDepends(<1>,RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))),RootApp(GenDynRules([])))")}
+
+  context-free syntax
+    Id                                           -> RuleDec {cons("RDecNoArgs")}
+    Id "(" {Typedid ","}* ")"                    -> RuleDec {cons("RDec")}
+    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" -> RuleDec {cons("RDecT")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* ")"?                    -> RuleDec {completion, cons("RDec")}
+    "@#$" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? -> RuleDec {completion, cons("RDecT")}
+    "@#$" Id "(" {Typedid ","}* "|"? ")"?               -> RuleDec {completion, ast("RDecT(<1>,<2>,[])")}
+
+  sorts RuleNames
+
+  context-free syntax
+    {Id ","}*                    -> RuleNames {cons("RuleNames")}
+    "~" Term                     -> RuleNames {cons("RuleNames")}
+    "/" RuleNames "\\*" Strategy -> Strategy  {cons("DynRuleIntersectFix")}
+
+  context-free syntax
+    "@#$" "/" RuleNames "\\*"? -> Strategy {completion, ast("DynRuleIntersectFix(<1>,GenDynRules([]))")}
+
+  syntax
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>                                               -> <Strategy-CF> {cons("DynRuleUnionFix")}
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>                                              -> <Strategy-CF> {cons("DynRuleUnionFix")}
+    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>  -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+  context-free syntax
+    Strategy "/" RuleNames "\\" Strategy               -> Strategy {cons("DynRuleIntersect"), right}
+    Strategy "\\" RuleNames "/" Strategy               -> Strategy {cons("DynRuleUnion"), right}
+    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy {cons("DynRuleIntersectUnion"), right}
+
+  context-free syntax
+    "@#$" Strategy "/" RuleNames "\\"?               -> Strategy {completion, ast("DynRuleIntersect(<1>,<2>,GenDynRules([]))"), right}
+    "@#$" Strategy "\\" RuleNames "/"?               -> Strategy {completion, ast("DynRuleUnion(<1>,<2>,GenDynRules([]))"), right}
+    "@#$" Strategy "/" RuleNames "\\" RuleNames "/"? -> Strategy {completion, ast("DynRuleIntersectUnion(<1>,<2>,<3>,GenDynRules([]))"), right}
+    "@#$" Strategy "/" RuleNames "\\"? "/"?          -> Strategy {completion, ast("DynRuleIntersectUnion(<1>,<2>,RuleNames([]),GenDynRules([]))"), right}
+
+  priorities
+    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")} >
+    { "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF> ->
+      <Strategy-CF> {cons("DynRuleUnionFix")}
+      "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> ->
+      <Strategy-CF> {cons("DynRuleUnionFix")}
+      
+      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+      
+      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")} } >
+    <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF>
+    {cons("AM")}
+
+  context-free priorities
+    StrategyAngle Term -> Strategy {cons("BA")} >
+    "/" RuleNames "\\*" Strategy -> Strategy {cons("DynRuleIntersectFix")} >
+    Strategy "=>" Term -> Strategy {cons("AM")} >
+    Strategy "/" RuleNames "\\" Strategy -> Strategy
+    {cons("DynRuleIntersect"), right} >
+    Strategy "\\" RuleNames "/" Strategy -> Strategy
+    {cons("DynRuleUnion"), right} >
+    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy
+    {cons("DynRuleIntersectUnion"), right} >
+    Strategy ";" Strategy -> Strategy {cons("Seq"), right}
+
+module Stratego-Sugar-Rules
+imports Stratego-Sugar-Strategies
+
+exports
+  sorts RuleDef
+
+  context-free syntax
+    Id ":" Rule                                           -> RuleDef {cons("RDefNoArgs")}
+    Id "(" {Typedid ","}* ")" ":" Rule                    -> RuleDef {cons("RDef")}
+    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" ":" Rule -> RuleDef {cons("RDefT")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* ")"? ":"?                    -> RuleDef {completion, ast("RDef(<1>,<2>,RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+    "@#$" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? ":"? -> RuleDef {completion, ast("RDefT(<1>,<2>,<3>,RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+    "@#$" Id "(" {Typedid ","}* "|"? ")"? ":"?               -> RuleDef {completion, ast("RDefT(<1>,<2>,[],RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+    "@#$" Id                                                 -> RuleDef {completion, ast("RDefT(<1>,[],[],RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+
+  sorts Rule RuleCond
+
+  context-free syntax
+    Term "->" Term                  -> Rule     {cons("RuleNoCond")}
+    Term "->" Term "where" Strategy -> Rule     {cons("Rule")}
+    Term "->" Term RuleCond+        -> Rule     {cons("Rule"), avoid}
+    "where" Strategy                -> RuleCond {cons("WhereClause")}
+    "with" Strategy                 -> RuleCond {cons("WithClause")}
+
+  context-free syntax
+    "@#$" Term "->" Term "where"? -> Rule {completion, ast("Rule(<1>,<2>,GenDynRules([]))")}
+    "@#$" Term                    -> Rule {completion, ast("Rule(<1>,RootApp(GenDynRules([])),[WhereClause(GenDynRules([]))])"), avoid}
+
+module Stratego-Sugar-Strategies
+imports Stratego-Core-Strategies Stratego-Sugar-Terms Stratego-Sugar-Constants
+        Stratego-Sugar-Signatures
+
+exports
+  context-free syntax
+    Id "=" Strategy                        -> StrategyDef {cons("SDefNoArgs")}
+    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* ")"? "="? -> StrategyDef {completion, ast("SDef(<1>,<2>,GenDynRules([]))")}
+    "@#$" Id                              -> StrategyDef {completion, ast("SDef(<1>,[],GenDynRules([]))")}
+
+  context-free syntax
+    ID -> Typedid {cons("DefaultVarDec")}
+
+  context-free syntax
+    
+
+  sorts Rule
+
+  sorts StrategyParen StrategyCurly StrategyAngle
+
+  context-free syntax
+    SVar "(" {Strategy ","}* ")"          -> Strategy      {cons("Call")}
+    "{" Strategy "}"                      -> Strategy      {cons("ScopeDefault")}
+    StrategyAngle Term                    -> Strategy      {cons("BA")}
+    "<" Strategy ">"                      -> StrategyAngle {bracket}
+    Strategy "<+" Strategy                -> Strategy      {cons("LChoice"), right}
+    "rec" Id "(" Strategy ")"             -> Strategy      {cons("Rec")}
+    "not" "(" Strategy ")"                -> Strategy      {cons("Not")}
+    "where" "(" Strategy ")"              -> Strategy      {cons("Where")}
+    "with" "(" Strategy ")"               -> Strategy      {cons("With"), prefer}
+    "test" "(" Strategy ")"               -> Strategy      {cons("Test")}
+    "prim" "(" String ")"                 -> Strategy      {cons("PrimNoArgs")}
+    "prim" "(" String "," {Term ","}* ")" -> Strategy      {cons("Prim")}
+    String                                -> Strategy      {cons("StrCong")}
+    Int                                   -> Strategy      {cons("IntCong")}
+    Real                                  -> Strategy      {cons("RealCong")}
+    Char                                  -> Strategy      {cons("CharCong")}
+    String "(" {Strategy ","}* ")"        -> Strategy      {cons("CongQ")}
+    Strategy StrategyCurly                -> Strategy      {cons("AnnoCong")}
+    "{" Strategy "}"                      -> StrategyCurly {cons("StrategyCurly")}
+    "(" ")"                               -> Strategy      {cons("EmptyTupleCong")}
+    "(" Strategy ")"                      -> Strategy      {bracket}
+    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy      {cons("TupleCong")}
+    "[" {Strategy ","}* "]"               -> Strategy      {cons("ListCongNoTail")}
+    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy      {cons("ListCong")}
+    Strategy "#" StrategyParen            -> Strategy      {cons("ExplodeCong")}
+
+  context-free syntax
+    "@#$" SVar "(" {Strategy ","}* ")"?          -> Strategy      {completion, cons("Call")}
+    "@#$" SVar                                   -> Strategy      {completion, ast("Call(<1>,[])")}
+    "@#$" "{" Strategy "}"?                      -> Strategy      {completion, cons("ScopeDefault")}
+    "@#$" StrategyAngle                          -> Strategy      {completion, ast("BA(<1>,RootApp(GenDynRules([])))")}
+    "@#$" "<" Strategy ">"?                      -> StrategyAngle {completion, bracket}
+    "@#$" "rec" Id "(" Strategy ")"?             -> Strategy      {completion, cons("Rec")}
+    "@#$" "rec" Id "("? ")"?                     -> Strategy      {completion, ast("Rec(<1>,GenDynRules([]))")}
+    "@#$" "not" "(" Strategy ")"?                -> Strategy      {completion, cons("Not")}
+    "@#$" "where" "(" Strategy ")"?              -> Strategy      {completion, cons("Where")}
+    "@#$" "with" "(" Strategy ")"?               -> Strategy      {completion, cons("With"), prefer}
+    "@#$" "test" "(" Strategy ")"?               -> Strategy      {completion, cons("Test")}
+    "@#$" "prim" "(" String ")"?                 -> Strategy      {completion, cons("PrimNoArgs")}
+    "@#$" "prim" "(" String "," {Term ","}* ")"? -> Strategy      {completion, cons("Prim")}
+    "@#$" "prim" "(" String ","? ")"?            -> Strategy      {completion, ast("Prim(<1>,[])")}
+    "@#$" String "(" {Strategy ","}* ")"?        -> Strategy      {completion, cons("CongQ")}
+    "@#$" "{" Strategy "}"?                      -> StrategyCurly {completion, cons("StrategyCurly")}
+    "@#$" "(" Strategy ")"?                      -> Strategy      {completion, bracket}
+    "@#$" "(" Strategy "," {Strategy ","}+ ")"?  -> Strategy      {completion, cons("TupleCong")}
+    "@#$" "(" Strategy ","? ")"?                 -> Strategy      {completion, ast("TupleCong(<1>,[GenDynRules([])])")}
+    "@#$" "[" {Strategy ","}* "]"?               -> Strategy      {completion, cons("ListCongNoTail")}
+    "@#$" "[" {Strategy ","}* "|" Strategy "]"?  -> Strategy      {completion, cons("ListCong")}
+    "@#$" "[" {Strategy ","}* "|"? "]"?          -> Strategy      {completion, ast("ListCong(<1>,GenDynRules([]))")}
+
+  sorts SwitchCase
+
+  context-free syntax
+    SVar                                                         -> Strategy   {cons("CallNoArgs")}
+    "\\" Rule "\\"                                               -> Strategy   {cons("LRule")}
+    "(" Rule ")"                                                 -> Strategy   {cons("SRule")}
+    Strategy "+" Strategy                                        -> Strategy   {cons("Choice"), right}
+    Strategy "+>" Strategy                                       -> Strategy   {cons("RChoice"), right}
+    "if" Strategy "then" Strategy "else" Strategy "end"          -> Strategy   {cons("CondChoice")}
+    "if" Strategy "then" Strategy "end"                          -> Strategy   {cons("IfThen")}
+    "switch" Strategy SwitchCase* "end"                          -> Strategy   {cons("SwitchChoiceNoOtherwise")}
+    "switch" Strategy SwitchCase* "otherwise" ":" Strategy "end" -> Strategy   {cons("SwitchChoice")}
+    "case" Strategy ":" Strategy                                 -> SwitchCase {cons("SwitchCase")}
+    Strategy "=>" Term                                           -> Strategy   {cons("AM")}
+    Term ":=" Term                                               -> Strategy   {cons("Assign")}
+
+  context-free syntax
+    "@#$" "\\" Rule "\\"?                                               -> Strategy   {completion, cons("LRule")}
+    "@#$" "(" Rule ")"?                                                 -> Strategy   {completion, cons("SRule")}
+    "@#$" "if" Strategy "then" Strategy "else" Strategy "end"?          -> Strategy   {completion, cons("CondChoice")}
+    "@#$" "if" Strategy "then" Strategy "else"? "end"?                  -> Strategy   {completion, ast("CondChoice(<1>,<2>,GenDynRules([]))")}
+    "@#$" "if" Strategy "then"? "else"? "end"?                          -> Strategy   {completion, ast("CondChoice(<1>,GenDynRules([]),GenDynRules([]))")}
+    "@#$" "if" Strategy "then" Strategy "end"?                          -> Strategy   {completion, cons("IfThen")}
+    "@#$" "if" Strategy "then"? "end"?                                  -> Strategy   {completion, ast("IfThen(<1>,GenDynRules([]))")}
+    "@#$" "switch" Strategy SwitchCase* "end"?                          -> Strategy   {completion, cons("SwitchChoiceNoOtherwise")}
+    "@#$" "switch" Strategy "end"?                                      -> Strategy   {completion, ast("SwitchChoiceNoOtherwise(<1>,[])")}
+    "@#$" "switch" Strategy SwitchCase* "otherwise" ":" Strategy "end"? -> Strategy   {completion, cons("SwitchChoice")}
+    "@#$" "switch" Strategy SwitchCase* "otherwise"? ":"? "end"?        -> Strategy   {completion, ast("SwitchChoice(<1>,<2>,GenDynRules([]))")}
+    "@#$" "switch" Strategy "otherwise"? ":"? "end"?                    -> Strategy   {completion, ast("SwitchChoice(<1>,[],GenDynRules([]))")}
+    "@#$" "case" Strategy ":"?                                          -> SwitchCase {completion, ast("SwitchCase(<1>,GenDynRules([]))")}
+    "@#$" Term                                                          -> Strategy   {completion, ast("Assign(<1>,RootApp(GenDynRules([])))")}
+
+  context-free priorities
+    { Strategy StrategyCurly -> Strategy 
+      Strategy "#" StrategyParen -> Strategy  } >
+    { "!" Term -> Strategy 
+      "?" Term -> Strategy  } >
+    StrategyAngle Term -> Strategy  >
+    Strategy "=>" Term -> Strategy  >
+    Strategy ";" Strategy -> Strategy  >
+    {right:
+      Strategy "+" Strategy -> Strategy 
+      Strategy "<+" Strategy -> Strategy 
+      Strategy "+>" Strategy -> Strategy 
+      Strategy "<" StrategyMid "+" Strategy -> Strategy 
+    }
+
+  context-free priorities
+    Strategy -> StrategyMid  >
+    Strategy "+" Strategy -> Strategy 
+
+  context-free priorities
+    { Strategy StrategyCurly -> Strategy 
+      Strategy "#" StrategyParen -> Strategy  } . >
+    Term ":=" Term -> Strategy 
+
+module Stratego-Sugar-Terms
+imports Stratego-Core-Terms Stratego-Sugar-Strategies
+
+exports
+  sorts LID
+
+  context-free syntax
+    LId -> LID {cons("ListVar")}
+    LID -> Var {cons("Var")}
+    LID -> ID  
+
+  context-free syntax
+    
+
+  context-free syntax
+    "_" PreTerm                  -> PreTerm {cons("BuildDefaultPT")}
+    "_" Term                     -> Term    {cons("BuildDefault"), prefer}
+    Char                         -> PreTerm {cons("Char")}
+    PreTerm "{" {Term ","}* "}"  -> Term    {cons("AnnoList")}
+    PreTerm                      -> Term    {cons("NoAnnoList")}
+    "<" Strategy ">" Term        -> PreTerm {cons("App")}
+    "<" Strategy ">" Term        -> Term    {cons("App"), prefer}
+    StrategyAngle                -> PreTerm {cons("RootApp")}
+    StrategyAngle                -> Term    {cons("RootApp"), prefer}
+    "(" {Term ","}* ")"          -> PreTerm {cons("Tuple")}
+    "[" {Term ","}* "]"          -> PreTerm {cons("List")}
+    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}
+
+  context-free syntax
+    "@#$" PreTerm "{" {Term ","}* "}"?  -> Term    {completion, cons("AnnoList")}
+    "@#$" "<" Strategy ">"?             -> PreTerm {completion, ast("App(<1>,RootApp(GenDynRules([])))")}
+    "@#$" "<" Strategy ">"?             -> Term    {completion, ast("App(<1>,RootApp(GenDynRules([])))"), prefer}
+    "@#$" "(" {Term ","}* ")"?          -> PreTerm {completion, cons("Tuple")}
+    "@#$" "[" {Term ","}* "]"?          -> PreTerm {completion, cons("List")}
+    "@#$" "[" {Term ","}* "|" Term "]"? -> PreTerm {completion, cons("ListTail")}
+    "@#$" "[" {Term ","}* "|"? "]"?     -> PreTerm {completion, ast("ListTail(<1>,RootApp(GenDynRules([])))")}
+
+  context-free priorities
+    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
+    PreTerm "{" {Term ","}* "}" -> Term {cons("AnnoList")} >
+    Var "@" Term -> Term {cons("As")}
+
+module Stratego-Sugar-Signatures
+imports Stratego-Core-Signatures Stratego-Sugar-Constants
+
+exports
+  sorts Sort
+
+  context-free syntax
+    "[" {Sort ","}* "]"          -> Sort {cons("SortList")}
+    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
+    "(" {Sort ","}* ")"          -> Sort {cons("SortTuple")}
+
+  context-free syntax
+    "@#$" "[" {Sort ","}* "]"?          -> Sort {completion, cons("SortList")}
+    "@#$" "[" {Sort ","}* "|" Sort "]"? -> Sort {completion, cons("SortListTl")}
+    "@#$" "[" {Sort ","}* "|"? "]"?     -> Sort {completion, ast("SortListTl(<1>,SortList([]))")}
+    "@#$" "(" {Sort ","}* ")"?          -> Sort {completion, cons("SortTuple")}
+
+  sorts Kind
+
+  context-free syntax
+    "*"  -> Kind {cons("Star")}
+    "**" -> Kind {cons("StarStar")}
+
+  context-free syntax
+    
+
+module Stratego-Core-Signatures
+imports Stratego-Core-Identifiers Stratego-Core-Constants
+
+exports
+  sorts Sdecl
+
+  context-free syntax
+    "sorts" Sort*          -> Sdecl {cons("Sorts")}
+    "constructors" Opdecl* -> Sdecl {cons("Constructors")}
+
+  context-free syntax
+    
+
+  sorts Sort
+
+  context-free syntax
+    LCID                   -> Sort {cons("SortVar")}
+    UCID                   -> Sort {cons("SortNoArgs")}
+    Id "(" {Sort ","}* ")" -> Sort {cons("Sort")}
+
+  context-free syntax
+    "@#$" Id "(" {Sort ","}* ")"? -> Sort {completion, cons("Sort")}
+    "@#$" Id                      -> Sort {completion, ast("Sort(<1>,[])")}
+
+  sorts Opdecl
+
+  context-free syntax
+    Id ":" Type     -> Opdecl {cons("OpDecl")}
+    String ":" Type -> Opdecl {cons("OpDeclQ")}
+    ":" Type        -> Opdecl {cons("OpDeclInj")}
+
+  context-free syntax
+    "@#$" Id     -> Opdecl {completion, ast("OpDecl(<1>,Boolean)")}
+    "@#$" String -> Opdecl {completion, ast("OpDeclQ(<1>,Boolean)")}
+
+  context-free syntax
+    "external" Id ":" Type     -> Opdecl {cons("ExtOpDecl")}
+    "external" String ":" Type -> Opdecl {cons("ExtOpDeclQ")}
+    "external" ":" Type        -> Opdecl {cons("ExtOpDeclInj")}
+
+  context-free syntax
+    "@#$" "external" Id ":"?     -> Opdecl {completion, ast("ExtOpDecl(<1>,Boolean)")}
+    "@#$" "external" String ":"? -> Opdecl {completion, ast("ExtOpDeclQ(<1>,Boolean)")}
+
+  sorts Type ArgType ConstType FunType RetType
+
+  context-free syntax
+    Sort                        -> ConstType {cons("ConstType")}
+    {ArgType "*"}+ "->" RetType -> FunType   {cons("FunType")}
+    "(" Type ")"                -> ArgType   {bracket}
+    ConstType                   -> ArgType   
+    Type                        -> RetType   
+    FunType                     -> RetType   {reject}
+    FunType                     -> Type      
+    ConstType                   -> Type      
+
+  context-free syntax
+    "@#$" {ArgType "*"}+ -> FunType {completion, ast("FunType(<1>,Boolean)")}
+    "@#$" "(" Type ")"?  -> ArgType {completion, bracket}
+
+  context-free restrictions
+    Sort -/- [\(]
+
+module Stratego-Core-Terms
+imports Stratego-Core-Identifiers Stratego-Core-Constants
+
+exports
+  sorts ID Var Wld
+
+  context-free syntax
+    Id -> Var {cons("Var")}
+    Id -> ID  
+
+  context-free syntax
+    
+
+  sorts Term PreTerm
+
+  context-free syntax
+    Var                        -> PreTerm 
+    Var                        -> Term    {prefer}
+    "_"                        -> Wld     {cons("Wld")}
+    Wld                        -> PreTerm 
+    Wld                        -> Term    {prefer}
+    Int                        -> PreTerm {cons("Int")}
+    Real                       -> PreTerm {cons("Real")}
+    String                     -> PreTerm {cons("Str")}
+    Id "(" {Term ","}* ")"     -> PreTerm {cons("Op")}
+    String "(" {Term ","}* ")" -> PreTerm {cons("OpQ")}
+    Term "#" "(" Term ")"      -> PreTerm {cons("Explode")}
+    PreTerm "{^" PreTerm "}"   -> Term    {cons("Anno")}
+    Var "@" Term               -> Term    {cons("As"), prefer}
+    Var "@" PreTerm            -> PreTerm {cons("As")}
+
+  context-free syntax
+    "@#$" Id "(" {Term ","}* ")"?     -> PreTerm {completion, cons("Op")}
+    "@#$" Id                          -> PreTerm {completion, ast("Op(<1>,[])")}
+    "@#$" String "(" {Term ","}* ")"? -> PreTerm {completion, cons("OpQ")}
+    "@#$" Term "#" "(" Term ")"?      -> PreTerm {completion, cons("Explode")}
+    "@#$" Term                        -> PreTerm {completion, ast("Explode(<1>,RootApp(GenDynRules([])))")}
+    "@#$" PreTerm "{^" PreTerm "}"?   -> Term    {completion, cons("Anno")}
+    "@#$" PreTerm                     -> Term    {completion, ast("Anno(<1>,RootApp(GenDynRules([])))")}
+
+  context-free priorities
+    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
+    Var "@" Term -> Term {cons("As")}
+
+module Stratego-Core-Strategies
+imports Stratego-Core-Terms Stratego-Core-Constants Stratego-Core-Signatures
+
+exports
+  sorts Def
+
+  context-free syntax
+    StrategyDef                                             -> Def      
+    Id                                                      -> SVar     {cons("SVar")}
+    "let" Def* "in" Strategy "end"                          -> Strategy {cons("Let")}
+    SVar "(" {Strategy ","}* "|" {Term ","}* ")"            -> Strategy {cons("CallT")}
+    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}
+
+  context-free syntax
+    "@#$" "let" Def* "in" Strategy "end"?                          -> Strategy {completion, cons("Let")}
+    "@#$" "let" Def* "in"? "end"?                                  -> Strategy {completion, ast("Let(<1>,GenDynRules([]))")}
+    "@#$" SVar "(" {Strategy ","}* "|" {Term ","}* ")"?            -> Strategy {completion, cons("CallT")}
+    "@#$" SVar "(" {Strategy ","}* "|"? ")"?                       -> Strategy {completion, ast("CallT(<1>,<2>,[])")}
+    "@#$" SVar                                                     -> Strategy {completion, ast("CallT(<1>,[],[])")}
+    "@#$" "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")"? -> Strategy {completion, cons("CallDynamic")}
+    "@#$" "call" "(" Term "|" {Strategy ","}* "|"? ")"?            -> Strategy {completion, ast("CallDynamic(<1>,<2>,[])")}
+    "@#$" "call" "(" Term "|"? "|"? ")"?                           -> Strategy {completion, ast("CallDynamic(<1>,[],[])")}
+
+  sorts StrategyDef
+
+  context-free syntax
+    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy            -> StrategyDef {cons("SDefT")}
+    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
+    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"              -> StrategyDef {cons("ExtSDef")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? "="?            -> StrategyDef {completion, ast("SDefT(<1>,<2>,<3>,GenDynRules([]))")}
+    "@#$" Id "(" {Typedid ","}* "|"? ")"? "="?                          -> StrategyDef {completion, ast("SDefT(<1>,<2>,[],GenDynRules([]))")}
+    "@#$" Id                                                            -> StrategyDef {completion, ast("SDefT(<1>,[],[],GenDynRules([]))")}
+    "@#$" "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? "="? -> StrategyDef {completion, ast("ExtSDefInl(<1>,<2>,<3>,GenDynRules([]))")}
+    "@#$" "external" Id "(" {Typedid ","}* "|"? ")"? "="?               -> StrategyDef {completion, ast("ExtSDefInl(<1>,<2>,[],GenDynRules([]))")}
+    "@#$" "external" Id "("? "|"? ")"? "="?                             -> StrategyDef {completion, ast("ExtSDefInl(<1>,[],[],GenDynRules([]))")}
+    "@#$" "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"?      -> StrategyDef {completion, cons("ExtSDef")}
+    "@#$" "external" Id "(" {Typedid ","}* "|"? ")"?                    -> StrategyDef {completion, ast("ExtSDef(<1>,<2>,[])")}
+    "@#$" "external" Id "("? "|"? ")"?                                  -> StrategyDef {completion, ast("ExtSDef(<1>,[],[])")}
+
+  sorts Typedid
+
+  context-free syntax
+    ID ":" Type -> Typedid {cons("VarDec")}
+
+  context-free syntax
+    "@#$" ID -> Typedid {completion, ast("VarDec(<1>,Boolean)")}
+
+  sorts Strategy SVar StrategyParen StrategyMid
+
+  context-free syntax
+    "(" Strategy ")"                                          -> StrategyParen {cons("ParenStrat")}
+    "fail"                                                    -> Strategy      {cons("Fail")}
+    "id"                                                      -> Strategy      {cons("Id")}
+    "?" Term                                                  -> Strategy      {cons("Match")}
+    "!" Term                                                  -> Strategy      {cons("Build")}
+    "{" {ID ","}* ":" Strategy "}"                            -> Strategy      {cons("Scope")}
+    Strategy ";" Strategy                                     -> Strategy      {cons("Seq"), right}
+    Strategy "<" StrategyMid "+" Strategy                     -> Strategy      {cons("GuardedLChoice"), right}
+    Strategy                                                  -> StrategyMid   
+    "prim" "(" String "," {Strategy ","}* "|" {Term ","}* ")" -> Strategy      {cons("PrimT")}
+    "some" "(" Strategy ")"                                   -> Strategy      {cons("Some")}
+    "one" "(" Strategy ")"                                    -> Strategy      {cons("One")}
+    "all" "(" Strategy ")"                                    -> Strategy      {cons("All")}
+
+  context-free syntax
+    "@#$" "(" Strategy ")"?                                          -> StrategyParen {completion, cons("ParenStrat")}
+    "@#$" "{" {ID ","}* ":" Strategy "}"?                            -> Strategy      {completion, cons("Scope")}
+    "@#$" "{" {ID ","}* ":"? "}"?                                    -> Strategy      {completion, ast("Scope(<1>,GenDynRules([]))")}
+    "@#$" Strategy "<" StrategyMid "+"?                              -> Strategy      {completion, ast("GuardedLChoice(<1>,<2>,GenDynRules([]))"), right}
+    "@#$" "prim" "(" String "," {Strategy ","}* "|" {Term ","}* ")"? -> Strategy      {completion, cons("PrimT")}
+    "@#$" "prim" "(" String "," {Strategy ","}* "|"? ")"?            -> Strategy      {completion, ast("PrimT(<1>,<2>,[])")}
+    "@#$" "prim" "(" String ","? "|"? ")"?                           -> Strategy      {completion, ast("PrimT(<1>,[],[])")}
+    "@#$" "some" "(" Strategy ")"?                                   -> Strategy      {completion, cons("Some")}
+    "@#$" "one" "(" Strategy ")"?                                    -> Strategy      {completion, cons("One")}
+    "@#$" "all" "(" Strategy ")"?                                    -> Strategy      {completion, cons("All")}
+
+  context-free priorities
+    { "!" Term -> Strategy {cons("Build")}
+      "?" Term -> Strategy {cons("Match")} } >
+    Strategy ";" Strategy -> Strategy {cons("Seq"), right} >
+    {right:
+      Strategy "<" StrategyMid "+" Strategy -> Strategy
+      {cons("GuardedLChoice"), right}
+    }
+
+  context-free syntax
+    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}
+
+  context-free syntax
+    "@#$" "import-term" "(" ModName ")"? -> Strategy {completion, cons("ImportTerm")}
+
+module Stratego-Core-Modules
+imports Stratego-Core-Identifiers Stratego-Core-Strategies
+        Stratego-Core-Signatures
+
+exports
+  sorts Module
+
+  context-free syntax
+    "module" ModName Decl* -> Module {cons("Module")}
+    "specification" Decl*  -> Module {cons("Specification")}
+
+  context-free syntax
+    
+
+  sorts Decl
+
+  context-free syntax
+    "imports" ImportModName* -> Decl {cons("Imports")}
+    "strategies" Def*        -> Decl {cons("Strategies")}
+    "signature" Sdecl*       -> Decl {cons("Signature")}
+
+  context-free syntax
+    
+
+  sorts ImportModName
+
+  context-free syntax
+    ModName -> ImportModName {cons("Import")}
+
+  context-free syntax
+    
+
+  syntax
+    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}
+
+module Stratego-Sugar-Modules
+imports Stratego-Core-Modules Stratego-Sugar-Strategies
+        Stratego-Sugar-Signatures Stratego-Sugar-Overlays Stratego-Sugar-Rules
+
+exports
+  sorts Decl Def
+
+  context-free syntax
+    "rules" Def*        -> Decl {cons("Rules")}
+    "overlays" Overlay* -> Decl {cons("Overlays")}
+    RuleDef             -> Def  
+
+  context-free syntax
+    
+
+module Stratego-Core-Constants
+exports
+  sorts Int Real String StrChar
+
+  lexical syntax
+    [\-]? [0-9]+             -> Int     
+    [\-]? [0-9]+ [\.] [0-9]+ -> Real    
+    "\"" StrChar* "\""       -> String  
+    ~[\"\\]                  -> StrChar 
+    [\\] [\"tnr\\]           -> StrChar 
+
+module Stratego-Sugar-Constants
+imports Stratego-Core-Identifiers Stratego-Core-Constants
+
+exports
+  sorts Char CharChar
+
+  lexical syntax
+    "'" CharChar "'" -> Char     
+    ~[\']            -> CharChar 
+    [\\] [\'ntr\ ]   -> CharChar 
+    Char             -> Id       {reject}
+
+module Stratego-Core-Identifiers
+exports
+  sorts ModName ModNamePart
+
+  lexical syntax
+    {ModNamePart "/"}+                -> ModName     
+    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart 
+
+  lexical restrictions
+    ModName -/- [a-zA-Z0-9\'\.\-\_]
+
+  lexical syntax
+    "imports"    -> ModName {reject}
+    "overlays"   -> ModName {reject}
+    "rules"      -> ModName {reject}
+    "signature"  -> ModName {reject}
+    "strategies" -> ModName {reject}
+
+  sorts Id LId LCID UCID Wld
+
+  lexical syntax
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id   
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId  
+    [\'] [a-z]+                       -> Id   
+    [a-z] [a-zA-Z0-9\'\-\_]*          -> LCID 
+    [A-Z] [a-zA-Z0-9\'\-\_]*          -> UCID 
+
+  lexical restrictions
+    Id -/- [a-zA-Z0-9\'\-\_\*]
+    LId -/- [a-zA-Z0-9\'\-\_]
+    LCID -/- [a-zA-Z0-9\'\-\_]
+    UCID -/- [a-zA-Z0-9\'\-\_]
+
+  lexical syntax
+    "_"     -> Id   {reject}
+    "'"     -> Id   {reject}
+    Keyword -> Id   {reject}
+    Keyword -> LId  {reject}
+    Keyword -> LCID {reject}
+    Keyword -> UCID {reject}
+
+  lexical restrictions
+    "all" "case" "constructors" "else" "end" "external" "fail" "id" "if" "in"
+    "imports" "let" "module" "not" "one" "overlays" "otherwise" "prim" "rec"
+    "rules" "script" "signature" "some" "sorts" "strategies" "stratego" "switch"
+    "test" "then" "where" "import-term" -/- [a-zA-Z0-9\'\-\_]
+
+  context-free restrictions
+    Wld -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Keyword
+
+  lexical syntax
+    "all"          -> Keyword 
+    "constructors" -> Keyword 
+    "fail"         -> Keyword 
+    "id"           -> Keyword 
+    "in"           -> Keyword 
+    "let"          -> Keyword 
+    "module"       -> Keyword 
+    "not"          -> Keyword 
+    "one"          -> Keyword 
+    "overlays"     -> Keyword 
+    "prim"         -> Keyword 
+    "rules"        -> Keyword 
+    "script"       -> Keyword 
+    "signature"    -> Keyword 
+    "some"         -> Keyword 
+    "sorts"        -> Keyword 
+    "strategies"   -> Keyword 
+    "stratego"     -> Keyword 
+    "test"         -> Keyword 
+    "where"        -> Keyword 
+    "import-term"  -> Keyword 
+
+module Stratego-Core-Layout
+exports
+  sorts Ws ShortCom LongCom CommChar Asterisk Eof
+
+  lexical syntax
+    [\t\ \n\r]             -> Ws       
+    "//" ~[\n]* [\n] | Eof -> ShortCom 
+    "/*" CommChar* "*/"    -> LongCom  
+                           -> Eof      
+    ~[\*]                  -> CommChar 
+    "*"                    -> Asterisk 
+    Asterisk               -> CommChar 
+
+  lexical restrictions
+    Asterisk -/- [\/]
+    Eof -/- ~[]
+
+  lexical syntax
+    ShortCom -> LAYOUT 
+    LongCom  -> LAYOUT 
+    Ws       -> LAYOUT 
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/] . [\*]
+    LAYOUT? -/- [\/] . [\/]
+
+module Stratego-Sugar-Layout
+imports Stratego-Core-Layout
+
+module Stratego-Sugar
+imports Stratego-Sugar-Layout Stratego-Core-Identifiers Stratego-Sugar-Constants
+        Stratego-Sugar-Modules Stratego-Sugar-Signatures Stratego-Sugar-Terms
+        Stratego-Sugar-Strategies Stratego-Sugar-Rules
+        Stratego-Sugar-DynamicRules Stratego-Sugar-Overlays
+
+hiddens
+  context-free start-symbols
+    Module
+
+module Stratego
+imports Stratego-Sugar
+
+hiddens
+  context-free start-symbols
+    Module
+
+module StrategoMix[Ctx0]
+imports Stratego
+          [ RuleNames      => RuleNames[[Ctx0]]
+            RuleDec        => RuleDec[[Ctx0]]
+            DynRuleScopeId => DynRuleScopeId[[Ctx0]]
+            DynRuleId      => DynRuleId[[Ctx0]]
+            DynRuleDef     => DynRuleDef[[Ctx0]]
+            ScopeLabels    => ScopeLabels[[Ctx0]]
+            RuleCond       => RuleCond[[Ctx0]]
+            Rule           => Rule[[Ctx0]]
+            RuleDef        => RuleDef[[Ctx0]]
+            Overlay        => Overlay[[Ctx0]]
+            SwitchCase     => SwitchCase[[Ctx0]]
+            StrategyCurly  => StrategyCurly[[Ctx0]]
+            StrategyAngle  => StrategyAngle[[Ctx0]]
+            Kind           => Kind[[Ctx0]]
+            LID            => LID[[Ctx0]]
+            ImportModName  => ImportModName[[Ctx0]]
+            Decl           => Decl[[Ctx0]]
+            Module         => Module[[Ctx0]]
+            StrategyParen  => StrategyParen[[Ctx0]]
+            Typedid        => Typedid[[Ctx0]]
+            StrategyDef    => StrategyDef[[Ctx0]]
+            SVar           => SVar[[Ctx0]]
+            Def            => Def[[Ctx0]]
+            Type           => Type[[Ctx0]]
+            RetType        => RetType[[Ctx0]]
+            ArgType        => ArgType[[Ctx0]]
+            FunType        => FunType[[Ctx0]]
+            ConstType      => ConstType[[Ctx0]]
+            Opdecl         => Opdecl[[Ctx0]]
+            Sort           => Sort[[Ctx0]]
+            Sdecl          => Sdecl[[Ctx0]]
+            Wld            => Wld[[Ctx0]]
+            ID             => ID[[Ctx0]]
+            Var            => Var[[Ctx0]]
+            CharChar       => CharChar[[Ctx0]]
+            Char           => Char[[Ctx0]]
+            StrChar        => StrChar[[Ctx0]]
+            String         => String[[Ctx0]]
+            Real           => Real[[Ctx0]]
+            Int            => Int[[Ctx0]]
+            Keyword        => Keyword[[Ctx0]]
+            UCID           => UCID[[Ctx0]]
+            LCID           => LCID[[Ctx0]]
+            LId            => LId[[Ctx0]]
+            Id             => Id[[Ctx0]]
+            ModNamePart    => ModNamePart[[Ctx0]]
+            ModName        => ModName[[Ctx0]]
+            PreTerm        => PreTerm[[Ctx0]]
+            Term           => Term[[Ctx0]]
+            StrategyMid    => StrategyMid[[Ctx0]]
+            Strategy       => Strategy[[Ctx0]] ]
+
+module StrategoJava
+imports StrategoMix[StrategoHost]
+        languages/java/EmbeddedJavaMix[JavaObject Term[[StrategoHost]]]
+
+exports
+  context-free start-symbols
+    Module[[StrategoHost]]
\ No newline at end of file

Added: sglr-recovery/trunk/Evaluate/grammars-completion/StrategoJava-WC-Completions.def
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/grammars-completion/StrategoJava-WC-Completions.def	Wed Aug 24 07:10:15 2011	(r23239)
@@ -0,0 +1,3085 @@
+definition
+
+module languages/java-15/expressions/Priorities
+imports languages/java-15/lexical/Identifiers languages/java-15/expressions/Main
+
+exports
+  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR
+
+  lexical syntax
+    ~[A-Za-z0-9\_]                 -> WATERTOKENSTART     {recover, avoid}
+    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
+    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}
+    "*"                            -> WATERTOKENSTAR      {recover, avoid}
+    WATERTOKEN                     -> WATER               
+    WATERTOKENSEPARATOR            -> WATER               
+    WATERTOKENSTAR                 -> WATER               
+                                   -> WATEREOF            
+
+  lexical restrictions
+    WATERTOKEN -/- [A-Za-z0-9\_]
+    WATERTOKENSTAR -/- [\/]
+
+  context-free syntax
+    WATER -> LAYOUT {cons("WATER")}
+
+  (
+
+  sorts WATEREOF
+
+  lexical restrictions
+    WATEREOF -/- ~[]
+
+  lexical syntax
+    %% Lexical insertion recovery rules                      
+                                        -> "class"           {recover, cons("INSERTION")}
+                                        -> ";"               {recover, cons("INSERTION")}
+                                        -> "."               {recover, cons("INSERTION")}
+                                        -> "&"               {recover, cons("INSERTION")}
+    "/*"                                -> INSERTSTART       {recover}
+    INSERTSTART CommentPart* WATEREOF   -> Comment           {cons("INSERTEND")}
+    "/**"                               -> INSERTSTART       {recover}
+    INSERTSTART CommentPart* WATEREOF   -> Comment           {cons("INSERTEND")}
+                                        -> "~bstm*:"         {recover, cons("INSERTION")}
+                                        -> "~switch-group*:" {recover, cons("INSERTION")}
+                                        -> "~package-dec?:"  {recover, cons("INSERTION")}
+                                        -> "~import-dec*:"   {recover, cons("INSERTION")}
+                                        -> "]|"              {recover, cons("INSERTION")}
+                                        -> "~name:"          {recover, cons("INSERTION")}
+                                        -> "~*:"             {recover, cons("INSERTION")}
+                                        -> "~*"              {recover, cons("INSERTION")}
+                                        -> "|}"              {recover, cons("INSERTION")}
+                                        -> ">"               {recover, cons("INSERTION")}
+                                        -> "\\"              {recover, cons("INSERTION")}
+                                        -> "]"               {recover, cons("INSERTION")}
+                                        -> "sorts"           {recover, cons("INSERTION")}
+                                        -> "constructors"    {recover, cons("INSERTION")}
+                                        -> ":"               {recover, cons("INSERTION")}
+                                        -> "*"               {recover, cons("INSERTION")}
+                                        -> "end"             {recover, cons("INSERTION")}
+                                        -> "}"               {recover, cons("INSERTION")}
+                                        -> ","               {recover, cons("INSERTION")}
+                                        -> ")"               {recover, cons("INSERTION")}
+                                        -> "@"               {recover, cons("INSERTION")}
+                                        -> "module"          {recover, cons("INSERTION")}
+                                        -> "specification"   {recover, cons("INSERTION")}
+                                        -> "imports"         {recover, cons("INSERTION")}
+                                        -> "strategies"      {recover, cons("INSERTION")}
+                                        -> "signature"       {recover, cons("INSERTION")}
+                                        -> "overlays"        {recover, cons("INSERTION")}
+    "\""                                -> INSERTOPENQUOTE   {recover}
+    INSERTOPENQUOTE StrChar* "\n"       -> String            {cons("INSERTEND")}
+    INSERTOPENQUOTE StrChar* WATEREOF   -> String            {cons("INSERTEND")}
+    "'"                                 -> INSERTOPENQUOTE   {recover}
+    INSERTOPENQUOTE CharChar "\n"       -> Char              {cons("INSERTEND")}
+    INSERTOPENQUOTE CharChar WATEREOF   -> Char              {cons("INSERTEND")}
+    "/*"                                -> INSERTSTART       {recover}
+    INSERTSTART CommChar* WATEREOF      -> LongCom           {cons("INSERTEND")}
+
+  syntax
+    %% Kernel syntax insertion recovery rules                    
+    "\""                                      -> INSERTOPENQUOTE {recover}
+    INSERTOPENQUOTE StringPart* "\n"          -> StringLiteral   {cons("INSERTEND")}
+    INSERTOPENQUOTE StringPart* WATEREOF      -> StringLiteral   {cons("INSERTEND")}
+    "'"                                       -> INSERTOPENQUOTE {recover}
+    INSERTOPENQUOTE CharContent "\n"          -> CharLiteral     {cons("INSERTEND")}
+    INSERTOPENQUOTE CharContent WATEREOF      -> CharLiteral     {cons("INSERTEND")}
+
+  )
+
+
+exports
+  context-free priorities
+    Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr
+     >
+    {right:
+      Expr "++" -> Expr 
+      Expr "--" -> Expr 
+    }
+
+  context-free priorities
+    {right:
+      Expr "++" -> Expr 
+      Expr "--" -> Expr 
+    } >
+    { "(" PrimType ")" Expr -> Expr 
+      "(" RefType ")" Expr -> Expr  }
+
+  context-free priorities
+    "(" PrimType ")" Expr -> Expr  >
+    {left:
+      Expr "*" Expr -> Expr 
+      Expr "/" Expr -> Expr 
+      Expr "%" Expr -> Expr 
+    }
+
+  context-free priorities
+    "(" RefType ")" Expr -> Expr  >
+    { "++" Expr -> Expr 
+      "--" Expr -> Expr 
+      "+" Expr -> Expr 
+      "-" Expr -> Expr  }
+
+  context-free priorities
+    { Expr ArraySubscript -> ArrayAccess 
+      Expr "." Id -> FieldAccess 
+      Expr "." TypeArgs? Id -> MethodSpec  } >
+    {right:
+      Expr "++" -> Expr 
+      Expr "--" -> Expr 
+    } >
+    { "++" Expr -> Expr 
+      "--" Expr -> Expr 
+      "+" Expr -> Expr 
+      "-" Expr -> Expr 
+      "~" Expr -> Expr 
+      "!" Expr -> Expr  } >
+    {left:
+      Expr "*" Expr -> Expr 
+      Expr "/" Expr -> Expr 
+      Expr "%" Expr -> Expr 
+    } >
+    {left:
+      Expr "+" Expr -> Expr 
+      Expr "-" Expr -> Expr 
+    } >
+    {left:
+      Expr "<<" Expr -> Expr 
+      Expr ">>" Expr -> Expr 
+      Expr ">>>" Expr -> Expr 
+    } >
+    {left:
+      Expr "instanceof" RefType -> Expr 
+      Expr "<" Expr -> Expr 
+      Expr ">" Expr -> Expr 
+      Expr "<=" Expr -> Expr 
+      Expr ">=" Expr -> Expr 
+    } >
+    {left:
+      Expr "==" Expr -> Expr 
+      Expr "!=" Expr -> Expr 
+    } >
+    Expr "&" Expr -> Expr  >
+    Expr "^" Expr -> Expr  >
+    Expr "|" Expr -> Expr  >
+    Expr "&&" Expr -> Expr  >
+    Expr "||" Expr -> Expr  >
+    Expr CondMid Expr -> Expr  >
+    {right:
+      LHS "=" Expr -> Expr 
+      LHS "*=" Expr -> Expr 
+      LHS "/=" Expr -> Expr 
+      LHS "%=" Expr -> Expr 
+      LHS "+=" Expr -> Expr 
+      LHS "-=" Expr -> Expr 
+      LHS "<<=" Expr -> Expr 
+      LHS ">>=" Expr -> Expr 
+      LHS ">>>=" Expr -> Expr 
+      LHS "&=" Expr -> Expr 
+      LHS "^=" Expr -> Expr 
+      LHS "|=" Expr -> Expr 
+    }
+
+module languages/java-15/expressions/Restrictions
+exports
+  lexical restrictions
+    "+" -/- [\+]
+    "-" -/- [\-]
+    "/" -/- [\/]
+
+module languages/java-15/expressions/AssignmentOperators
+imports languages/java-15/expressions/Main
+
+exports
+  sorts LHS
+
+  context-free syntax
+    LHS "=" Expr    -> Expr {cons("Assign")}
+    LHS "*=" Expr   -> Expr {cons("AssignMul")}
+    LHS "/=" Expr   -> Expr {cons("AssignDiv")}
+    LHS "%=" Expr   -> Expr {cons("AssignRemain")}
+    LHS "+=" Expr   -> Expr {cons("AssignPlus")}
+    LHS "-=" Expr   -> Expr {cons("AssignMinus")}
+    LHS "<<=" Expr  -> Expr {cons("AssignLeftShift")}
+    LHS ">>=" Expr  -> Expr {cons("AssignRightShift")}
+    LHS ">>>=" Expr -> Expr {cons("AssignURightShift")}
+    LHS "&=" Expr   -> Expr {cons("AssignAnd")}
+    LHS "^=" Expr   -> Expr {cons("AssignExcOr")}
+    LHS "|=" Expr   -> Expr {cons("AssignOr")}
+    ExprName        -> LHS  
+    FieldAccess     -> LHS  
+    ArrayAccess     -> LHS  
+
+  context-free syntax
+    "@#$" LHS -> Expr {completion, ast("AssignOr(<1>,This)")}
+
+module languages/java-15/expressions/BinaryOperators
+imports languages/java-15/expressions/Main languages/java-15/types/Main
+
+exports
+  sorts CondMid
+
+  context-free syntax
+    Expr "instanceof" RefType -> Expr    {cons("InstanceOf")}
+    Expr "*" Expr             -> Expr    {left, cons("Mul")}
+    Expr "/" Expr             -> Expr    {left, cons("Div")}
+    Expr "%" Expr             -> Expr    {left, cons("Remain")}
+    Expr "+" Expr             -> Expr    {left, cons("Plus")}
+    Expr "-" Expr             -> Expr    {left, cons("Minus")}
+    Expr "<<" Expr            -> Expr    {left, cons("LeftShift")}
+    Expr ">>" Expr            -> Expr    {left, cons("RightShift")}
+    Expr ">>>" Expr           -> Expr    {left, cons("URightShift")}
+    Expr "<" Expr             -> Expr    {left, cons("Lt")}
+    Expr ">" Expr             -> Expr    {left, cons("Gt")}
+    Expr "<=" Expr            -> Expr    {left, cons("LtEq")}
+    Expr ">=" Expr            -> Expr    {left, cons("GtEq")}
+    Expr "==" Expr            -> Expr    {left, cons("Eq")}
+    Expr "!=" Expr            -> Expr    {left, cons("NotEq")}
+    Expr "&&" Expr            -> Expr    {left, cons("LazyAnd")}
+    Expr "||" Expr            -> Expr    {left, cons("LazyOr")}
+    Expr "&" Expr             -> Expr    {left, cons("And")}
+    Expr "^" Expr             -> Expr    {left, cons("ExcOr")}
+    Expr "|" Expr             -> Expr    {left, cons("Or")}
+    Expr CondMid Expr         -> Expr    {right, cons("Cond")}
+    "?" Expr ":"              -> CondMid {bracket}
+
+  context-free syntax
+    "@#$" Expr CondMid  -> Expr    {completion, right, ast("Cond(<1>,<2>,This)")}
+    "@#$" "?" Expr ":"? -> CondMid {completion, bracket}
+
+module languages/java-15/expressions/UnaryOperators
+imports languages/java-15/expressions/Main
+
+exports
+  context-free syntax
+    "+" Expr              -> Expr {cons("Plus")}
+    "-" Expr              -> Expr {cons("Minus")}
+    "++" Expr             -> Expr {cons("PreIncr")}
+    "--" Expr             -> Expr {cons("PreDecr")}
+    "~" Expr              -> Expr {cons("Complement")}
+    "!" Expr              -> Expr {cons("Not")}
+    "(" PrimType ")" Expr -> Expr {cons("CastPrim")}
+    "(" RefType ")" Expr  -> Expr {cons("CastRef")}
+
+  context-free syntax
+    "@#$" "(" PrimType ")"? -> Expr {completion, ast("CastPrim(<1>,This)")}
+    "@#$" "(" RefType ")"?  -> Expr {completion, ast("CastRef(<1>,This)")}
+
+module languages/java-15/expressions/Postfix
+imports languages/java-15/expressions/Main
+
+exports
+  context-free syntax
+    ExprName  -> Expr 
+    Expr "++" -> Expr {cons("PostIncr")}
+    Expr "--" -> Expr {cons("PostDecr")}
+
+  context-free syntax
+    
+
+module languages/java-15/expressions/MethodInvocation
+imports languages/java-15/expressions/Main
+
+exports
+  sorts MethodSpec
+
+  context-free syntax
+    MethodSpec "(" {Expr ","}* ")"        -> Expr       {cons("Invoke")}
+    MethodName                            -> MethodSpec {cons("Method")}
+    Expr "." TypeArgs? Id                 -> MethodSpec {cons("Method")}
+    "super" "." TypeArgs? Id              -> MethodSpec {cons("SuperMethod")}
+    TypeName "." "super" "." TypeArgs? Id -> MethodSpec {cons("QSuperMethod")}
+    AmbName "." TypeArgs Id               -> MethodSpec {cons("GenericMethod")}
+
+  context-free syntax
+    "@#$" MethodSpec "(" {Expr ","}* ")"?    -> Expr       {completion, cons("Invoke")}
+    "@#$" MethodSpec                         -> Expr       {completion, ast("Invoke(<1>,[])")}
+    "@#$" Expr "." TypeArgs?                 -> MethodSpec {completion, ast("Method(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" Expr                               -> MethodSpec {completion, ast("Method(<1>,None,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" "super" "." TypeArgs?              -> MethodSpec {completion, ast("SuperMethod(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" TypeName "." "super" "." TypeArgs? -> MethodSpec {completion, ast("QSuperMethod(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" TypeName                           -> MethodSpec {completion, ast("QSuperMethod(<1>,None,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName "." TypeArgs               -> MethodSpec {completion, ast("GenericMethod(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName                            -> MethodSpec {completion, ast("GenericMethod(<1>,TypeArgs([Wildcard(None)]),FromMetaExpr(ToMetaExpr(This)))")}
+
+  context-free priorities
+    Expr "." TypeArgs? Id -> MethodSpec  >
+    ExprName -> Expr 
+
+module languages/java-15/expressions/ArrayAccess
+imports languages/java-15/expressions/Main
+
+exports
+  sorts ArrayAccess ArraySubscript
+
+  context-free syntax
+    ArrayAccess                      -> Expr           
+    Expr ArraySubscript              -> ArrayAccess    {cons("ArrayAccess")}
+    "[" Expr "]"                     -> ArraySubscript {bracket}
+    ArrayCreationExpr ArraySubscript -> ArrayAccess    {reject}
+
+  context-free syntax
+    "@#$" Expr          -> ArrayAccess    {completion, ast("ArrayAccess(<1>,This)")}
+    "@#$" "[" Expr "]"? -> ArraySubscript {completion, bracket}
+
+module languages/java-15/expressions/FieldAccess
+imports languages/java-15/expressions/Main
+
+exports
+  sorts FieldAccess
+
+  context-free syntax
+    FieldAccess -> Expr 
+
+  context-free syntax
+    
+
+  context-free syntax
+    Expr "." Id                 -> FieldAccess {cons("Field")}
+    ExprName "." Id             -> FieldAccess {reject}
+    "super" "." Id              -> FieldAccess {cons("SuperField")}
+    TypeName "." "super" "." Id -> FieldAccess {cons("QSuperField")}
+
+  context-free syntax
+    "@#$" Expr     -> FieldAccess {completion, ast("Field(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" TypeName -> FieldAccess {completion, ast("QSuperField(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+
+module languages/java-15/expressions/ArrayCreation
+imports languages/java-15/expressions/Main
+
+exports
+  sorts ArrayCreationExpr ArrayBaseType Dim DimExpr
+
+  context-free syntax
+    ArrayCreationExpr                  -> Expr              
+    "new" ArrayBaseType DimExpr+ Dim*  -> ArrayCreationExpr {cons("NewArray")}
+    "new" ArrayBaseType Dim+ ArrayInit -> ArrayCreationExpr {cons("NewArray")}
+    PrimType                           -> ArrayBaseType     
+    TypeName                           -> ArrayBaseType     
+    TypeName "<" "?" ">"               -> ArrayBaseType     {cons("UnboundWld")}
+    "[" Expr "]"                       -> DimExpr           {cons("Dim")}
+    "[" "]"                            -> Dim               {cons("Dim")}
+
+  context-free syntax
+    "@#$" "new" ArrayBaseType Dim+ -> ArrayCreationExpr {completion, ast("NewArray(<1>,<2>,ArrayInit([]))")}
+    "@#$" "new" ArrayBaseType      -> ArrayCreationExpr {completion, ast("NewArray(<1>,[Dim],ArrayInit([]))")}
+    "@#$" "[" Expr "]"?            -> DimExpr           {completion, cons("Dim")}
+
+module languages/java-15/expressions/ClassInstanceCreation
+imports languages/java-15/expressions/Main
+        languages/java-15/classes/ClassDeclarations
+
+exports
+  context-free syntax
+    "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")" ClassBody?  -> Expr {cons("NewInstance")}
+    Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")" ClassBody? -> Expr {cons("QNewInstance")}
+
+  context-free syntax
+    "@#$" "new" TypeArgs? ClassOrInterfaceType "(" {Expr ","}* ")"?  -> Expr {completion, ast("NewInstance(<1>,<2>,<3>,None)")}
+    "@#$" "new" TypeArgs? ClassOrInterfaceType "("? ")"?             -> Expr {completion, ast("NewInstance(<1>,<2>,[],None)")}
+    "@#$" "new" TypeArgs? "("? ")"?                                  -> Expr {completion, ast("NewInstance(<1>,ClassOrInterfaceType(TypeName(FromMetaExpr(ToMetaExpr(This))),None),[],None)")}
+    "@#$" Expr "." "new" TypeArgs? Id TypeArgs? "(" {Expr ","}* ")"? -> Expr {completion, ast("QNewInstance(<1>,<2>,<3>,<4>,<5>,None)")}
+    "@#$" Expr "." "new" TypeArgs? Id TypeArgs? "("? ")"?            -> Expr {completion, ast("QNewInstance(<1>,<2>,<3>,<4>,[],None)")}
+    "@#$" Expr "." "new" TypeArgs? Id "("? ")"?                      -> Expr {completion, ast("QNewInstance(<1>,<2>,<3>,None,[],None)")}
+    "@#$" Expr "." "new" TypeArgs? "("? ")"?                         -> Expr {completion, ast("QNewInstance(<1>,<2>,FromMetaExpr(ToMetaExpr(This)),None,[],None)")}
+
+module languages/java-15/expressions/Primary
+imports languages/java-15/lexical/literals/Main languages/java-15/names/Main
+        languages/java-15/expressions/Main
+
+exports
+  sorts Literal
+
+  context-free syntax
+    Literal       -> Expr    {cons("Lit")}
+    IntLiteral    -> Literal 
+    FloatLiteral  -> Literal 
+    BoolLiteral   -> Literal 
+    CharLiteral   -> Literal 
+    StringLiteral -> Literal 
+    NullLiteral   -> Literal 
+
+  context-free syntax
+    
+
+  sorts ClassLiteral
+
+  context-free syntax
+    ClassLiteral       -> Literal      
+    Type "." "class"   -> ClassLiteral {cons("Class")}
+    "void" "." "class" -> ClassLiteral {cons("VoidClass")}
+
+  context-free syntax
+    "@#$" Type -> ClassLiteral {completion, cons("Class")}
+
+  context-free syntax
+    "this"              -> Expr {cons("This")}
+    TypeName "." "this" -> Expr {cons("QThis")}
+
+  context-free syntax
+    "@#$" TypeName -> Expr {completion, cons("QThis")}
+
+  context-free syntax
+    "(" Expr ")" -> Expr {bracket}
+
+  context-free syntax
+    "@#$" "(" Expr ")"? -> Expr {completion, bracket}
+
+module languages/java-15/expressions/Main
+imports languages/java-15/expressions/Primary
+        languages/java-15/expressions/ClassInstanceCreation
+        languages/java-15/expressions/ArrayCreation
+        languages/java-15/expressions/FieldAccess
+        languages/java-15/expressions/ArrayAccess
+        languages/java-15/expressions/MethodInvocation
+        languages/java-15/expressions/Postfix
+        languages/java-15/expressions/UnaryOperators
+        languages/java-15/expressions/BinaryOperators
+        languages/java-15/expressions/AssignmentOperators
+        languages/java-15/expressions/Restrictions
+        languages/java-15/expressions/Priorities
+
+exports
+  sorts Expr
+
+module languages/java-15/statements/Main
+imports languages/java-15/statements/Blocks
+        languages/java-15/statements/LocalVariableDeclarations
+        languages/java-15/statements/Statements
+
+module languages/java-15/arrays/Main
+imports languages/java-15/arrays/ArrayInitializers
+
+module languages/java-15/interfaces/Main
+imports languages/java-15/interfaces/InterfaceDeclarations
+        languages/java-15/interfaces/AbstractMethodDeclarations
+        languages/java-15/interfaces/AnnotationTypes
+        languages/java-15/interfaces/Annotations
+
+module languages/java-15/classes/Main
+imports languages/java-15/classes/ClassDeclarations
+        languages/java-15/classes/EnumDeclarations
+
+module languages/java-15/packages/PackageDeclarations
+imports languages/java-15/names/Main languages/java-15/interfaces/Annotations
+
+exports
+  sorts PackageDec
+
+  context-free syntax
+    Anno* "package" PackageName ";" -> PackageDec {cons("PackageDec")}
+
+  context-free syntax
+    "@#$" Anno* "package" PackageName ";"? -> PackageDec {completion, cons("PackageDec")}
+    "@#$" Anno*                            -> PackageDec {completion, ast("PackageDec(<1>,PackageName([FromMetaExpr(ToMetaExpr(This))]))")}
+
+module languages/java-15/packages/ImportDeclarations
+imports languages/java-15/lexical/Identifiers languages/java-15/names/Main
+
+exports
+  sorts ImportDec
+
+  context-free syntax
+    "import" TypeName ";"                  -> ImportDec {cons("TypeImportDec")}
+    "import" PackageName "." "*" ";"       -> ImportDec {cons("TypeImportOnDemandDec")}
+    "import" "static" TypeName "." Id ";"  -> ImportDec {cons("StaticImportDec")}
+    "import" "static" TypeName "." "*" ";" -> ImportDec {cons("StaticImportOnDemandDec")}
+
+  context-free syntax
+    "@#$" "import" TypeName ";"?                    -> ImportDec {completion, cons("TypeImportDec")}
+    "@#$" "import" PackageName "."? "*"? ";"?       -> ImportDec {completion, cons("TypeImportOnDemandDec")}
+    "@#$" "import" "static" TypeName "." Id ";"?    -> ImportDec {completion, cons("StaticImportDec")}
+    "@#$" "import" "static" TypeName "."? ";"?      -> ImportDec {completion, ast("StaticImportDec(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" "import" "static" TypeName "."? "*"? ";"? -> ImportDec {completion, cons("StaticImportOnDemandDec")}
+
+module languages/java-15/interfaces/AnnotationTypes
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/classes/ClassDeclarations
+        languages/java-15/classes/EnumDeclarations
+        languages/java-15/interfaces/InterfaceDeclarations
+        languages/java-15/interfaces/AbstractMethodDeclarations
+        languages/java-15/interfaces/ConstantDeclarations
+        languages/java-15/interfaces/Annotations
+
+exports
+  sorts AnnoDec AnnoDecHead
+
+  context-free syntax
+    AnnoDecHead "{" AnnoElemDec* "}"            -> AnnoDec     {cons("AnnoDec")}
+    ( Anno | InterfaceMod )* "@" "interface" Id -> AnnoDecHead {cons("AnnoDecHead")}
+
+  context-free syntax
+    "@#$" AnnoDecHead "{" AnnoElemDec* "}"? -> AnnoDec     {completion, cons("AnnoDec")}
+    "@#$" AnnoDecHead                       -> AnnoDec     {completion, ast("AnnoDec(<1>,[])")}
+    "@#$" ( Anno | InterfaceMod )*          -> AnnoDecHead {completion, ast("AnnoDecHead(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+
+  sorts AnnoElemDec DefaultVal
+
+  context-free syntax
+    AbstractMethodMod* Type Id "(" ")" DefaultVal? ";" -> AnnoElemDec {cons("AnnoMethodDec")}
+    ConstantDec                                        -> AnnoElemDec 
+    ClassDec                                           -> AnnoElemDec 
+    InterfaceDec                                       -> AnnoElemDec 
+    EnumDec                                            -> AnnoElemDec 
+    AnnoDec                                            -> AnnoElemDec 
+    ";"                                                -> AnnoElemDec {cons("Semicolon")}
+    "default" ElemVal                                  -> DefaultVal  {cons("DefaultVal")}
+
+  context-free syntax
+    "@#$" AbstractMethodMod* Type Id "(" ")" DefaultVal? ";"? -> AnnoElemDec {completion, cons("AnnoMethodDec")}
+    "@#$" AbstractMethodMod* Type Id                          -> AnnoElemDec {completion, ast("AnnoMethodDec(<1>,<2>,<3>,None)")}
+    "@#$" AbstractMethodMod* Type                             -> AnnoElemDec {completion, ast("AnnoMethodDec(<1>,<2>,FromMetaExpr(ToMetaExpr(This)),None)")}
+    "@#$" AbstractMethodMod*                                  -> AnnoElemDec {completion, ast("AnnoMethodDec(<1>,Boolean,FromMetaExpr(ToMetaExpr(This)),None)")}
+
+module languages/java-15/interfaces/AbstractMethodDeclarations
+imports languages/java-15/lexical/Modifiers languages/java-15/names/Main
+        languages/java-15/types/Main
+        languages/java-15/classes/MethodDeclarations
+
+exports
+  sorts AbstractMethodDec AbstractMethodMod
+
+  context-free syntax
+    ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";"      -> AbstractMethodDec {cons("AbstractMethodDec")}
+    ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";" -> AbstractMethodDec {cons("DeprAbstractMethodDec")}
+    Public                                                                                              -> AbstractMethodMod 
+    Abstract                                                                                            -> AbstractMethodMod 
+
+  context-free syntax
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws? ";"?      -> AbstractMethodDec {completion, cons("AbstractMethodDec")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? ";"? -> AbstractMethodDec {completion, cons("DeprAbstractMethodDec")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ ";"?         -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,<4>,<5>,<6>,None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")"? ";"?             -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,<4>,<5>,[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType Id                                              -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,<4>,[],[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams? ResultType                                                 -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,<3>,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )* TypeParams?                                                            -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,<2>,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | AbstractMethodMod )*                                                                        -> AbstractMethodDec {completion, ast("DeprAbstractMethodDec(<1>,None,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+
+module languages/java-15/interfaces/ConstantDeclarations
+imports languages/java-15/lexical/Modifiers languages/java-15/types/Main
+        languages/java-15/classes/MethodDeclarations
+        languages/java-15/interfaces/Annotations
+
+exports
+  sorts ConstantDec ConstantMod
+
+  context-free syntax
+    ( Anno | ConstantMod )* Type {VarDec ","}+ ";" -> ConstantDec {cons("ConstantDec")}
+    Public                                         -> ConstantMod 
+    Static                                         -> ConstantMod 
+    Final                                          -> ConstantMod 
+
+  context-free syntax
+    "@#$" ( Anno | ConstantMod )* Type {VarDec ","}+ -> ConstantDec {completion, cons("ConstantDec")}
+    "@#$" ( Anno | ConstantMod )* Type               -> ConstantDec {completion, ast("ConstantDec(<1>,<2>,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+    "@#$" ( Anno | ConstantMod )*                    -> ConstantDec {completion, ast("ConstantDec(<1>,Boolean,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+
+module languages/java-15/interfaces/InterfaceDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers languages/java-15/names/Main
+        languages/java-15/types/Main languages/java-15/classes/ClassDeclarations
+        languages/java-15/classes/MethodDeclarations
+        languages/java-15/interfaces/ConstantDeclarations
+        languages/java-15/interfaces/AbstractMethodDeclarations
+        languages/java-15/interfaces/AnnotationTypes
+        languages/java-15/interfaces/Annotations
+
+exports
+  sorts InterfaceDec InterfaceDecHead ExtendsInterfaces InterfaceMemberDec
+        InterfaceMod
+
+  context-free syntax
+    AnnoDec                                                                -> InterfaceDec      
+    InterfaceDecHead "{" InterfaceMemberDec* "}"                           -> InterfaceDec      {cons("InterfaceDec")}
+    ( Anno | InterfaceMod )* "interface" Id TypeParams? ExtendsInterfaces? -> InterfaceDecHead  {cons("InterfaceDecHead")}
+    "extends" {InterfaceType ","}+                                         -> ExtendsInterfaces {cons("ExtendsInterfaces")}
+
+  context-free syntax
+    "@#$" InterfaceDecHead "{" InterfaceMemberDec* "}"? -> InterfaceDec     {completion, cons("InterfaceDec")}
+    "@#$" InterfaceDecHead                              -> InterfaceDec     {completion, ast("InterfaceDec(<1>,[])")}
+    "@#$" ( Anno | InterfaceMod )*                      -> InterfaceDecHead {completion, ast("InterfaceDecHead(<1>,FromMetaExpr(ToMetaExpr(This)),None,None)")}
+
+  context-free syntax
+    ConstantDec       -> InterfaceMemberDec 
+    AbstractMethodDec -> InterfaceMemberDec 
+    ClassDec          -> InterfaceMemberDec 
+    InterfaceDec      -> InterfaceMemberDec 
+    ";"               -> InterfaceMemberDec {cons("Semicolon")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    Public    -> InterfaceMod 
+    Protected -> InterfaceMod 
+    Private   -> InterfaceMod 
+    Abstract  -> InterfaceMod 
+    Static    -> InterfaceMod 
+    StrictFP  -> InterfaceMod 
+
+  context-free syntax
+    
+
+module languages/java-15/classes/EnumDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/classes/ClassDeclarations
+
+exports
+  sorts EnumDec EnumDecHead EnumBody EnumConst EnumConstArgs EnumBodyDecs
+
+  context-free syntax
+    EnumDecHead EnumBody                       -> EnumDec       {cons("EnumDec")}
+    ( Anno | ClassMod )* "enum" Id Interfaces? -> EnumDecHead   {cons("EnumDecHead")}
+    "{" {EnumConst ","}* EnumBodyDecs? "}"     -> EnumBody      {cons("EnumBody")}
+    "{" {EnumConst ","}* "," EnumBodyDecs? "}" -> EnumBody      {cons("EnumBody")}
+    Id EnumConstArgs? ClassBody?               -> EnumConst     {cons("EnumConst")}
+    "(" {Expr ","}* ")"                        -> EnumConstArgs {bracket}
+    ";" ClassBodyDec*                          -> EnumBodyDecs  {cons("EnumBodyDecs")}
+
+  context-free syntax
+    "@#$" EnumDecHead                                 -> EnumDec       {completion, ast("EnumDec(<1>,EnumBody([],None))")}
+    "@#$" ( Anno | ClassMod )*                        -> EnumDecHead   {completion, ast("EnumDecHead(<1>,FromMetaExpr(ToMetaExpr(This)),None)")}
+    "@#$" "{" {EnumConst ","}* EnumBodyDecs? "}"?     -> EnumBody      {completion, cons("EnumBody")}
+    "@#$" "{" {EnumConst ","}* "}"?                   -> EnumBody      {completion, ast("EnumBody(<1>,None)")}
+    "@#$" "{" {EnumConst ","}* "," EnumBodyDecs? "}"? -> EnumBody      {completion, cons("EnumBody")}
+    "@#$" "{" {EnumConst ","}* ","? "}"?              -> EnumBody      {completion, ast("EnumBody(<1>,None)")}
+    "@#$" "(" {Expr ","}* ")"?                        -> EnumConstArgs {completion, bracket}
+
+module languages/java-15/classes/ConstructorDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers
+        languages/java-15/interfaces/Annotations
+        languages/java-15/statements/Main languages/java-15/expressions/Main
+
+exports
+  sorts ConstrDec ConstrBody ConstrHead ConstrInv
+
+  context-free syntax
+    ConstrHead ConstrBody                                                   -> ConstrDec  {cons("ConstrDec")}
+    ( Anno | ConstrMod )* TypeParams? Id "(" {FormalParam ","}* ")" Throws? -> ConstrHead {cons("ConstrDecHead")}
+    "{" ConstrInv? BlockStm* "}"                                            -> ConstrBody {cons("ConstrBody")}
+    TypeArgs? "this" "(" {Expr ","}* ")" ";"                                -> ConstrInv  {cons("AltConstrInv")}
+    TypeArgs? "super" "(" {Expr ","}* ")" ";"                               -> ConstrInv  {cons("SuperConstrInv")}
+    Expr "." TypeArgs? "super" "(" {Expr ","}* ")" ";"                      -> ConstrInv  {cons("QSuperConstrInv")}
+
+  context-free syntax
+    "@#$" ConstrHead                                                       -> ConstrDec  {completion, ast("ConstrDec(<1>,ConstrBody(None,[]))")}
+    "@#$" ( Anno | ConstrMod )* TypeParams? Id "(" {FormalParam ","}* ")"? -> ConstrHead {completion, ast("ConstrDecHead(<1>,<2>,<3>,<4>,None)")}
+    "@#$" ( Anno | ConstrMod )* TypeParams? Id                             -> ConstrHead {completion, ast("ConstrDecHead(<1>,<2>,<3>,[],None)")}
+    "@#$" ( Anno | ConstrMod )* TypeParams?                                -> ConstrHead {completion, ast("ConstrDecHead(<1>,<2>,FromMetaExpr(ToMetaExpr(This)),[],None)")}
+    "@#$" ( Anno | ConstrMod )*                                            -> ConstrHead {completion, ast("ConstrDecHead(<1>,None,FromMetaExpr(ToMetaExpr(This)),[],None)")}
+    "@#$" "{" ConstrInv? BlockStm* "}"?                                    -> ConstrBody {completion, cons("ConstrBody")}
+    "@#$" "{" ConstrInv? "}"?                                              -> ConstrBody {completion, ast("ConstrBody(<1>,[])")}
+    "@#$" TypeArgs? "this" "(" {Expr ","}* ")"? ";"?                       -> ConstrInv  {completion, cons("AltConstrInv")}
+    "@#$" TypeArgs? "super" "(" {Expr ","}* ")"? ";"?                      -> ConstrInv  {completion, cons("SuperConstrInv")}
+    "@#$" TypeArgs?                                                        -> ConstrInv  {completion, ast("SuperConstrInv(<1>,[])")}
+    "@#$" Expr "." TypeArgs? "super" "(" {Expr ","}* ")"? ";"?             -> ConstrInv  {completion, cons("QSuperConstrInv")}
+    "@#$" Expr "." TypeArgs? "super"? "("? ")"? ";"?                       -> ConstrInv  {completion, ast("QSuperConstrInv(<1>,<2>,[])")}
+    "@#$" Expr                                                             -> ConstrInv  {completion, ast("QSuperConstrInv(<1>,None,[])")}
+
+  sorts ConstrMod
+
+  context-free syntax
+    Public    -> ConstrMod 
+    Protected -> ConstrMod 
+    Private   -> ConstrMod 
+
+  context-free syntax
+    
+
+module languages/java-15/classes/StaticInitializers
+imports languages/java-15/statements/Blocks
+
+exports
+  sorts StaticInit
+
+  context-free syntax
+    "static" Block -> StaticInit {cons("StaticInit")}
+
+  context-free syntax
+    
+
+module languages/java-15/classes/InstanceInitializers
+imports languages/java-15/statements/Blocks
+
+exports
+  sorts InstanceInit
+
+  context-free syntax
+    Block -> InstanceInit {cons("InstanceInit")}
+
+  context-free syntax
+    
+
+module languages/java-15/statements/Statements
+imports languages/java-15/statements/LocalVariableDeclarations
+        languages/java-15/statements/Blocks languages/java-15/expressions/Main
+
+exports
+  sorts Stm ExprStm
+
+  context-free syntax
+    Block -> Stm 
+
+  context-free syntax
+    
+
+  context-free syntax
+    ";" -> Stm {cons("Empty")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    Id ":" Stm -> Stm {cons("Labeled")}
+
+  context-free syntax
+    "@#$" Id -> Stm {completion, ast("Labeled(<1>,Empty)")}
+
+  context-free syntax
+    Expr ";" -> ExprStm {cons("ExprStm")}
+    ExprStm  -> Stm     
+
+  context-free syntax
+    "@#$" Expr -> ExprStm {completion, cons("ExprStm")}
+
+  context-free syntax
+    "if" "(" Expr ")" Stm            -> Stm {prefer, cons("If")}
+    "if" "(" Expr ")" Stm "else" Stm -> Stm {cons("If")}
+
+  context-free syntax
+    "@#$" "if" "(" Expr ")"?            -> Stm {completion, prefer, ast("If(<1>,Empty)")}
+    "@#$" "if" "(" Expr ")" Stm "else"? -> Stm {completion, ast("If(<1>,<2>,Empty)")}
+    "@#$" "if" "(" Expr ")"? "else"?    -> Stm {completion, ast("If(<1>,Empty,Empty)")}
+
+  context-free syntax
+    "assert" Expr ";"          -> Stm {cons("AssertStm")}
+    "assert" Expr ":" Expr ";" -> Stm {cons("AssertStm")}
+
+  context-free syntax
+    "@#$" "assert" Expr ";"?          -> Stm {completion, cons("AssertStm")}
+    "@#$" "assert" Expr ":" Expr ";"? -> Stm {completion, cons("AssertStm")}
+    "@#$" "assert" Expr ":"? ";"?     -> Stm {completion, ast("AssertStm(<1>,This)")}
+
+  sorts SwitchBlock SwitchGroup SwitchLabel
+
+  context-free syntax
+    "switch" "(" Expr ")" SwitchBlock -> Stm         {cons("Switch")}
+    "{" SwitchGroup* SwitchLabel* "}" -> SwitchBlock {cons("SwitchBlock")}
+    SwitchLabel+ BlockStm+            -> SwitchGroup {cons("SwitchGroup")}
+    "case" Expr ":"                   -> SwitchLabel {cons("Case")}
+    "default" ":"                     -> SwitchLabel {cons("Default")}
+
+  context-free syntax
+    "@#$" "switch" "(" Expr ")"?             -> Stm         {completion, ast("Switch(<1>,SwitchBlock([],[]))")}
+    "@#$" "{" SwitchGroup* SwitchLabel* "}"? -> SwitchBlock {completion, cons("SwitchBlock")}
+    "@#$" "{" SwitchGroup* "}"?              -> SwitchBlock {completion, ast("SwitchBlock(<1>,[])")}
+    "@#$" SwitchLabel+                       -> SwitchGroup {completion, ast("SwitchGroup(<1>,[Empty])")}
+    "@#$" "case" Expr ":"?                   -> SwitchLabel {completion, cons("Case")}
+
+  context-free syntax
+    "while" "(" Expr ")" Stm -> Stm {cons("While")}
+
+  context-free syntax
+    "@#$" "while" "(" Expr ")"? -> Stm {completion, ast("While(<1>,Empty)")}
+
+  context-free syntax
+    "do" Stm "while" "(" Expr ")" ";" -> Stm {cons("DoWhile")}
+
+  context-free syntax
+    "@#$" "do" Stm "while" "(" Expr ")"? ";"? -> Stm {completion, cons("DoWhile")}
+    "@#$" "do" Stm "while"? "("? ")"? ";"?    -> Stm {completion, ast("DoWhile(<1>,This)")}
+
+  context-free syntax
+    "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+    "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")" Stm -> Stm {cons("For")}
+    "for" "(" FormalParam ":" Expr ")" Stm                  -> Stm {cons("ForEach")}
+
+  context-free syntax
+    "@#$" "for" "(" LocalVarDec ";" Expr? ";" {Expr ","}* ")"? -> Stm {completion, ast("For(<1>,<2>,<3>,Empty)")}
+    "@#$" "for" "(" LocalVarDec ";" Expr? ";"? ")"?            -> Stm {completion, ast("For(<1>,<2>,[],Empty)")}
+    "@#$" "for" "(" LocalVarDec ";"? ";"? ")"?                 -> Stm {completion, ast("For(<1>,None,[],Empty)")}
+    "@#$" "for" "(" {Expr ","}* ";" Expr? ";" {Expr ","}* ")"? -> Stm {completion, ast("For(<1>,<2>,<3>,Empty)")}
+    "@#$" "for" "(" {Expr ","}* ";" Expr? ";"? ")"?            -> Stm {completion, ast("For(<1>,<2>,[],Empty)")}
+    "@#$" "for" "(" {Expr ","}* ";"? ";"? ")"?                 -> Stm {completion, ast("For(<1>,None,[],Empty)")}
+    "@#$" "for" "(" FormalParam ":" Expr ")"?                  -> Stm {completion, ast("ForEach(<1>,<2>,Empty)")}
+    "@#$" "for" "(" FormalParam ":"? ")"?                      -> Stm {completion, ast("ForEach(<1>,This,Empty)")}
+
+  context-free syntax
+    "break" Id? ";" -> Stm {cons("Break")}
+
+  context-free syntax
+    "@#$" "break" Id? ";"? -> Stm {completion, cons("Break")}
+
+  context-free syntax
+    "continue" Id? ";" -> Stm {cons("Continue")}
+
+  context-free syntax
+    "@#$" "continue" Id? ";"? -> Stm {completion, cons("Continue")}
+
+  context-free syntax
+    "return" Expr? ";" -> Stm {cons("Return")}
+
+  context-free syntax
+    "@#$" "return" Expr? ";"? -> Stm {completion, cons("Return")}
+
+  context-free syntax
+    "throw" Expr ";" -> Stm {cons("Throw")}
+
+  context-free syntax
+    "@#$" "throw" Expr ";"? -> Stm {completion, cons("Throw")}
+
+  context-free syntax
+    "synchronized" "(" Expr ")" Block -> Stm {cons("Synchronized")}
+
+  context-free syntax
+    "@#$" "synchronized" "(" Expr ")"? -> Stm {completion, ast("Synchronized(<1>,Block([]))")}
+
+  sorts CatchClause
+
+  context-free syntax
+    "try" Block CatchClause+                 -> Stm         {cons("Try")}
+    "try" Block CatchClause* "finally" Block -> Stm         {cons("Try")}
+    "catch" "(" FormalParam ")" Block        -> CatchClause {cons("Catch")}
+
+  context-free syntax
+    "@#$" "try" Block                         -> Stm         {completion, ast("Try(<1>,[Catch(FromMetaExpr(ToMetaExpr(This)),Block([]))])")}
+    "@#$" "try" Block CatchClause* "finally"? -> Stm         {completion, ast("Try(<1>,<2>,Block([]))")}
+    "@#$" "try" Block "finally"?              -> Stm         {completion, ast("Try(<1>,[],Block([]))")}
+    "@#$" "catch" "(" FormalParam ")"?        -> CatchClause {completion, ast("Catch(<1>,Block([]))")}
+
+module languages/java-15/statements/LocalVariableDeclarations
+imports languages/java-15/classes/MethodDeclarations
+        languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts LocalVarDecStm LocalVarDec
+
+  context-free syntax
+    LocalVarDec ";"                       -> LocalVarDecStm {cons("LocalVarDecStm")}
+    ( Anno | VarMod )* Type {VarDec ","}+ -> LocalVarDec    {cons("LocalVarDec")}
+    Expr "<" Expr ">" Expr ";"            -> ExprStm        {reject}
+
+  context-free syntax
+    "@#$" LocalVarDec             -> LocalVarDecStm {completion, cons("LocalVarDecStm")}
+    "@#$" ( Anno | VarMod )* Type -> LocalVarDec    {completion, ast("LocalVarDec(<1>,<2>,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+    "@#$" ( Anno | VarMod )*      -> LocalVarDec    {completion, ast("LocalVarDec(<1>,Boolean,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+
+module languages/java-15/statements/Blocks
+imports languages/java-15/classes/ClassDeclarations
+        languages/java-15/statements/LocalVariableDeclarations
+        languages/java-15/statements/Statements
+
+exports
+  sorts BlockStm Block
+
+  context-free syntax
+    "{" BlockStm* "}" -> Block    {cons("Block")}
+    LocalVarDecStm    -> BlockStm 
+    ClassDec          -> BlockStm {cons("ClassDecStm")}
+    Stm               -> BlockStm 
+
+  context-free syntax
+    "@#$" "{" BlockStm* "}"? -> Block {completion, cons("Block")}
+
+module languages/java-15/classes/MethodDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers languages/java-15/types/Main
+        languages/java-15/classes/FieldDeclarations
+        languages/java-15/interfaces/Annotations
+        languages/java-15/statements/Blocks
+
+exports
+  sorts MethodDec MethodDecHead ResultType
+
+  context-free syntax
+    MethodDecHead MethodBody                                                                -> MethodDec     {cons("MethodDec")}
+    ( Anno | MethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Throws?      -> MethodDecHead {cons("MethodDecHead")}
+    ( Anno | MethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")" Dim+ Throws? -> MethodDecHead {cons("DeprMethodDecHead")}
+    Type                                                                                    -> ResultType    
+    "void"                                                                                  -> ResultType    {cons("Void")}
+
+  context-free syntax
+    "@#$" MethodDecHead                                                               -> MethodDec     {completion, ast("MethodDec(<1>,Block([]))")}
+    "@#$" ( Anno | MethodMod )* TypeParams? ResultType Id "(" {FormalParam ","}* ")"? -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,<3>,<4>,<5>,[Dim],None)")}
+    "@#$" ( Anno | MethodMod )* TypeParams? ResultType Id                             -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,<3>,<4>,[],[Dim],None)")}
+    "@#$" ( Anno | MethodMod )* TypeParams? ResultType                                -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,<3>,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | MethodMod )* TypeParams?                                           -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,<2>,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+    "@#$" ( Anno | MethodMod )*                                                       -> MethodDecHead {completion, ast("DeprMethodDecHead(<1>,None,Void,FromMetaExpr(ToMetaExpr(This)),[],[Dim],None)")}
+
+  sorts FormalParam
+
+  context-free syntax
+    ( Anno | VarMod )* Type VarDecId       -> FormalParam {cons("Param")}
+    ( Anno | VarMod )* Type "..." VarDecId -> FormalParam {cons("VarArityParam")}
+
+  context-free syntax
+    "@#$" ( Anno | VarMod )* Type -> FormalParam {completion, ast("VarArityParam(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" ( Anno | VarMod )*      -> FormalParam {completion, ast("VarArityParam(<1>,Boolean,FromMetaExpr(ToMetaExpr(This)))")}
+
+  sorts VarMod
+
+  context-free syntax
+    Final -> VarMod 
+
+  context-free syntax
+    
+
+  sorts MethodMod
+
+  context-free syntax
+    Public       -> MethodMod 
+    Protected    -> MethodMod 
+    Private      -> MethodMod 
+    Abstract     -> MethodMod 
+    Static       -> MethodMod 
+    Final        -> MethodMod 
+    Synchronized -> MethodMod 
+    Native       -> MethodMod 
+    StrictFP     -> MethodMod 
+
+  context-free syntax
+    
+
+  sorts Throws ExceptionType
+
+  context-free syntax
+    "throws" {ExceptionType ","}+ -> Throws        {cons("ThrowsDec")}
+    ClassType                     -> ExceptionType 
+
+  context-free syntax
+    
+
+  sorts MethodBody
+
+  context-free syntax
+    Block -> MethodBody 
+    ";"   -> MethodBody {cons("NoMethodBody")}
+
+  context-free syntax
+    
+
+module languages/java-15/arrays/ArrayInitializers
+imports languages/java-15/classes/FieldDeclarations
+
+exports
+  sorts ArrayInit
+
+  context-free syntax
+    "{" {VarInit ","}* "}"     -> ArrayInit {cons("ArrayInit")}
+    "{" {VarInit ","}* "," "}" -> ArrayInit {cons("ArrayInit")}
+
+  context-free syntax
+    "@#$" "{" {VarInit ","}* "}"?      -> ArrayInit {completion, cons("ArrayInit")}
+    "@#$" "{" {VarInit ","}* ","? "}"? -> ArrayInit {completion, cons("ArrayInit")}
+
+module languages/java-15/interfaces/Annotations
+imports languages/java-15/lexical/Identifiers languages/java-15/names/Main
+        languages/java-15/expressions/Main
+
+exports
+  sorts Anno ElemVal ElemValPair
+
+  context-free syntax
+    "@" TypeName "(" {ElemValPair ","}* ")" -> Anno {cons("Anno")}
+    "@" TypeName "(" ElemVal ")"            -> Anno {cons("SingleElemAnno")}
+    "@" TypeName                            -> Anno {cons("MarkerAnno")}
+
+  context-free syntax
+    "@#$" "@" TypeName "(" {ElemValPair ","}* ")"? -> Anno {completion, cons("Anno")}
+    "@#$" "@" TypeName "(" ElemVal ")"?            -> Anno {completion, cons("SingleElemAnno")}
+    "@#$" "@" TypeName "("? ")"?                   -> Anno {completion, ast("SingleElemAnno(<1>,This)")}
+
+  context-free syntax
+    Id "=" ElemVal             -> ElemValPair {cons("ElemValPair")}
+    Expr                       -> ElemVal     
+    Anno                       -> ElemVal     
+    "{" {ElemVal ","}* "}"     -> ElemVal     {cons("ElemValArrayInit")}
+    "{" {ElemVal ","}* "," "}" -> ElemVal     {cons("ElemValArrayInit")}
+    LHS "=" Expr               -> ElemVal     {reject}
+
+  context-free syntax
+    "@#$" Id                           -> ElemValPair {completion, ast("ElemValPair(<1>,This)")}
+    "@#$" "{" {ElemVal ","}* "}"?      -> ElemVal     {completion, cons("ElemValArrayInit")}
+    "@#$" "{" {ElemVal ","}* ","? "}"? -> ElemVal     {completion, cons("ElemValArrayInit")}
+
+module languages/java-15/classes/FieldDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers languages/java-15/types/Main
+        languages/java-15/interfaces/Annotations
+        languages/java-15/arrays/ArrayInitializers
+        languages/java-15/expressions/Main
+
+exports
+  sorts FieldDec VarDec VarDecId Dim VarInit
+
+  context-free syntax
+    ( Anno | FieldMod )* Type {VarDec ","}+ ";" -> FieldDec {cons("FieldDec")}
+    VarDecId                                    -> VarDec   {cons("VarDec")}
+    VarDecId "=" VarInit                        -> VarDec   {cons("VarDec")}
+    Id                                          -> VarDecId 
+    Id Dim+                                     -> VarDecId {cons("ArrayVarDecId")}
+    "[" "]"                                     -> Dim      {cons("Dim")}
+    Expr                                        -> VarInit  
+    ArrayInit                                   -> VarInit  
+
+  context-free syntax
+    "@#$" ( Anno | FieldMod )* Type {VarDec ","}+ -> FieldDec {completion, cons("FieldDec")}
+    "@#$" ( Anno | FieldMod )* Type               -> FieldDec {completion, ast("FieldDec(<1>,<2>,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+    "@#$" ( Anno | FieldMod )*                    -> FieldDec {completion, ast("FieldDec(<1>,Boolean,[VarDec(FromMetaExpr(ToMetaExpr(This)))])")}
+
+  sorts FieldMod
+
+  context-free syntax
+    Public    -> FieldMod 
+    Protected -> FieldMod 
+    Private   -> FieldMod 
+    Static    -> FieldMod 
+    Final     -> FieldMod 
+    Transient -> FieldMod 
+    Volatile  -> FieldMod 
+
+  context-free syntax
+    
+
+module languages/java-15/classes/ClassDeclarations
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/lexical/Modifiers
+        languages/java-15/types/ReferenceTypes
+        languages/java-15/types/TypeVariables
+        languages/java-15/classes/FieldDeclarations
+        languages/java-15/classes/MethodDeclarations
+        languages/java-15/classes/InstanceInitializers
+        languages/java-15/classes/StaticInitializers
+        languages/java-15/classes/ConstructorDeclarations
+        languages/java-15/classes/EnumDeclarations
+        languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts ClassDec ClassBody ClassDecHead
+
+  context-free syntax
+    EnumDec                                                        -> ClassDec     
+    ClassDecHead ClassBody                                         -> ClassDec     {cons("ClassDec")}
+    "{" ClassBodyDec* "}"                                          -> ClassBody    {cons("ClassBody")}
+    ( Anno | ClassMod )* "class" Id TypeParams? Super? Interfaces? -> ClassDecHead {cons("ClassDecHead")}
+
+  context-free syntax
+    "@#$" ClassDecHead           -> ClassDec     {completion, ast("ClassDec(<1>,ClassBody([]))")}
+    "@#$" "{" ClassBodyDec* "}"? -> ClassBody    {completion, cons("ClassBody")}
+    "@#$" ( Anno | ClassMod )*   -> ClassDecHead {completion, ast("ClassDecHead(<1>,FromMetaExpr(ToMetaExpr(This)),None,None,None)")}
+
+  sorts ClassMod
+
+  context-free syntax
+    Abstract  -> ClassMod 
+    Public    -> ClassMod 
+    Protected -> ClassMod 
+    Private   -> ClassMod 
+    Static    -> ClassMod 
+    Final     -> ClassMod 
+    StrictFP  -> ClassMod 
+
+  context-free syntax
+    
+
+  sorts Super
+
+  context-free syntax
+    "extends" ClassType -> Super {cons("SuperDec")}
+
+  context-free syntax
+    
+
+  sorts Interfaces
+
+  context-free syntax
+    "implements" {InterfaceType ","}+ -> Interfaces {cons("ImplementsDec")}
+
+  context-free syntax
+    
+
+  sorts ClassBodyDec ClassMemberDec
+
+  context-free syntax
+    ClassMemberDec -> ClassBodyDec 
+    InstanceInit   -> ClassBodyDec 
+    StaticInit     -> ClassBodyDec 
+    ConstrDec      -> ClassBodyDec 
+
+  context-free syntax
+    
+
+  context-free syntax
+    FieldDec     -> ClassMemberDec 
+    MethodDec    -> ClassMemberDec 
+    ClassDec     -> ClassMemberDec 
+    InterfaceDec -> ClassMemberDec 
+    ";"          -> ClassMemberDec {cons("Semicolon")}
+
+  context-free syntax
+    
+
+module languages/java-15/packages/TypeDeclarations
+imports languages/java-15/classes/ClassDeclarations
+        languages/java-15/interfaces/InterfaceDeclarations
+
+exports
+  sorts TypeDec
+
+  context-free syntax
+    ClassDec     -> TypeDec 
+    InterfaceDec -> TypeDec 
+    ";"          -> TypeDec {cons("Semicolon")}
+
+  context-free syntax
+    
+
+module languages/java-15/packages/CompilationUnits
+imports languages/java-15/packages/PackageDeclarations
+        languages/java-15/packages/ImportDeclarations
+        languages/java-15/packages/TypeDeclarations
+
+exports
+  sorts CompilationUnit
+
+  context-free syntax
+    PackageDec? ImportDec* TypeDec+ -> CompilationUnit {cons("CompilationUnit")}
+
+  context-free syntax
+    "@#$" PackageDec? ImportDec* -> CompilationUnit {completion, ast("CompilationUnit(<1>,<2>,[Semicolon])")}
+    "@#$" PackageDec?            -> CompilationUnit {completion, ast("CompilationUnit(<1>,[],[Semicolon])")}
+
+module languages/java-15/packages/Main
+imports languages/java-15/packages/CompilationUnits
+        languages/java-15/packages/ImportDeclarations
+        languages/java-15/packages/PackageDeclarations
+
+module languages/java-15/names/Main
+imports languages/java-15/lexical/Identifiers
+
+exports
+  sorts PackageName
+
+  context-free syntax
+    {Id "."}+ -> PackageName {cons("PackageName")}
+
+  context-free syntax
+    
+
+  sorts TypeName ExprName MethodName PackageOrTypeName AmbName
+
+  context-free syntax
+    Id                       -> AmbName           {cons("AmbName")}
+    AmbName "." Id           -> AmbName           {cons("AmbName")}
+    Id                       -> TypeName          {cons("TypeName")}
+    PackageOrTypeName "." Id -> TypeName          {cons("TypeName")}
+    Id                       -> ExprName          {cons("ExprName")}
+    AmbName "." Id           -> ExprName          {cons("ExprName")}
+    Id                       -> MethodName        {cons("MethodName")}
+    AmbName "." Id           -> MethodName        {cons("MethodName")}
+    Id                       -> PackageOrTypeName {cons("PackageOrTypeName")}
+    PackageOrTypeName "." Id -> PackageOrTypeName {cons("PackageOrTypeName")}
+
+  context-free syntax
+    "@#$" PackageOrTypeName -> TypeName   {completion, ast("TypeName(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName           -> ExprName   {completion, ast("ExprName(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+    "@#$" AmbName           -> MethodName {completion, ast("MethodName(<1>,FromMetaExpr(ToMetaExpr(This)))")}
+
+module languages/java-15/types/ParameterizedTypes
+imports languages/java-15/types/ReferenceTypes
+
+exports
+  sorts TypeArgs ActualTypeArg WildcardBound
+
+  context-free syntax
+    "<" {ActualTypeArg ","}+ ">" -> TypeArgs      {cons("TypeArgs")}
+    Type                         -> ActualTypeArg 
+    "?" WildcardBound?           -> ActualTypeArg {cons("Wildcard")}
+    "extends" RefType            -> WildcardBound {cons("WildcardUpperBound")}
+    "super" RefType              -> WildcardBound {cons("WildcardLowerBound")}
+
+  context-free syntax
+    "@#$" "<" {ActualTypeArg ","}+ ">"? -> TypeArgs {completion, cons("TypeArgs")}
+
+module languages/java-15/types/TypeVariables
+imports languages/java-15/lexical/Identifiers
+        languages/java-15/types/ReferenceTypes
+
+exports
+  sorts TypeParams TypeParam TypeBound TypeVarId
+
+  context-free syntax
+    TypeVarId TypeBound?                  -> TypeParam  {cons("TypeParam")}
+    "extends" {ClassOrInterfaceType "&"}+ -> TypeBound  {cons("TypeBound")}
+    "<" {TypeParam ","}+ ">"              -> TypeParams {cons("TypeParams")}
+    Id                                    -> TypeVarId  
+
+  context-free syntax
+    "@#$" "<" {TypeParam ","}+ ">"? -> TypeParams {completion, cons("TypeParams")}
+
+module languages/java-15/types/ReferenceTypes
+imports languages/java-15/lexical/Identifiers languages/java-15/names/Main
+        languages/java-15/types/Main languages/java-15/types/ParameterizedTypes
+        languages/java-15/types/TypeVariables
+
+exports
+  sorts RefType ClassOrInterfaceType ClassType InterfaceType TypeDecSpec
+        ArrayType TypeVar
+
+  context-free syntax
+    ClassOrInterfaceType -> RefType 
+    ArrayType            -> RefType 
+
+  context-free syntax
+    
+
+  context-free syntax
+    TypeDecSpec TypeArgs?       -> ClassOrInterfaceType {cons("ClassOrInterfaceType")}
+    TypeDecSpec TypeArgs?       -> ClassType            {cons("ClassType")}
+    TypeDecSpec TypeArgs?       -> InterfaceType        {cons("InterfaceType")}
+    TypeName                    -> TypeDecSpec          
+    TypeDecSpec TypeArgs "." Id -> TypeDecSpec          {cons("Member")}
+
+  context-free syntax
+    "@#$" TypeDecSpec TypeArgs -> TypeDecSpec {completion, ast("Member(<1>,<2>,FromMetaExpr(ToMetaExpr(This)))")}
+
+  context-free syntax
+    TypeVarId -> TypeVar {cons("TypeVar")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    Type "[" "]" -> ArrayType {cons("ArrayType")}
+
+  context-free syntax
+    "@#$" Type -> ArrayType {completion, cons("ArrayType")}
+
+module languages/java-15/types/PrimitiveTypes
+exports
+  sorts PrimType NumType IntType FloatType
+
+  context-free syntax
+    NumType   -> PrimType  
+    "boolean" -> PrimType  {cons("Boolean")}
+    IntType   -> NumType   
+    FloatType -> NumType   
+    "byte"    -> IntType   {cons("Byte")}
+    "short"   -> IntType   {cons("Short")}
+    "int"     -> IntType   {cons("Int")}
+    "long"    -> IntType   {cons("Long")}
+    "char"    -> IntType   {cons("Char")}
+    "float"   -> FloatType {cons("Float")}
+    "double"  -> FloatType {cons("Double")}
+
+  context-free syntax
+    
+
+module languages/java-15/types/Main
+imports languages/java-15/types/PrimitiveTypes
+        languages/java-15/types/ReferenceTypes
+        languages/java-15/types/TypeVariables
+        languages/java-15/types/ParameterizedTypes
+
+exports
+  sorts Type
+
+  context-free syntax
+    PrimType -> Type 
+    RefType  -> Type 
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/literals/NullLiteral
+exports
+  sorts NullLiteral
+
+  context-free syntax
+    "null" -> NullLiteral {cons("Null")}
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/literals/StringLiterals
+imports languages/java-15/lexical/literals/EscapeSequences
+        languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts StringLiteral StringPart StringChars FooStringChars
+
+  syntax
+    StringLiteral         -> <StringLiteral-CF>   
+    "\"" StringPart* "\"" -> StringLiteral        {cons("String")}
+    StringChars           -> StringPart           {cons("Chars")}
+    UnicodeEscape         -> StringPart           
+    EscapeSeq             -> StringPart           
+    <FooStringChars-LEX>  -> StringChars          
+    ~[\"\\\n\13]+         -> <FooStringChars-LEX> 
+
+  restrictions
+    StringChars -/- ~[\"\\\n\13]
+
+module languages/java-15/lexical/literals/EscapeSequences
+imports 
+
+exports
+  sorts EscapeSeq NamedEscape OctaEscape LastOcta
+
+  syntax
+    OctaEscape             -> EscapeSeq   
+    NamedEscape            -> EscapeSeq   
+    "\\" [btnfr\"\'\\]     -> NamedEscape {cons("NamedEscape")}
+    "\\" LastOcta          -> OctaEscape  {cons("OctaEscape1")}
+    "\\" [0-3] LastOcta    -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [4-7] [0-7]       -> OctaEscape  {cons("OctaEscape2")}
+    "\\" [0-3] [0-7] [0-7] -> OctaEscape  {cons("OctaEscape3")}
+    [0-7]                  -> LastOcta    
+
+  restrictions
+    LastOcta -/- [0-7]
+
+module languages/java-15/lexical/literals/CharacterLiterals
+imports languages/java-15/lexical/literals/EscapeSequences
+        languages/java-15/lexical/UnicodeEscapes
+
+exports
+  sorts CharLiteral CharContent SingleChar
+
+  syntax
+    CharLiteral         -> <CharLiteral-CF> 
+    "'" CharContent "'" -> CharLiteral      {cons("Char")}
+    SingleChar          -> CharContent      {cons("Single")}
+    UnicodeEscape       -> CharContent      
+    EscapeSeq           -> CharContent      
+    ~[\r\n\'\\]         -> SingleChar       
+
+module languages/java-15/lexical/literals/BooleanLiterals
+exports
+  sorts Bool BoolLiteral
+
+  context-free syntax
+    Bool    -> BoolLiteral {cons("Bool")}
+    "true"  -> Bool        {cons("True")}
+    "false" -> Bool        {cons("False")}
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/literals/FloatingPointLiterals
+exports
+  sorts FloatLiteral DeciFloatLiteral HexaFloatLiteral
+
+  context-free syntax
+    DeciFloatLiteral -> FloatLiteral {cons("Float")}
+    HexaFloatLiteral -> FloatLiteral {cons("Float")}
+
+  context-free syntax
+    
+
+  lexical syntax
+    DeciFloatNumeral [fFdD]? -> DeciFloatLiteral 
+    HexaFloatNumeral [fFdD]? -> HexaFloatLiteral 
+    [0-9]+                   -> DeciFloatLiteral {reject}
+
+  lexical syntax
+     -> "@#$" {completion}
+
+  lexical restrictions
+    DeciFloatLiteral -/- [fFdD]
+    HexaFloatLiteral -/- [fFdD]
+
+  sorts DeciFloatNumeral DeciFloatDigits DeciFloatExponentPart
+
+  lexical syntax
+    DeciFloatDigits DeciFloatExponentPart? -> DeciFloatNumeral      
+    [0-9]* "." [0-9]*                      -> DeciFloatDigits       
+    "."                                    -> DeciFloatDigits       {reject}
+    [0-9]+                                 -> DeciFloatDigits       
+    [eE] SignedInteger                     -> DeciFloatExponentPart 
+    [\+\-]? [0-9]+                         -> SignedInteger         
+
+  lexical restrictions
+    DeciFloatDigits -/- [0-9]
+    DeciFloatExponentPart -/- [0-9]
+
+  sorts HexaFloatNumeral HexaSignificand BinaryExponent SignedInteger
+
+  lexical syntax
+    HexaSignificand BinaryExponent         -> HexaFloatNumeral 
+    [0] [xX] [0-9a-fA-F]+                  -> HexaSignificand  
+    [0] [xX] [0-9a-fA-F]* "." [0-9a-fA-F]* -> HexaSignificand  
+    [0] [xX] "."                           -> HexaSignificand  {reject}
+    [pP] SignedInteger                     -> BinaryExponent   
+
+  lexical restrictions
+    HexaSignificand -/- [0-9a-fA-F]
+    SignedInteger -/- [0-9]
+
+module languages/java-15/lexical/literals/IntegerLiterals
+exports
+  sorts IntLiteral DeciLiteral HexaLiteral OctaLiteral DeciNumeral HexaNumeral
+        OctaNumeral
+
+  context-free syntax
+    DeciLiteral -> IntLiteral {cons("Deci")}
+    HexaLiteral -> IntLiteral {cons("Hexa")}
+    OctaLiteral -> IntLiteral {cons("Octa")}
+
+  context-free syntax
+    
+
+  lexical syntax
+    DeciNumeral [lL]?     -> DeciLiteral 
+    HexaNumeral [lL]?     -> HexaLiteral 
+    OctaNumeral [lL]?     -> OctaLiteral 
+    "0"                   -> DeciNumeral 
+    [1-9] [0-9]*          -> DeciNumeral 
+    [0] [xX] [0-9a-fA-F]+ -> HexaNumeral 
+    [0] [0-7]+            -> OctaNumeral 
+
+  lexical restrictions
+    DeciNumeral -/- [0-9\.fFdD]
+    HexaNumeral -/- [0-9a-fA-F]
+    OctaNumeral -/- [0-7]
+    DeciLiteral -/- [lL]
+    HexaLiteral -/- [lL]
+    OctaLiteral -/- [lL]
+
+module languages/java-15/lexical/literals/Main
+imports languages/java-15/lexical/literals/IntegerLiterals
+        languages/java-15/lexical/literals/FloatingPointLiterals
+        languages/java-15/lexical/literals/BooleanLiterals
+        languages/java-15/lexical/literals/CharacterLiterals
+        languages/java-15/lexical/literals/StringLiterals
+        languages/java-15/lexical/literals/NullLiteral
+
+module languages/java-15/lexical/Modifiers
+exports
+  sorts Public Private Protected Abstract Final Static Native Transient Volatile
+        Synchronized StrictFP Modifier
+
+  context-free syntax
+    "public"       -> Public       {cons("Public")}
+    "private"      -> Private      {cons("Private")}
+    "protected"    -> Protected    {cons("Protected")}
+    "abstract"     -> Abstract     {cons("Abstract")}
+    "final"        -> Final        {cons("Final")}
+    "static"       -> Static       {cons("Static")}
+    "native"       -> Native       {cons("Native")}
+    "transient"    -> Transient    {cons("Transient")}
+    "volatile"     -> Volatile     {cons("Volatile")}
+    "synchronized" -> Synchronized {cons("Synchronized")}
+    "strictfp"     -> StrictFP     {cons("StrictFP")}
+    Public         -> Modifier     
+    Private        -> Modifier     
+    Protected      -> Modifier     
+    Abstract       -> Modifier     
+    Final          -> Modifier     
+    Static         -> Modifier     
+    Native         -> Modifier     
+    Transient      -> Modifier     
+    Volatile       -> Modifier     
+    Synchronized   -> Modifier     
+    StrictFP       -> Modifier     
+
+  context-free syntax
+    
+
+module languages/java-15/lexical/Keywords
+exports
+  sorts Keyword
+
+  lexical syntax
+    "abstract"     -> Keyword 
+    "assert"       -> Keyword 
+    "boolean"      -> Keyword 
+    "break"        -> Keyword 
+    "byte"         -> Keyword 
+    "case"         -> Keyword 
+    "catch"        -> Keyword 
+    "char"         -> Keyword 
+    "class"        -> Keyword 
+    "const"        -> Keyword 
+    "continue"     -> Keyword 
+    "default"      -> Keyword 
+    "do"           -> Keyword 
+    "double"       -> Keyword 
+    "else"         -> Keyword 
+    "enum"         -> Keyword 
+    "extends"      -> Keyword 
+    "final"        -> Keyword 
+    "finally"      -> Keyword 
+    "float"        -> Keyword 
+    "for"          -> Keyword 
+    "goto"         -> Keyword 
+    "if"           -> Keyword 
+    "implements"   -> Keyword 
+    "import"       -> Keyword 
+    "instanceof"   -> Keyword 
+    "int"          -> Keyword 
+    "interface"    -> Keyword 
+    "long"         -> Keyword 
+    "native"       -> Keyword 
+    "new"          -> Keyword 
+    "package"      -> Keyword 
+    "private"      -> Keyword 
+    "protected"    -> Keyword 
+    "public"       -> Keyword 
+    "return"       -> Keyword 
+    "short"        -> Keyword 
+    "static"       -> Keyword 
+    "strictfp"     -> Keyword 
+    "super"        -> Keyword 
+    "switch"       -> Keyword 
+    "synchronized" -> Keyword 
+    "this"         -> Keyword 
+    "throw"        -> Keyword 
+    "throws"       -> Keyword 
+    "transient"    -> Keyword 
+    "try"          -> Keyword 
+    "void"         -> Keyword 
+    "volatile"     -> Keyword 
+    "while"        -> Keyword 
+
+  lexical restrictions
+    "abstract" "assert" "boolean" "break" "byte" "case" "catch" "char" "class"
+    "const" "continue" "default" "do" "double" "else" "enum" "extends" "final"
+    "finally" "float" "for" "goto" "if" "implements" "import" "instanceof" "int"
+    "interface" "long" "native" "new" "package" "private" "protected" "public"
+    "return" "short" "static" "strictfp" "super" "switch" "synchronized" "this"
+    "throw" "throws" "transient" "try" "void" "volatile" "while"
+    -/- [A-Za-z0-9\_\$]
+
+module languages/java-15/lexical/Identifiers
+imports languages/java-15/lexical/Keywords
+
+exports
+  sorts Id ID
+
+  context-free syntax
+    ID -> Id {cons("Id")}
+
+  context-free syntax
+    
+
+  lexical syntax
+    [A-Za-z\_\$] [A-Za-z0-9\_\$]* -> ID 
+    Keyword                       -> ID {reject}
+    "true"                        -> ID {reject}
+    "false"                       -> ID {reject}
+    "null"                        -> ID {reject}
+
+  lexical restrictions
+    ID -/- [a-zA-Z0-9\_\$]
+
+module languages/java-15/lexical/Comments
+imports languages/java-15/lexical/LineTerminators
+
+exports
+  sorts Comment EOLCommentChars CommentPart UnicodeEscape BlockCommentChars
+        Asterisk EscEscChar EscChar
+
+  lexical syntax
+    Comment                                                   -> LAYOUT            
+    "//" EOLCommentChars LineTerminator                       -> Comment           
+    ~[\n\r]*                                                  -> EOLCommentChars   
+    "/*" CommentPart* "*/"                                    -> Comment           
+    "/**" CommentPart* "*/"                                   -> Comment           
+    "/**/"                                                    -> Comment           
+    BlockCommentChars                                         -> CommentPart       
+    EscChar                                                   -> CommentPart       
+    EscEscChar                                                -> CommentPart       
+    Asterisk                                                  -> CommentPart       
+    UnicodeEscape                                             -> CommentPart       
+    ~[\*\\]+                                                  -> BlockCommentChars 
+    "*"                                                       -> Asterisk          
+    "\\\\"                                                    -> EscEscChar        
+    "\\"                                                      -> EscChar           
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape     
+
+  lexical restrictions
+    "/**" -/- [\/]
+    "/*" -/- [\*]
+    Asterisk -/- [\/]
+    EscChar -/- [\\u]
+    BlockCommentChars -/- ~[\*\\]
+    EOLCommentChars -/- ~[\n\13]
+
+  context-free restrictions
+    LAYOUT? -/- [\/] . [\*]
+    LAYOUT? -/- [\/] . [\/]
+
+module languages/java-15/lexical/WhiteSpace
+exports
+  lexical syntax
+    [\ \t\12\r\n] -> LAYOUT 
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\12\n\r]
+
+module languages/java-15/lexical/LineTerminators
+exports
+  sorts LineTerminator CarriageReturn EndOfFile
+
+  lexical syntax
+    [\n]           -> LineTerminator 
+    [\r] [\n]      -> LineTerminator 
+    CarriageReturn -> LineTerminator 
+    EndOfFile      -> LineTerminator 
+    [\r]           -> CarriageReturn 
+
+  lexical restrictions
+    CarriageReturn -/- [\n]
+
+  lexical syntax
+     -> EndOfFile 
+
+  lexical restrictions
+    EndOfFile -/- ~[]
+
+module languages/java-15/lexical/UnicodeEscapes
+exports
+  sorts UnicodeEscape
+
+  syntax
+    "\\" [u]+ [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] -> UnicodeEscape {cons("UnicodeEscape")}
+
+module languages/java-15/lexical/Main
+imports languages/java-15/lexical/UnicodeEscapes
+        languages/java-15/lexical/LineTerminators
+        languages/java-15/lexical/WhiteSpace languages/java-15/lexical/Comments
+        languages/java-15/lexical/Identifiers languages/java-15/lexical/Keywords
+        languages/java-15/lexical/Modifiers
+        languages/java-15/lexical/literals/Main
+
+module languages/java-15/Main
+imports languages/java-15/lexical/Main languages/java-15/types/Main
+        languages/java-15/names/Main languages/java-15/packages/Main
+        languages/java-15/classes/Main languages/java-15/interfaces/Main
+        languages/java-15/arrays/Main languages/java-15/statements/Main
+        languages/java-15/expressions/Main
+
+module languages/java/EmbeddedJava[E]
+imports languages/java-15/Main
+
+exports
+  variables
+    [ij] [0-9\']*             -> DeciLiteral {prefer}
+    [ij] [\_] [a-zA-Z0-9\']*  -> DeciLiteral {prefer}
+    [xyz] [0-9\']*            -> ID          {prefer}
+    [xyz] [\_] [a-zA-Z0-9\']* -> ID          {prefer}
+
+  context-free restrictions
+    ID -/- [\_a-zA-Z0-9\']
+
+exports
+  variables
+    "e" [0-9\']*            -> Expr           {prefer}
+    "e_" [a-zA-Z0-9\']*     -> Expr           {prefer}
+    "e" [0-9\']* "*"        -> {VarInit ","}* {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {VarInit ","}* {prefer}
+    "e" [0-9\']* "*"        -> {Expr ","}*    {prefer}
+    "e_" [a-zA-Z0-9\']* "*" -> {Expr ","}*    {prefer}
+
+  lexical syntax
+    "e" [0-9\']*        -> ID {reject}
+    "e_" [a-zA-Z0-9\']* -> ID {reject}
+
+  context-free syntax
+    "e" "|[" Expr "]|"           -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"   -> E {cons("ToMetaExpr")}
+    "expr" "|[" Expr "]|"        -> E {cons("ToMetaExpr")}
+    "java" "|[" Expr "]|"        -> E {cons("ToMetaExpr")}
+    "|[" Expr "]|"               -> E {cons("ToMetaExpr")}
+    "var-init" "|[" VarInit "]|" -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "e" "|[" Expr "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:expr" "|[" Expr "]|"?   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "expr" "|[" Expr "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" Expr "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" Expr "]|"?               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "var-init" "|[" VarInit "]|"? -> E {completion, cons("ToMetaExpr")}
+
+exports
+  variables
+    "stm" [0-9\']*             -> Stm       {prefer}
+    "stm_" [a-zA-Z0-9\']*      -> Stm       {prefer}
+    "bstm" [0-9\']*            -> BlockStm  {prefer}
+    "bstm_" [a-zA-Z0-9\']*     -> BlockStm  {prefer}
+    "bstm" [0-9\']* "*"        -> BlockStm* {prefer}
+    "bstm_" [a-zA-Z0-9\']* "*" -> BlockStm* {prefer}
+
+  context-free syntax
+    "java:bstm" "|[" BlockStm "]|"            -> E {cons("ToMetaExpr")}
+    "bstm" "|[" BlockStm "]|"                 -> E {cons("ToMetaExpr")}
+    "java" "|[" BlockStm "]|"                 -> E {cons("ToMetaExpr")}
+    "|[" BlockStm "]|"                        -> E {cons("ToMetaExpr")}
+    "java:bstm*" "|[" BlockStm* "]|"          -> E {cons("ToMetaListExpr")}
+    "bstm*" "|[" BlockStm* "]|"               -> E {cons("ToMetaListExpr")}
+    "java:block-stm" "|[" BlockStm "]|"       -> E {cons("ToMetaExpr")}
+    "block-stm" "|[" BlockStm "]|"            -> E {cons("ToMetaExpr")}
+    "java" "|[" BlockStm "]|"                 -> E {cons("ToMetaExpr")}
+    "|[" BlockStm "]|"                        -> E {cons("ToMetaExpr")}
+    "java:block-stm*" "|[" BlockStm* "]|"     -> E {cons("ToMetaListExpr")}
+    "block-stm*" "|[" BlockStm* "]|"          -> E {cons("ToMetaListExpr")}
+    "java:stm" "|[" Stm "]|"                  -> E {cons("ToMetaExpr")}
+    "stm" "|[" Stm "]|"                       -> E {cons("ToMetaExpr")}
+    "switch-group" "|[" SwitchGroup "]|"      -> E {cons("ToMetaListExpr")}
+    "java:switch-group" "|[" SwitchGroup "]|" -> E {cons("ToMetaListExpr")}
+
+  context-free syntax
+    "@#$" "java:bstm" "|[" BlockStm "]|"?            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "bstm" "|[" BlockStm "]|"?                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:bstm*" "|[" BlockStm* "]|"?          -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "bstm*" "|[" BlockStm* "]|"?               -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:block-stm" "|[" BlockStm "]|"?       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "block-stm" "|[" BlockStm "]|"?            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" BlockStm "]|"?                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" BlockStm "]|"?                        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:block-stm*" "|[" BlockStm* "]|"?     -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "block-stm*" "|[" BlockStm* "]|"?          -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:stm" "|[" Stm "]|"?                  -> E {completion, cons("ToMetaExpr")}
+    "@#$" "stm" "|[" Stm "]|"?                       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "switch-group" "|[" SwitchGroup "]|"?      -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:switch-group" "|[" SwitchGroup "]|"? -> E {completion, cons("ToMetaListExpr")}
+
+  context-free syntax
+    "~" E               -> BlockStm     {cons("FromMetaExpr")}
+    "~bstm:" E          -> BlockStm     {cons("FromMetaExpr")}
+    "~*" E              -> BlockStm*    {cons("FromMetaExpr")}
+    "~bstm*:" E         -> BlockStm*    {cons("FromMetaExpr")}
+    "~stm:" E           -> Stm          {cons("FromMetaExpr"), prefer}
+    "~" E               -> Stm          {cons("FromMetaExpr")}
+    "~*" E              -> SwitchGroup* {cons("FromMetaExpr")}
+    "~switch-group*:" E -> SwitchGroup* {cons("FromMetaExpr")}
+    "~" E               -> SwitchGroup  {cons("FromMetaExpr")}
+    "~switch-group:" E  -> SwitchGroup  {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+  variables
+    "lvdec" [0-9]*           -> LocalVarDec   {prefer}
+    "lvdec_" [a-zA-Z0-9]*    -> LocalVarDec   {prefer}
+    "vdec" [0-9]*            -> VarDec        {prefer}
+    "vdec_" [a-zA-Z0-9]*     -> VarDec        {prefer}
+    "vdec" [0-9]* "*"        -> {VarDec ","}+ {prefer}
+    "vdec_" [a-zA-Z0-9]* "*" -> {VarDec ","}+ {prefer}
+
+  lexical syntax
+    "lvdec"               -> ID {reject}
+    "lvdec_" [a-zA-Z0-9]* -> ID {reject}
+    "vdec"                -> ID {reject}
+    "vdec_" [a-zA-Z0-9]*  -> ID {reject}
+
+  context-free syntax
+    "java:lvdec" "|[" LocalVarDec "]|" -> E {cons("ToMetaExpr")}
+    "lvdec" "|[" LocalVarDec "]|"      -> E {cons("ToMetaExpr")}
+    "java:vdec" "|[" VarDec "]|"       -> E {cons("ToMetaExpr")}
+    "vdec" "|[" VarDec "]|"            -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "java:lvdec" "|[" LocalVarDec "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "lvdec" "|[" LocalVarDec "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:vdec" "|[" VarDec "]|"?       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "vdec" "|[" VarDec "]|"?            -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    
+
+  context-free syntax
+    
+
+exports
+  variables
+    "lhs" [0-9\']* -> LHS {prefer}
+    "e" [0-9\']*   -> LHS {prefer}
+
+  lexical syntax
+    "lhs" [0-9\']* -> ID {reject}
+
+exports
+  variables
+    MetaTypeVar     -> Type     {prefer}
+    MetaPrimTypeVar -> PrimType {prefer}
+    MetaRefTypeVar  -> RefType  {prefer}
+
+  lexical syntax
+    "t" [0-9\']*           -> MetaTypeVar     
+    "t_" [a-zA-Z0-9\']*    -> MetaTypeVar     
+    "ty" [0-9]*            -> MetaTypeVar     
+    "ty_" [a-zA-Z0-9\']*   -> MetaTypeVar     
+    "primt" [0-9]*         -> MetaPrimTypeVar 
+    "primt_" [a-zA-Z0-9]*  -> MetaPrimTypeVar 
+    "primty" [0-9]*        -> MetaPrimTypeVar 
+    "primty_" [a-zA-Z0-9]* -> MetaPrimTypeVar 
+    "reft" [0-9]*          -> MetaRefTypeVar  
+    "reft_" [a-zA-Z0-9]*   -> MetaRefTypeVar  
+    "refty" [0-9]*         -> MetaRefTypeVar  
+    "refty_" [a-zA-Z0-9]*  -> MetaRefTypeVar  
+    "t" [0-9\']*           -> ID              {reject}
+    "t_" [a-zA-Z0-9]*      -> ID              {reject}
+    "ty" [0-9]*            -> ID              {reject}
+    "ty_" [a-zA-Z0-9]*     -> ID              {reject}
+    "primt" [0-9]*         -> ID              {reject}
+    "primt_" [a-zA-Z0-9]*  -> ID              {reject}
+    "primty" [0-9]*        -> ID              {reject}
+    "primty_" [a-zA-Z0-9]* -> ID              {reject}
+    "reft" [0-9]*          -> ID              {reject}
+    "reft_" [a-zA-Z0-9]*   -> ID              {reject}
+    "refty" [0-9]*         -> ID              {reject}
+    "refty_" [a-zA-Z0-9]*  -> ID              {reject}
+
+  lexical restrictions
+    MetaTypeVar -/- [a-zA-Z0-9\_\$\']
+
+  context-free syntax
+    "t" "|[" Type "]|"         -> E {cons("ToMetaExpr")}
+    "ty" "|[" Type "]|"        -> E {cons("ToMetaExpr")}
+    "java:type" "|[" Type "]|" -> E {cons("ToMetaExpr")}
+    "type" "|[" Type "]|"      -> E {cons("ToMetaExpr")}
+    "java" "|[" Type "]|"      -> E {cons("ToMetaExpr")}
+    "|[" Type "]|"             -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "t" "|[" Type "]|"?         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "ty" "|[" Type "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:type" "|[" Type "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "type" "|[" Type "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" Type "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" Type "]|"?             -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~" E      -> Type {cons("FromMetaExpr")}
+    "~type:" E -> Type {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  variables
+    "ambname" [0-9]*         -> AmbName           {prefer}
+    "ambname_" [a-zA-Z0-9]*  -> AmbName           {prefer}
+    "ename" [0-9]*           -> ExprName          {prefer}
+    "ename_" [a-zA-Z0-9]*    -> ExprName          {prefer}
+    "fname" [0-9]*           -> MethodName        {prefer}
+    "fname_" [a-zA-Z0-9]*    -> MethodName        {prefer}
+    "tname" [0-9]*           -> TypeName          {prefer}
+    "tname_" [a-zA-Z0-9]*    -> TypeName          {prefer}
+    "pkgtname" [0-9]*        -> PackageOrTypeName {prefer}
+    "pkgtname_" [a-zA-Z0-9]* -> PackageOrTypeName {prefer}
+    "pkgname" [0-9]*         -> PackageName       {prefer}
+    "pkgname_" [a-zA-Z0-9]*  -> PackageName       {prefer}
+
+  context-free syntax
+    "ambname" "|[" AmbName "]|"            -> E {cons("ToMetaExpr")}
+    "ename" "|[" ExprName "]|"             -> E {cons("ToMetaExpr")}
+    "fname" "|[" MethodName "]|"           -> E {cons("ToMetaExpr")}
+    "tname" "|[" TypeName "]|"             -> E {cons("ToMetaExpr")}
+    "pkgtname" "|[" PackageOrTypeName "]|" -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "ambname" "|[" AmbName "]|"?            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "ename" "|[" ExprName "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "fname" "|[" MethodName "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "tname" "|[" TypeName "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "pkgtname" "|[" PackageOrTypeName "]|"? -> E {completion, cons("ToMetaExpr")}
+
+exports
+  variables
+    "mod" [0-9]*            -> MethodMod             {prefer}
+    "mod_" [a-zA-Z0-9]*     -> MethodMod             {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | MethodMod )* {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | MethodMod )* {prefer}
+    "mod" [0-9]*            -> ClassMod              {prefer}
+    "mod_" [a-zA-Z0-9]*     -> ClassMod              {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | ClassMod )*  {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | ClassMod )*  {prefer}
+    "mod" [0-9]*            -> ConstrMod             {prefer}
+    "mod_" [a-zA-Z0-9]*     -> ConstrMod             {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | ConstrMod )* {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | ConstrMod )* {prefer}
+    "mod" [0-9]*            -> VarMod                {prefer}
+    "mod_" [a-zA-Z0-9]*     -> VarMod                {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | VarMod )*    {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | VarMod )*    {prefer}
+    "mod" [0-9]*            -> FieldMod              {prefer}
+    "mod_" [a-zA-Z0-9]*     -> FieldMod              {prefer}
+    "mod" [0-9]* "*"        -> ( Anno | FieldMod )*  {prefer}
+    "mod_" [a-zA-Z0-9]* "*" -> ( Anno | FieldMod )*  {prefer}
+
+  context-free syntax
+    "|[" Modifier "]|"       -> E {cons("ToMetaExpr")}
+    "mod" "|[" Modifier "]|" -> E {cons("ToMetaExpr")}
+    "anno" "|[" Anno "]|"    -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "|[" Modifier "]|"?       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "mod" "|[" Modifier "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "anno" "|[" Anno "]|"?    -> E {completion, cons("ToMetaExpr")}
+
+exports
+  variables
+    "param" [0-9]*            -> FormalParam        {prefer}
+    "param_" [a-zA-Z0-9]*     -> FormalParam        {prefer}
+    "param" [0-9]* "*"        -> {FormalParam ","}* {prefer}
+    "param_" [a-zA-Z0-9]* "*" -> {FormalParam ","}* {prefer}
+
+  context-free syntax
+    "param" "|[" FormalParam "]|"                     -> E {cons("ToMetaExpr")}
+    "java:param" "|[" FormalParam "]|"                -> E {cons("ToMetaExpr")}
+    "param*" "|[" {FormalParam ","}* "]|"             -> E {cons("ToMetaExpr")}
+    "java:param*" "|[" {FormalParam ","}* "]|"        -> E {cons("ToMetaExpr")}
+    "java:formal-param" "|[" FormalParam "]|"         -> E {cons("ToMetaExpr")}
+    "formal-param" "|[" FormalParam "]|"              -> E {cons("ToMetaExpr")}
+    "java" "|[" FormalParam "]|"                      -> E {cons("ToMetaExpr")}
+    "|[" FormalParam "]|"                             -> E {cons("ToMetaExpr")}
+    "java:formal-param*" "|[" {FormalParam ","}* "]|" -> E {cons("ToMetaExpr")}
+    "formal-param*" "|[" {FormalParam ","}* "]|"      -> E {cons("ToMetaExpr")}
+    "java" "|[" {FormalParam ","}* "]|"               -> E {cons("ToMetaExpr")}
+    "|[" {FormalParam ","}* "]|"                      -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "param" "|[" FormalParam "]|"?                     -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:param" "|[" FormalParam "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "param*" "|[" {FormalParam ","}* "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:param*" "|[" {FormalParam ","}* "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:formal-param" "|[" FormalParam "]|"?         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "formal-param" "|[" FormalParam "]|"?              -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" FormalParam "]|"?                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" FormalParam "]|"?                             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:formal-param*" "|[" {FormalParam ","}* "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "formal-param*" "|[" {FormalParam ","}* "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" {FormalParam ","}* "]|"?               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" {FormalParam ","}* "]|"?                      -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~" E  -> FormalParam        {cons("FromMetaExpr")}
+    "~*" E -> {FormalParam ","}* {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  context-free syntax
+    "java:package-dec" "|[" PackageDec "]|"   -> E {cons("ToMetaExpr")}
+    "package-dec" "|[" PackageDec "]|"        -> E {cons("ToMetaExpr")}
+    "|[" PackageDec "]|"                      -> E {cons("ToMetaExpr")}
+    "java:package-dec?" "|[" PackageDec? "]|" -> E {cons("ToMetaExpr")}
+    "package-dec?" "|[" PackageDec? "]|"      -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "java:package-dec" "|[" PackageDec "]|"?   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "package-dec" "|[" PackageDec "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" PackageDec "]|"?                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:package-dec?" "|[" PackageDec? "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "package-dec?" "|[" PackageDec? "]|"?      -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~package-dec:" E  -> PackageDec  {cons("FromMetaExpr")}
+    "~package-dec?:" E -> PackageDec? {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  context-free syntax
+    "java:import-dec" "|[" ImportDec "]|"   -> E {cons("ToMetaExpr")}
+    "import-dec" "|[" ImportDec "]|"        -> E {cons("ToMetaExpr")}
+    "|[" ImportDec "]|"                     -> E {cons("ToMetaExpr")}
+    "java:import-dec*" "|[" ImportDec* "]|" -> E {cons("ToMetaListExpr")}
+    "import-dec*" "|[" ImportDec* "]|"      -> E {cons("ToMetaListExpr")}
+
+  context-free syntax
+    "@#$" "java:import-dec" "|[" ImportDec "]|"?   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "import-dec" "|[" ImportDec "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" ImportDec "]|"?                     -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:import-dec*" "|[" ImportDec* "]|"? -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "import-dec*" "|[" ImportDec* "]|"?      -> E {completion, cons("ToMetaListExpr")}
+
+  context-free syntax
+    "~import-dec:" E  -> ImportDec  {cons("FromMetaExpr")}
+    "~import-dec*:" E -> ImportDec* {cons("FromMetaExpr")}
+
+  context-free syntax
+    
+
+exports
+  context-free syntax
+    "e" "|[" Expr "]|"                                       -> E {cons("ToMetaExpr")}
+    "java:expr" "|[" Expr "]|"                               -> E {cons("ToMetaExpr")}
+    "expr" "|[" Expr "]|"                                    -> E {cons("ToMetaExpr")}
+    "java" "|[" Expr "]|"                                    -> E {cons("ToMetaExpr")}
+    "|[" Expr "]|"                                           -> E {cons("ToMetaExpr")}
+    "java:compilation-unit" "|[" CompilationUnit "]|"        -> E {cons("ToMetaExpr")}
+    "compilation-unit" "|[" CompilationUnit "]|"             -> E {cons("ToMetaExpr")}
+    "java" "|[" CompilationUnit "]|"                         -> E {cons("ToMetaExpr")}
+    "|[" CompilationUnit "]|"                                -> E {cons("ToMetaExpr")}
+    "java:importdecl" "|[" ImportDec "]|"                    -> E {cons("ToMetaExpr")}
+    "importdecl" "|[" ImportDec "]|"                         -> E {cons("ToMetaExpr")}
+    "java" "|[" ImportDec "]|"                               -> E {cons("ToMetaExpr")}
+    "java:type-dec" "|[" TypeDec "]|"                        -> E {cons("ToMetaExpr")}
+    "type-dec" "|[" TypeDec "]|"                             -> E {cons("ToMetaExpr")}
+    "java" "|[" TypeDec "]|"                                 -> E {cons("ToMetaExpr")}
+    "|[" TypeDec "]|"                                        -> E {cons("ToMetaExpr")}
+    "java:class-body-dec" "|[" ClassBodyDec "]|"             -> E {cons("ToMetaExpr")}
+    "class-body-dec" "|[" ClassBodyDec "]|"                  -> E {cons("ToMetaExpr")}
+    "java" "|[" ClassBodyDec "]|"                            -> E {cons("ToMetaExpr")}
+    "|[" ClassBodyDec "]|"                                   -> E {cons("ToMetaExpr")}
+    "java:interface-member-dec" "|[" InterfaceMemberDec "]|" -> E {cons("ToMetaExpr")}
+    "interface-member-dec" "|[" InterfaceMemberDec "]|"      -> E {cons("ToMetaExpr")}
+    "java:constant-dec" "|[" ConstantDec "]|"                -> E {cons("ToMetaExpr")}
+    "constant-dec" "|[" ConstantDec "]|"                     -> E {cons("ToMetaExpr")}
+    "java:class-body-dec*" "|[" ClassBodyDec* "]|"           -> E {cons("ToMetaExpr")}
+    "class-body-dec*" "|[" ClassBodyDec* "]|"                -> E {cons("ToMetaExpr")}
+    "java" "|[" ClassBodyDec* "]|"                           -> E {cons("ToMetaExpr")}
+    "|[" ClassBodyDec* "]|"                                  -> E {cons("ToMetaListExpr")}
+    "java:stm" "|[" Stm "]|"                                 -> E {cons("ToMetaExpr")}
+    "stm" "|[" Stm "]|"                                      -> E {cons("ToMetaExpr")}
+    "java:imember-dec" "|[" AbstractMethodDec "]|"           -> E {cons("ToMetaExpr")}
+    "imember-dec" "|[" AbstractMethodDec "]|"                -> E {cons("ToMetaExpr")}
+    "java" "|[" AbstractMethodDec "]|"                       -> E {cons("ToMetaExpr")}
+    "|[" AbstractMethodDec "]|"                              -> E {cons("ToMetaExpr")}
+    "java:imember-dec*" "|[" AbstractMethodDec* "]|"         -> E {cons("ToMetaExpr")}
+    "imember-dec*" "|[" AbstractMethodDec* "]|"              -> E {cons("ToMetaExpr")}
+    "java" "|[" AbstractMethodDec* "]|"                      -> E {cons("ToMetaExpr")}
+    "|[" AbstractMethodDec* "]|"                             -> E {cons("ToMetaExpr")}
+
+  context-free syntax
+    "@#$" "e" "|[" Expr "]|"?                                       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:expr" "|[" Expr "]|"?                               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "expr" "|[" Expr "]|"?                                    -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" Expr "]|"?                                    -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" Expr "]|"?                                           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:compilation-unit" "|[" CompilationUnit "]|"?        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "compilation-unit" "|[" CompilationUnit "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" CompilationUnit "]|"?                         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" CompilationUnit "]|"?                                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:importdecl" "|[" ImportDec "]|"?                    -> E {completion, cons("ToMetaExpr")}
+    "@#$" "importdecl" "|[" ImportDec "]|"?                         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" ImportDec "]|"?                               -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:type-dec" "|[" TypeDec "]|"?                        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "type-dec" "|[" TypeDec "]|"?                             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" TypeDec "]|"?                                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" TypeDec "]|"?                                        -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:class-body-dec" "|[" ClassBodyDec "]|"?             -> E {completion, cons("ToMetaExpr")}
+    "@#$" "class-body-dec" "|[" ClassBodyDec "]|"?                  -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" ClassBodyDec "]|"?                            -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" ClassBodyDec "]|"?                                   -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:interface-member-dec" "|[" InterfaceMemberDec "]|"? -> E {completion, cons("ToMetaExpr")}
+    "@#$" "interface-member-dec" "|[" InterfaceMemberDec "]|"?      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:constant-dec" "|[" ConstantDec "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "constant-dec" "|[" ConstantDec "]|"?                     -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:class-body-dec*" "|[" ClassBodyDec* "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "class-body-dec*" "|[" ClassBodyDec* "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" ClassBodyDec* "]|"?                           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" ClassBodyDec* "]|"?                                  -> E {completion, cons("ToMetaListExpr")}
+    "@#$" "java:stm" "|[" Stm "]|"?                                 -> E {completion, cons("ToMetaExpr")}
+    "@#$" "stm" "|[" Stm "]|"?                                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:imember-dec" "|[" AbstractMethodDec "]|"?           -> E {completion, cons("ToMetaExpr")}
+    "@#$" "imember-dec" "|[" AbstractMethodDec "]|"?                -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" AbstractMethodDec "]|"?                       -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" AbstractMethodDec "]|"?                              -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java:imember-dec*" "|[" AbstractMethodDec* "]|"?         -> E {completion, cons("ToMetaExpr")}
+    "@#$" "imember-dec*" "|[" AbstractMethodDec* "]|"?              -> E {completion, cons("ToMetaExpr")}
+    "@#$" "java" "|[" AbstractMethodDec* "]|"?                      -> E {completion, cons("ToMetaExpr")}
+    "@#$" "|[" AbstractMethodDec* "]|"?                             -> E {completion, cons("ToMetaExpr")}
+
+  context-free syntax
+    "~" E         -> Name                 {cons("FromMetaExpr")}
+    "~name:" E    -> Name                 {cons("FromMetaExpr")}
+    "~*:" E       -> Name                 {cons("FromMetaExpr")}
+    "~" E         -> Id                   {cons("FromMetaExpr")}
+    "~id:" E      -> Id                   {cons("FromMetaExpr")}
+    "~idd:" E ":" -> Id                   {cons("FromMetaExpr")}
+    "~x:" E       -> ID                   {cons("FromMetaExpr")}
+    "~" E         -> TypeParam            {cons("FromMetaExpr")}
+    "~*" E        -> {TypeParam ","}+     {cons("FromMetaExpr")}
+    "~*" E        -> {ExceptionType ","}* {cons("FromMetaExpr")}
+    "~" E         -> Expr                 {cons("FromMetaExpr")}
+    "~e:" E       -> Expr                 {prefer, cons("FromMetaExpr")}
+    "~expr:" E    -> Expr                 {prefer, cons("FromMetaExpr")}
+    "~*" E        -> {Expr ","}*          {cons("FromMetaExpr")}
+    "~*" E        -> {VarInit ","}*       {cons("FromMetaExpr")}
+    "~" E         -> TypeDec              {cons("FromMetaExpr")}
+    "~*" E        -> TypeDec*             {cons("FromMetaExpr")}
+    "~" E         -> ClassBodyDec         {cons("FromMetaExpr")}
+    "~*" E        -> ClassBodyDec*        {cons("FromMetaExpr")}
+    "~" E         -> InterfaceMemberDec   {cons("FromMetaExpr")}
+    "~*" E        -> InterfaceMemberDec*  {cons("FromMetaExpr")}
+    "~i:" E       -> DeciLiteral          {cons("FromMetaExpr")}
+    "~deci:" E    -> DeciLiteral          {cons("FromMetaExpr")}
+    "~hexa:" E    -> HexaLiteral          {cons("FromMetaExpr")}
+    "~octa:" E    -> OctaLiteral          {cons("FromMetaExpr")}
+    "~float:" E   -> FloatLiteral         {cons("FromMetaExpr")}
+    "~string:" E  -> StringLiteral        {cons("FromMetaExpr")}
+    "~char:" E    -> CharLiteral          {cons("FromMetaExpr")}
+
+  context-free syntax
+    "@#$" "~idd:" E ":"? -> Id {completion, cons("FromMetaExpr")}
+
+  syntax
+    "~" <E-CF>              -> StringChars {cons("FromMetaExpr"), prefer}
+    "~" <E-CF> <LAYOUT?-CF> -> SingleChar  {cons("FromMetaExpr"), prefer}
+
+module languages/java/EmbeddedJavaMix[Ctx0 E]
+imports languages/java/EmbeddedJava[E]
+          [ Name                  => Name[[Ctx0]]
+            MetaRefTypeVar        => MetaRefTypeVar[[Ctx0]]
+            MetaPrimTypeVar       => MetaPrimTypeVar[[Ctx0]]
+            MetaTypeVar           => MetaTypeVar[[Ctx0]]
+            CompilationUnit       => CompilationUnit[[Ctx0]]
+            TypeDec               => TypeDec[[Ctx0]]
+            ImportDec             => ImportDec[[Ctx0]]
+            PackageDec            => PackageDec[[Ctx0]]
+            ElemVal               => ElemVal[[Ctx0]]
+            ElemValPair           => ElemValPair[[Ctx0]]
+            Anno                  => Anno[[Ctx0]]
+            LHS                   => LHS[[Ctx0]]
+            CondMid               => CondMid[[Ctx0]]
+            ArraySubscript        => ArraySubscript[[Ctx0]]
+            DimExpr               => DimExpr[[Ctx0]]
+            ArrayBaseType         => ArrayBaseType[[Ctx0]]
+            ArrayCreationExpr     => ArrayCreationExpr[[Ctx0]]
+            ClassMemberDec        => ClassMemberDec[[Ctx0]]
+            ClassBodyDec          => ClassBodyDec[[Ctx0]]
+            Interfaces            => Interfaces[[Ctx0]]
+            Super                 => Super[[Ctx0]]
+            ClassMod              => ClassMod[[Ctx0]]
+            ClassDecHead          => ClassDecHead[[Ctx0]]
+            ClassBody             => ClassBody[[Ctx0]]
+            ClassDec              => ClassDec[[Ctx0]]
+            InterfaceMod          => InterfaceMod[[Ctx0]]
+            InterfaceMemberDec    => InterfaceMemberDec[[Ctx0]]
+            ExtendsInterfaces     => ExtendsInterfaces[[Ctx0]]
+            InterfaceDecHead      => InterfaceDecHead[[Ctx0]]
+            InterfaceDec          => InterfaceDec[[Ctx0]]
+            DefaultVal            => DefaultVal[[Ctx0]]
+            AnnoElemDec           => AnnoElemDec[[Ctx0]]
+            AnnoDecHead           => AnnoDecHead[[Ctx0]]
+            AnnoDec               => AnnoDec[[Ctx0]]
+            AbstractMethodMod     => AbstractMethodMod[[Ctx0]]
+            AbstractMethodDec     => AbstractMethodDec[[Ctx0]]
+            ConstantMod           => ConstantMod[[Ctx0]]
+            ConstantDec           => ConstantDec[[Ctx0]]
+            EnumBodyDecs          => EnumBodyDecs[[Ctx0]]
+            EnumConstArgs         => EnumConstArgs[[Ctx0]]
+            EnumConst             => EnumConst[[Ctx0]]
+            EnumBody              => EnumBody[[Ctx0]]
+            EnumDecHead           => EnumDecHead[[Ctx0]]
+            EnumDec               => EnumDec[[Ctx0]]
+            ConstrMod             => ConstrMod[[Ctx0]]
+            ConstrInv             => ConstrInv[[Ctx0]]
+            ConstrBody            => ConstrBody[[Ctx0]]
+            ConstrHead            => ConstrHead[[Ctx0]]
+            ConstrDec             => ConstrDec[[Ctx0]]
+            StaticInit            => StaticInit[[Ctx0]]
+            InstanceInit          => InstanceInit[[Ctx0]]
+            MethodBody            => MethodBody[[Ctx0]]
+            ExceptionType         => ExceptionType[[Ctx0]]
+            Throws                => Throws[[Ctx0]]
+            MethodMod             => MethodMod[[Ctx0]]
+            VarMod                => VarMod[[Ctx0]]
+            FormalParam           => FormalParam[[Ctx0]]
+            ResultType            => ResultType[[Ctx0]]
+            MethodDecHead         => MethodDecHead[[Ctx0]]
+            MethodDec             => MethodDec[[Ctx0]]
+            BlockStm              => BlockStm[[Ctx0]]
+            Block                 => Block[[Ctx0]]
+            CatchClause           => CatchClause[[Ctx0]]
+            SwitchLabel           => SwitchLabel[[Ctx0]]
+            SwitchGroup           => SwitchGroup[[Ctx0]]
+            SwitchBlock           => SwitchBlock[[Ctx0]]
+            Stm                   => Stm[[Ctx0]]
+            ExprStm               => ExprStm[[Ctx0]]
+            LocalVarDec           => LocalVarDec[[Ctx0]]
+            LocalVarDecStm        => LocalVarDecStm[[Ctx0]]
+            FieldMod              => FieldMod[[Ctx0]]
+            VarInit               => VarInit[[Ctx0]]
+            Dim                   => Dim[[Ctx0]]
+            VarDecId              => VarDecId[[Ctx0]]
+            VarDec                => VarDec[[Ctx0]]
+            FieldDec              => FieldDec[[Ctx0]]
+            ArrayInit             => ArrayInit[[Ctx0]]
+            ClassLiteral          => ClassLiteral[[Ctx0]]
+            Literal               => Literal[[Ctx0]]
+            Type                  => Type[[Ctx0]]
+            ArrayType             => ArrayType[[Ctx0]]
+            TypeVar               => TypeVar[[Ctx0]]
+            TypeDecSpec           => TypeDecSpec[[Ctx0]]
+            InterfaceType         => InterfaceType[[Ctx0]]
+            ClassType             => ClassType[[Ctx0]]
+            ClassOrInterfaceType  => ClassOrInterfaceType[[Ctx0]]
+            RefType               => RefType[[Ctx0]]
+            TypeVarId             => TypeVarId[[Ctx0]]
+            TypeParams            => TypeParams[[Ctx0]]
+            TypeBound             => TypeBound[[Ctx0]]
+            TypeParam             => TypeParam[[Ctx0]]
+            WildcardBound         => WildcardBound[[Ctx0]]
+            ActualTypeArg         => ActualTypeArg[[Ctx0]]
+            TypeArgs              => TypeArgs[[Ctx0]]
+            PackageOrTypeName     => PackageOrTypeName[[Ctx0]]
+            MethodName            => MethodName[[Ctx0]]
+            ExprName              => ExprName[[Ctx0]]
+            TypeName              => TypeName[[Ctx0]]
+            AmbName               => AmbName[[Ctx0]]
+            PackageName           => PackageName[[Ctx0]]
+            FloatType             => FloatType[[Ctx0]]
+            IntType               => IntType[[Ctx0]]
+            NumType               => NumType[[Ctx0]]
+            PrimType              => PrimType[[Ctx0]]
+            NullLiteral           => NullLiteral[[Ctx0]]
+            FooStringChars        => FooStringChars[[Ctx0]]
+            StringChars           => StringChars[[Ctx0]]
+            StringPart            => StringPart[[Ctx0]]
+            StringLiteral         => StringLiteral[[Ctx0]]
+            SingleChar            => SingleChar[[Ctx0]]
+            CharContent           => CharContent[[Ctx0]]
+            CharLiteral           => CharLiteral[[Ctx0]]
+            LastOcta              => LastOcta[[Ctx0]]
+            OctaEscape            => OctaEscape[[Ctx0]]
+            NamedEscape           => NamedEscape[[Ctx0]]
+            EscapeSeq             => EscapeSeq[[Ctx0]]
+            Bool                  => Bool[[Ctx0]]
+            BoolLiteral           => BoolLiteral[[Ctx0]]
+            BinaryExponent        => BinaryExponent[[Ctx0]]
+            HexaSignificand       => HexaSignificand[[Ctx0]]
+            HexaFloatNumeral      => HexaFloatNumeral[[Ctx0]]
+            SignedInteger         => SignedInteger[[Ctx0]]
+            DeciFloatExponentPart => DeciFloatExponentPart[[Ctx0]]
+            DeciFloatDigits       => DeciFloatDigits[[Ctx0]]
+            DeciFloatNumeral      => DeciFloatNumeral[[Ctx0]]
+            FloatLiteral          => FloatLiteral[[Ctx0]]
+            HexaFloatLiteral      => HexaFloatLiteral[[Ctx0]]
+            DeciFloatLiteral      => DeciFloatLiteral[[Ctx0]]
+            IntLiteral            => IntLiteral[[Ctx0]]
+            OctaNumeral           => OctaNumeral[[Ctx0]]
+            HexaNumeral           => HexaNumeral[[Ctx0]]
+            DeciNumeral           => DeciNumeral[[Ctx0]]
+            OctaLiteral           => OctaLiteral[[Ctx0]]
+            HexaLiteral           => HexaLiteral[[Ctx0]]
+            DeciLiteral           => DeciLiteral[[Ctx0]]
+            Modifier              => Modifier[[Ctx0]]
+            StrictFP              => StrictFP[[Ctx0]]
+            Synchronized          => Synchronized[[Ctx0]]
+            Volatile              => Volatile[[Ctx0]]
+            Transient             => Transient[[Ctx0]]
+            Native                => Native[[Ctx0]]
+            Static                => Static[[Ctx0]]
+            Final                 => Final[[Ctx0]]
+            Abstract              => Abstract[[Ctx0]]
+            Protected             => Protected[[Ctx0]]
+            Private               => Private[[Ctx0]]
+            Public                => Public[[Ctx0]]
+            Id                    => Id[[Ctx0]]
+            ID                    => ID[[Ctx0]]
+            Keyword               => Keyword[[Ctx0]]
+            ArrayAccess           => ArrayAccess[[Ctx0]]
+            FieldAccess           => FieldAccess[[Ctx0]]
+            MethodSpec            => MethodSpec[[Ctx0]]
+            Expr                  => Expr[[Ctx0]] ]
+
+module Stratego-Sugar-Overlays
+imports Stratego-Core-Identifiers Stratego-Sugar-Terms
+
+exports
+  sorts Overlay
+
+  context-free syntax
+    Id "=" Term                   -> Overlay {cons("OverlayNoArgs")}
+    Id "(" {Id ","}* ")" "=" Term -> Overlay {cons("Overlay")}
+
+  context-free syntax
+    "@#$" Id "(" {Id ","}* ")"? "="? -> Overlay {completion, ast("Overlay(<1>,<2>,RootApp(GenDynRules([])))")}
+    "@#$" Id                         -> Overlay {completion, ast("Overlay(<1>,[],RootApp(GenDynRules([])))")}
+
+module Stratego-Sugar-DynamicRules
+imports Stratego-Core-Identifiers Stratego-Sugar-Strategies Stratego-Sugar-Rules
+
+exports
+  sorts ScopeLabels
+
+  context-free syntax
+    "{|" ScopeLabels ":" Strategy "|}" -> Strategy    {cons("DynRuleScope")}
+    {DynRuleScopeId ","}*              -> ScopeLabels {cons("ScopeLabels")}
+    "~" Term                           -> ScopeLabels {cons("ScopeLabels")}
+
+  context-free syntax
+    "@#$" "{|" ScopeLabels ":" Strategy "|}"? -> Strategy {completion, cons("DynRuleScope")}
+    "@#$" "{|" ScopeLabels ":"? "|}"?         -> Strategy {completion, ast("DynRuleScope(<1>,GenDynRules([]))")}
+
+  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec
+
+  context-free syntax
+    "rules" "(" DynRuleDef* ")"            -> Strategy       {cons("GenDynRules")}
+    Id "+" Term                            -> DynRuleDef     {cons("AddScopeLabel")}
+    DynRuleId ":-" Term                    -> DynRuleDef     {cons("UndefineDynRule")}
+    DynRuleId ":" Rule                     -> DynRuleDef     {cons("SetDynRule")}
+    DynRuleId ":+" Rule                    -> DynRuleDef     {cons("AddDynRule")}
+    DynRuleId ":" Term                     -> DynRuleDef     {cons("SetDynRuleMatch")}
+    DynRuleId ":=" Term                    -> DynRuleDef     {cons("DynRuleAssign")}
+    DynRuleId ":+=" Term                   -> DynRuleDef     {cons("DynRuleAssignAdd")}
+    DynRuleId ":" Rule "depends" "on" Term -> DynRuleDef     {cons("SetDynRuleDepends")}
+    RuleDec "." Term                       -> DynRuleId      {cons("LabeledDynRuleId")}
+    RuleDec "+" Term                       -> DynRuleId      {cons("AddLabelDynRuleId")}
+    RuleDec                                -> DynRuleId      {cons("DynRuleId")}
+    Id "." Term                            -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
+    Id                                     -> DynRuleScopeId {cons("DynRuleScopeId")}
+
+  context-free syntax
+    "@#$" "rules" "(" DynRuleDef* ")"?        -> Strategy   {completion, cons("GenDynRules")}
+    "@#$" Id                                  -> DynRuleDef {completion, ast("AddScopeLabel(<1>,RootApp(GenDynRules([])))")}
+    "@#$" DynRuleId ":" Rule "depends"? "on"? -> DynRuleDef {completion, ast("SetDynRuleDepends(<1>,<2>,RootApp(GenDynRules([])))")}
+    "@#$" DynRuleId                           -> DynRuleDef {completion, ast("SetDynRuleDepends(<1>,RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))),RootApp(GenDynRules([])))")}
+
+  context-free syntax
+    Id                                           -> RuleDec {cons("RDecNoArgs")}
+    Id "(" {Typedid ","}* ")"                    -> RuleDec {cons("RDec")}
+    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" -> RuleDec {cons("RDecT")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* ")"?                    -> RuleDec {completion, cons("RDec")}
+    "@#$" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? -> RuleDec {completion, cons("RDecT")}
+    "@#$" Id "(" {Typedid ","}* "|"? ")"?               -> RuleDec {completion, ast("RDecT(<1>,<2>,[])")}
+
+  sorts RuleNames
+
+  context-free syntax
+    {Id ","}*                    -> RuleNames {cons("RuleNames")}
+    "~" Term                     -> RuleNames {cons("RuleNames")}
+    "/" RuleNames "\\*" Strategy -> Strategy  {cons("DynRuleIntersectFix")}
+
+  context-free syntax
+    "@#$" "/" RuleNames "\\*"? -> Strategy {completion, ast("DynRuleIntersectFix(<1>,GenDynRules([]))")}
+
+  syntax
+    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>                                               -> <Strategy-CF> {cons("DynRuleUnionFix")}
+    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>                                              -> <Strategy-CF> {cons("DynRuleUnionFix")}
+    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>  -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+
+  context-free syntax
+    Strategy "/" RuleNames "\\" Strategy               -> Strategy {cons("DynRuleIntersect"), right}
+    Strategy "\\" RuleNames "/" Strategy               -> Strategy {cons("DynRuleUnion"), right}
+    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy {cons("DynRuleIntersectUnion"), right}
+
+  context-free syntax
+    "@#$" Strategy "/" RuleNames "\\"?               -> Strategy {completion, ast("DynRuleIntersect(<1>,<2>,GenDynRules([]))"), right}
+    "@#$" Strategy "\\" RuleNames "/"?               -> Strategy {completion, ast("DynRuleUnion(<1>,<2>,GenDynRules([]))"), right}
+    "@#$" Strategy "/" RuleNames "\\" RuleNames "/"? -> Strategy {completion, ast("DynRuleIntersectUnion(<1>,<2>,<3>,GenDynRules([]))"), right}
+    "@#$" Strategy "/" RuleNames "\\"? "/"?          -> Strategy {completion, ast("DynRuleIntersectUnion(<1>,<2>,RuleNames([]),GenDynRules([]))"), right}
+
+  priorities
+    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")} >
+    { "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF> ->
+      <Strategy-CF> {cons("DynRuleUnionFix")}
+      "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> ->
+      <Strategy-CF> {cons("DynRuleUnionFix")}
+      
+      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
+      
+      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
+      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")} } >
+    <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF>
+    {cons("AM")}
+
+  context-free priorities
+    StrategyAngle Term -> Strategy {cons("BA")} >
+    "/" RuleNames "\\*" Strategy -> Strategy {cons("DynRuleIntersectFix")} >
+    Strategy "=>" Term -> Strategy {cons("AM")} >
+    Strategy "/" RuleNames "\\" Strategy -> Strategy
+    {cons("DynRuleIntersect"), right} >
+    Strategy "\\" RuleNames "/" Strategy -> Strategy
+    {cons("DynRuleUnion"), right} >
+    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy
+    {cons("DynRuleIntersectUnion"), right} >
+    Strategy ";" Strategy -> Strategy {cons("Seq"), right}
+
+module Stratego-Sugar-Rules
+imports Stratego-Sugar-Strategies
+
+exports
+  sorts RuleDef
+
+  context-free syntax
+    Id ":" Rule                                           -> RuleDef {cons("RDefNoArgs")}
+    Id "(" {Typedid ","}* ")" ":" Rule                    -> RuleDef {cons("RDef")}
+    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" ":" Rule -> RuleDef {cons("RDefT")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* ")"? ":"?                    -> RuleDef {completion, ast("RDef(<1>,<2>,RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+    "@#$" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? ":"? -> RuleDef {completion, ast("RDefT(<1>,<2>,<3>,RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+    "@#$" Id "(" {Typedid ","}* "|"? ")"? ":"?               -> RuleDef {completion, ast("RDefT(<1>,<2>,[],RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+    "@#$" Id                                                 -> RuleDef {completion, ast("RDefT(<1>,[],[],RuleNoCond(RootApp(GenDynRules([])),RootApp(GenDynRules([]))))")}
+
+  sorts Rule RuleCond
+
+  context-free syntax
+    Term "->" Term                  -> Rule     {cons("RuleNoCond")}
+    Term "->" Term "where" Strategy -> Rule     {cons("Rule")}
+    Term "->" Term RuleCond+        -> Rule     {cons("Rule"), avoid}
+    "where" Strategy                -> RuleCond {cons("WhereClause")}
+    "with" Strategy                 -> RuleCond {cons("WithClause")}
+
+  context-free syntax
+    "@#$" Term "->" Term "where"? -> Rule {completion, ast("Rule(<1>,<2>,GenDynRules([]))")}
+    "@#$" Term                    -> Rule {completion, ast("Rule(<1>,RootApp(GenDynRules([])),[WhereClause(GenDynRules([]))])"), avoid}
+
+module Stratego-Sugar-Strategies
+imports Stratego-Core-Strategies Stratego-Sugar-Terms Stratego-Sugar-Constants
+        Stratego-Sugar-Signatures
+
+exports
+  context-free syntax
+    Id "=" Strategy                        -> StrategyDef {cons("SDefNoArgs")}
+    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* ")"? "="? -> StrategyDef {completion, ast("SDef(<1>,<2>,GenDynRules([]))")}
+    "@#$" Id                              -> StrategyDef {completion, ast("SDef(<1>,[],GenDynRules([]))")}
+
+  context-free syntax
+    ID -> Typedid {cons("DefaultVarDec")}
+
+  context-free syntax
+    
+
+  sorts Rule
+
+  sorts StrategyParen StrategyCurly StrategyAngle
+
+  context-free syntax
+    SVar "(" {Strategy ","}* ")"          -> Strategy      {cons("Call")}
+    "{" Strategy "}"                      -> Strategy      {cons("ScopeDefault")}
+    StrategyAngle Term                    -> Strategy      {cons("BA")}
+    "<" Strategy ">"                      -> StrategyAngle {bracket}
+    Strategy "<+" Strategy                -> Strategy      {cons("LChoice"), right}
+    "rec" Id "(" Strategy ")"             -> Strategy      {cons("Rec")}
+    "not" "(" Strategy ")"                -> Strategy      {cons("Not")}
+    "where" "(" Strategy ")"              -> Strategy      {cons("Where")}
+    "with" "(" Strategy ")"               -> Strategy      {cons("With"), prefer}
+    "test" "(" Strategy ")"               -> Strategy      {cons("Test")}
+    "prim" "(" String ")"                 -> Strategy      {cons("PrimNoArgs")}
+    "prim" "(" String "," {Term ","}* ")" -> Strategy      {cons("Prim")}
+    String                                -> Strategy      {cons("StrCong")}
+    Int                                   -> Strategy      {cons("IntCong")}
+    Real                                  -> Strategy      {cons("RealCong")}
+    Char                                  -> Strategy      {cons("CharCong")}
+    String "(" {Strategy ","}* ")"        -> Strategy      {cons("CongQ")}
+    Strategy StrategyCurly                -> Strategy      {cons("AnnoCong")}
+    "{" Strategy "}"                      -> StrategyCurly {cons("StrategyCurly")}
+    "(" ")"                               -> Strategy      {cons("EmptyTupleCong")}
+    "(" Strategy ")"                      -> Strategy      {bracket}
+    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy      {cons("TupleCong")}
+    "[" {Strategy ","}* "]"               -> Strategy      {cons("ListCongNoTail")}
+    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy      {cons("ListCong")}
+    Strategy "#" StrategyParen            -> Strategy      {cons("ExplodeCong")}
+
+  context-free syntax
+    "@#$" SVar "(" {Strategy ","}* ")"?          -> Strategy      {completion, cons("Call")}
+    "@#$" SVar                                   -> Strategy      {completion, ast("Call(<1>,[])")}
+    "@#$" "{" Strategy "}"?                      -> Strategy      {completion, cons("ScopeDefault")}
+    "@#$" StrategyAngle                          -> Strategy      {completion, ast("BA(<1>,RootApp(GenDynRules([])))")}
+    "@#$" "<" Strategy ">"?                      -> StrategyAngle {completion, bracket}
+    "@#$" "rec" Id "(" Strategy ")"?             -> Strategy      {completion, cons("Rec")}
+    "@#$" "rec" Id "("? ")"?                     -> Strategy      {completion, ast("Rec(<1>,GenDynRules([]))")}
+    "@#$" "not" "(" Strategy ")"?                -> Strategy      {completion, cons("Not")}
+    "@#$" "where" "(" Strategy ")"?              -> Strategy      {completion, cons("Where")}
+    "@#$" "with" "(" Strategy ")"?               -> Strategy      {completion, cons("With"), prefer}
+    "@#$" "test" "(" Strategy ")"?               -> Strategy      {completion, cons("Test")}
+    "@#$" "prim" "(" String ")"?                 -> Strategy      {completion, cons("PrimNoArgs")}
+    "@#$" "prim" "(" String "," {Term ","}* ")"? -> Strategy      {completion, cons("Prim")}
+    "@#$" "prim" "(" String ","? ")"?            -> Strategy      {completion, ast("Prim(<1>,[])")}
+    "@#$" String "(" {Strategy ","}* ")"?        -> Strategy      {completion, cons("CongQ")}
+    "@#$" "{" Strategy "}"?                      -> StrategyCurly {completion, cons("StrategyCurly")}
+    "@#$" "(" Strategy ")"?                      -> Strategy      {completion, bracket}
+    "@#$" "(" Strategy "," {Strategy ","}+ ")"?  -> Strategy      {completion, cons("TupleCong")}
+    "@#$" "(" Strategy ","? ")"?                 -> Strategy      {completion, ast("TupleCong(<1>,[GenDynRules([])])")}
+    "@#$" "[" {Strategy ","}* "]"?               -> Strategy      {completion, cons("ListCongNoTail")}
+    "@#$" "[" {Strategy ","}* "|" Strategy "]"?  -> Strategy      {completion, cons("ListCong")}
+    "@#$" "[" {Strategy ","}* "|"? "]"?          -> Strategy      {completion, ast("ListCong(<1>,GenDynRules([]))")}
+
+  sorts SwitchCase
+
+  context-free syntax
+    SVar                                                         -> Strategy   {cons("CallNoArgs")}
+    "\\" Rule "\\"                                               -> Strategy   {cons("LRule")}
+    "(" Rule ")"                                                 -> Strategy   {cons("SRule")}
+    Strategy "+" Strategy                                        -> Strategy   {cons("Choice"), right}
+    Strategy "+>" Strategy                                       -> Strategy   {cons("RChoice"), right}
+    "if" Strategy "then" Strategy "else" Strategy "end"          -> Strategy   {cons("CondChoice")}
+    "if" Strategy "then" Strategy "end"                          -> Strategy   {cons("IfThen")}
+    "switch" Strategy SwitchCase* "end"                          -> Strategy   {cons("SwitchChoiceNoOtherwise")}
+    "switch" Strategy SwitchCase* "otherwise" ":" Strategy "end" -> Strategy   {cons("SwitchChoice")}
+    "case" Strategy ":" Strategy                                 -> SwitchCase {cons("SwitchCase")}
+    Strategy "=>" Term                                           -> Strategy   {cons("AM")}
+    Term ":=" Term                                               -> Strategy   {cons("Assign")}
+
+  context-free syntax
+    "@#$" "\\" Rule "\\"?                                               -> Strategy   {completion, cons("LRule")}
+    "@#$" "(" Rule ")"?                                                 -> Strategy   {completion, cons("SRule")}
+    "@#$" "if" Strategy "then" Strategy "else" Strategy "end"?          -> Strategy   {completion, cons("CondChoice")}
+    "@#$" "if" Strategy "then" Strategy "else"? "end"?                  -> Strategy   {completion, ast("CondChoice(<1>,<2>,GenDynRules([]))")}
+    "@#$" "if" Strategy "then"? "else"? "end"?                          -> Strategy   {completion, ast("CondChoice(<1>,GenDynRules([]),GenDynRules([]))")}
+    "@#$" "if" Strategy "then" Strategy "end"?                          -> Strategy   {completion, cons("IfThen")}
+    "@#$" "if" Strategy "then"? "end"?                                  -> Strategy   {completion, ast("IfThen(<1>,GenDynRules([]))")}
+    "@#$" "switch" Strategy SwitchCase* "end"?                          -> Strategy   {completion, cons("SwitchChoiceNoOtherwise")}
+    "@#$" "switch" Strategy "end"?                                      -> Strategy   {completion, ast("SwitchChoiceNoOtherwise(<1>,[])")}
+    "@#$" "switch" Strategy SwitchCase* "otherwise" ":" Strategy "end"? -> Strategy   {completion, cons("SwitchChoice")}
+    "@#$" "switch" Strategy SwitchCase* "otherwise"? ":"? "end"?        -> Strategy   {completion, ast("SwitchChoice(<1>,<2>,GenDynRules([]))")}
+    "@#$" "switch" Strategy "otherwise"? ":"? "end"?                    -> Strategy   {completion, ast("SwitchChoice(<1>,[],GenDynRules([]))")}
+    "@#$" "case" Strategy ":"?                                          -> SwitchCase {completion, ast("SwitchCase(<1>,GenDynRules([]))")}
+    "@#$" Term                                                          -> Strategy   {completion, ast("Assign(<1>,RootApp(GenDynRules([])))")}
+
+  context-free priorities
+    { Strategy StrategyCurly -> Strategy 
+      Strategy "#" StrategyParen -> Strategy  } >
+    { "!" Term -> Strategy 
+      "?" Term -> Strategy  } >
+    StrategyAngle Term -> Strategy  >
+    Strategy "=>" Term -> Strategy  >
+    Strategy ";" Strategy -> Strategy  >
+    {right:
+      Strategy "+" Strategy -> Strategy 
+      Strategy "<+" Strategy -> Strategy 
+      Strategy "+>" Strategy -> Strategy 
+      Strategy "<" StrategyMid "+" Strategy -> Strategy 
+    }
+
+  context-free priorities
+    Strategy -> StrategyMid  >
+    Strategy "+" Strategy -> Strategy 
+
+  context-free priorities
+    { Strategy StrategyCurly -> Strategy 
+      Strategy "#" StrategyParen -> Strategy  } . >
+    Term ":=" Term -> Strategy 
+
+module Stratego-Sugar-Terms
+imports Stratego-Core-Terms Stratego-Sugar-Strategies
+
+exports
+  sorts LID
+
+  context-free syntax
+    LId -> LID {cons("ListVar")}
+    LID -> Var {cons("Var")}
+    LID -> ID  
+
+  context-free syntax
+    
+
+  context-free syntax
+    "_" PreTerm                  -> PreTerm {cons("BuildDefaultPT")}
+    "_" Term                     -> Term    {cons("BuildDefault"), prefer}
+    Char                         -> PreTerm {cons("Char")}
+    PreTerm "{" {Term ","}* "}"  -> Term    {cons("AnnoList")}
+    PreTerm                      -> Term    {cons("NoAnnoList")}
+    "<" Strategy ">" Term        -> PreTerm {cons("App")}
+    "<" Strategy ">" Term        -> Term    {cons("App"), prefer}
+    StrategyAngle                -> PreTerm {cons("RootApp")}
+    StrategyAngle                -> Term    {cons("RootApp"), prefer}
+    "(" {Term ","}* ")"          -> PreTerm {cons("Tuple")}
+    "[" {Term ","}* "]"          -> PreTerm {cons("List")}
+    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}
+
+  context-free syntax
+    "@#$" PreTerm "{" {Term ","}* "}"?  -> Term    {completion, cons("AnnoList")}
+    "@#$" "<" Strategy ">"?             -> PreTerm {completion, ast("App(<1>,RootApp(GenDynRules([])))")}
+    "@#$" "<" Strategy ">"?             -> Term    {completion, ast("App(<1>,RootApp(GenDynRules([])))"), prefer}
+    "@#$" "(" {Term ","}* ")"?          -> PreTerm {completion, cons("Tuple")}
+    "@#$" "[" {Term ","}* "]"?          -> PreTerm {completion, cons("List")}
+    "@#$" "[" {Term ","}* "|" Term "]"? -> PreTerm {completion, cons("ListTail")}
+    "@#$" "[" {Term ","}* "|"? "]"?     -> PreTerm {completion, ast("ListTail(<1>,RootApp(GenDynRules([])))")}
+
+  context-free priorities
+    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
+    PreTerm "{" {Term ","}* "}" -> Term {cons("AnnoList")} >
+    Var "@" Term -> Term {cons("As")}
+
+module Stratego-Sugar-Signatures
+imports Stratego-Core-Signatures Stratego-Sugar-Constants
+
+exports
+  sorts Sort
+
+  context-free syntax
+    "[" {Sort ","}* "]"          -> Sort {cons("SortList")}
+    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
+    "(" {Sort ","}* ")"          -> Sort {cons("SortTuple")}
+
+  context-free syntax
+    "@#$" "[" {Sort ","}* "]"?          -> Sort {completion, cons("SortList")}
+    "@#$" "[" {Sort ","}* "|" Sort "]"? -> Sort {completion, cons("SortListTl")}
+    "@#$" "[" {Sort ","}* "|"? "]"?     -> Sort {completion, ast("SortListTl(<1>,SortList([]))")}
+    "@#$" "(" {Sort ","}* ")"?          -> Sort {completion, cons("SortTuple")}
+
+  sorts Kind
+
+  context-free syntax
+    "*"  -> Kind {cons("Star")}
+    "**" -> Kind {cons("StarStar")}
+
+  context-free syntax
+    
+
+module Stratego-Core-Signatures
+imports Stratego-Core-Identifiers Stratego-Core-Constants
+
+exports
+  sorts Sdecl
+
+  context-free syntax
+    "sorts" Sort*          -> Sdecl {cons("Sorts")}
+    "constructors" Opdecl* -> Sdecl {cons("Constructors")}
+
+  context-free syntax
+    
+
+  sorts Sort
+
+  context-free syntax
+    LCID                   -> Sort {cons("SortVar")}
+    UCID                   -> Sort {cons("SortNoArgs")}
+    Id "(" {Sort ","}* ")" -> Sort {cons("Sort")}
+
+  context-free syntax
+    "@#$" Id "(" {Sort ","}* ")"? -> Sort {completion, cons("Sort")}
+    "@#$" Id                      -> Sort {completion, ast("Sort(<1>,[])")}
+
+  sorts Opdecl
+
+  context-free syntax
+    Id ":" Type     -> Opdecl {cons("OpDecl")}
+    String ":" Type -> Opdecl {cons("OpDeclQ")}
+    ":" Type        -> Opdecl {cons("OpDeclInj")}
+
+  context-free syntax
+    "@#$" Id     -> Opdecl {completion, ast("OpDecl(<1>,Boolean)")}
+    "@#$" String -> Opdecl {completion, ast("OpDeclQ(<1>,Boolean)")}
+
+  context-free syntax
+    "external" Id ":" Type     -> Opdecl {cons("ExtOpDecl")}
+    "external" String ":" Type -> Opdecl {cons("ExtOpDeclQ")}
+    "external" ":" Type        -> Opdecl {cons("ExtOpDeclInj")}
+
+  context-free syntax
+    "@#$" "external" Id ":"?     -> Opdecl {completion, ast("ExtOpDecl(<1>,Boolean)")}
+    "@#$" "external" String ":"? -> Opdecl {completion, ast("ExtOpDeclQ(<1>,Boolean)")}
+
+  sorts Type ArgType ConstType FunType RetType
+
+  context-free syntax
+    Sort                        -> ConstType {cons("ConstType")}
+    {ArgType "*"}+ "->" RetType -> FunType   {cons("FunType")}
+    "(" Type ")"                -> ArgType   {bracket}
+    ConstType                   -> ArgType   
+    Type                        -> RetType   
+    FunType                     -> RetType   {reject}
+    FunType                     -> Type      
+    ConstType                   -> Type      
+
+  context-free syntax
+    "@#$" {ArgType "*"}+ -> FunType {completion, ast("FunType(<1>,Boolean)")}
+    "@#$" "(" Type ")"?  -> ArgType {completion, bracket}
+
+  context-free restrictions
+    Sort -/- [\(]
+
+module Stratego-Core-Terms
+imports Stratego-Core-Identifiers Stratego-Core-Constants
+
+exports
+  sorts ID Var Wld
+
+  context-free syntax
+    Id -> Var {cons("Var")}
+    Id -> ID  
+
+  context-free syntax
+    
+
+  sorts Term PreTerm
+
+  context-free syntax
+    Var                        -> PreTerm 
+    Var                        -> Term    {prefer}
+    "_"                        -> Wld     {cons("Wld")}
+    Wld                        -> PreTerm 
+    Wld                        -> Term    {prefer}
+    Int                        -> PreTerm {cons("Int")}
+    Real                       -> PreTerm {cons("Real")}
+    String                     -> PreTerm {cons("Str")}
+    Id "(" {Term ","}* ")"     -> PreTerm {cons("Op")}
+    String "(" {Term ","}* ")" -> PreTerm {cons("OpQ")}
+    Term "#" "(" Term ")"      -> PreTerm {cons("Explode")}
+    PreTerm "{^" PreTerm "}"   -> Term    {cons("Anno")}
+    Var "@" Term               -> Term    {cons("As"), prefer}
+    Var "@" PreTerm            -> PreTerm {cons("As")}
+
+  context-free syntax
+    "@#$" Id "(" {Term ","}* ")"?     -> PreTerm {completion, cons("Op")}
+    "@#$" Id                          -> PreTerm {completion, ast("Op(<1>,[])")}
+    "@#$" String "(" {Term ","}* ")"? -> PreTerm {completion, cons("OpQ")}
+    "@#$" Term "#" "(" Term ")"?      -> PreTerm {completion, cons("Explode")}
+    "@#$" Term                        -> PreTerm {completion, ast("Explode(<1>,RootApp(GenDynRules([])))")}
+    "@#$" PreTerm "{^" PreTerm "}"?   -> Term    {completion, cons("Anno")}
+    "@#$" PreTerm                     -> Term    {completion, ast("Anno(<1>,RootApp(GenDynRules([])))")}
+
+  context-free priorities
+    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
+    Var "@" Term -> Term {cons("As")}
+
+module Stratego-Core-Strategies
+imports Stratego-Core-Terms Stratego-Core-Constants Stratego-Core-Signatures
+
+exports
+  sorts Def
+
+  context-free syntax
+    StrategyDef                                             -> Def      
+    Id                                                      -> SVar     {cons("SVar")}
+    "let" Def* "in" Strategy "end"                          -> Strategy {cons("Let")}
+    SVar "(" {Strategy ","}* "|" {Term ","}* ")"            -> Strategy {cons("CallT")}
+    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}
+
+  context-free syntax
+    "@#$" "let" Def* "in" Strategy "end"?                          -> Strategy {completion, cons("Let")}
+    "@#$" "let" Def* "in"? "end"?                                  -> Strategy {completion, ast("Let(<1>,GenDynRules([]))")}
+    "@#$" SVar "(" {Strategy ","}* "|" {Term ","}* ")"?            -> Strategy {completion, cons("CallT")}
+    "@#$" SVar "(" {Strategy ","}* "|"? ")"?                       -> Strategy {completion, ast("CallT(<1>,<2>,[])")}
+    "@#$" SVar                                                     -> Strategy {completion, ast("CallT(<1>,[],[])")}
+    "@#$" "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")"? -> Strategy {completion, cons("CallDynamic")}
+    "@#$" "call" "(" Term "|" {Strategy ","}* "|"? ")"?            -> Strategy {completion, ast("CallDynamic(<1>,<2>,[])")}
+    "@#$" "call" "(" Term "|"? "|"? ")"?                           -> Strategy {completion, ast("CallDynamic(<1>,[],[])")}
+
+  sorts StrategyDef
+
+  context-free syntax
+    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy            -> StrategyDef {cons("SDefT")}
+    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
+    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"              -> StrategyDef {cons("ExtSDef")}
+
+  context-free syntax
+    "@#$" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? "="?            -> StrategyDef {completion, ast("SDefT(<1>,<2>,<3>,GenDynRules([]))")}
+    "@#$" Id "(" {Typedid ","}* "|"? ")"? "="?                          -> StrategyDef {completion, ast("SDefT(<1>,<2>,[],GenDynRules([]))")}
+    "@#$" Id                                                            -> StrategyDef {completion, ast("SDefT(<1>,[],[],GenDynRules([]))")}
+    "@#$" "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"? "="? -> StrategyDef {completion, ast("ExtSDefInl(<1>,<2>,<3>,GenDynRules([]))")}
+    "@#$" "external" Id "(" {Typedid ","}* "|"? ")"? "="?               -> StrategyDef {completion, ast("ExtSDefInl(<1>,<2>,[],GenDynRules([]))")}
+    "@#$" "external" Id "("? "|"? ")"? "="?                             -> StrategyDef {completion, ast("ExtSDefInl(<1>,[],[],GenDynRules([]))")}
+    "@#$" "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"?      -> StrategyDef {completion, cons("ExtSDef")}
+    "@#$" "external" Id "(" {Typedid ","}* "|"? ")"?                    -> StrategyDef {completion, ast("ExtSDef(<1>,<2>,[])")}
+    "@#$" "external" Id "("? "|"? ")"?                                  -> StrategyDef {completion, ast("ExtSDef(<1>,[],[])")}
+
+  sorts Typedid
+
+  context-free syntax
+    ID ":" Type -> Typedid {cons("VarDec")}
+
+  context-free syntax
+    "@#$" ID -> Typedid {completion, ast("VarDec(<1>,Boolean)")}
+
+  sorts Strategy SVar StrategyParen StrategyMid
+
+  context-free syntax
+    "(" Strategy ")"                                          -> StrategyParen {cons("ParenStrat")}
+    "fail"                                                    -> Strategy      {cons("Fail")}
+    "id"                                                      -> Strategy      {cons("Id")}
+    "?" Term                                                  -> Strategy      {cons("Match")}
+    "!" Term                                                  -> Strategy      {cons("Build")}
+    "{" {ID ","}* ":" Strategy "}"                            -> Strategy      {cons("Scope")}
+    Strategy ";" Strategy                                     -> Strategy      {cons("Seq"), right}
+    Strategy "<" StrategyMid "+" Strategy                     -> Strategy      {cons("GuardedLChoice"), right}
+    Strategy                                                  -> StrategyMid   
+    "prim" "(" String "," {Strategy ","}* "|" {Term ","}* ")" -> Strategy      {cons("PrimT")}
+    "some" "(" Strategy ")"                                   -> Strategy      {cons("Some")}
+    "one" "(" Strategy ")"                                    -> Strategy      {cons("One")}
+    "all" "(" Strategy ")"                                    -> Strategy      {cons("All")}
+
+  context-free syntax
+    "@#$" "(" Strategy ")"?                                          -> StrategyParen {completion, cons("ParenStrat")}
+    "@#$" "{" {ID ","}* ":" Strategy "}"?                            -> Strategy      {completion, cons("Scope")}
+    "@#$" "{" {ID ","}* ":"? "}"?                                    -> Strategy      {completion, ast("Scope(<1>,GenDynRules([]))")}
+    "@#$" Strategy "<" StrategyMid "+"?                              -> Strategy      {completion, ast("GuardedLChoice(<1>,<2>,GenDynRules([]))"), right}
+    "@#$" "prim" "(" String "," {Strategy ","}* "|" {Term ","}* ")"? -> Strategy      {completion, cons("PrimT")}
+    "@#$" "prim" "(" String "," {Strategy ","}* "|"? ")"?            -> Strategy      {completion, ast("PrimT(<1>,<2>,[])")}
+    "@#$" "prim" "(" String ","? "|"? ")"?                           -> Strategy      {completion, ast("PrimT(<1>,[],[])")}
+    "@#$" "some" "(" Strategy ")"?                                   -> Strategy      {completion, cons("Some")}
+    "@#$" "one" "(" Strategy ")"?                                    -> Strategy      {completion, cons("One")}
+    "@#$" "all" "(" Strategy ")"?                                    -> Strategy      {completion, cons("All")}
+
+  context-free priorities
+    { "!" Term -> Strategy {cons("Build")}
+      "?" Term -> Strategy {cons("Match")} } >
+    Strategy ";" Strategy -> Strategy {cons("Seq"), right} >
+    {right:
+      Strategy "<" StrategyMid "+" Strategy -> Strategy
+      {cons("GuardedLChoice"), right}
+    }
+
+  context-free syntax
+    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}
+
+  context-free syntax
+    "@#$" "import-term" "(" ModName ")"? -> Strategy {completion, cons("ImportTerm")}
+
+module Stratego-Core-Modules
+imports Stratego-Core-Identifiers Stratego-Core-Strategies
+        Stratego-Core-Signatures
+
+exports
+  sorts Module
+
+  context-free syntax
+    "module" ModName Decl* -> Module {cons("Module")}
+    "specification" Decl*  -> Module {cons("Specification")}
+
+  context-free syntax
+    
+
+  sorts Decl
+
+  context-free syntax
+    "imports" ImportModName* -> Decl {cons("Imports")}
+    "strategies" Def*        -> Decl {cons("Strategies")}
+    "signature" Sdecl*       -> Decl {cons("Signature")}
+
+  context-free syntax
+    
+
+  sorts ImportModName
+
+  context-free syntax
+    ModName -> ImportModName {cons("Import")}
+
+  context-free syntax
+    
+
+  syntax
+    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}
+
+module Stratego-Sugar-Modules
+imports Stratego-Core-Modules Stratego-Sugar-Strategies
+        Stratego-Sugar-Signatures Stratego-Sugar-Overlays Stratego-Sugar-Rules
+
+exports
+  sorts Decl Def
+
+  context-free syntax
+    "rules" Def*        -> Decl {cons("Rules")}
+    "overlays" Overlay* -> Decl {cons("Overlays")}
+    RuleDef             -> Def  
+
+  context-free syntax
+    
+
+module Stratego-Core-Constants
+exports
+  sorts Int Real String StrChar
+
+  lexical syntax
+    [\-]? [0-9]+             -> Int     
+    [\-]? [0-9]+ [\.] [0-9]+ -> Real    
+    "\"" StrChar* "\""       -> String  
+    ~[\"\\]                  -> StrChar 
+    [\\] [\"tnr\\]           -> StrChar 
+
+module Stratego-Sugar-Constants
+imports Stratego-Core-Identifiers Stratego-Core-Constants
+
+exports
+  sorts Char CharChar
+
+  lexical syntax
+    "'" CharChar "'" -> Char     
+    ~[\']            -> CharChar 
+    [\\] [\'ntr\ ]   -> CharChar 
+    Char             -> Id       {reject}
+
+module Stratego-Core-Identifiers
+exports
+  sorts ModName ModNamePart
+
+  lexical syntax
+    {ModNamePart "/"}+                -> ModName     
+    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart 
+
+  lexical restrictions
+    ModName -/- [a-zA-Z0-9\'\.\-\_]
+
+  lexical syntax
+    "imports"    -> ModName {reject}
+    "overlays"   -> ModName {reject}
+    "rules"      -> ModName {reject}
+    "signature"  -> ModName {reject}
+    "strategies" -> ModName {reject}
+
+  sorts Id LId LCID UCID Wld
+
+  lexical syntax
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id   
+    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId  
+    [\'] [a-z]+                       -> Id   
+    [a-z] [a-zA-Z0-9\'\-\_]*          -> LCID 
+    [A-Z] [a-zA-Z0-9\'\-\_]*          -> UCID 
+
+  lexical restrictions
+    Id -/- [a-zA-Z0-9\'\-\_\*]
+    LId -/- [a-zA-Z0-9\'\-\_]
+    LCID -/- [a-zA-Z0-9\'\-\_]
+    UCID -/- [a-zA-Z0-9\'\-\_]
+
+  lexical syntax
+    "_"     -> Id   {reject}
+    "'"     -> Id   {reject}
+    Keyword -> Id   {reject}
+    Keyword -> LId  {reject}
+    Keyword -> LCID {reject}
+    Keyword -> UCID {reject}
+
+  lexical restrictions
+    "all" "case" "constructors" "else" "end" "external" "fail" "id" "if" "in"
+    "imports" "let" "module" "not" "one" "overlays" "otherwise" "prim" "rec"
+    "rules" "script" "signature" "some" "sorts" "strategies" "stratego" "switch"
+    "test" "then" "where" "import-term" -/- [a-zA-Z0-9\'\-\_]
+
+  context-free restrictions
+    Wld -/- [a-zA-Z0-9\'\-\_]
+
+  sorts Keyword
+
+  lexical syntax
+    "all"          -> Keyword 
+    "constructors" -> Keyword 
+    "fail"         -> Keyword 
+    "id"           -> Keyword 
+    "in"           -> Keyword 
+    "let"          -> Keyword 
+    "module"       -> Keyword 
+    "not"          -> Keyword 
+    "one"          -> Keyword 
+    "overlays"     -> Keyword 
+    "prim"         -> Keyword 
+    "rules"        -> Keyword 
+    "script"       -> Keyword 
+    "signature"    -> Keyword 
+    "some"         -> Keyword 
+    "sorts"        -> Keyword 
+    "strategies"   -> Keyword 
+    "stratego"     -> Keyword 
+    "test"         -> Keyword 
+    "where"        -> Keyword 
+    "import-term"  -> Keyword 
+
+module Stratego-Core-Layout
+exports
+  sorts Ws ShortCom LongCom CommChar Asterisk Eof
+
+  lexical syntax
+    [\t\ \n\r]             -> Ws       
+    "//" ~[\n]* [\n] | Eof -> ShortCom 
+    "/*" CommChar* "*/"    -> LongCom  
+                           -> Eof      
+    ~[\*]                  -> CommChar 
+    "*"                    -> Asterisk 
+    Asterisk               -> CommChar 
+
+  lexical restrictions
+    Asterisk -/- [\/]
+    Eof -/- ~[]
+
+  lexical syntax
+    ShortCom -> LAYOUT 
+    LongCom  -> LAYOUT 
+    Ws       -> LAYOUT 
+
+  context-free restrictions
+    LAYOUT? -/- [\ \t\n\r]
+    LAYOUT? -/- [\/] . [\*]
+    LAYOUT? -/- [\/] . [\/]
+
+module Stratego-Sugar-Layout
+imports Stratego-Core-Layout
+
+module Stratego-Sugar
+imports Stratego-Sugar-Layout Stratego-Core-Identifiers Stratego-Sugar-Constants
+        Stratego-Sugar-Modules Stratego-Sugar-Signatures Stratego-Sugar-Terms
+        Stratego-Sugar-Strategies Stratego-Sugar-Rules
+        Stratego-Sugar-DynamicRules Stratego-Sugar-Overlays
+
+hiddens
+  context-free start-symbols
+    Module
+
+module Stratego
+imports Stratego-Sugar
+
+hiddens
+  context-free start-symbols
+    Module
+
+module StrategoMix[Ctx0]
+imports Stratego
+          [ RuleNames      => RuleNames[[Ctx0]]
+            RuleDec        => RuleDec[[Ctx0]]
+            DynRuleScopeId => DynRuleScopeId[[Ctx0]]
+            DynRuleId      => DynRuleId[[Ctx0]]
+            DynRuleDef     => DynRuleDef[[Ctx0]]
+            ScopeLabels    => ScopeLabels[[Ctx0]]
+            RuleCond       => RuleCond[[Ctx0]]
+            Rule           => Rule[[Ctx0]]
+            RuleDef        => RuleDef[[Ctx0]]
+            Overlay        => Overlay[[Ctx0]]
+            SwitchCase     => SwitchCase[[Ctx0]]
+            StrategyCurly  => StrategyCurly[[Ctx0]]
+            StrategyAngle  => StrategyAngle[[Ctx0]]
+            Kind           => Kind[[Ctx0]]
+            LID            => LID[[Ctx0]]
+            ImportModName  => ImportModName[[Ctx0]]
+            Decl           => Decl[[Ctx0]]
+            Module         => Module[[Ctx0]]
+            StrategyParen  => StrategyParen[[Ctx0]]
+            Typedid        => Typedid[[Ctx0]]
+            StrategyDef    => StrategyDef[[Ctx0]]
+            SVar           => SVar[[Ctx0]]
+            Def            => Def[[Ctx0]]
+            Type           => Type[[Ctx0]]
+            RetType        => RetType[[Ctx0]]
+            ArgType        => ArgType[[Ctx0]]
+            FunType        => FunType[[Ctx0]]
+            ConstType      => ConstType[[Ctx0]]
+            Opdecl         => Opdecl[[Ctx0]]
+            Sort           => Sort[[Ctx0]]
+            Sdecl          => Sdecl[[Ctx0]]
+            Wld            => Wld[[Ctx0]]
+            ID             => ID[[Ctx0]]
+            Var            => Var[[Ctx0]]
+            CharChar       => CharChar[[Ctx0]]
+            Char           => Char[[Ctx0]]
+            StrChar        => StrChar[[Ctx0]]
+            String         => String[[Ctx0]]
+            Real           => Real[[Ctx0]]
+            Int            => Int[[Ctx0]]
+            Keyword        => Keyword[[Ctx0]]
+            UCID           => UCID[[Ctx0]]
+            LCID           => LCID[[Ctx0]]
+            LId            => LId[[Ctx0]]
+            Id             => Id[[Ctx0]]
+            ModNamePart    => ModNamePart[[Ctx0]]
+            ModName        => ModName[[Ctx0]]
+            PreTerm        => PreTerm[[Ctx0]]
+            Term           => Term[[Ctx0]]
+            StrategyMid    => StrategyMid[[Ctx0]]
+            Strategy       => Strategy[[Ctx0]] ]
+
+module StrategoJava
+imports StrategoMix[StrategoHost]
+        languages/java/EmbeddedJavaMix[JavaObject Term[[StrategoHost]]]
+
+exports
+  context-free start-symbols
+    Module[[StrategoHost]]
\ No newline at end of file

From m.dejonge at tudelft.nl  Thu Aug 25 07:29:58 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 25 Aug 2011 05:29:58 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23240 -
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego
Message-ID: <20110825052958.F1612CC0EA@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug 25 05:29:56 2011
New Revision: 23240
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23240&sc=1

Log:


Deleted:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/stratego/DocumentStructure.java

From m.dejonge at tudelft.nl  Thu Aug 25 15:40:16 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 25 Aug 2011 13:40:16 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23241 - in
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client:
	. imploder
Message-ID: <20110825134016.124607F802A@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug 25 13:40:15 2011
New Revision: 23241
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23241&sc=1

Log:
runtime support for completion rules

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Production.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Reduce.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ReduceLookahead.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Label.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -41,6 +41,10 @@
     public boolean isRecoverProduction() {
         return productionAttributes.isRecoverProduction();
     }
+    
+    public boolean isCompletionProduction() {
+        return productionAttributes.isCompletionProduction();
+    }
 
     public boolean isMoreEager(Label rightProd) {
         return productionAttributes.isMoreEager(rightProd.productionAttributes);

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParseTable.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -272,6 +272,7 @@
         if (attr.getName().equals("attrs")) {
             int type = 0;
             boolean isRecover = false;
+            boolean isCompletion = false;
             IStrategoTerm term = null;
 
             for (IStrategoList ls = (IStrategoList) attr.getSubterm(0); !ls.isEmpty(); ls = ls.tail()) {
@@ -312,8 +313,10 @@
                     			term = t.getSubterm(0).getSubterm(0);
                     		} else if (child.getSubtermCount() == 0 && child.getName().equals("recover")) {
                     		    hasRecovers = isRecover = true;
+                       		} else if (child.getSubtermCount() == 0 && child.getName().equals("completion")) {
+                    		    isCompletion = true;
                     		}
-                    	}
+                        }
                     	// TODO Support other terms that are not a constructor (custom annotations)
                     } else if (ctor.equals("id")) {
                         // FIXME not certain about this
@@ -323,9 +326,9 @@
                     }
                 }
             }
-            return new ProductionAttributes(term, type, isRecover);
+            return new ProductionAttributes(term, type, isRecover, isCompletion);
         } else if (attr.getName().equals("no-attrs")) {
-            return new ProductionAttributes(null, ProductionType.NO_TYPE, false);
+            return new ProductionAttributes(null, ProductionType.NO_TYPE, false, false);
         }
         throw new InvalidParseTableException("Unknown attribute type: " + attr);
     }
@@ -387,7 +390,8 @@
                 int label = intAt(a, 1);
                 int status = intAt(a, 2);
                 boolean isRecoverAction = getLabel(label).getAttributes().isRecoverProduction();
-                item = makeReduce(productionArity, label, status, isRecoverAction);
+                boolean isCompletionAction = getLabel(label).getAttributes().isCompletionProduction();
+                item = makeReduce(productionArity, label, status, isRecoverAction, isCompletionAction);
             } else if(a.getName().equals("reduce") && a.getConstructor().getArity() == 4) {
                 int productionArity = intAt(a, 0);
                 int label = intAt(a, 1);
@@ -452,8 +456,8 @@
         return new ReduceLookahead(productionArity, label, status, charClasses);
     }
 
-    private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction) {
-        Reduce r = new Reduce(arity, label, status, isRecoverAction);
+    private Reduce makeReduce(int arity, int label, int status, boolean isRecoverAction, boolean isCompletionAction) {
+        Reduce r = new Reduce(arity, label, status, isRecoverAction, isCompletionAction);
         Reduce cached = reduceCache.get(r);
         if (cached == null) {
             reduceCache.put(r, r);

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Production.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Production.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Production.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -26,11 +26,14 @@
     
     private final boolean isRecover;
 
-    public Production(int arity, int label, int status, boolean isRecover) {
+    private final boolean isCompletion;
+
+    public Production(int arity, int label, int status, boolean isRecover, boolean isCompletion) {
         this.arity = arity;
         this.label = label;
         this.status = status;
         this.isRecover = isRecover;
+        this.isCompletion = isCompletion;
     }
 
     public AbstractParseNode apply(AbstractParseNode[] kids) {
@@ -55,6 +58,17 @@
         return isRecover;
     }
 
+    public boolean isCompletionProduction() {
+        return isCompletion;
+    }
+
+    /**
+     * -> "@#$"{completion} (added for performance reasons)
+     */
+    public boolean isCompletionStartProduction() {
+        return isCompletion && this.arity == 0; 
+    }
+
     @Override
     public boolean equals(Object obj) {
         if(!(obj instanceof Production))

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ProductionAttributes.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -22,12 +22,15 @@
 
     private final boolean isRecover;
 
+    private final boolean isCompletion;
+
     private final transient IStrategoTerm abstractCtor;
 
-    ProductionAttributes(IStrategoTerm ctor, int type, boolean isRecover) {
+    ProductionAttributes(IStrategoTerm ctor, int type, boolean isRecover, boolean isCompletion) {
         this.type = type;
         this.abstractCtor = ctor;
         this.isRecover = isRecover;
+        this.isCompletion = isCompletion;
     }
 
     public final int getType() {
@@ -42,6 +45,10 @@
         return isRecover;
     }
 
+    public boolean isCompletionProduction() {
+        return isCompletion;
+    }
+
     public boolean isMoreEager(ProductionAttributes other) {
         return type != other.type && (type == PREFER || other.type == AVOID);
     }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Reduce.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Reduce.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/Reduce.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -21,7 +21,7 @@
 
     public final Production production;
 
-    public Reduce(int arity, int label, int status, boolean isRecoverAction) {
+    public Reduce(int arity, int label, int status, boolean isRecoverAction, boolean isCompletionAction) {
 
         super(REDUCE);
 
@@ -29,7 +29,7 @@
         this.label = label;
         this.status = status;
 
-        production = new Production(arity, label, status, isRecoverAction);
+        production = new Production(arity, label, status, isRecoverAction, isCompletionAction);
     }
 
 

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ReduceLookahead.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ReduceLookahead.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ReduceLookahead.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -30,7 +30,7 @@
         this.status = status;
         this.charRanges = charClasses;
 
-        production = new Production(arity, label, status, false);
+        production = new Production(arity, label, status, false, false);
     }
 
     @Override

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -23,7 +23,9 @@
 
 public class SGLR {
 
-    private RecoveryPerformance performanceMeasuring;
+    private static final int COMPLETION_REGION_SIZE = 1000;
+
+	private RecoveryPerformance performanceMeasuring;
 
 	private final Set<BadTokenException> collectedErrors = new LinkedHashSet<BadTokenException>();
 
@@ -103,6 +105,14 @@
 
 	private boolean fineGrainedOnRegion;
 
+	private int cursorLocation;
+
+	private boolean isCompletionMode;
+	
+	private void setCompletionParse(boolean isCompletionMode, int cursorLocation){
+		this.isCompletionMode = isCompletionMode;
+		this.cursorLocation = cursorLocation;
+	}
 
 	protected ArrayDeque<Frame> getRecoverStacks() {
 		return recoverStacks;
@@ -252,6 +262,23 @@
 	/**
 	 * Parses a string and constructs a new tree using the tree builder.
 	 * 
+	 * @param input           The input string.
+	 * @param filename        The source filename of the string, or null if not available.
+	 * @param startSymbol     The start symbol to use, or null if any applicable.
+	 * @param completionMode  True in case the parser result is used for content completion.
+	 * @param cursorLocation  The location of the cursor used to find completion recoveries.
+	 */
+    public Object parse(String input, String filename, String startSymbol, boolean completionMode, int cursorLocation) 
+    	throws BadTokenException, TokenExpectedException, ParseException, SGLRException {
+    	setCompletionParse(completionMode, cursorLocation);
+    	Object parseResult = parse(input, filename, startSymbol);
+    	setCompletionParse(false, Integer.MAX_VALUE);
+    	return parseResult;
+    }
+
+    /**
+	 * Parses a string and constructs a new tree using the tree builder.
+	 * 
 	 * @param input        The input string.
 	 * @param filename     The source filename of the string, or null if not available.
 	 * @param startSymbol  The start symbol to use, or null if any applicable.
@@ -273,7 +300,6 @@
 		try {
 			do {
 				readNextToken();
-				//System.out.print((char)currentToken);
 				history.keepTokenAndState(this);
 				doParseStep();
 			} while (getCurrentToken() != SGLR.EOF && activeStacks.size() > 0);
@@ -591,7 +617,16 @@
 	}
 
 	private boolean recoverModeOk(Frame st, Production prod) {
-		return !prod.isRecoverProduction() || fineGrainedOnRegion;
+		if(!prod.isCompletionProduction()){
+			return !prod.isRecoverProduction() || fineGrainedOnRegion;
+		}
+		return inCompletionMode(prod);
+	}
+
+	private boolean inCompletionMode(Production prod) {
+		if(!prod.isCompletionStartProduction()) //Performance trick: -> "@#$" {completion} starts the completion
+			return isCompletionMode && cursorLocation <= this.tokensSeen && this.tokensSeen <= cursorLocation + COMPLETION_REGION_SIZE;
+		return isCompletionMode && cursorLocation - COMPLETION_REGION_SIZE <= this.tokensSeen && this.tokensSeen <= cursorLocation;
 	}
 
 	private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
@@ -616,10 +651,12 @@
 			final Frame st0 = path.getEnd();
 			final State next = parseTable.go(st0.state, prod.label);
 			logReductionPath(prod, path, st0, next);
-			if(!prod.isRecoverProduction())
-				reducer(st0, next, prod, kids, path);
-			else
-				reducerRecoverProduction(st0, next, prod, kids, path);				
+			if(!prod.isCompletionProduction() || isReductionOverCursorLocation(path)){
+				if(!prod.isRecoverProduction())
+					reducer(st0, next, prod, kids, path);
+				else
+					reducerRecoverProduction(st0, next, prod, kids, path);
+			}
 		}
 
 		if (asyncAborted) {
@@ -628,6 +665,10 @@
 		}
 	}
 
+	private boolean isReductionOverCursorLocation(final Path path) {
+		return tokensSeen - path.getLength() < cursorLocation;
+	}
+
 	
 	private void reducer(Frame st0, State s, Production prod, AbstractParseNode[] kids, Path path) {
 		assert(!prod.isRecoverProduction());
@@ -786,9 +827,9 @@
 
 	private int calcRecoverCount(Production prod, Path path) {
 		int result = path.getRecoverCount();
-		if (prod.isRecoverProduction()){
+		if (prod.isRecoverProduction() || prod.isCompletionProduction()){
 			result += 1;
-			if (path.getLength() > 0)
+			if (path.getLength() > 0 && !prod.isCompletionProduction())
 				result += 1; //Hack: insertion rules (length 0) should be preferred above water rules.
 		}
 		return result;

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -64,7 +64,7 @@
 	}
 
 	public void markPossibleSyntaxError(LabelInfo label, IToken prevToken, int endOffset, ProductionAttributeReader prodReader) {
-		if (label.isRecover() || label.isReject() || label.getDeprecationMessage() != null) {
+		if (label.isRecover() || label.isReject() || label.getDeprecationMessage() != null || label.isCompletion()) {
 			if (prodReader.isIgnoredUnspecifiedRecoverySort(label.getSort())) {
 				// Special case: don't report here, but further up the tree
 				return;
@@ -94,7 +94,16 @@
 			if (tokenText.length() > 40)
 				tokenText = tokenText.substring(0, 40) + "...";
 			
-			if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
+			if (label.isCompletion()) {
+				if(last.getKind() == IToken.TK_LAYOUT){
+					last = findLeftMostLayoutToken(last);
+					if (last.getKind() == TK_LAYOUT)
+						last = getTokenBefore(last);
+				}
+				String completionText = toString(first, last);
+				setErrorMessage(first, last, "Syntax error, incomplete construct"
+						+ ": '" + completionText + "'");
+			} else if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
 				setErrorMessage(first, last, ERROR_WATER_PREFIX
 						+ ": '" + tokenText + "'");
 			} else if (prodReader.isInsertEndConstructor(label.getConstructor())) {

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -42,7 +42,9 @@
 	private final boolean isOptional;
 	
 	private final boolean isRecover;
-	
+
+	private final boolean isCompletion;
+
 	private final boolean isReject;
 	
 	private final String metaVarConstructor;
@@ -64,6 +66,7 @@
 		isLiteral = reader.isLiteral(rhs);
 		isOptional = reader.isOptional(rhs);
 		isRecover = reader.isRecoverProduction(attrs, constructor);
+		isCompletion = reader.isCompletionProduction(attrs, production.getSubtermCount());
 		isReject = reader.isRejectProduction(attrs);
 		deprecationMessage = reader.getDeprecationMessage(attrs);
 		isSortProduction = reader.sortFun == rhs.getConstructor() || reader.parameterizedSortFun == rhs.getConstructor();
@@ -129,7 +132,11 @@
 	public boolean isRecover() {
 		return isRecover;
 	}
-	
+
+	public boolean isCompletion() {
+		return isCompletion;
+	}
+
 	public boolean isReject() {
 		return isReject;
 	}

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Thu Aug 25 05:29:56 2011	(r23240)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ProductionAttributeReader.java	Thu Aug 25 13:40:15 2011	(r23241)
@@ -148,7 +148,11 @@
 	public boolean isRecoverProduction(IStrategoAppl attrs, String constructor) {
 		return getAttribute(attrs, "recover") != null || isWaterConstructor(constructor);
 	}
-	
+
+	public boolean isCompletionProduction(IStrategoAppl attrs, int subtermCount) {
+		return getAttribute(attrs, "completion") != null && subtermCount > 0;
+	}
+
 	public boolean isRejectProduction(IStrategoAppl attrs) {
 		return getAttribute(attrs, "reject") != null;
 	}

From m.dejonge at tudelft.nl  Thu Aug 25 15:40:23 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Thu, 25 Aug 2011 13:40:23 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23242 - in
	spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime:
	parser services
Message-ID: <20110825134023.7B8A4108C035@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Thu Aug 25 13:40:20 2011
New Revision: 23242
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23242&sc=1

Log:
runtime support for completion rules

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java
   spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java	Thu Aug 25 13:40:15 2011	(r23241)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/parser/JSGLRI.java	Thu Aug 25 13:40:20 2011	(r23242)
@@ -44,14 +44,21 @@
 	
 	private int timeout;
 	
+	private int cursorLocation;
+	
 	// Initialization and parsing
 	
+	public void setCursorLocation(int cursorLocation) {
+		this.cursorLocation = cursorLocation;
+	}
+
 	public JSGLRI(ParseTableProvider parseTable, String startSymbol,
 			SGLRParseController controller) {
 		super(parseTable, startSymbol, controller);
 		
 		this.parseTable = parseTable;
 		this.parser = Environment.createSGLR(getParseTable());
+		this.cursorLocation = Integer.MAX_VALUE;
 		resetState();
 	}
 	
@@ -160,7 +167,11 @@
 			Debug.startTimer();
 			IStrategoTerm result;
 			try {
-				result = (IStrategoTerm) parser.parse(input, filename, getStartSymbol());
+				//TODO: completionMode true or false depends on whether this method is called via CompletionParser
+				// true means all completion productions are enabled
+				// false means that only wellformed productions are enabled
+				// Idee: mark wellformed productions as {completion, recover} and treat them as completion
+				result = (IStrategoTerm) parser.parse(input, filename, getStartSymbol(), true, cursorLocation);
 			} finally {
 				Debug.stopTimer("File parsed: " + new File(filename).getName());
 			}

Modified: spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java	Thu Aug 25 13:40:15 2011	(r23241)
+++ spoofax-imp/trunk/org.strategoxt.imp.runtime/src/org/strategoxt/imp/runtime/services/AutoEditStrategy.java	Thu Aug 25 13:40:20 2011	(r23242)
@@ -44,6 +44,7 @@
 import org.spoofax.jsglr.client.imploder.ITokenizer;
 import org.strategoxt.imp.runtime.EditorState;
 import org.strategoxt.imp.runtime.Environment;
+import org.strategoxt.imp.runtime.parser.SGLRParseController;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -116,7 +117,9 @@
 	public void verifyKey(VerifyEvent event) {
 		try {
 			String input = new String(new char[] { event.character });
-			Point selection = getEditor().getSelection();
+			Point selection = getEditor().getSelection(); 
+			if(controller instanceof SGLRParseController)
+				((SGLRParseController)controller).getParser().setCursorLocation(selection.x);
 			ISourceViewer viewer = getEditor().getServiceControllerManager().getSourceViewer();
 			if (event.widget instanceof StyledText
 					&& indentAfterNewline(viewer, viewer.getDocument(), selection.x, selection.y, input)) {

From m.dejonge at tudelft.nl  Fri Aug 26 09:21:56 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Fri, 26 Aug 2011 07:21:56 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23243 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder
Message-ID: <20110826072156.A9591CC0BE@mx4.tudelft.nl>

Author: MaartjeDeJonge
Date: Fri Aug 26 07:21:54 2011
New Revision: 23243
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23243&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITokenizer.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	Thu Aug 25 13:40:20 2011	(r23242)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	Fri Aug 26 07:21:54 2011	(r23243)
@@ -101,7 +101,7 @@
 						last = getTokenBefore(last);
 				}
 				String completionText = toString(first, last);
-				setErrorMessage(first, last, "Syntax error, incomplete construct"
+				setErrorMessage(first, last, ERROR_INCOMPLETE_PREFIX
 						+ ": '" + completionText + "'");
 			} else if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
 				setErrorMessage(first, last, ERROR_WATER_PREFIX

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITokenizer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Thu Aug 25 13:40:20 2011	(r23242)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/ITokenizer.java	Fri Aug 26 07:21:54 2011	(r23243)
@@ -22,13 +22,17 @@
 	
 	public static final String ERROR_INSERT_END_PREFIX =
 		"Syntax error, unterminated construct";
-	
+
+	public static final String ERROR_INCOMPLETE_PREFIX =
+		"Syntax error, incomplete construct";
+
 	public static final String ERROR_GENERIC_PREFIX =
 		"Syntax error";
 
 	public static final String ERROR_WARNING_PREFIX =
 		"Warning";
 
+
 	String getInput();
 
 	int getStartOffset();

From m.dejonge at tudelft.nl  Sun Aug 28 08:27:25 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 28 Aug 2011 06:27:25 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23244 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110828062725.091157F8028@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug 28 06:27:24 2011
New Revision: 23244
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23244&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Fri Aug 26 07:21:54 2011	(r23243)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Sun Aug 28 06:27:24 2011	(r23244)
@@ -141,6 +141,8 @@
 
     private boolean tryBridgeRepair(String errorFragment) {
         String repairedFragment = repairBridges(errorFragment);
+        if(repairedFragment.trim().equals(errorFragment.trim()))
+        	return false;
         mySGLR.activeStacks.addAll(skipRecovery.getStartLineErrorFragment().getStackNodes());   
         tryParsing(repairedFragment, false);      
         return parseRemainingTokens(true);

From m.dejonge at tudelft.nl  Sun Aug 28 10:36:53 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 28 Aug 2011 08:36:53 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23245 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder
Message-ID: <20110828083653.217CE108C00A@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug 28 08:36:49 2011
New Revision: 23245
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23245&sc=1

Log:
- Ignore artificial start completion prods
- show INSERT markers at the end of the previous token (instead of at the start of the next token after layout)
- mark completed production

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	Sun Aug 28 06:27:24 2011	(r23244)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/AbstractTokenizer.java	Sun Aug 28 08:36:49 2011	(r23245)
@@ -74,25 +74,27 @@
 				isSyntaxCorrect = label.getDeprecationMessage() != null;
 			
 			// TODO: make TK_ERROR_LAYOUT token from preceding first whitespaces?
-			
+			//TODO: refactor
 			IToken first, last;
 			
 			if (prevToken == currentToken()) {
 				first = last = makeToken(endOffset, TK_ERROR, true);
 			} else {
-				first = findRightMostLayoutToken(getTokenAfter(prevToken));
+				first = getTokenAfter(prevToken);
+				if (first != currentToken() && first.getKind() == TK_LAYOUT)
+					first = findRightMostLayoutToken(first);
 				if (first != currentToken() && first.getKind() == TK_LAYOUT)
 					first = getTokenAfter(first);
 				last = currentToken();
 			}
-			if (first.getStartOffset() + 1 == last.getEndOffset()) {
+			if (first.getStartOffset() - 1 == last.getEndOffset()) {
 				// bah, we need some characters to mark, to the left then...
-				first = findLeftMostLayoutToken(first);
+				first = last = findLeftMostLayoutToken(first);//mark insertion errors at the end of previous token (before layout)
+				if (first.getKind() == TK_LAYOUT)
+					first = last = getTokenBefore(last);
 			}
 			
-			String tokenText = toString(first, last);
-			if (tokenText.length() > 40)
-				tokenText = tokenText.substring(0, 40) + "...";
+			String tokenText = makeTokenText(first, last);
 			
 			if (label.isCompletion()) {
 				if(last.getKind() == IToken.TK_LAYOUT){
@@ -100,7 +102,7 @@
 					if (last.getKind() == TK_LAYOUT)
 						last = getTokenBefore(last);
 				}
-				String completionText = toString(first, last);
+				String completionText = makeTokenText(first, last);
 				setErrorMessage(first, last, ERROR_INCOMPLETE_PREFIX
 						+ ": '" + completionText + "'");
 			} else if (label.isReject() || prodReader.isWaterConstructor(label.getConstructor())) {
@@ -124,6 +126,13 @@
 		}
 	}
 
+	private String makeTokenText(IToken first, IToken last) {
+		String tokenText = toString(first, last);
+		if (tokenText.length() > 40)
+			tokenText = tokenText.substring(0, 40) + "...";
+		return tokenText;
+	}
+
 	/**
 	 * Sets a syntax error for the specified token range.
 	 * (Setting any other kind of error would break cacheability.)

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Sun Aug 28 06:27:24 2011	(r23244)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/LabelInfo.java	Sun Aug 28 08:36:49 2011	(r23245)
@@ -134,7 +134,7 @@
 	}
 
 	public boolean isCompletion() {
-		return isCompletion;
+		return isCompletion && !isLiteral; //exclude artificial completion start: -> "@#$"{completion}
 	}
 
 	public boolean isReject() {

From m.dejonge at tudelft.nl  Sun Aug 28 11:13:27 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 28 Aug 2011 09:13:27 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23246 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110828091327.D7E9A7F8010@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug 28 09:13:24 2011
New Revision: 23246
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23246&sc=1

Log:
improvement: completion rules work also in recovery mode (tokensseen info comes from ParserHistory)

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java	Sun Aug 28 08:36:49 2011	(r23245)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/ParserHistory.java	Sun Aug 28 09:13:24 2011	(r23246)
@@ -94,6 +94,7 @@
         indentHandler.updateIndentation(myParser.getCurrentToken());
         recoverTokenCount++;
         tokenIndex++;
+        assert myParser.tokensSeen == this.getTokenIndex(): "inconsistentcy in token index";
         if(indentHandler.lineMarginEnded() || myParser.getCurrentToken()==SGLR.EOF || tokenIndex == 1)
             keepNewLinePoint(myParser, myParser.tokensSeen-1, false, indentHandler);
     }

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Sun Aug 28 08:36:49 2011	(r23245)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/SGLR.java	Sun Aug 28 09:13:24 2011	(r23246)
@@ -102,6 +102,10 @@
 	public ParserHistory getHistory() {
 		return history;
 	}
+	
+	public int getParserLocation(){
+		return this.getHistory().getTokenIndex(); //should also work in recover mode
+	}
 
 	private boolean fineGrainedOnRegion;
 
@@ -625,8 +629,8 @@
 
 	private boolean inCompletionMode(Production prod) {
 		if(!prod.isCompletionStartProduction()) //Performance trick: -> "@#$" {completion} starts the completion
-			return isCompletionMode && cursorLocation <= this.tokensSeen && this.tokensSeen <= cursorLocation + COMPLETION_REGION_SIZE;
-		return isCompletionMode && cursorLocation - COMPLETION_REGION_SIZE <= this.tokensSeen && this.tokensSeen <= cursorLocation;
+			return isCompletionMode && cursorLocation <= getParserLocation() && getParserLocation() <= cursorLocation + COMPLETION_REGION_SIZE;
+		return isCompletionMode && cursorLocation - COMPLETION_REGION_SIZE <= getParserLocation() && getParserLocation() <= cursorLocation;
 	}
 
 	private void doLimitedReductions(Frame st, Production prod, Link l) { //Todo: Look add sharing code with doReductions
@@ -666,7 +670,7 @@
 	}
 
 	private boolean isReductionOverCursorLocation(final Path path) {
-		return tokensSeen - path.getLength() < cursorLocation;
+		return getParserLocation() - path.getLength() < cursorLocation;
 	}
 
 	

From m.dejonge at tudelft.nl  Sun Aug 28 11:40:18 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 28 Aug 2011 09:40:18 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23247 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/trans
Message-ID: <20110828094018.6034A108C00A@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug 28 09:40:16 2011
New Revision: 23247
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23247&sc=1

Log:
added: TODO

Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/trans/sdf.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/trans/sdf.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/trans/sdf.str	Sun Aug 28 09:13:24 2011	(r23246)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.sdf/trans/sdf.str	Sun Aug 28 09:40:16 2011	(r23247)
@@ -100,11 +100,13 @@
   context-free-syntax-warning:
     alt(x, y) -> (<id>, $[The | construct is deprecated: instead of A|B->C use A->C B->C])
 
+  // TODO: don't warn for ? in {ast("...")} productions
   context-free-syntax-warning:
     opt(s @ seq(_, _)) -> (s, $[Extract sequence in optional to separate productions to ensure acceptable abstract syntax])
     where
       <occurrences(is-non-terminal)> s => 1
 
+  // TODO: don't warn for ? in {ast("...")} productions
   context-free-syntax-warning:
     opt(lit) -> (lit, $[Extract literal in optional to separate productions to ensure consistent abstract syntax])
     where

From m.dejonge at tudelft.nl  Sun Aug 28 11:58:46 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Sun, 28 Aug 2011 09:58:46 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23248 -
	sglr-recovery/completion-rules
Message-ID: <20110828095846.EC1087F8030@mx1.tudelft.nl>

Author: MaartjeDeJonge
Date: Sun Aug 28 09:58:45 2011
New Revision: 23248
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23248&sc=1

Log:
cons => ast attribute, also for literals only productions.

Modified:
   sglr-recovery/completion-rules/generate-completion-rules.str

Modified: sglr-recovery/completion-rules/generate-completion-rules.str
==============================================================================
--- sglr-recovery/completion-rules/generate-completion-rules.str	Sun Aug 28 09:40:16 2011	(r23247)
+++ sglr-recovery/completion-rules/generate-completion-rules.str	Sun Aug 28 09:58:45 2011	(r23248)
@@ -3,7 +3,7 @@
 imports
   SDF
   libstratego-sdf
-  SDF-parenthesize
+  include/SDF-parenthesize
   sdf-desugar
 
 
@@ -60,15 +60,15 @@
 	(lhs-prefix, lhs-suffix, rhs, attr) -> prod(<add-optional-lexicals(|lhs-suffix)> lhs-prefix, rhs, attr-completion)
 	where
 		suffix-sorts := <filter(is-sort-term)> lhs-suffix;
-		if <not(?[])> suffix-sorts then
+		//if <not(?[])> suffix-sorts then
 			constructor := <get-constructor-name> attr; 
 			prefix-sorts-count := <filter(is-sort-term); length> lhs-prefix;
 			suffix-placeholders := <map(lookup-placeholder)> suffix-sorts; 
 			ast-string := <make-ast-string>(constructor, prefix-sorts-count, suffix-placeholders); 
-			attr-completion := <replace-cons-with-ast(|ast-string); add-completion-attr> attr
-		else
-			attr-completion:= <add-completion-attr> attr
-		end
+			attr-completion := <replace-cons-with-ast(|ast-string); add-completion-attr; remove-bracket-left-right-attributes> attr
+		//else
+			//attr-completion:= <add-completion-attr; remove-bracket-left-right-attributes> attr
+		//end
 
 add-optional-lexicals(|lhs-suffix):
 	lhs-prefix -> <conc>(lhs-prefix, optional-lexicals)
@@ -80,7 +80,7 @@
 		end
 
 to-opt-lit = 
-	to-opt-lit-opt <+
+	to-opt-lit-opt <+ 
 	to-opt-lit-iter <+
 	to-opt-lit-lit
 
@@ -223,12 +223,12 @@
 lookup-placeholder:
 	iter-sep(srt, _) -> [<lookup-placeholder> srt]
 
-get-lexical-default-placeholder = !"MISSING_LEXICAL"
+get-lexical-default-placeholder = !"MISSING_TOKEN"
 
-get-cf-default-placeholder = !MISSING()
+get-cf-default-placeholder = !NULL()
 
 signature constructors
-	MISSING : Missing
+	NULL : Missing
 
 
 rules //helpers
@@ -258,15 +258,31 @@
 
 get-cf-productions =
 	collect-all(?context-free-syntax(<id>));
-	flatten-list
+	flatten-list;
+	filter(not(is-ignore-production))
 
 get-lexical-productions =
 	collect-all(?lexical-syntax(<id>));
-	flatten-list
+	flatten-list;
+	filter(not(is-ignore-production))
+	
+is-ignore-production:
+	p at prod(_, _, attr) -> p
+	where
+		oncetd(
+			?fun(unquoted("recover")) <+
+			?fun(unquoted("completion"))
+		) 
 
 add-completion-attr:
 	 attrs(lst) -> attrs([term(default(fun(unquoted("completion"))))|lst])
 
+remove-bracket-left-right-attributes:
+	attrs(lst) -> attrs(<filter(not(is-bracket-left-right-attr))>lst)
+
+is-bracket-left-right-attr =
+	?bracket() <+ ?assoc(left()) <+ ?assoc(right())
+
 replace-cons-with-ast(|ast-string) = 
 	oncetd(replace-cons-attr-with-ast-attr(|ast-string))
 
@@ -278,6 +294,7 @@
 	parenthesize-SDFX; 
 	pp-sdf-string
 
+
 equal-productions:
 	prod-pair@(prod(lhs, rhs, _), prod(lhs, rhs, _)) -> prod-pair
 

From M.A.Akhter at student.tudelft.nl  Sun Aug 28 12:12:30 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 28 Aug 2011 10:12:30 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23249 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src:
	jdbm jdbm/btree jdbm/helper jdbm/test
	org/spoofax/interpreter/library/language org/spoofax/i...
Message-ID: <20110828101230.6098BCC04E@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 28 10:12:29 2011
New Revision: 23249
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23249&sc=1

Log:
index infrastructure for spxlang ( inprogress)

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/TestInverseHashMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/BaseScope.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/GlobalScope.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ModuleScope.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentStoreTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/PackageScope.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_init.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/Scope.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexEntry.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexEntryFactory.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSecondarySortedMap.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/SecondaryKeyHelper.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/SemanticIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerFactory.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -53,7 +53,7 @@
 	 *             if some options are invalid.
 	 */
 	public static RecordManager createRecordManager(String name)
-			throws IOException {
+	throws IOException {
 		return createRecordManager(name, new Properties());
 	}
 
@@ -75,57 +75,60 @@
 	@SuppressWarnings("unchecked")
 	public static RecordManager createRecordManager(String name,
 			Properties options) throws IOException {
-			
-			RecordManager recman = new BaseRecordManager( name , RecordManagerOptions.INDEX_DIRECTORY_RELATIVE_PATH);
-            
-            String value = options.getProperty( RecordManagerOptions.DISABLE_TRANSACTIONS, "false" );
-            if ( value.equalsIgnoreCase( "TRUE" ) ) {
-                ( (BaseRecordManager) recman ).disableTransactions();
-            }
-
-            value = options.getProperty(RecordManagerOptions.COMPRESS,"false");
-            boolean compress = value.equalsIgnoreCase("TRUE");
-            if(compress)
-                    ( (BaseRecordManager) recman ).setCompress(true);
-
-            value = options.getProperty(RecordManagerOptions.APPEND_TO_END,"true");
-            boolean append = value.equalsIgnoreCase("TRUE");
-            if(append)
-                    ( (BaseRecordManager) recman ).setAppendToEnd(true);
-
-
-            String cacheType = options.getProperty( RecordManagerOptions.CACHE_TYPE, "auto" );
-
-            value = options.getProperty( RecordManagerOptions.CACHE_SIZE, "1000" );
-            int cacheSize = Integer.parseInt( value );
-
-            if("auto".equals(cacheType)){
-                    try{
-                            //disable SOFT if available memory is bellow 50 MB
-                            if(Runtime.getRuntime().maxMemory()<=50000000)
-                                    cacheType = "mru";
-                            else
-                                    cacheType = "soft";
-                    }catch(Exception e){
-                            cacheType = "mru";
-                    }
-            }
-
-            if ("mru".equals(cacheType)) {
-                    if(cacheSize>0){
-                            recman = new CacheRecordManager( recman,cacheSize,false);
-                    }
-            }else if ("soft".equals(cacheType)) {
-                    // cachesize is the size of the internal MRU, not the soft cache
-                    recman = new CacheRecordManager(recman, cacheSize,true);
-
-            }else if ("none".equals(cacheType)) {
-                    //do nothing
-            }else{
-                    throw new IllegalArgumentException("Unknown cache type: "+cacheType);
-            }
 
-            return recman;
+
+		String relPath = options.getProperty( RecordManagerOptions.INDEX_RELATIVE_PATH_OPTION, RecordManagerOptions.INDEX_DIRECTORY_RELATIVE_PATH);
+		
+		RecordManager recman = new BaseRecordManager( name , relPath);
+
+		String value = options.getProperty( RecordManagerOptions.DISABLE_TRANSACTIONS, "false" );
+		if ( value.equalsIgnoreCase( "TRUE" ) ) {
+			( (BaseRecordManager) recman ).disableTransactions();
+		}
+
+		value = options.getProperty(RecordManagerOptions.COMPRESS,"false");
+		boolean compress = value.equalsIgnoreCase("TRUE");
+		if(compress)
+			( (BaseRecordManager) recman ).setCompress(true);
+
+		value = options.getProperty(RecordManagerOptions.APPEND_TO_END,"true");
+		boolean append = value.equalsIgnoreCase("TRUE");
+		if(append)
+			( (BaseRecordManager) recman ).setAppendToEnd(true);
+
+
+		String cacheType = options.getProperty( RecordManagerOptions.CACHE_TYPE, "auto" );
+
+		value = options.getProperty( RecordManagerOptions.CACHE_SIZE, "1000" );
+		int cacheSize = Integer.parseInt( value );
+
+		if("auto".equals(cacheType)){
+			try{
+				//disable SOFT if available memory is bellow 50 MB
+				if(Runtime.getRuntime().maxMemory()<=50000000)
+					cacheType = "mru";
+				else
+					cacheType = "soft";
+			}catch(Exception e){
+				cacheType = "mru";
+			}
+		}
+
+		if ("mru".equals(cacheType)) {
+			if(cacheSize>0){
+				recman = new CacheRecordManager( recman,cacheSize,false);
+			}
+		}else if ("soft".equals(cacheType)) {
+			// cachesize is the size of the internal MRU, not the soft cache
+			recman = new CacheRecordManager(recman, cacheSize,true);
+
+		}else if ("none".equals(cacheType)) {
+			//do nothing
+		}else{
+			throw new IllegalArgumentException("Unknown cache type: "+cacheType);
+		}
+
+		return recman;
 
 	}
 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/RecordManagerOptions.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -91,5 +91,12 @@
      */
 	public static final String COMPRESS = "jdbm.compress";
 
-	public static final String INDEX_DIRECTORY_RELATIVE_PATH = ".index";
+	
+
+	
+	public static final String INDEX_RELATIVE_PATH_OPTION = "jdbm.index.relativepath" ;
+	
+	
+	// TODO : make this similar to the above implementation.
+	public static String INDEX_DIRECTORY_RELATIVE_PATH = ".index";
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSecondarySortedMap.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSecondarySortedMap.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/btree/BTreeSecondarySortedMap.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -26,6 +26,7 @@
 	implements SecondaryTreeMap<A,K,V>{
 
 	protected final JdbmBase<K,V > b;
+	
 	public BTreeSecondarySortedMap(BTree<A, Iterable<K>> tree, JdbmBase<K,V> b) {
 		super(tree, true);
 		this.b = b;

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/SecondaryKeyHelper.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/SecondaryKeyHelper.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/helper/SecondaryKeyHelper.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -109,7 +109,8 @@
     }
 
     static public <A,K,V> HTree<A,Iterable<K>>  secondaryHTree(String objectName, 
-    		final SecondaryKeyExtractor<A,K,V> keyExtractor, JdbmBase<K,V> b,Serializer<A> secondaryKeySerializer)
+    		final SecondaryKeyExtractor<A,K,V> keyExtractor, 
+    		JdbmBase<K,V> b,Serializer<A> secondaryKeySerializer)
     		throws IOException{
     	HTree<A,Iterable<K>> secIndex = null;
         long recid = b.getRecordManager().getNamedObject( objectName );

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/HelloWorld.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -25,7 +25,7 @@
 		{
 			LinkedList<String> l = new LinkedList<String>();
 			l.add(value);
-			
+		
 			hashmap.put(key, l);
 		}
 	}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/TestInverseHashMap.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/jdbm/test/TestInverseHashMap.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,39 @@
+package jdbm.test;
+
+import java.io.IOException;
+
+import jdbm.InverseHashView;
+import jdbm.PrimaryHashMap;
+import jdbm.RecordManager;
+import jdbm.RecordManagerFactory;
+
+public class TestInverseHashMap {
+
+	
+	public static void main(String args[]) throws IOException
+	{
+		String managerName = "testmanager";
+		RecordManager manager  = RecordManagerFactory.createRecordManager( managerName);
+		PrimaryHashMap<String , String> primaryMap =  manager.hashMap("test");
+
+		InverseHashView<String, String> primaryMapInverse = primaryMap.inverseHashView ( "testInverse");
+		
+		String test = "testString" ;
+		
+		primaryMap.put("1", test);
+		primaryMap.put("2", test);
+		primaryMap.put("4", test);
+		
+		manager.commit();
+		manager.close();
+		
+		
+		RecordManager manager2  = RecordManagerFactory.createRecordManager( managerName);
+		PrimaryHashMap<String , String> primaryMap2 =  manager2.hashMap("test");
+
+		
+		System.out.println(primaryMap2.keySet());
+		
+		
+	}
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -1,6 +1,9 @@
 package org.spoofax.interpreter.library.language;
 
 import org.spoofax.interpreter.library.AbstractStrategoOperatorRegistry;
+import org.spoofax.interpreter.library.language.spxlang.SPX_index_init;
+import org.spoofax.interpreter.library.language.spxlang.SPX_index_save;
+import org.spoofax.interpreter.library.language.spxlang.SpxSemanticIndex;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -22,6 +25,11 @@
 		add(new LANG_index_is_indexed_file(index));
 		add(new LANG_index_setup(index));
 		add(new LANG_get_all_projects_in_Workspace());
+		
+		SpxSemanticIndex spxIndex= new SpxSemanticIndex();
+		
+		add(new SPX_index_init(spxIndex));
+		add(new SPX_index_save(spxIndex));
 	}
 
 	public String getOperatorRegistryName() {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/SemanticIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/SemanticIndex.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/SemanticIndex.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -1,6 +1,7 @@
 package org.spoofax.interpreter.library.language;
 
 import java.io.File;
+import java.io.Writer;
 import java.net.URI;
 import java.util.Collections;
 import java.util.HashMap;
@@ -298,4 +299,6 @@
 	public String toString() {
 		return table.keySet().toString();
 	}
+	
+
 }

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/BaseScope.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/BaseScope.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,84 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+
+import java.net.URI;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * BaseScope  is an abstract base class that implements Scope Interface
+ * 
+ * @author Md. Adil Akhter
+ * Created On : Aug 27, 2011
+ */
+abstract class BaseScope implements Scope {
+	
+	private IStrategoTerm _id;
+		
+	private final ITermFactory _termFactory;
+		
+	public BaseScope(IStrategoTerm id, ITermFactory termFactory) {
+		
+		_termFactory = termFactory;
+		
+		setScopeId(id);
+	}
+	
+	protected ITermFactory getTermFactory() {
+		return _termFactory;
+	}
+	
+	public IStrategoTerm getScopeId() {
+		return _id;
+	}
+
+	private void setScopeId(IStrategoTerm _id) {
+		this._id = _id;
+	}
+	
+	public abstract IStrategoTerm getType(); 
+	
+	
+	/* 
+	 * Returns the enclosing scope of the current scope.
+	 * */
+	public Scope getEnclosingScope() {
+		return null;
+	}
+	
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((_id == null) ? 0 : _id.hashCode());
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		BaseScope other = (BaseScope) obj;
+		if (_id == null) {
+			if (other._id != null)
+				return false;
+		} else if (!_id.match(other._id))
+			return false;
+		return true;
+	}
+
+	/* Gets the URI of the current scope. Returns Null is scope is not associated with 
+	 * any URI.
+	 * 
+	 * @see org.spoofax.interpreter.library.language.spxlang.Scope#getScopeURI()
+	 */
+	public URI getScopeURI() {
+		
+		return null;
+	} 
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/GlobalScope.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/GlobalScope.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,24 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+class GlobalScope extends BaseScope {
+	
+	private final String _scopeType = "Global" ;
+	
+	public GlobalScope(IStrategoTerm id , ITermFactory factory) {
+		
+		super(id , factory);
+	}
+	
+	/**
+	 * Returns the type of the current Scope 
+	 */
+	public IStrategoTerm getType() {
+		
+		return getTermFactory().makeConstructor(_scopeType, 0);
+	}
+	
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ModuleScope.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ModuleScope.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,105 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.net.URI;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 21, 2011
+ */
+
+class ModuleScope extends BaseScope
+{
+	private Scope _enclosingScope;
+	
+	private final String _scopeType = "Module" ;
+	
+	private URI _file; 
+	
+	/**
+	 * Instantiates ModuleScope 
+	 * @param id refers to the ID of the Scope
+	 * @param enclosingScope refers to the enclosing scope. It
+	 * provides a reference to the container of the current Scope.  
+	 */
+	public ModuleScope(IStrategoTerm id, Scope enclosingScope , ITermFactory factory , URI file) {
+		super(id,factory);
+
+		this._enclosingScope = enclosingScope;
+		this._file = file;
+	}
+	
+	public Scope getEnclosingScope() {
+		return _enclosingScope;
+	}
+	
+	/**
+	 * Returns the type of the Scope 
+	 */
+	public IStrategoTerm getType() {
+		return getTermFactory().makeConstructor(_scopeType, 0);
+	}
+	
+	/* 
+	 * (non-Javadoc)
+	 * @see java.lang.Object#equals(java.lang.Object)
+	 */
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (!super.equals(obj))
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		
+		ModuleScope other = (ModuleScope) obj;
+		if (_enclosingScope == null) {
+			if (other._enclosingScope != null)
+				return false;
+		} else if (!_enclosingScope.equals(other._enclosingScope))
+			return false;
+		if (_file == null) {
+			if (other._file != null)
+				return false;
+		} else if (!_file.equals(other._file))
+			return false;
+		if (_scopeType == null) {
+			if (other._scopeType != null)
+				return false;
+		} else if (!_scopeType.equals(other._scopeType))
+			return false;
+		return true;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#hashCode()
+	 */
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = super.hashCode();
+		result = prime * result
+				+ ((_enclosingScope == null) ? 0 : _enclosingScope.hashCode());
+		result = prime * result + ((_file == null) ? 0 : _file.hashCode());
+		result = prime * result
+				+ ((_scopeType == null) ? 0 : _scopeType.hashCode());
+		return result;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#toString()
+	 */
+	@Override
+	public String toString() {
+		return "ModuleScope [" +
+				"getScopeId()=" + getScopeId() + "]"		
+				+",enclosingScope=" + _enclosingScope
+				+ ", _scopeType=" + _scopeType + ", _file=" + _file ;
+	}
+
+	
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentStoreTable.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentStoreTable.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,156 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import jdbm.PrimaryMap;
+import jdbm.PrimaryStoreMap;
+import jdbm.RecordManager;
+
+//TODO : convert it to a actual HashMap . Currently, it is just acting 
+// as a wrapper around HashMap
+class MultiValuePersistentStoreTable<K, V> {
+
+	private final PrimaryMap<K, ArrayList<Long>> _keyMap;
+	
+	private final PrimaryStoreMap<Long, V> _valueMap;
+
+	private final RecordManager _recordManager;
+
+	/**
+	 * Creates a multivalue hash table for storing/indexing symbols.
+	 * 
+	 * @param name The name of the symbol table .
+	 * @param manager RecordManager to manage physical values. 
+	 */
+	public MultiValuePersistentStoreTable(String name, RecordManager manager)
+	{
+		_recordManager = manager;
+		
+		_keyMap = _recordManager.hashMap("__"+name+"_Key");
+
+		_valueMap = _recordManager.storeMap(name);
+	}
+
+	
+	/**
+	 * Clears the storage.
+	 * @throws IOException 
+	 */
+	public void clear() throws IOException {
+		synchronized(this)
+		{
+			//Clears the symbol table
+			_valueMap.clear();
+			_keyMap.clear();
+			
+			
+			// Committing the changes of symbol table.
+			_recordManager.commit();
+		}
+		
+	}
+
+	
+	/**
+	 * Adds the value in the symbol table
+	 * 
+	 * @param key
+	 * @param value
+	 * @return
+	 */
+	public void define( K key , V value)
+	{
+		synchronized(this)
+		{	
+			long recid = _valueMap.putValue(value); 
+			
+			if ( _keyMap.containsKey(key))
+			{
+				_keyMap.get(key).add(recid);
+			}
+			else
+			{
+				ArrayList<Long> recIdsMappedUsingKey  = new ArrayList<Long>();
+				recIdsMappedUsingKey.add(recid);
+			
+				_keyMap.put(key, recIdsMappedUsingKey);
+			}	
+		}
+	}
+	
+	
+	/**
+	 * Returns the list of Keys
+	 * 
+	 * @return keyset
+	 */
+	public Set<K> keySet() {
+		return _keyMap.keySet();
+	}
+	
+	
+	/**
+	 * Gets the collection of values that are hashed using the key specified.
+	 * @param key  The Key whose associated value is to be returned
+	 * @return The values to which this key is mapped to in this Symbol Table. 
+	 * Returns empty list if no mapping for the keys is not found.   
+	 */
+	public List<V> resolve(K key) 
+	{
+		ArrayList<V> storageElements = new ArrayList<V>();
+		
+		if(_keyMap.containsKey(key))
+		{
+			ArrayList<Long> physicalKeys = getPhysicalStorageKeys(key) ;
+	
+			if (physicalKeys!=null)
+			{
+				for( Long l : physicalKeys)
+				{
+					addToCollection ( l , storageElements);
+				}
+			}
+		}
+		return storageElements;
+	}
+	
+
+	/**
+	 * Adds value hashed using physical keys in the collection
+	 * 
+	 * @param physicalKey
+	 * @param collectionToAdd
+	 */
+	private void addToCollection( long physicalKey, List<V> collectionToAdd)
+	{
+		if (_valueMap.containsKey(physicalKey))
+		{
+			collectionToAdd.add(_valueMap.get(physicalKey));
+		}
+	}
+	
+	/**
+	 * Returns the physical storage keys. Given virtual key, it gets the physical keys for the storage elements.
+	 * @param key virtual key 
+	 * @return  Collection of Physical Storage Key
+	 */
+	private ArrayList<Long> getPhysicalStorageKeys(K key) {
+		return _keyMap.get(key);
+	}
+
+
+	/**
+	 * Verifies whether key exists in the current symbol table.
+	 * 
+	 * @param key The key whose presence to be tested 
+	 * 
+	 * @return true if the table contains a mapping for the specified key. 
+	 */
+	public boolean containsKey(Object key) {
+		return _keyMap.containsKey(key);
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentTable.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentTable.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,69 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+import jdbm.PrimaryMap;
+import jdbm.RecordManager;
+
+/**
+ * MultiValue Symbol Table to store the symbols. Symbols are stored in memory and persisted
+ * on the disk whenever specified to do so.  
+ * 
+ * @author Md. Adil Akhter
+ * Created On : Aug 22, 2011
+ */
+class MultiValuePersistentTable<K, V> {
+
+	private final PrimaryMap<K,ArrayList<V>> _primaryMap;
+	
+	private final RecordManager _recordManager;
+	
+	private String _mapName ;
+	
+	public MultiValuePersistentTable(String name, RecordManager manager)
+	{
+		_mapName  = name ;
+		
+		_recordManager = manager;
+	
+		_primaryMap = _recordManager.hashMap(_mapName);
+	}
+	
+	
+	/**
+	 * Clears the Map
+	 * @throws IOException 
+	 */
+	public void clear() throws IOException
+	{
+		_primaryMap.clear();
+		
+		_recordManager.commit();
+	}
+	
+	
+	/**
+	 * Defines symbol in the current symbol table. Define does not replace  
+	 * old symbol mapped using the key with the new one. It just adds the 
+	 * new symbol at the end of the multivalue-list. 
+	 * 
+	 * @param key - The key that the symbol will be mapped to .
+	 * @param symbol - The symbol to store. 
+	 */
+	public void define(K key , V symbol)
+	{	
+		if ( _primaryMap.containsKey(key))
+		{
+			_primaryMap.get(key).add(symbol);
+		}
+		else
+		{
+			ArrayList<V> values = new ArrayList<V>(); 
+			values.add(symbol);
+			
+			_primaryMap.put( key , values );
+		}
+	}
+}
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/PackageScope.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/PackageScope.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,73 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+class PackageScope  extends BaseScope {
+	
+	private final String _scopeType = "Package" ;
+	
+	public PackageScope(IStrategoTerm id , ITermFactory factory) {
+		
+		super(id,factory);
+		
+	}
+	
+	@Override public IStrategoTerm getType() {
+	
+		return getTermFactory().makeConstructor(_scopeType, 0);
+	}
+
+
+	@Override public Scope getEnclosingScope() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#hashCode()
+	 */
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = super.hashCode();
+		result = prime * result
+				+ ((_scopeType == null) ? 0 : _scopeType.hashCode());
+		return result;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#equals(java.lang.Object)
+	 */
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (!super.equals(obj))
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		PackageScope other = (PackageScope) obj;
+		if (_scopeType == null) {
+			if (other._scopeType != null)
+				return false;
+		} else if (!_scopeType.equals(other._scopeType))
+			return false;
+		return true;
+	}
+
+	
+	/* (non-Javadoc)
+	 * @see java.lang.Object#toString()
+	 */
+	@Override
+	public String toString() {
+		return "PackageScope [_scopeType=" + _scopeType
+				+ ", getScopeId()=" + getScopeId() + "]";
+	}
+	
+}
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java	Sun Aug 28 09:58:45 2011	(r23248)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -11,32 +11,33 @@
 
 import org.spoofax.interpreter.core.IContext;
 import org.spoofax.interpreter.library.AbstractPrimitive;
-import org.spoofax.interpreter.library.language.SemanticIndex;
 import org.spoofax.interpreter.stratego.Strategy;
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 /**
- * @author adil
+ * @author Md. Adil Akhter
  *
  */
 public class SPX_index_add_module extends AbstractPrimitive {
 
 	private static String NAME = "SPX_index_add_module";
-	
-	private final SemanticIndex index;
-	
-	public SPX_index_add_module(SemanticIndex index) {
+
+	private final SpxSemanticIndex index;
+
+	public SPX_index_add_module(SpxSemanticIndex index) {
 		super(NAME, 0, 0);
 		this.index = index;
 	}
 
+
 	@Override
 	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
 		if (isTermAppl(tvars[0]) && isTermString(tvars[1])) {
-			IStrategoAppl entry = (IStrategoAppl) tvars[0];
-			URI file = index.toFileURI(asJavaString(tvars[1]));
-			index.add(entry, file);
+			//IStrategoAppl entry = (IStrategoAppl) tvars[0];
+			//URI file = index.toFileURI(asJavaString(tvars[1]));
+			
+			//index.add(entry, asJavaString(tvars[1]));
 			return true;
 		} else {
 			return false;

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_init.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_init.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,43 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 25, 2011
+ */
+public class SPX_index_init extends AbstractPrimitive {
+
+	private static String NAME = "SPX_index_init";
+
+	private final SpxSemanticIndex index;
+
+	public SPX_index_init(SpxSemanticIndex index) {
+		super(NAME, 0, 1);
+		this.index = index;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.spoofax.interpreter.library.AbstractPrimitive#call(org.spoofax.interpreter.core.IContext, org.spoofax.interpreter.stratego.Strategy[], org.spoofax.interpreter.terms.IStrategoTerm[])
+	 */
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+	{
+		if ( tvars.length != 1)
+			return false;
+
+		IStrategoString projectName = (IStrategoString)tvars[0];
+		
+		return index.initialize(projectName , env.getFactory(), SSLLibrary.instance(env).getIOAgent());
+
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,55 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import static org.spoofax.interpreter.core.Tools.isTermAppl;
+
+import java.io.IOException;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 25, 2011
+ */
+public class SPX_index_save extends AbstractPrimitive {
+
+	private static String NAME = "SPX_index_save";
+
+	private final SpxSemanticIndex index;
+
+	public SPX_index_save(SpxSemanticIndex index) {
+		super(NAME, 0, 1);
+		this.index = index;
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.spoofax.interpreter.library.AbstractPrimitive#call(org.spoofax.interpreter.core.IContext, org.spoofax.interpreter.stratego.Strategy[], org.spoofax.interpreter.terms.IStrategoTerm[])
+	 */
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+			throws InterpreterException {
+	
+		if ( tvars.length != 1)
+			return false;
+		
+		if (Tools.isTermString(tvars[0]))
+			return false;
+		
+		try 
+		{
+			return index.save(tvars[0]);
+		}
+		catch(Exception ex)
+		{
+			SSLLibrary.instance(env).getIOAgent().printError("["+NAME+"] Error : "+ ex.getMessage());
+			return false;
+		}
+		
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/Scope.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/Scope.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,22 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.net.URI;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/*
+ * This interface defines Scope for semantic index.
+ * */
+interface Scope 
+{
+	public IStrategoTerm getScopeId();
+	
+	public Scope getEnclosingScope();
+	
+	public IStrategoTerm getType();
+	
+	public URI getScopeURI();
+	
+	//TODO : Add Scope specific Define and Resolve 
+	//
+}
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,87 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+import java.util.Properties;
+
+import jdbm.PrimaryHashMap;
+import jdbm.PrimaryStoreMap;
+import jdbm.RecordManager;
+import jdbm.RecordManagerFactory;
+import jdbm.RecordManagerOptions;
+
+/**
+ * PersistenceManager responsible for initializing and maintaining various 
+ * symbol table needed for SpoofaxLang Implementation. 
+ * 
+ * @author Md. Adil Akhter
+ * Created On : Aug 22, 2011
+ */
+class SpxPersistenceManager {
+
+	//TODO : create a registry that keeps all the loaded SymbolTable
+	//and perform operation on that.  
+	private RecordManager _recordManager = null;
+	
+	private final String indexDirectory = ".index" ;
+	
+	public void initialize (String projectName) throws IOException
+	{
+		initialize( projectName, null);
+	}
+	
+	public void initialize(String projectName , Properties options) throws IOException
+	{
+		// Creating empty properties collection if it is null
+		if( options  == null)
+			options = new Properties();
+		// setting up the working directory for the Index 
+		options.put(RecordManagerOptions.INDEX_RELATIVE_PATH_OPTION, indexDirectory + "/" + projectName);
+	
+		//If recordmanager is not null, saving and closing the recordmanager
+		if ( _recordManager != null)
+			commitAndClose();
+		
+		//creating recordmanager for the particular project
+		_recordManager = RecordManagerFactory.createRecordManager(projectName , options);
+	}
+	
+	/* 
+	 * Creates named symbol table. If the symbol table already exists , it loads the particular
+	 * symbol table.
+	 * 
+	 * */
+	public <K, V>  MultiValuePersistentTable<K, V>  loadTable(String tableName)
+	{
+		
+		return new MultiValuePersistentTable<K, V>( tableName, _recordManager);
+	}
+		
+	/*
+	 * Creates a storage table with the name specified. 
+	 * */
+	public <K, V>  MultiValuePersistentStoreTable<K, V>  loadStorage (String storageName)
+	{	
+		return new MultiValuePersistentStoreTable<K,V>(storageName,  _recordManager);
+	}
+	
+	private void commit() throws IOException
+	{
+		_recordManager.commit();
+	}
+	
+	private void close() throws IOException
+	{
+		_recordManager.close();	
+	}
+	
+	/**
+	 * Commits the unsaved and closes the connection. 
+	 * @throws IOException
+	 */
+	public void commitAndClose() throws IOException
+	{	
+		this.commit();
+		this.close();
+	}
+}
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,127 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.spoofax.interpreter.library.IOAgent;
+import org.spoofax.interpreter.library.language.SemanticIndexEntry;
+import org.spoofax.interpreter.library.language.SemanticIndexEntryFactory;
+import org.spoofax.interpreter.library.language.SemanticIndexEntryParent;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoList;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+/**
+ * Semantic Index to store the symbols of SPXlang projects. 
+ *  
+ * @author Md. Adil Akhter
+ * Created On : Aug 20, 2011
+ */
+public class SpxSemanticIndex {
+
+	
+	/**
+	 * Registry keeps the mapping of projectName to its own facade
+	 * to create and perform various operations related to semantic index.
+	 */
+	private SpxSemanticIndexFacadeRegistry _facadeRegistry;
+
+	public SpxSemanticIndex()
+	{
+		_facadeRegistry = new SpxSemanticIndexFacadeRegistry();
+	}
+	
+	/**
+	 * Initializing Index for the project specified by the projectName
+	 * @param projectName Name of the project
+	 * @param termFactory Term Factory  
+	 * @param agent IOAgent responsible for providing IO operations.
+	 * @return true if the operation is successful ; false otherwise.
+	 */
+	public boolean initialize(IStrategoTerm projectName,  ITermFactory termFactory, IOAgent agent) 
+	{
+		try
+		{	// Adding a new entry of the facade for the project 
+			// in the registry. 
+			_facadeRegistry.add(projectName, termFactory, agent) ;
+			
+			return true; 
+		}
+		catch (IOException ex)
+		{
+			agent.printError("[SPX_Index_Initialize] Error : "+ex.getMessage());
+			
+			return false;	
+		}
+	}
+
+
+	/**
+	 * Adds entry to the Index 
+	 * 
+	 * @param entry
+	 * @param file
+	 */
+	public void add(String projectName , IStrategoAppl entry, String file)
+	{
+		// adds entry to the table
+
+		
+	}
+	
+	
+	// adds module definition in the index . 
+	public void addModuleDefinition(IStrategoTerm moduleDefinition , URI file)
+	{
+
+	}
+
+	/**
+	 * Saves the indexes of the project specified by the projectName
+	 * @param projectName Term representation of the projectName 
+	 * @return true if the operation is successful ; otherwise false.
+	 */
+	public boolean save(IStrategoTerm projectName) 
+	{
+		boolean retvalue = false;
+		
+		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
+		try {
+			
+			idxFacade.persistChanges();
+			retvalue = true;
+		} catch (Exception e) {
+			idxFacade.printError( "[SPX_Index_Save failed] Error : "+ e.getMessage()) ; //e.printStackTrace();
+		}
+
+		return retvalue;
+	}
+
+	private SpxSemanticIndexFacade getFacade(IStrategoTerm projectName) {
+
+		SpxSemanticIndexFacade facade = _facadeRegistry.getFacade(projectName);
+		ensureInitialized(facade);
+		
+		return facade;
+	}
+	
+	private void ensureInitialized(SpxSemanticIndexFacade idxFactory) {
+		if (idxFactory == null)
+			throw new IllegalStateException("Semantic index not initialized");
+	}
+
+	private URI toFileURI(SpxSemanticIndexFacade idxFactory, String uriString)
+	{
+		return idxFactory.toFileURI(uriString);
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexEntry.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexEntry.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,197 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 20, 2011
+ */
+class SpxSemanticIndexEntry {
+
+	
+	private Scope _scope; 
+	
+	private IStrategoTerm data;
+	
+	public SpxSemanticIndexEntry (Scope scope)
+	{
+		setScope(scope);
+	}
+	
+	
+	public Scope getScope() {
+		return _scope;
+	}
+
+	private void setScope(Scope scope) {
+		this._scope = scope;
+	}
+
+	/**
+	 * @return the data
+	 */
+	protected IStrategoTerm getData() {
+		return data;
+	}
+
+	/**
+	 * @param data the data to set
+	 */
+	protected void setData(IStrategoTerm data) {
+		this.data = data;
+	}
+	
+	/* (non-Javadoc)
+	 * @see java.lang.Object#toString()
+	 */
+	@Override
+	public String toString() {
+		return "IndexEntry [_scope=" + _scope + ", data=" + data
+				+ "]";
+	}
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#hashCode()
+	 */
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result + ((_scope == null) ? 0 : _scope.hashCode());
+		result = prime * result + ((data == null) ? 0 : data.hashCode());
+		return result;
+	}
+
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#equals(java.lang.Object)
+	 */
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		SpxSemanticIndexEntry other = (SpxSemanticIndexEntry) obj;
+		if (_scope == null) {
+			if (other._scope != null)
+				return false;
+		} else if (!_scope.equals(other._scope))
+			return false;
+		if (data == null) {
+			if (other.data != null)
+				return false;
+		} else if (!data.match(other.data))
+			return false;
+		return true;
+	}
+}
+
+
+
+class SpxSemanticIndexKey extends SpxSemanticIndexEntry
+{	
+	public SpxSemanticIndexKey(Scope scope, IStrategoTerm key)
+	{
+		super(scope);
+	}
+	
+	public IStrategoTerm getKey()
+	{
+		return getData(); 
+		
+	}
+	
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#toString()
+	 */
+	@Override
+	public String toString() {
+		return "SpxSemanticIndexKey [ " +
+				"key =" + getData().toString() +
+				"scope="  + getScope().toString() +
+				"]";
+	}
+}
+
+
+class SpxSemanticIndexSymbol extends SpxSemanticIndexEntry
+{
+	private final IStrategoTerm _key ;
+
+	public SpxSemanticIndexSymbol ( Scope scope, IStrategoTerm symbol, IStrategoTerm key)
+	{
+		super(scope);
+		
+		_key = key;
+		setData(symbol);
+	}
+	
+	
+	/**
+	 * @return the _key
+	 */
+	public IStrategoTerm getKey() {
+		return _key;
+	}
+
+	
+	public IStrategoTerm getValue()
+	{
+		return getData();
+	}
+
+
+	
+	
+	/* (non-Javadoc)
+	 * @see java.lang.Object#hashCode()
+	 */
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = super.hashCode();
+		result = prime * result + ((_key == null) ? 0 : _key.hashCode());
+		return result;
+	}
+
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#equals(java.lang.Object)
+	 */
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (!super.equals(obj))
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		SpxSemanticIndexSymbol other = (SpxSemanticIndexSymbol) obj;
+		if (_key == null) {
+			if (other._key != null)
+				return false;
+		} else if (!_key.match(other._key))
+			return false;
+		return true;
+	}
+
+
+	/* (non-Javadoc)
+	 * @see java.lang.Object#toString()
+	 */
+	@Override
+	public String toString() {
+		return "SpxSemanticIndexSymbol [ " +
+				"key=" + _key.toString() + 
+				"symbol=" + getData().toString() +
+				"scope="  + getScope().toString() +
+				"]";
+	}
+	
+}
+
+

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexEntryFactory.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexEntryFactory.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,22 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import org.spoofax.interpreter.terms.ITermFactory;
+
+
+class SpxSemanticIndexEntryFactory {
+
+	private final ITermFactory _termFactory;
+	
+	/**
+	 * Instantiates IndexEntry Factory . 
+	 * 
+	 * @param termFactory
+	 */
+	public SpxSemanticIndexEntryFactory(ITermFactory termFactory)
+	{
+		_termFactory = termFactory;
+	}
+	
+	
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Sun Aug 28 10:12:29 2011	(r23249)
@@ -0,0 +1,165 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import static org.spoofax.interpreter.core.Tools.asJavaString;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.util.HashMap;
+
+import org.spoofax.interpreter.library.IOAgent;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+//TODO : create a registry that keeps a mapping from 
+//project name to the IndexFactory . Current Implementation 
+//will still work in multiproject situation - but will be 
+//using only one SemanticIndexFactory and require initialization. 
+class SpxSemanticIndexFacadeRegistry
+{
+	
+	final HashMap<String, SpxSemanticIndexFacade> _registry = new HashMap<String, SpxSemanticIndexFacade>();
+	
+	/**
+	 * Initializes the SemanticIndexFactory
+	 * @param projectName
+	 * @param factory
+	 * @throws IOException
+	 */
+	public void add(IStrategoTerm projectName , ITermFactory factory , IOAgent agent) throws IOException
+	{	
+		String projectNameString = asJavaString(projectName);
+		
+		if ( !_registry.containsKey(projectNameString))
+		{
+			SpxSemanticIndexFacade fac = new SpxSemanticIndexFacade(projectName, factory, agent);
+			
+			_registry.put(fac.getProjectNameString(), fac);
+		}
+	}
+	
+	
+	/**
+	 * Gets the porject's Semantic Index factory
+	 * @param projectName  ProjectName Term
+	 * 
+	 * @return SpxSemanticIndexFactory mapped with the projectName. If no mapping is found, it is returning null. 
+	 */
+	public SpxSemanticIndexFacade getFacade( IStrategoTerm projectName)
+	{
+		String key = asJavaString(projectName);
+		
+		return _registry.get(key);
+	}
+	
+	
+	public void ClearAll()
+	{
+		_registry.clear();
+	}
+	
+}
+
+class SpxSemanticIndexFacade {
+
+	private final SpxPersistenceManager _persistenceManager;
+	
+	private final String _projectName ; 
+	
+	private final ITermFactory _termFactory;
+	
+	private final IOAgent _agent;
+	
+	private final SpxSemanticIndexEntryFactory _entryFactory;
+	
+	/**
+	 * Initializes the SemanticIndexFactory
+	 * @param projectName
+	 * @param termFactory
+	 * @throws IOException
+	 */
+	public SpxSemanticIndexFacade(IStrategoTerm projectName , ITermFactory termFactory , IOAgent agent) throws IOException
+	{
+		_projectName = asJavaString(projectName);	
+		_entryFactory = new SpxSemanticIndexEntryFactory(termFactory);
+		
+		_persistenceManager = new SpxPersistenceManager();
+	
+		//Initializes persistent manager
+		_persistenceManager.initialize(_projectName) ; // Initializing PersistenceManger for the current Project
+			
+		//Sets the Term Factory 
+		_termFactory = termFactory;
+
+		//IOAgent to handle URI
+		_agent = agent;
+	}
+	
+	/**
+	 * Returns the TermFactory 
+	 * @return
+	 */
+	public ITermFactory getTermFactory() {
+		return _termFactory;
+	}
+	
+	/**
+	 * Gets the project name as String
+	 * @return
+	 */
+	public String getProjectNameString()
+	{
+		return _projectName;
+	}
+	
+	/**
+	 * Get ProjectName as IStrategoTerm
+	 * 
+	 * @return IStrategoTerm
+	 */
+	public IStrategoTerm getProjectName()
+	{
+		return _termFactory.makeString(_projectName);
+	}
+	
+	/**
+	 * 
+	 * @return
+	 */
+	public SpxPersistenceManager getPersistenceManager()
+	{
+		return _persistenceManager;
+	}
+	
+	/**
+	 * @param path
+	 * @return
+	 */
+	public URI toFileURI(String path)
+	{
+		File file = new File(path);
+		return file.isAbsolute()
+			? file.toURI()
+			: new File(_agent.getWorkingDir(), path).toURI();
+	}
+	
+	public String fromFileURI(URI uri) {
+		File file = new File(uri);
+		return file.toString();
+	}
+
+	public IOAgent getIOAgent() {
+		return _agent;
+	}
+		
+	public void persistChanges() throws IOException 
+	{
+		_persistenceManager.commitAndClose();
+	}
+	
+	public void printError(String errMessage)
+	{
+		_agent.printError(errMessage);
+	}
+}

From M.A.Akhter at student.tudelft.nl  Sun Aug 28 14:39:20 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Sun, 28 Aug 2011 12:39:20 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23250 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang
Message-ID: <20110828123920.98943108C00F@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Sun Aug 28 12:39:17 2011
New Revision: 23250
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23250&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentStoreTable.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentStoreTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentStoreTable.java	Sun Aug 28 10:12:29 2011	(r23249)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentStoreTable.java	Sun Aug 28 12:39:17 2011	(r23250)
@@ -9,10 +9,19 @@
 import jdbm.PrimaryStoreMap;
 import jdbm.RecordManager;
 
-//TODO : convert it to a actual HashMap . Currently, it is just acting 
-// as a wrapper around HashMap
+/**
+ * Implementation of  Generic Table which supports persistence of the entries 
+ * and loading of those entries in a lazy manner. Entries are loaded only when 
+ * it is needed. Hence, memory usage is optimize significantly.
+ * 
+ * Support for Persistence mechanism is implemented using {@link PrimaryStoreMap} 
+ *  
+ */
 class MultiValuePersistentStoreTable<K, V> {
+	//TODO : convert it to a actual HashMap . Currently, it is just acting 
+	// as a wrapper around HashMap
 
+	
 	private final PrimaryMap<K, ArrayList<Long>> _keyMap;
 	
 	private final PrimaryStoreMap<Long, V> _valueMap;

From m.dejonge at tudelft.nl  Mon Aug 29 12:05:42 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 29 Aug 2011 10:05:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23251 - in
	sglr-recovery/trunk/Evaluate/src: evaluation_runs fileprocessing
Message-ID: <20110829100542.6793A108C01E@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 29 10:05:40 2011
New Revision: 23251
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23251&sc=1

Log:
JDT testrun

Added:
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunJDT.java   (contents, props changed)
Modified:
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/Completion.java
   sglr-recovery/trunk/Evaluate/src/evaluation_runs/Scalability.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
   sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/Completion.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/Completion.java	Sun Aug 28 12:39:17 2011	(r23250)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/Completion.java	Mon Aug 29 10:05:40 2011	(r23251)
@@ -22,9 +22,9 @@
 	private static final String TESTRUN_NAME = null; //name of result files, default is <technique>_<grammar>
 	private static final String TESTSUITE = "stratego-java-completions";
 	//private static final Permissive GRAMMAR = Permissive.WC_COMPLETIONS;
-	//private static final Permissive GRAMMAR = Permissive.COMPLETIONS;
+	private static final Permissive GRAMMAR = Permissive.COMPLETIONS;
 	//private static final Permissive GRAMMAR = Permissive.NoRecovery;
-	private static final Permissive GRAMMAR = Permissive.WC_COMPLETIONS;
+	//private static final Permissive GRAMMAR = Permissive.WC_COMPLETIONS;
 	//private static final Technique TECHNIQUE = Technique.RS;
 	private static final Technique TECHNIQUE = Technique.NO_RECOVERY_SUPPORT;
 	//private static final Technique TECHNIQUE = Technique.RS_FG; // Technique.RS_BP; // Technique.RS_BP_FG;  

Added: sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunJDT.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/RunJDT.java	Mon Aug 29 10:05:40 2011	(r23251)
@@ -0,0 +1,115 @@
+package evaluation_runs;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+
+import org.junit.Test;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.jsglr.client.InvalidParseTableException;
+import org.spoofax.jsglr.client.ParseException;
+import org.spoofax.jsglr.shared.BadTokenException;
+import org.spoofax.jsglr.shared.SGLRException;
+import org.spoofax.jsglr.shared.TokenExpectedException;
+
+import fileprocessing.Directories;
+import fileprocessing.FilenameFilters;
+import fileprocessing.TestRun;
+import fileprocessing.TestRun.Permissive;
+import fileprocessing.TestRun.Technique;
+
+
+public class RunJDT {
+
+	private static final String TESTRUN_NAME = null; 
+	private static final String TESTSUITE = "java-jdt";
+	private static final Permissive GRAMMAR = Permissive.NoRecovery;
+	private static final Technique TECHNIQUE = Technique.NO_RECOVERY_SUPPORT;
+
+	@Test
+	public void test_JDT() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException, InterpreterException {
+		TestRun run=new TestRun(TESTSUITE);
+		processFiles(run);
+	}
+
+	@Test
+	public void test_Java_RS_FG_WC() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException, InterpreterException {
+		TestRun run=new TestRun(TESTSUITE);
+		Directories.clearAllDirectories();
+		run.setTechnique(Technique.RS_FG);
+		run.setPermissive(Permissive.WC);
+		run.setSuiteName(null);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("RDef"));
+		run.processErrorFiles(10);
+	}
+
+	@Test
+	public void test_Java_RS_BP_FG_WC() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException, InterpreterException {
+		TestRun run=new TestRun(TESTSUITE);
+		Directories.clearAllDirectories();
+		run.setTechnique(Technique.RS_BP_FG);
+		run.setPermissive(Permissive.WC);
+		run.setSuiteName(null);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("RDef"));
+		run.processErrorFiles(10);
+	}
+
+
+	@Test
+	public void test_Java_RS_BP() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException, InterpreterException {
+		TestRun run=new TestRun(TESTSUITE);
+		Directories.clearAllDirectories();
+		run.setTechnique(Technique.RS_BP);
+		run.setPermissive(Permissive.NoRecovery);
+		run.setSuiteName(null);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("incomplete.585"));
+		run.processErrorFiles(10);
+	}
+
+	@Test
+	public void test_Test() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException, InterpreterException {
+		TestRun run=new TestRun(TESTSUITE);
+		Directories.clearAllDirectories();
+		run.setTechnique(Technique.RS_BP);
+		run.setPermissive(Permissive.NoRecovery);
+		run.setSuiteName("Test-BP-Failures");
+		run.setFilenameFilter(FilenameFilters.getNameFilter("incomplete.585"));
+		run.processErrorFiles(0);
+	}
+
+	@Test
+	public void test_Java_RS() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException, InterpreterException {
+		TestRun run=new TestRun(TESTSUITE);
+		Directories.clearAllDirectories();
+		run.setTechnique(Technique.RS);
+		run.setPermissive(Permissive.NoRecovery);
+		run.setSuiteName(null);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("679"));
+		run.processErrorFiles(10);
+	}
+
+	@Test
+	public void test_Java_FG() throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, org.spoofax.jsglr.shared.SGLRException, InterpreterException {
+		TestRun run=new TestRun(TESTSUITE);
+		Directories.clearAllDirectories();
+		run.setTechnique(Technique.FG);
+		run.setPermissive(Permissive.WC);
+		run.setSuiteName(null);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("679"));
+		run.processErrorFiles(10);
+	}
+
+	private void processFiles(TestRun run) throws IOException,
+			InvalidParseTableException, InterruptedException,
+			TokenExpectedException, BadTokenException, ParseException,
+			SGLRException, FileNotFoundException, InterpreterException {
+		//run.correctInputFiles();
+		Directories.clearAllDirectories();
+		run.setTechnique(TECHNIQUE);
+		run.setPermissive(GRAMMAR);
+		run.setSuiteName(TESTRUN_NAME);
+		//run.setFilenameFilter(FilenameFilters.getNameFilter("RDef"));
+		run.processFilesJDT(10);
+	}
+
+
+}

Modified: sglr-recovery/trunk/Evaluate/src/evaluation_runs/Scalability.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/evaluation_runs/Scalability.java	Sun Aug 28 12:39:17 2011	(r23250)
+++ sglr-recovery/trunk/Evaluate/src/evaluation_runs/Scalability.java	Mon Aug 29 10:05:40 2011	(r23251)
@@ -42,7 +42,7 @@
 		run.setTechnique(TECHNIQUE);
 		run.setPermissive(GRAMMAR);
 		run.setSuiteName(TESTRUN_NAME);
-		//run.setFilenameFilter(FilenameFilters.getNameFilter("err0"));
+		run.setFilenameFilter(FilenameFilters.getNameFilter("err0"));
 		run.warmup();
 		run.processErrorFiles(10, null);
 	}

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Sun Aug 28 12:39:17 2011	(r23250)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/FileProcessing.java	Mon Aug 29 10:05:40 2011	(r23251)
@@ -15,6 +15,7 @@
 import org.bridget.compare.Tree;
 import org.bridget.compare.TreeAlignment;
 //import org.spoofax.jsglr.client;
+import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.jsglr.client.Asfix2TreeBuilder;
 import org.spoofax.jsglr.client.IRecoveryParser;
@@ -30,6 +31,9 @@
 import org.spoofax.terms.TermFactory;
 import org.spoofax.terms.io.binary.TermReader;
 import org.strategoxt.lang.compat.NativeCallHelper;
+import org.strategoxt.stratego_lib.system_about_0_0;
+
+import sglrbridges.otherparsers.JDTParser;
 
 import compare.StrategoCostFunction;
 import compare.StrategoTranslator;
@@ -139,6 +143,33 @@
 		}
 	}
 
+	
+	public static void processJDTFile(TestFile test) throws FileNotFoundException, IOException, InvalidParseTableException, InterruptedException, TokenExpectedException, BadTokenException, ParseException, SGLRException, InterpreterException{
+		String tempFilePath=Directories.TEMP_DIR+ File.separator+test.getFilename();
+		long t_start = System.currentTimeMillis();
+		createJDT_Tree(test.getPathToIntendedFile(), tempFilePath+".intended.ast");
+		test.setParsetimeIntended(t_start - System.currentTimeMillis());
+		t_start = System.currentTimeMillis();
+		createJDT_Tree(test.getPathToErrorFile(), tempFilePath+".err.ast");
+		test.setParsetimeError(t_start - System.currentTimeMillis());
+		pp_aterm(tempFilePath + ".intended.ast", test.getPathToIntendedAST());
+		pp_aterm(tempFilePath + ".err.ast", test.getPathToErrorAST());
+		if(Results.getLineCount(test.getPathToErrorAST()) <= 1 || !new File(test.getPathToErrorAST()).exists()){
+			test.setRecoverySucceeded(false);
+		}
+		else {
+			test.setRecoverySucceeded(true);
+			diff(test.getPathToErrorAST(), test.getPathToIntendedAST(), test.getPathToASTDiff());
+			test.setAstDiffLines(Results.getLineCount(test.getPathToASTDiff()));
+		}
+	}
+	
+	private static void createJDT_Tree(String inputfile, String outputfile) throws IOException, InterpreterException {	
+		String[] args= new String[]{"-i", inputfile, "-o", outputfile, "-sr"};
+		JDTParser.main(args);
+	}
+
+
 	public void createRecoveredAst(TestFile test)
 			throws FileNotFoundException, IOException,
 			InvalidParseTableException {
@@ -208,7 +239,7 @@
 		caller.call(commandArgs, new String[0], null, System.out, System.err);		
 	}
 	
-	private void pp_aterm(String inputFile, String outputFile) throws InterruptedException, IOException {
+	private static void pp_aterm(String inputFile, String outputFile) throws InterruptedException, IOException {
 		NativeCallHelper caller=new NativeCallHelper();
 		String[] commandArgs = {
 				"pp-aterm", 

Modified: sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java
==============================================================================
--- sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Sun Aug 28 12:39:17 2011	(r23250)
+++ sglr-recovery/trunk/Evaluate/src/fileprocessing/TestRun.java	Mon Aug 29 10:05:40 2011	(r23251)
@@ -11,12 +11,16 @@
 import java.util.Map;
 
 import org.omg.CORBA.ContextList;
+import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.jsglr.client.IRecoveryParser;
 import org.spoofax.jsglr.client.InvalidParseTableException;
 import org.spoofax.jsglr.client.ParseException;
 import org.spoofax.jsglr.shared.BadTokenException;
 import org.spoofax.jsglr.shared.SGLRException;
 import org.spoofax.jsglr.shared.TokenExpectedException;
+import sglrbridges.otherparsers.JDTParser;
+
+import sglrbridges.otherparsers.JDTParser;
 
 import bridgeparser.SGLRBridgeParser;
 
@@ -28,7 +32,8 @@
 		RS,
 		RS_FG,
 		RS_BP_FG,
-		RS_BP
+		RS_BP, 
+		JDT_PARSER
 	}
 	
 	public enum Permissive{
@@ -42,7 +47,8 @@
 		WC_COMPLETIONS,
 		WC_COMPLETIONS_WELLFORMED,
 		COMPLETIONS,
-		COMPLETIONS_WELLFORMED
+		COMPLETIONS_WELLFORMED, 
+		JDT_GRAMMAR
 	}
 	
 	private String suite;
@@ -71,7 +77,8 @@
 		parseTableBaseNames.put("stratego-java-test", "StrategoJava");
 		parseTableBaseNames.put("stratego-java-completions", "StrategoJava");
 		parseTableBaseNames.put("stratego-java-scalability", "StrategoJava");
-		parseTableBaseNames.put("java", "Java-15");
+		parseTableBaseNames.put("java", "Java");
+		parseTableBaseNames.put("java-jdt", "Java");
 		parseTableBaseNames.put("java-sql", "Java-SQL");
 		parseTableBaseNames.put("webdsl", "WebDSL");
 		return parseTableBaseNames;
@@ -163,7 +170,7 @@
 	public IRecoveryParser getRecoveryParser() {
 		IRecoveryParser parser = null;
 		if (technique.equals(Technique.RS_BP_FG)|| technique.equals(Technique.RS_BP)) {
-			if (suite.equals("java")) {
+			if (suite.startsWith("java")) {
 				parser = new SGLRBridgeParser(new java15.MainBridgeParser());
 			} else if (suite.equals("webdsl")) {
 				parser = new SGLRBridgeParser(new webdsl.MainBridgeParser());
@@ -290,7 +297,35 @@
 		printPerformanceResults(testcases);
 		printParseTimeResults(testcases);		
 	}
+	
+	public void processFilesJDT(int warmup) throws IOException, InterpreterException, InvalidParseTableException, TokenExpectedException, BadTokenException, ParseException, InterruptedException, SGLRException {
+		ArrayList<TestFile> testcases = getErrorFileList();
+		if(testcases.size() > 0){
+			for(int i = 0; i < warmup; i++){
+				FileProcessing.processJDTFile(testcases.get(warmup));
+			}
+		}
+		for (TestFile test : testcases) {
+			try{
+				FileProcessing.processJDTFile(test);
+				System.out.println("JDT parsed: " + test.getFilename());
+			}
+			catch (Error e)
+		    {
+				System.err.println("Error while jdt-parsing: "+test.getFilename());
+				//System.err.println(e.getMessage());
+		        e.printStackTrace(); 
+				//Log error
+		    }
+		}
+		PrintStream prsDiff=new PrintStream(getDirSuite()+"results" +File.separator+"quality"+File.separator+getTestRunName());
+		Results.writeDiffStats(testcases, prsDiff);		
+		printPerformanceResults(testcases);
+		printParseTimeResults(testcases);		
+	}
+
 
+	
 	private void printPerformanceResults(ArrayList<TestFile> testcases)
 			throws FileNotFoundException {
 		PrintStream prsTime = new PrintStream(getDirSuite() + "results"
@@ -388,4 +423,5 @@
 	public void setSuiteName(String suiteName) {
 		this.suiteName = suiteName;
 	}
+
 }

From m.dejonge at tudelft.nl  Mon Aug 29 12:06:31 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 29 Aug 2011 10:06:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23252 -
	sglr-recovery/trunk/Evaluate
Message-ID: <20110829100631.165602B8003@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 29 10:06:30 2011
New Revision: 23252
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23252&sc=1

Log:


Modified:
   sglr-recovery/trunk/Evaluate/.classpath

Modified: sglr-recovery/trunk/Evaluate/.classpath
==============================================================================
--- sglr-recovery/trunk/Evaluate/.classpath	Mon Aug 29 10:05:40 2011	(r23251)
+++ sglr-recovery/trunk/Evaluate/.classpath	Mon Aug 29 10:06:30 2011	(r23252)
@@ -12,5 +12,7 @@
 	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/javasql.jar"/>
 	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/strategojava.jar"/>
 	<classpathentry kind="lib" path="/bridge-definitions/grammars/generated/webdsl.jar"/>
+	<classpathentry kind="src" path="/other-parsers"/>
+	<classpathentry combineaccessrules="false" kind="src" path="/org.spoofax.interpreter.adapter.ecj"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>

From M.A.Akhter at student.tudelft.nl  Mon Aug 29 15:27:48 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 29 Aug 2011 13:27:48 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23253 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language:
	. spxlang
Message-ID: <20110829132748.F2F23108C006@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 29 13:27:48 2011
New Revision: 23253
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23253&sc=1

Log:
SPX SymbolTable + indexing infrastructure (in-progress)

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxComplicationUnitInfo.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Mon Aug 29 10:06:30 2011	(r23252)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -1,9 +1,7 @@
 package org.spoofax.interpreter.library.language;
 
 import org.spoofax.interpreter.library.AbstractStrategoOperatorRegistry;
-import org.spoofax.interpreter.library.language.spxlang.SPX_index_init;
-import org.spoofax.interpreter.library.language.spxlang.SPX_index_save;
-import org.spoofax.interpreter.library.language.spxlang.SpxSemanticIndex;
+import org.spoofax.interpreter.library.language.spxlang.*;
 
 /**
  * @author Lennart Kats <lennart add lclnet.nl>
@@ -30,6 +28,7 @@
 		
 		add(new SPX_index_init(spxIndex));
 		add(new SPX_index_save(spxIndex));
+		add(new SPX_index_add_module(spxIndex));
 	}
 
 	public String getOperatorRegistryName() {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentTable.java	Mon Aug 29 10:06:30 2011	(r23252)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/MultiValuePersistentTable.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -7,8 +7,8 @@
 import jdbm.RecordManager;
 
 /**
- * MultiValue Symbol Table to store the symbols. Symbols are stored in memory and persisted
- * on the disk whenever specified to do so.  
+ * Generic MultiValue Symbol Table to store the symbols. Symbols are stored in memory and persisted
+ * on the disk if committed via {@link SpxPersistenceManager}.
  * 
  * @author Md. Adil Akhter
  * Created On : Aug 22, 2011

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java	Mon Aug 29 10:06:30 2011	(r23252)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_add_module.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -26,14 +26,13 @@
 	private final SpxSemanticIndex index;
 
 	public SPX_index_add_module(SpxSemanticIndex index) {
-		super(NAME, 0, 0);
+		super(NAME, 0, 1);
 		this.index = index;
 	}
 
-
 	@Override
 	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) {
-		if (isTermAppl(tvars[0]) && isTermString(tvars[1])) {
+		if (isTermAppl(tvars[0])) {
 			//IStrategoAppl entry = (IStrategoAppl) tvars[0];
 			//URI file = index.toFileURI(asJavaString(tvars[1]));
 			

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java	Mon Aug 29 10:06:30 2011	(r23252)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -34,9 +34,6 @@
 	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
 			throws InterpreterException {
 	
-		if ( tvars.length != 1)
-			return false;
-		
 		if (Tools.isTermString(tvars[0]))
 			return false;
 		
@@ -46,7 +43,7 @@
 		}
 		catch(Exception ex)
 		{
-			SSLLibrary.instance(env).getIOAgent().printError("["+NAME+"] Error : "+ ex.getMessage());
+			SSLLibrary.instance(env).getIOAgent().printError("["+NAME+"] Invokation failed. Error : "+ ex.getMessage());
 			return false;
 		}
 		

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -0,0 +1,21 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+import jdbm.PrimaryHashMap;
+import jdbm.PrimaryStoreMap;
+
+class SpxCompilationUnitSymbolTable {
+	
+	PrimaryHashMap<String , SpxComplicationUnitInfo> _infoMap;
+	
+	PrimaryStoreMap<Long,IStrategoTerm> _unitStorage;
+	
+	
+	public SpxCompilationUnitSymbolTable( SpxPersistenceManager manager)
+	{
+		
+		
+	}
+	
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxComplicationUnitInfo.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxComplicationUnitInfo.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -0,0 +1,95 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.File;
+import java.io.Serializable;
+import java.net.URI;
+
+/**
+ * Represent information regarding Spoofaxlang CompilationUnit 
+ * 
+ * @author Md. Adil Akhter
+ * Created On : Aug 29, 2011
+ */
+class SpxComplicationUnitInfo implements Serializable
+{
+	private static final long serialVersionUID = 4874917828420267542L;
+
+	private long _recId;
+	
+	private int _version;
+	
+	private URI _absPath;
+	
+	public SpxComplicationUnitInfo( long recourceId, int versionNo, URI absPath)
+	{
+		_recId = recourceId;
+		_version = versionNo;
+		_absPath = absPath;
+	}
+
+	long getRecId() {
+		return _recId;
+	}
+
+	void setRecId(long recId) {
+		this._recId = recId;
+	}
+
+	int getVersionNo() {
+		return _version;
+	}
+
+	void setVersionNo(int version) {
+		this._version = version;
+	}
+
+	URI getAbsPath() {
+		return _absPath;
+	}
+
+	String getAbsPathString()
+	{
+		return new File(getAbsPath()).getAbsolutePath();
+	}
+	
+	void setAbsPath(URI absPath) {
+		this._absPath = absPath;
+	}
+	
+	public String toString() {
+		return "SpxComplicationUnitResourceInfo [ResourceId=" + _recId
+				+ ", VersionNo=" + _version + ", AbsPath=" + _absPath + "]";
+	}
+
+	@Override
+	public int hashCode() {
+		final int prime = 31;
+		int result = 1;
+		result = prime * result
+				+ ((_absPath == null) ? 0 : _absPath.hashCode());
+		result = prime * result + (int) (_recId ^ (_recId >>> 32));
+		result = prime * result + _version;
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (this == obj)
+			return true;
+		if (obj == null)
+			return false;
+		if (getClass() != obj.getClass())
+			return false;
+		SpxComplicationUnitInfo other = (SpxComplicationUnitInfo) obj;
+		if (_absPath == null) {
+			if (other._absPath != null)
+				return false;
+		} else if (!_absPath.equals(other._absPath))
+			return false;
+		if (_recId != other._recId)
+			return false;
+		if (_version != other._version)
+			return false;
+		return true;
+	}
+}
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Mon Aug 29 10:06:30 2011	(r23252)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -13,6 +13,9 @@
  * PersistenceManager responsible for initializing and maintaining various 
  * symbol table needed for SpoofaxLang Implementation. 
  * 
+ * It hosts all the SymbolTables. SymbolTables are loaded whenever is needed 
+ * and changes are persisted when following operation is performed : {@link SpxPersistenceManager}.commit.
+ * 
  * @author Md. Adil Akhter
  * Created On : Aug 22, 2011
  */
@@ -20,62 +23,81 @@
 
 	//TODO : create a registry that keeps all the loaded SymbolTable
 	//and perform operation on that.  
-	private RecordManager _recordManager = null;
+	private final RecordManager _recordManager;
 	
 	private final String indexDirectory = ".index" ;
 	
-	public void initialize (String projectName) throws IOException
+	//TODO : All the maps will be hosted by this  object 
+	public SpxPersistenceManager(String projectName) throws IOException
 	{
-		initialize( projectName, null);
+		this( projectName, null);
 	}
 	
-	public void initialize(String projectName , Properties options) throws IOException
+	public SpxPersistenceManager (String projectName , Properties options) throws IOException
 	{
 		// Creating empty properties collection if it is null
 		if( options  == null)
 			options = new Properties();
+		
 		// setting up the working directory for the Index 
 		options.put(RecordManagerOptions.INDEX_RELATIVE_PATH_OPTION, indexDirectory + "/" + projectName);
 	
-		//If recordmanager is not null, saving and closing the recordmanager
-		if ( _recordManager != null)
-			commitAndClose();
-		
 		//creating recordmanager for the particular project
 		_recordManager = RecordManagerFactory.createRecordManager(projectName , options);
 	}
 	
-	/* 
-	 * Creates named symbol table. If the symbol table already exists , it loads the particular
-	 * symbol table.
+	
+	/**
+	 * Instantiates a new HashMap 
 	 * 
-	 * */
-	public <K, V>  MultiValuePersistentTable<K, V>  loadTable(String tableName)
+	 * @param <K>
+	 * @param <V>
+	 * @param mapName
+	 * @return
+	 */
+	<K,V> PrimaryHashMap<K,V> loadHashMap ( String mapName)
 	{
+		return _recordManager.hashMap(mapName) ;
 		
-		return new MultiValuePersistentTable<K, V>( tableName, _recordManager);
 	}
-		
-	/*
-	 * Creates a storage table with the name specified. 
-	 * */
-	public <K, V>  MultiValuePersistentStoreTable<K, V>  loadStorage (String storageName)
-	{	
-		return new MultiValuePersistentStoreTable<K,V>(storageName,  _recordManager);
+	
+	
+	/**
+	 * Instantiates a new StoreHashMap
+	 * 
+	 * @param <V>
+	 * @param storeMapName
+	 * @return
+	 */
+	<V> PrimaryStoreMap <Long, V> loadStoreMap( String storeMapName)
+	{
+		return _recordManager.storeMap(storeMapName);
 	}
 	
-	private void commit() throws IOException
+	
+	/**
+	 * Commits any unsaved changes to the disk 
+	 * @throws IOException
+	 */
+	void commit() throws IOException
 	{
 		_recordManager.commit();
 	}
 	
-	private void close() throws IOException
+	
+	/**
+	 * Closes RecordManager
+	 * 
+	 * @throws IOException
+	 */
+	void close() throws IOException
 	{
 		_recordManager.close();	
 	}
 	
 	/**
-	 * Commits the unsaved and closes the connection. 
+	 * Commits the unsaved and closes the connection.
+	 *  
 	 * @throws IOException
 	 */
 	public void commitAndClose() throws IOException

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Mon Aug 29 10:06:30 2011	(r23252)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -90,7 +90,7 @@
 	 * @param projectName Term representation of the projectName 
 	 * @return true if the operation is successful ; otherwise false.
 	 */
-	public boolean save(IStrategoTerm projectName) 
+	public boolean save(IStrategoTerm projectName) throws IllegalStateException
 	{
 		boolean retvalue = false;
 		
@@ -110,11 +110,10 @@
 
 		SpxSemanticIndexFacade facade = _facadeRegistry.getFacade(projectName);
 		ensureInitialized(facade);
-		
 		return facade;
 	}
 	
-	private void ensureInitialized(SpxSemanticIndexFacade idxFactory) {
+	private void ensureInitialized(SpxSemanticIndexFacade idxFactory) throws IllegalStateException {
 		if (idxFactory == null)
 			throw new IllegalStateException("Semantic index not initialized");
 	}
@@ -124,4 +123,22 @@
 		return idxFactory.toFileURI(uriString);
 	}
 
+	
+	public boolean indexCompilationUnit(IStrategoString projectName,
+			IStrategoString spxCompilationUnitPath,
+			IStrategoAppl spxCompilationUnitAST) throws IllegalStateException, Exception{
+
+		boolean successStatement = false;
+		
+		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
+		try {
+			
+		}
+		catch (Exception ex)
+		{
+			throw ex;
+		}
+		return successStatement;
+	}
+
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Mon Aug 29 10:06:30 2011	(r23252)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Mon Aug 29 13:27:48 2011	(r23253)
@@ -84,11 +84,9 @@
 		_projectName = asJavaString(projectName);	
 		_entryFactory = new SpxSemanticIndexEntryFactory(termFactory);
 		
-		_persistenceManager = new SpxPersistenceManager();
-	
 		//Initializes persistent manager
-		_persistenceManager.initialize(_projectName) ; // Initializing PersistenceManger for the current Project
-			
+		_persistenceManager = new SpxPersistenceManager(_projectName);
+	
 		//Sets the Term Factory 
 		_termFactory = termFactory;
 

From m.dejonge at tudelft.nl  Mon Aug 29 19:35:39 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Mon, 29 Aug 2011 17:35:39 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23254 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client
Message-ID: <20110829173539.462DE2B8005@mx2.tudelft.nl>

Author: MaartjeDeJonge
Date: Mon Aug 29 17:35:38 2011
New Revision: 23254
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23254&sc=1

Log:
bugfix: FG after RS fails did not work in EOF cases

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Mon Aug 29 13:27:48 2011	(r23253)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/FineGrainedOnRegion.java	Mon Aug 29 17:35:38 2011	(r23254)
@@ -17,10 +17,9 @@
         return mySGLR.getHistory();
     }
    
-    public void setInfoFGOnly(){
-        regionEndPosition=mySGLR.tokensSeen+5;
-        acceptRecoveryPosition=regionEndPosition+15;
-        int lastIndex=getHistory().getIndexLastLine();       
+    public void setInfoFGOnly(int tokensSeen, int lastIndex){
+        regionEndPosition = Integer.MAX_VALUE;
+        acceptRecoveryPosition=tokensSeen + 20;
         for (int i = Math.max(0, lastIndex-MAX_NR_OF_EXPLORED_LINES); i < lastIndex; i++) {
             IndentInfo line= getHistory().getLine(i);
             if(line.getStackNodes()!=null && line.getStackNodes().size()>0){

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Mon Aug 29 13:27:48 2011	(r23253)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/RecoveryConnector.java	Mon Aug 29 17:35:38 2011	(r23254)
@@ -50,9 +50,11 @@
     }
 
     private void combinedRecover() {
+        int tokensSeen = mySGLR.tokensSeen; 
+        int lastIndex = getHistory().getIndexLastLine();
         if(onlyFineGrained){
             mySGLR.getPerformanceMeasuring().startFG();
-            boolean fg=tryFineGrainedRepair();
+            boolean fg=tryFineGrainedRepair(tokensSeen, lastIndex, false);
             mySGLR.getPerformanceMeasuring().endFG(fg);
             return;
         }
@@ -83,7 +85,7 @@
         //FINEGRAINED REPAIR 
         if(useFineGrained){
             mySGLR.getPerformanceMeasuring().startFG();
-            boolean FGSucceeded=tryFineGrainedRepair();
+            boolean FGSucceeded=tryFineGrainedRepair(tokensSeen, lastIndex, skipSucceeded);
             mySGLR.getPerformanceMeasuring().endFG(FGSucceeded);
             if(FGSucceeded){ //FG succeeded  
                 //addSkipOption(skipSucceeded);
@@ -126,13 +128,13 @@
         return (mySGLR.activeStacks.size()>0 || mySGLR.acceptingStack!=null);
     }
 
-    private boolean tryFineGrainedRepair() {
+    private boolean tryFineGrainedRepair(int tokensSeen, int lastIndex, boolean useRegion) {
         FineGrainedOnRegion fgRepair=new FineGrainedOnRegion(mySGLR); 
-        if(!onlyFineGrained){
+        if(useRegion){
             fgRepair.setRegionInfo(skipRecovery.getErroneousRegion(), skipRecovery.getAcceptPosition());
         }
         else{
-            fgRepair.setInfoFGOnly();
+            fgRepair.setInfoFGOnly(tokensSeen, lastIndex);
         }
         fgRepair.recover();
         fgRepair.parseRemainingTokens();

From M.A.Akhter at student.tudelft.nl  Mon Aug 29 21:27:50 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 29 Aug 2011 19:27:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23255 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang
Message-ID: <20110829192750.A1D76CC051@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 29 19:27:47 2011
New Revision: 23255
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23255&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit.java

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit.java	Mon Aug 29 19:27:47 2011	(r23255)
@@ -0,0 +1,56 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 25, 2011
+ */
+public class SPX_index_compilation_unit extends AbstractPrimitive {
+
+	private static String NAME = "SPX_index_compilation_unit";
+
+	private final SpxSemanticIndex index;
+
+	public SPX_index_compilation_unit(SpxSemanticIndex index) {
+		super(NAME, 0, 3);
+		this.index = index;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.spoofax.interpreter.library.AbstractPrimitive#call(org.spoofax.interpreter.core.IContext, org.spoofax.interpreter.stratego.Strategy[], org.spoofax.interpreter.terms.IStrategoTerm[])
+	 */
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) 
+	{
+		boolean successStatement = false;
+		 
+		if ( Tools.isTermString(tvars[0]) && Tools.isTermString(tvars[1]) && Tools.isTermAppl(tvars[2])) 
+		{
+			IStrategoString projectName = (IStrategoString)tvars[0];
+			IStrategoString spxCompilationUnitPath = (IStrategoString)tvars[1];
+			IStrategoAppl  spxCompilationUnitAST = (IStrategoAppl)tvars[2];
+			
+			try {
+				successStatement  = index.indexCompilationUnit(projectName ,  spxCompilationUnitPath ,  spxCompilationUnitAST);
+			} 
+			catch(Exception ex)
+			{
+				SSLLibrary.instance(env).getIOAgent().printError("["+NAME+" Invokation failed . ] Error : "+ ex.getMessage());
+			}
+		}
+		
+		return successStatement;
+	}
+
+}

From M.A.Akhter at student.tudelft.nl  Mon Aug 29 21:28:42 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 29 Aug 2011 19:28:42 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23256 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language
Message-ID: <20110829192842.4E907108C003@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 29 19:28:42 2011
New Revision: 23256
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23256&sc=1

Log:
added new primitive - index-compilation-unit in language library

Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Mon Aug 29 19:27:47 2011	(r23255)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Mon Aug 29 19:28:42 2011	(r23256)
@@ -29,6 +29,7 @@
 		add(new SPX_index_init(spxIndex));
 		add(new SPX_index_save(spxIndex));
 		add(new SPX_index_add_module(spxIndex));
+		add(new SPX_index_compilation_unit(spxIndex));
 	}
 
 	public String getOperatorRegistryName() {

From M.A.Akhter at student.tudelft.nl  Mon Aug 29 23:03:08 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 29 Aug 2011 21:03:08 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23257 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang
Message-ID: <20110829210308.A6BEF7F8011@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 29 21:03:05 2011
New Revision: 23257
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23257&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitInfo.java
      - copied, changed from r23253, spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxComplicationUnitInfo.java
Deleted:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxComplicationUnitInfo.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java

Copied and modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitInfo.java (from r23253, spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxComplicationUnitInfo.java)
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxComplicationUnitInfo.java	Mon Aug 29 13:27:48 2011	(r23253, copy source)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitInfo.java	Mon Aug 29 21:03:05 2011	(r23257)
@@ -10,7 +10,7 @@
  * @author Md. Adil Akhter
  * Created On : Aug 29, 2011
  */
-class SpxComplicationUnitInfo implements Serializable
+class SpxCompilationUnitInfo implements Serializable
 {
 	private static final long serialVersionUID = 4874917828420267542L;
 
@@ -20,7 +20,7 @@
 	
 	private URI _absPath;
 	
-	public SpxComplicationUnitInfo( long recourceId, int versionNo, URI absPath)
+	public SpxCompilationUnitInfo( long recourceId, int versionNo, URI absPath)
 	{
 		_recId = recourceId;
 		_version = versionNo;
@@ -80,7 +80,7 @@
 			return false;
 		if (getClass() != obj.getClass())
 			return false;
-		SpxComplicationUnitInfo other = (SpxComplicationUnitInfo) obj;
+		SpxCompilationUnitInfo other = (SpxCompilationUnitInfo) obj;
 		if (_absPath == null) {
 			if (other._absPath != null)
 				return false;

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Mon Aug 29 19:28:42 2011	(r23256)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Mon Aug 29 21:03:05 2011	(r23257)
@@ -1,5 +1,8 @@
 package org.spoofax.interpreter.library.language.spxlang;
 
+import java.net.URI;
+
+import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 import jdbm.PrimaryHashMap;
@@ -7,14 +10,19 @@
 
 class SpxCompilationUnitSymbolTable {
 	
-	PrimaryHashMap<String , SpxComplicationUnitInfo> _infoMap;
+	PrimaryHashMap<String , SpxCompilationUnitInfo> _infoMap;
 	
 	PrimaryStoreMap<Long,IStrategoTerm> _unitStorage;
 	
 	
-	public SpxCompilationUnitSymbolTable( SpxPersistenceManager manager)
+	public SpxCompilationUnitSymbolTable(SpxPersistenceManager manager)
 	{
 		
+	}
+	
+	
+	public void define ( SpxCompilationUnitInfo info, IStrategoAppl compilationUnit)
+	{
 		
 	}
 	

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Mon Aug 29 19:28:42 2011	(r23256)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Mon Aug 29 21:03:05 2011	(r23257)
@@ -25,7 +25,10 @@
 	//and perform operation on that.  
 	private final RecordManager _recordManager;
 	
-	private final String indexDirectory = ".index" ;
+	private final String indexDirectory = ".index" ; //TODO : remove hardcoding  
+	
+	private final SpxCompilationUnitSymbolTable _spxUnitsTable;  
+	
 	
 	//TODO : All the maps will be hosted by this  object 
 	public SpxPersistenceManager(String projectName) throws IOException
@@ -44,6 +47,9 @@
 	
 		//creating recordmanager for the particular project
 		_recordManager = RecordManagerFactory.createRecordManager(projectName , options);
+		
+		
+		_spxUnitsTable = new SpxCompilationUnitSymbolTable(this);
 	}
 	
 	

From M.A.Akhter at student.tudelft.nl  Mon Aug 29 23:14:37 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Mon, 29 Aug 2011 21:14:37 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23258 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang
Message-ID: <20110829211437.E23E4108C00E@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Mon Aug 29 21:14:36 2011
New Revision: 23258
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23258&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java	Mon Aug 29 21:14:36 2011	(r23258)
@@ -0,0 +1,21 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+
+import jdbm.PrimaryHashMap;
+import jdbm.PrimaryStoreMap;
+
+interface ISpxPersistenceManager {
+
+	/**
+	 * Commits the unsaved and closes the connection.
+	 *  
+	 * @throws IOException
+	 */
+	public void commitAndClose()  throws IOException;
+	
+	public <V> PrimaryStoreMap <Long, V> loadStoreMap( String storeMapName);
+	
+	public <K,V> PrimaryHashMap<K,V> loadHashMap ( String mapName);
+
+}
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Mon Aug 29 21:03:05 2011	(r23257)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Mon Aug 29 21:14:36 2011	(r23258)
@@ -12,15 +12,24 @@
 	
 	PrimaryHashMap<String , SpxCompilationUnitInfo> _infoMap;
 	
-	PrimaryStoreMap<Long,IStrategoTerm> _unitStorage;
+	PrimaryStoreMap<Long,IStrategoTerm> _spxUnitStorageMap;
 	
 	
-	public SpxCompilationUnitSymbolTable(SpxPersistenceManager manager)
+	/**
+	 * 
+	 * @param tableName
+	 * @param manager
+	 */
+	public SpxCompilationUnitSymbolTable(String tableName , ISpxPersistenceManager manager)
 	{
-		
+		_infoMap = manager.loadHashMap(tableName+ "._infomap");
+		_spxUnitStorageMap = manager.loadStoreMap(tableName + "._spxUnitStorageMap");
 	}
 	
-	
+	/**
+	 * @param info
+	 * @param compilationUnit
+	 */
 	public void define ( SpxCompilationUnitInfo info, IStrategoAppl compilationUnit)
 	{
 		

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Mon Aug 29 21:03:05 2011	(r23257)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Mon Aug 29 21:14:36 2011	(r23258)
@@ -19,7 +19,7 @@
  * @author Md. Adil Akhter
  * Created On : Aug 22, 2011
  */
-class SpxPersistenceManager {
+class SpxPersistenceManager implements ISpxPersistenceManager {
 
 	//TODO : create a registry that keeps all the loaded SymbolTable
 	//and perform operation on that.  
@@ -48,8 +48,7 @@
 		//creating recordmanager for the particular project
 		_recordManager = RecordManagerFactory.createRecordManager(projectName , options);
 		
-		
-		_spxUnitsTable = new SpxCompilationUnitSymbolTable(this);
+		_spxUnitsTable = new SpxCompilationUnitSymbolTable(projectName+"_spxUnitTable", this);
 	}
 	
 	
@@ -61,7 +60,7 @@
 	 * @param mapName
 	 * @return
 	 */
-	<K,V> PrimaryHashMap<K,V> loadHashMap ( String mapName)
+	public <K,V> PrimaryHashMap<K,V> loadHashMap ( String mapName)
 	{
 		return _recordManager.hashMap(mapName) ;
 		
@@ -75,7 +74,7 @@
 	 * @param storeMapName
 	 * @return
 	 */
-	<V> PrimaryStoreMap <Long, V> loadStoreMap( String storeMapName)
+	public <V> PrimaryStoreMap <Long, V> loadStoreMap( String storeMapName)
 	{
 		return _recordManager.storeMap(storeMapName);
 	}
@@ -101,10 +100,8 @@
 		_recordManager.close();	
 	}
 	
-	/**
-	 * Commits the unsaved and closes the connection.
-	 *  
-	 * @throws IOException
+	/* (non-Javadoc)
+	 * @see org.spoofax.interpreter.library.language.spxlang.ISpxPersistenceManager#commitAndClose()
 	 */
 	public void commitAndClose() throws IOException
 	{	

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Mon Aug 29 21:03:05 2011	(r23257)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Mon Aug 29 21:14:36 2011	(r23258)
@@ -63,7 +63,7 @@
 
 class SpxSemanticIndexFacade {
 
-	private final SpxPersistenceManager _persistenceManager;
+	private final ISpxPersistenceManager _persistenceManager;
 	
 	private final String _projectName ; 
 	
@@ -125,7 +125,7 @@
 	 * 
 	 * @return
 	 */
-	public SpxPersistenceManager getPersistenceManager()
+	public ISpxPersistenceManager getPersistenceManager()
 	{
 		return _persistenceManager;
 	}

From M.A.Akhter at student.tudelft.nl  Tue Aug 30 10:13:29 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 30 Aug 2011 08:13:29 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23259 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang
Message-ID: <20110830081329.F102E108C019@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Aug 30 08:13:29 2011
New Revision: 23259
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23259&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitInfo.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit.java	Mon Aug 29 21:14:36 2011	(r23258)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit.java	Tue Aug 30 08:13:29 2011	(r23259)
@@ -39,10 +39,10 @@
 		{
 			IStrategoString projectName = (IStrategoString)tvars[0];
 			IStrategoString spxCompilationUnitPath = (IStrategoString)tvars[1];
-			IStrategoAppl  spxCompilationUnitAST = (IStrategoAppl)tvars[2];
+			IStrategoAppl  compilationUnitRTree = (IStrategoAppl)tvars[2];
 			
 			try {
-				successStatement  = index.indexCompilationUnit(projectName ,  spxCompilationUnitPath ,  spxCompilationUnitAST);
+				successStatement  = index.indexCompilationUnit(projectName ,  spxCompilationUnitPath ,  compilationUnitRTree);
 			} 
 			catch(Exception ex)
 			{

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitInfo.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitInfo.java	Mon Aug 29 21:14:36 2011	(r23258)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitInfo.java	Tue Aug 30 08:13:29 2011	(r23259)
@@ -14,13 +14,18 @@
 {
 	private static final long serialVersionUID = 4874917828420267542L;
 
-	private long _recId;
+	private final long _recId;
 	
 	private int _version;
 	
-	private URI _absPath;
+	private final URI _absPath;
 	
-	public SpxCompilationUnitInfo( long recourceId, int versionNo, URI absPath)
+	public SpxCompilationUnitInfo(URI absPath,long recourceId)
+	{
+		this (0 , absPath , recourceId);
+	}
+	
+	public SpxCompilationUnitInfo( int versionNo, URI absPath,long recourceId)
 	{
 		_recId = recourceId;
 		_version = versionNo;
@@ -31,18 +36,10 @@
 		return _recId;
 	}
 
-	void setRecId(long recId) {
-		this._recId = recId;
-	}
-
 	int getVersionNo() {
 		return _version;
 	}
-
-	void setVersionNo(int version) {
-		this._version = version;
-	}
-
+	
 	URI getAbsPath() {
 		return _absPath;
 	}
@@ -52,10 +49,23 @@
 		return new File(getAbsPath()).getAbsolutePath();
 	}
 	
-	void setAbsPath(URI absPath) {
-		this._absPath = absPath;
+
+	void IncrementVersionNo()
+	{
+		_version = _version + 1;
 	}
+
 	
+	/**
+	 * Returns the Absolute Path of the given URI 
+	 * @param uri URI of the Resource. 
+	 * @return Absolute Path represented by the URI  
+	 */
+	public static String toAbsulatePath( URI uri)
+	{
+		return new File( uri).getAbsolutePath();
+		
+	}
 	public String toString() {
 		return "SpxComplicationUnitResourceInfo [ResourceId=" + _recId
 				+ ", VersionNo=" + _version + ", AbsPath=" + _absPath + "]";

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Mon Aug 29 21:14:36 2011	(r23258)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Tue Aug 30 08:13:29 2011	(r23259)
@@ -2,6 +2,8 @@
 
 import java.net.URI;
 
+import static org.spoofax.interpreter.library.language.spxlang.SpxCompilationUnitInfo.toAbsulatePath;
+
 import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
@@ -12,7 +14,7 @@
 	
 	PrimaryHashMap<String , SpxCompilationUnitInfo> _infoMap;
 	
-	PrimaryStoreMap<Long,IStrategoTerm> _spxUnitStorageMap;
+	PrimaryStoreMap<Long,IStrategoTerm> _spxUnitStoreMap;
 	
 	
 	/**
@@ -23,16 +25,69 @@
 	public SpxCompilationUnitSymbolTable(String tableName , ISpxPersistenceManager manager)
 	{
 		_infoMap = manager.loadHashMap(tableName+ "._infomap");
-		_spxUnitStorageMap = manager.loadStoreMap(tableName + "._spxUnitStorageMap");
+		_spxUnitStoreMap = manager.loadStoreMap(tableName + "._spxUnitStorageMap");
 	}
 	
 	/**
 	 * @param info
 	 * @param compilationUnit
 	 */
-	public void define ( SpxCompilationUnitInfo info, IStrategoAppl compilationUnit)
+	public void define(URI absPath , IStrategoAppl compilationUnitRTree)
+	{	
+		String abspathString = toAbsulatePath(absPath);
+		
+		if ( _infoMap.containsKey(abspathString))
+			this.update(absPath, compilationUnitRTree); //URI is already there in the symbol table . Hence updating the table
+		else
+			this.add(absPath, compilationUnitRTree);  
+	}
+	
+	/**
+	 * Adding the new CompilationUnit in this symbol table 
+	 * @param absPath
+	 */
+	private void add(URI absPath , IStrategoAppl compilationUnitRTree) 
+	{
+		// adding Compilation Unit to the storemap
+		long resID = _spxUnitStoreMap.putValue(compilationUnitRTree);
+		
+		// instantiating a new SpxCompilationUnitInfo object with the newly created resID
+		// and storing it in infomap
+		SpxCompilationUnitInfo newResInfo = new SpxCompilationUnitInfo(absPath,resID);
+		_infoMap.put(newResInfo.getAbsPathString(), newResInfo);
+	}
+	
+	
+	private void update(URI absPath , IStrategoAppl compilationUnitRTree)
+	{	
+		
+		// key is already there in the info map .
+		SpxCompilationUnitInfo resInfoToUpdate = _infoMap.get( toAbsulatePath(absPath));
+		
+		_spxUnitStoreMap.put(resInfoToUpdate.getRecId(), compilationUnitRTree);
+		
+		resInfoToUpdate.IncrementVersionNo();
+	}
+	
+	
+	/**
+	 * Removes a SPX Compilation Unit from the symbol table.
+	 * 
+	 * @param absPath URI for the SPXCompilationUnit to remove
+	 */
+	public void remove(URI absPath)
 	{
+		String key = toAbsulatePath(absPath);
+		
+		SpxCompilationUnitInfo resInfoToUpdate = _infoMap.remove(key);
 		
+		if ( resInfoToUpdate != null)
+		{	
+			_spxUnitStoreMap.remove(resInfoToUpdate.getRecId());
+		}
 	}
 	
+	
+	
+	
 }

From M.A.Akhter at student.tudelft.nl  Tue Aug 30 12:48:57 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 30 Aug 2011 10:48:57 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23260 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang
Message-ID: <20110830104857.42A797F801E@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Aug 30 10:48:56 2011
New Revision: 23260
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23260&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacadeRegistry.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java	Tue Aug 30 08:13:29 2011	(r23259)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java	Tue Aug 30 10:48:56 2011	(r23260)
@@ -18,4 +18,5 @@
 	
 	public <K,V> PrimaryHashMap<K,V> loadHashMap ( String mapName);
 
+	public SpxCompilationUnitSymbolTable  spxCompilcationUnitTable();
 }
\ No newline at end of file

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Tue Aug 30 08:13:29 2011	(r23259)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Tue Aug 30 10:48:56 2011	(r23260)
@@ -4,7 +4,6 @@
 
 import static org.spoofax.interpreter.library.language.spxlang.SpxCompilationUnitInfo.toAbsulatePath;
 
-import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
 import jdbm.PrimaryHashMap;
@@ -32,7 +31,7 @@
 	 * @param info
 	 * @param compilationUnit
 	 */
-	public void define(URI absPath , IStrategoAppl compilationUnitRTree)
+	public void define(URI absPath , IStrategoTerm compilationUnitRTree)
 	{	
 		String abspathString = toAbsulatePath(absPath);
 		
@@ -46,7 +45,7 @@
 	 * Adding the new CompilationUnit in this symbol table 
 	 * @param absPath
 	 */
-	private void add(URI absPath , IStrategoAppl compilationUnitRTree) 
+	private void add(URI absPath , IStrategoTerm compilationUnitRTree) 
 	{
 		// adding Compilation Unit to the storemap
 		long resID = _spxUnitStoreMap.putValue(compilationUnitRTree);
@@ -58,7 +57,13 @@
 	}
 	
 	
-	private void update(URI absPath , IStrategoAppl compilationUnitRTree)
+	/**
+	 * Updates an Existing Table Entry 
+	 * 
+	 * @param absPath
+	 * @param compilationUnitRTree
+	 */
+	private void update(URI absPath , IStrategoTerm compilationUnitRTree)
 	{	
 		
 		// key is already there in the info map .
@@ -87,6 +92,22 @@
 		}
 	}
 	
+	/**
+	 * Returns SPXCompilationUnit mapped by the specified absPath argument.
+	 * 
+	 * @param absPath
+	 * @return
+	 */
+	public IStrategoTerm get(URI absPath)
+	{
+		String key = toAbsulatePath(absPath);
+		
+		SpxCompilationUnitInfo retUnitData= _infoMap.get(key);
+		
+		return _spxUnitStoreMap.get(retUnitData.getRecId());
+		
+	}
+	
 	
 	
 	

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Tue Aug 30 08:13:29 2011	(r23259)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Tue Aug 30 10:48:56 2011	(r23260)
@@ -108,5 +108,11 @@
 		this.commit();
 		this.close();
 	}
+
+	
+	public SpxCompilationUnitSymbolTable spxCompilcationUnitTable() {
+		
+		return _spxUnitsTable;
+	}
 }
 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Tue Aug 30 08:13:29 2011	(r23259)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Tue Aug 30 10:48:56 2011	(r23260)
@@ -117,12 +117,6 @@
 		if (idxFactory == null)
 			throw new IllegalStateException("Semantic index not initialized");
 	}
-
-	private URI toFileURI(SpxSemanticIndexFacade idxFactory, String uriString)
-	{
-		return idxFactory.toFileURI(uriString);
-	}
-
 	
 	public boolean indexCompilationUnit(IStrategoString projectName,
 			IStrategoString spxCompilationUnitPath,
@@ -132,11 +126,12 @@
 		
 		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
 		try {
-			
+			idxFacade.indexCompilationUnit( spxCompilationUnitPath, spxCompilationUnitAST);
+			successStatement = true; // setting the flag to indicate the operation is successful
 		}
 		catch (Exception ex)
-		{
-			throw ex;
+		{	
+			idxFacade.printError( "[SPX_Index_Save failed] Error : "+ ex.getMessage()) ;	//logging exception.
 		}
 		return successStatement;
 	}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Tue Aug 30 08:13:29 2011	(r23259)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Tue Aug 30 10:48:56 2011	(r23260)
@@ -7,72 +7,27 @@
 import java.net.URI;
 import java.util.HashMap;
 
+import org.spoofax.interpreter.core.Tools;
 import org.spoofax.interpreter.library.IOAgent;
+import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
 
-//TODO : create a registry that keeps a mapping from 
-//project name to the IndexFactory . Current Implementation 
-//will still work in multiproject situation - but will be 
-//using only one SemanticIndexFactory and require initialization. 
-class SpxSemanticIndexFacadeRegistry
-{
-	
-	final HashMap<String, SpxSemanticIndexFacade> _registry = new HashMap<String, SpxSemanticIndexFacade>();
-	
-	/**
-	 * Initializes the SemanticIndexFactory
-	 * @param projectName
-	 * @param factory
-	 * @throws IOException
-	 */
-	public void add(IStrategoTerm projectName , ITermFactory factory , IOAgent agent) throws IOException
-	{	
-		String projectNameString = asJavaString(projectName);
-		
-		if ( !_registry.containsKey(projectNameString))
-		{
-			SpxSemanticIndexFacade fac = new SpxSemanticIndexFacade(projectName, factory, agent);
-			
-			_registry.put(fac.getProjectNameString(), fac);
-		}
-	}
-	
-	
-	/**
-	 * Gets the porject's Semantic Index factory
-	 * @param projectName  ProjectName Term
-	 * 
-	 * @return SpxSemanticIndexFactory mapped with the projectName. If no mapping is found, it is returning null. 
-	 */
-	public SpxSemanticIndexFacade getFacade( IStrategoTerm projectName)
-	{
-		String key = asJavaString(projectName);
-		
-		return _registry.get(key);
-	}
-	
-	
-	public void ClearAll()
-	{
-		_registry.clear();
-	}
-	
-}
+
 
 class SpxSemanticIndexFacade {
 
 	private final ISpxPersistenceManager _persistenceManager;
-	
+
 	private final String _projectName ; 
-	
+
 	private final ITermFactory _termFactory;
-	
+
 	private final IOAgent _agent;
-	
+
 	private final SpxSemanticIndexEntryFactory _entryFactory;
-	
+
 	/**
 	 * Initializes the SemanticIndexFactory
 	 * @param projectName
@@ -83,17 +38,17 @@
 	{
 		_projectName = asJavaString(projectName);	
 		_entryFactory = new SpxSemanticIndexEntryFactory(termFactory);
-		
+
 		//Initializes persistent manager
 		_persistenceManager = new SpxPersistenceManager(_projectName);
-	
+
 		//Sets the Term Factory 
 		_termFactory = termFactory;
 
 		//IOAgent to handle URI
 		_agent = agent;
 	}
-	
+
 	/**
 	 * Returns the TermFactory 
 	 * @return
@@ -101,7 +56,7 @@
 	public ITermFactory getTermFactory() {
 		return _termFactory;
 	}
-	
+
 	/**
 	 * Gets the project name as String
 	 * @return
@@ -110,7 +65,7 @@
 	{
 		return _projectName;
 	}
-	
+
 	/**
 	 * Get ProjectName as IStrategoTerm
 	 * 
@@ -120,7 +75,7 @@
 	{
 		return _termFactory.makeString(_projectName);
 	}
-	
+
 	/**
 	 * 
 	 * @return
@@ -129,20 +84,25 @@
 	{
 		return _persistenceManager;
 	}
-	
+
 	/**
 	 * @param path
 	 * @return
 	 */
-	public URI toFileURI(String path)
+	URI toFileURI(String path)
 	{
 		File file = new File(path);
 		return file.isAbsolute()
-			? file.toURI()
-			: new File(_agent.getWorkingDir(), path).toURI();
+		? file.toURI()
+				: new File(_agent.getWorkingDir(), path).toURI();
+	}
+
+	URI toFileURI(IStrategoTerm filePath) 
+	{
+		return toFileURI(Tools.asJavaString(filePath));
 	}
-	
-	public String fromFileURI(URI uri) {
+
+	String fromFileURI(URI uri) {
 		File file = new File(uri);
 		return file.toString();
 	}
@@ -150,14 +110,36 @@
 	public IOAgent getIOAgent() {
 		return _agent;
 	}
-		
+
 	public void persistChanges() throws IOException 
 	{
 		_persistenceManager.commitAndClose();
 	}
-	
+
+	/**
+	 * Printing error message
+	 * 
+	 * @param errMessage
+	 */
 	public void printError(String errMessage)
 	{
 		_agent.printError(errMessage);
 	}
+
+	/**
+	 * Adds CompilationUnit to the symbol table 
+	 * 
+	 * @param spxCompilationUnitPath path of the SpxCompilation Unit. 
+	 * It can be a relative path (  relative to project) or absolute path. 
+	 * @param spxCompilationUnitAST SPXCompilationUnit AST 
+	 */
+	public void indexCompilationUnit(
+			IStrategoString spxCompilationUnitPath,
+			IStrategoAppl spxCompilationUnitAST) {
+
+		URI resUri = toFileURI(spxCompilationUnitPath); // Converting IStrategoString to File URI 
+		
+		SpxCompilationUnitSymbolTable table = _persistenceManager.spxCompilcationUnitTable();
+		table.define(resUri, spxCompilationUnitAST);
+	}
 }

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacadeRegistry.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacadeRegistry.java	Tue Aug 30 10:48:56 2011	(r23260)
@@ -0,0 +1,59 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import static org.spoofax.interpreter.core.Tools.asJavaString;
+
+import java.io.IOException;
+import java.util.HashMap;
+
+import org.spoofax.interpreter.library.IOAgent;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+import org.spoofax.interpreter.terms.ITermFactory;
+
+//TODO : create a registry that keeps a mapping from 
+//project name to the IndexFactory . Current Implementation 
+//will still work in multiproject situation - but will be 
+//using only one SemanticIndexFactory and require initialization. 
+class SpxSemanticIndexFacadeRegistry
+{
+	
+	final HashMap<String, SpxSemanticIndexFacade> _registry = new HashMap<String, SpxSemanticIndexFacade>();
+	
+	/**
+	 * Initializes the SemanticIndexFactory
+	 * @param projectName
+	 * @param factory
+	 * @throws IOException
+	 */
+	public void add(IStrategoTerm projectName , ITermFactory factory , IOAgent agent) throws IOException
+	{	
+		String projectNameString = asJavaString(projectName);
+		
+		if ( !_registry.containsKey(projectNameString))
+		{
+			SpxSemanticIndexFacade fac = new SpxSemanticIndexFacade(projectName, factory, agent);
+			
+			_registry.put(fac.getProjectNameString(), fac);
+		}
+	}
+	
+	
+	/**
+	 * Gets the porject's Semantic Index factory
+	 * @param projectName  ProjectName Term
+	 * 
+	 * @return SpxSemanticIndexFactory mapped with the projectName. If no mapping is found, it is returning null. 
+	 */
+	public SpxSemanticIndexFacade getFacade( IStrategoTerm projectName)
+	{
+		String key = asJavaString(projectName);
+		
+		return _registry.get(key);
+	}
+	
+	
+	public void ClearAll()
+	{
+		_registry.clear();
+	}
+	
+}
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Tue Aug 30 13:23:54 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Tue, 30 Aug 2011 11:23:54 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23261 -
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang
Message-ID: <20110830112354.EC5CB2B8017@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Tue Aug 30 11:23:54 2011
New Revision: 23261
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23261&sc=1

Log:
added primitives to  - 
 
1] lookup and  
2]remove 

SpxCompilationUnit from the Index

Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_get_compilation_unit.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_remove_compilation_unit.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/   (props changed)
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_get_compilation_unit.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_get_compilation_unit.java	Tue Aug 30 11:23:54 2011	(r23261)
@@ -0,0 +1,56 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 25, 2011
+ */
+public class SPX_index_get_compilation_unit extends AbstractPrimitive {
+
+	private static String NAME = "SPX_index_get_compilation_unit";
+
+	private final SpxSemanticIndex index;
+
+	public SPX_index_get_compilation_unit(SpxSemanticIndex index) {
+		super(NAME, 0, 2);
+		this.index = index;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.spoofax.interpreter.library.AbstractPrimitive#call(org.spoofax.interpreter.core.IContext, org.spoofax.interpreter.stratego.Strategy[], org.spoofax.interpreter.terms.IStrategoTerm[])
+	 */
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) 
+	{
+		boolean successStatement = false;
+		 
+		if ( Tools.isTermString(tvars[0]) && Tools.isTermString(tvars[1])) 
+		{
+			IStrategoString projectName = (IStrategoString)tvars[0];
+			IStrategoString spxCompilationUnitPath = (IStrategoString)tvars[1];
+			
+			try {
+				successStatement  = index.getCompilationUnit(projectName ,  spxCompilationUnitPath);
+			} 
+			catch(Exception ex)
+			{
+				// logging any unhandled exception 
+				SSLLibrary.instance(env).getIOAgent().printError("["+NAME+" Invokation failed . ] Error : "+ ex.getMessage());
+			}
+		}
+		
+		return successStatement;
+	}
+
+}

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_remove_compilation_unit.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_remove_compilation_unit.java	Tue Aug 30 11:23:54 2011	(r23261)
@@ -0,0 +1,56 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import java.io.IOException;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoAppl;
+import org.spoofax.interpreter.terms.IStrategoString;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 25, 2011
+ */
+public class SPX_index_remove_compilation_unit extends AbstractPrimitive {
+
+	private static String NAME = "SPX_index_remove_compilation_unit";
+
+	private final SpxSemanticIndex index;
+
+	public SPX_index_remove_compilation_unit(SpxSemanticIndex index) {
+		super(NAME, 0, 2);
+		this.index = index;
+	}
+
+	/* (non-Javadoc)
+	 * @see org.spoofax.interpreter.library.AbstractPrimitive#call(org.spoofax.interpreter.core.IContext, org.spoofax.interpreter.stratego.Strategy[], org.spoofax.interpreter.terms.IStrategoTerm[])
+	 */
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars) 
+	{
+		boolean successStatement = false;
+		 
+		if ( Tools.isTermString(tvars[0]) && Tools.isTermString(tvars[1])) 
+		{
+			IStrategoString projectName = (IStrategoString)tvars[0];
+			IStrategoString spxCompilationUnitPath = (IStrategoString)tvars[1];
+		
+			try {
+				successStatement  = index.removeCompilationUnit(projectName ,  spxCompilationUnitPath);
+			} 
+			catch(Exception ex)
+			{
+				// logging any unhandled exception 
+				SSLLibrary.instance(env).getIOAgent().printError("["+NAME+" Invokation failed . ] Error : "+ ex.getMessage());
+			}
+		}
+		
+		return successStatement;
+	}
+
+}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Tue Aug 30 10:48:56 2011	(r23260)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Tue Aug 30 11:23:54 2011	(r23261)
@@ -131,9 +131,42 @@
 		}
 		catch (Exception ex)
 		{	
-			idxFacade.printError( "[SPX_Index_Save failed] Error : "+ ex.getMessage()) ;	//logging exception.
+			idxFacade.printError( "[SPX_Index_CompilationUnit failed] Error : "+ ex.getMessage()) ;	//logging exception.
 		}
 		return successStatement;
 	}
 
+	public boolean getCompilationUnit(IStrategoString projectName,
+			IStrategoString spxCompilationUnitPath) {
+		
+		boolean successStatement = false;
+		
+		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
+		try {
+			idxFacade.getCompilationUnit(spxCompilationUnitPath);
+			successStatement = true; // setting the flag to indicate the operation is successful
+		}
+		catch (Exception ex)
+		{	
+			idxFacade.printError( "[SPX_Index_getCompilationUnit failed] Error : "+ ex.getMessage()) ;	//logging exception.
+		}
+		return successStatement;
+	}
+	
+	public boolean removeCompilationUnit(IStrategoString projectName,
+			IStrategoString spxCompilationUnitPath) {
+		
+		boolean successStatement = false;
+		
+		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
+		try {
+			idxFacade.removeCompilationUnit(spxCompilationUnitPath);
+			successStatement = true; // setting the flag to indicate the operation is successful
+		}
+		catch (Exception ex)
+		{	
+			idxFacade.printError( "[SPX_Index_removeCompilationUnit failed] Error : "+ ex.getMessage()) ;	//logging exception.
+		}
+		return successStatement;
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Tue Aug 30 10:48:56 2011	(r23260)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Tue Aug 30 11:23:54 2011	(r23261)
@@ -117,7 +117,7 @@
 	}
 
 	/**
-	 * Printing error message
+	 * Prints error message
 	 * 
 	 * @param errMessage
 	 */
@@ -142,4 +142,22 @@
 		SpxCompilationUnitSymbolTable table = _persistenceManager.spxCompilcationUnitTable();
 		table.define(resUri, spxCompilationUnitAST);
 	}
+
+	public IStrategoTerm getCompilationUnit(IStrategoString spxCompilationUnitPath)
+	{
+		URI resUri = toFileURI(spxCompilationUnitPath);
+		
+		SpxCompilationUnitSymbolTable table = _persistenceManager.spxCompilcationUnitTable();
+		
+		return table.get(resUri);
+	}
+	
+	public void removeCompilationUnit( IStrategoString spxCompilationUnitPath )
+	{
+		URI resUri = toFileURI(spxCompilationUnitPath);
+		
+		SpxCompilationUnitSymbolTable table = _persistenceManager.spxCompilcationUnitTable();
+		
+		table.remove(resUri);
+	}
 }

From m.dejonge at tudelft.nl  Tue Aug 30 21:56:43 2011
From: m.dejonge at tudelft.nl (Maartje de Jonge)
Date: Tue, 30 Aug 2011 19:56:43 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23262 -
	sglr-recovery/trunk/permissive-grammars/trans/make-permissive
Message-ID: <20110830195643.73BEE108C00E@mx3.tudelft.nl>

Author: MaartjeDeJonge
Date: Tue Aug 30 19:56:43 2011
New Revision: 23262
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23262&sc=1

Log:
completion rules: nog geen opties

Added:
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/completion-sections.astr
Modified:
   sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr

Added: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/completion-sections.astr
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/completion-sections.astr	Tue Aug 30 19:56:43 2011	(r23262)
@@ -0,0 +1,296 @@
+module completion-sections
+
+imports
+
+rules //extend grammar with completion rules
+
+generate-completion-grammar-top:
+	ast -> ast'
+	where
+		<store-placeholders-top> ast;
+		ast' := <
+			alltd(add-completion-syntax);
+			oncetd(add-completion-start-rule);
+			alltd(flatten-list)
+		> ast
+		
+add-completion-start-rule:
+	lexical-syntax(l-prods) -> [lexical-syntax(l-prods), lexical-syntax([<start-lexical-production>])]
+
+add-completion-syntax:
+	context-free-syntax(cf-prods) -> [context-free-syntax(cf-prods), context-free-syntax(completion-prods)]
+	where
+		completion-prods := <generate-completion-productions> cf-prods
+
+generate-completion-productions-top:
+	ast -> completion-productions
+	where
+		<store-placeholders-top> ast;
+		cf-prods := <get-cf-productions> ast;
+		completion-productions := <generate-completion-productions> cf-prods
+
+generate-completion-productions:
+	cf-prods -> <map(add-start-lexical)> completion-productions
+	where
+		completion-prods-unfiltered := <filter(make-completion-productions); flatten-list> cf-prods;
+		completion-productions := <filter-superfluous-completions(|cf-prods)> completion-prods-unfiltered
+
+filter-superfluous-completions(|cf-prods):
+	completion-prods -> completion-prods-filtered
+	where
+		completion-prods-filtered := <
+			diff(equal-productions);
+			mk-set(equal-productions);
+			filter(not({lhs: ?prod([lhs], lhs, _)}))
+		> (completion-prods, cf-prods)
+
+rules //create completion rules for context-free productions
+
+make-completion-productions:
+	prod at prod(_, _, _) -> completion-productions
+	where
+		completion-productions := <completion-parts; map(make-completion-production)> prod
+	
+make-completion-production:
+	(lhs-prefix, lhs-suffix, rhs, attr) -> prod(<add-optional-lexicals(|lhs-suffix)> lhs-prefix, rhs, attr-completion)
+	where
+		suffix-sorts := <filter(is-sort-term)> lhs-suffix;
+		constructor := <get-constructor-name> attr; 
+		prefix-sorts-count := <filter(is-sort-term); length> lhs-prefix;
+		suffix-placeholders := <map(lookup-placeholder)> suffix-sorts; 
+		ast-string := <make-ast-string>(constructor, prefix-sorts-count, suffix-placeholders); 
+		attr-completion := <replace-cons-with-ast(|ast-string); add-completion-attr; remove-bracket-left-right-attributes> attr
+
+add-optional-lexicals(|lhs-suffix):
+	lhs-prefix -> <conc>(lhs-prefix, optional-lexicals)
+	where
+		if <not(map(is-sort-term))> lhs-prefix then //auto-edit strategy is typically triggered by a lexical in the prefix
+			optional-lexicals := <filter(to-opt-lit)> lhs-suffix
+		else
+			optional-lexicals := []
+		end
+
+to-opt-lit = 
+	to-opt-lit-opt <+ 
+	to-opt-lit-iter <+
+	to-opt-lit-lit
+
+to-opt-lit-opt: opt-lit at opt(lit(_)) -> opt-lit
+to-opt-lit-iter: iter-lit at iter-star(lit(_)) -> iter-lit
+to-opt-lit-iter: iter-lit at iter-star-sep(lit(_), _) -> iter-lit	
+to-opt-lit-iter: iter(lit(l)) -> iter-star(lit(l))
+to-opt-lit-iter: iter-sep(lit(l), sep) -> iter-star-sep(lit(l), sep)	
+to-opt-lit-lit: lit(_) -> opt(<id>)		
+
+make-ast-string:
+	(constructor, prefix-sorts-count, suffix-placeholders) -> $["[constructor]([arg-string])"]
+	where
+		prefix-number-strings := <upto; Tl; map(!$[<[<id>]>])> prefix-sorts-count; 
+		suffix-placeholder-strings := <map(write-to-string)> suffix-placeholders; 
+		arg-string := <conc; separate-by(|","); concat-strings>(prefix-number-strings, suffix-placeholder-strings)
+
+completion-parts:
+	prod(lhs, rhs, attr) -> completion-parts
+	where
+		lhs-completion-parts := <completion-lhs-parts> lhs;
+		completion-parts := <map(\(prefix, suffix) -> (prefix, suffix, rhs, attr)\)> lhs-completion-parts
+
+completion-lhs-parts:
+	lhs -> <completion-lhs-parts(|lhs, 1)> []
+	
+completion-lhs-parts(|lhs, n) = 
+	completion-lhs-parts-stop(|lhs, n) <+
+	completion-lhs-parts-add(|lhs, n) <+
+	completion-lhs-parts-skip(|lhs, n)
+	
+completion-lhs-parts-stop(|lhs, n):
+	lhs-tuples -> lhs-tuples
+	where
+		<gt>(n, <length> lhs)
+
+completion-lhs-parts-skip(|lhs, n):
+	lhs-tuples -> <completion-lhs-parts(|lhs, <inc> n)> lhs-tuples
+
+completion-lhs-parts-add(|lhs, n):
+	lhs-tuples -> <completion-lhs-parts(|lhs, <inc> n)>[(prefix, suffix)|lhs-tuples]
+	where
+		(prefix, suffix) := <split-at(|n)> lhs;
+		<is-lhs-completion-prefix> prefix;
+		<is-lhs-completion-suffix> suffix
+
+is-lhs-completion-prefix:
+	prefix -> prefix
+	where //prefix should end with sort term
+		<last; is-sort-term> prefix
+
+is-lhs-completion-suffix:
+	suffix -> suffix
+	where //suffix should contain a non-optional subterm
+		<not(map(?opt(_) <+ ?iter-star(_) <+ ?iter-star-sep(_, _)))> suffix
+		
+rules //recursive generation of suitable placeholders for sorts
+
+/**
+ * Fills lookup table that maps sorts to placeholder ast nodes
+ */
+store-placeholders-top:
+	ast -> ast
+	where
+	  cf-productions := <get-cf-productions> ast;
+	  remaining-cf-prods-1 := <store-placeholders-iteratively> cf-productions; //stores all wellformed placeholders
+	  lexical-productions := <get-lexical-productions> ast;
+	  <filter(store-lexical-default-placeholder)> lexical-productions; //stores placeholders for lexical productions
+	  remaining-cf-prods-2 := <store-placeholders-iteratively> remaining-cf-prods-1;  //stores placeholders with possible malformed strings 
+	  <filter(store-cf-default-placeholder)> remaining-cf-prods-2 //stores placeholders with NULL() elements
+
+store-placeholders-iteratively:
+	cf-prods -> remaining-cf-prods
+	where
+	  remaining-cf-prods := 
+	  	<repeat({prods: ?prods; filter(not(store-placeholder)); not(?prods)})> cf-prods
+	
+store-placeholder:
+	prod(lhs, rhs, attrs) -> prod(lhs, rhs, attrs)
+	where
+		<not(lookup-placeholder)> rhs;
+		placeholder := <create-placeholder> prod(lhs, rhs, attrs); 
+		rules(LookupPlaceholder: rhs -> placeholder)
+
+create-placeholder:
+	prod(lhs, _, attrs) -> placeholder
+	where
+		child-placeholders := <filter(is-sort-term); map(lookup-placeholder)> lhs;
+		constructor := <get-constructor-name> attrs;
+		placeholder := constructor#(child-placeholders)
+
+create-placeholder:
+	p at prod(lhs, _, attrs) -> placeholder
+	where
+		<is-injection-production> p; 
+		placeholder := <filter(is-sort-term); ?[<lookup-placeholder>]> lhs
+
+store-lexical-default-placeholder:
+	p at prod(_, rhs, _) -> p
+	where
+		<not(lookup-placeholder)> rhs;
+		placeholder := <get-lexical-default-placeholder> ; 
+		rules(LookupPlaceholder: rhs -> placeholder)
+
+store-cf-default-placeholder:
+	p at prod(_, rhs, _) -> p
+	where
+		<not(lookup-placeholder)> rhs;
+		placeholder := <get-cf-default-placeholder>;
+		rules(LookupPlaceholder: rhs -> placeholder)
+	
+rules //inductively created placeholders
+
+lookup-placeholder = LookupPlaceholder
+	
+lookup-placeholder:
+	iter-star(_) -> []
+	where
+		is-sort-term
+
+lookup-placeholder:
+	iter-star-sep(_, _) -> []	
+	where
+		is-sort-term
+
+lookup-placeholder:
+	opt(_) -> None()
+	where
+		is-sort-term
+
+lookup-placeholder:
+	alt(a, b) -> <<lookup-placeholder> a <+ <lookup-placeholder> b >
+
+lookup-placeholder:
+	iter(srt) -> [<lookup-placeholder> srt]
+
+lookup-placeholder:
+	iter-sep(srt, _) -> [<lookup-placeholder> srt]
+
+get-lexical-default-placeholder = !"MISSING_TOKEN"
+
+get-cf-default-placeholder = !NULL()
+
+signature constructors
+	NULL : Missing
+
+
+rules //helpers
+	
+is-sort-term = where(oncetd(?sort(_)))
+
+is-injection-production:
+	p at prod(lhs, _, attrs) -> p
+	where
+		<not(has-ast-attr)> attrs;
+		<filter(is-sort-term); ?[_]> lhs
+
+has-ast-attr =
+	where(
+		oncetd(
+			?default(appl(unquoted("ast"),_)) <+
+			?default(appl(unquoted("cons"),_))
+		)
+	)
+
+get-constructor-name:
+	attrs -> cons-name
+	where
+	  oncetd(
+		?default(appl(unquoted("cons"), [fun(quoted(<un-double-quote; ?cons-name>))]))
+	  )
+
+get-cf-productions =
+	collect-all(?context-free-syntax(<id>));
+	flatten-list;
+	filter(not(is-ignore-production))
+
+get-lexical-productions =
+	collect-all(?lexical-syntax(<id>));
+	flatten-list;
+	filter(not(is-ignore-production))
+	
+is-ignore-production:
+	p at prod(_, _, attr) -> p
+	where
+		oncetd(
+			?fun(unquoted("recover")) <+
+			?fun(unquoted("completion"))
+		) 
+
+add-completion-attr:
+	 attrs(lst) -> attrs([term(default(fun(unquoted("completion"))))|lst])
+
+remove-bracket-left-right-attributes:
+	attrs(lst) -> attrs(<filter(not(is-bracket-left-right-attr))>lst)
+
+is-bracket-left-right-attr =
+	?bracket() <+ ?assoc(left()) <+ ?assoc(right())
+
+replace-cons-with-ast(|ast-string) = 
+	oncetd(replace-cons-attr-with-ast-attr(|ast-string))
+
+replace-cons-attr-with-ast-attr(|ast-string) :
+	default(appl(unquoted("cons"), [fun(quoted(_))])) -> default(appl(unquoted("ast"), [fun(quoted(ast-string))]))
+
+equal-productions:
+	prod-pair@(prod(lhs, rhs, _), prod(lhs, rhs, _)) -> prod-pair
+
+mk-set(eq)=
+	foldr(![], union(eq), ![<id>])
+
+add-start-lexical:
+	prod(lhs, rhs, attr) -> prod([<start-lexical>|lhs], rhs, attr)
+
+start-lexical-production =
+	!prod(
+	      []
+	    , <start-lexical>
+	    , attrs([term(default(fun(unquoted("completion"))))])
+	    )
+
+start-lexical = !lit("\"@#$\"")
\ No newline at end of file

Modified: sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr
==============================================================================
--- sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr	Tue Aug 30 11:23:54 2011	(r23261)
+++ sglr-recovery/trunk/permissive-grammars/trans/make-permissive/make-permissive.astr	Tue Aug 30 19:56:43 2011	(r23262)
@@ -18,6 +18,7 @@
   insert-sections
   optimize
   pp-commented-sdf
+  completion-sections
 
 overlays
 
@@ -49,6 +50,7 @@
       id.init;
 
       add-permissive-sections;
+      generate-completion-grammar-top;
       
       /* Disabled:
          Adding rules for separate characters may cause them to be used to

From M.A.Akhter at student.tudelft.nl  Wed Aug 31 10:48:50 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 31 Aug 2011 08:48:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23263 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests
Message-ID: <20110831084850.98C50108C02F@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 31 08:48:50 2011
New Revision: 23263
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23263&sc=1

Log:


Added:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/symboltable.str

Added: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/symboltable.str
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/symboltable.str	Wed Aug 31 08:48:50 2011	(r23263)
@@ -0,0 +1,79 @@
+module unit-tests/symboltable
+
+imports 
+	normalize/-
+	include/spoofaxlang
+signature constructors
+
+
+
+rules 
+	
+	test-constructors1: 	
+		(selected, position, ast, path, project-path) -> None()
+		where
+				packageDef := PackageDef(Package( ["test" , "A"]) , "String Path ");
+				<debug(!"Test PackageDef : ")>packageDef
+
+	test-constructors2: 	
+		(selected, position, ast, path, project-path) -> None()
+		where
+				moduleDef := ModuleDef(Module( ["test" , "A"]) , "String Path 2" , Package(["test"]) , Module(None(), SPXModuleName("Outliner"), []) , Module(None(), SPXModuleName("Outliner"), []));
+				<debug(!"Test ModuleDef : ")>moduleDef
+		where		
+				packageDef := PackageDef(Package( ["test" , "A"]) , "String Path ");
+				prim(
+				  "SPX_index_add_module" , 
+				  ModuleDef(
+			      Module( ["test" , "A"]) ,  // name of the module 
+			      "StringPath2" ,  // path 
+			      Package(["test"]) , // package name  
+			      Module(None(), SPXModuleName("Outliner"), []) , // ast  
+			      Module(None(), SPXModuleName("Outliner"), [])  // annotated ast 
+		      )
+	      )
+rules 
+
+	test-spx-index-init:
+    (selected, position, ast, path, project-path) -> None()
+    where
+    	debug(!"Invoking : SPX_index_init");
+      prim("SPX_index_init" , "test");
+      debug(!"SPX_index_init is ok!")
+ 		where
+ 			prim("SPX_index_add_module")
+
+ 		where
+ 			debug(!"Invoking : SPX_index_save");
+      prim("SPX_index_save" , "test");
+      debug(!"SPX_index_save is ok!")
+      	
+
+rules 
+	
+	
+	test-spx-index-compilation-unit-save: 
+		(selected, position, ast, path, project-path) -> None()
+    where
+    	full-path := <concat-strings>[project-path, "/" , path]
+    
+    	
+ 
+rules 
+	
+  // Initializes index  with the project name specifed  
+  test-spx-index-init:
+    (selected, position, ast, path, project-path) -> None()
+    where
+    	debug(!"Invoking : SPX_index_init");
+      prim("SPX_index_init" , "test");
+      debug(!"SPX_index_init is ok!")
+ 
+ 
+ 	// TODO : add more real-life tests 
+  test-spx-index-save:   (selected, position, ast, path, project-path) -> None()
+    where
+    	debug(!"Invoking : SPX_index_save");
+      prim("SPX_index_save" , "test");
+      debug(!"SPX_index_save is ok!")
+      
\ No newline at end of file

From M.A.Akhter at student.tudelft.nl  Wed Aug 31 20:53:50 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 31 Aug 2011 18:53:50 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23264 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder
Message-ID: <20110831185350.D0CB1108C00A@mx3.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 31 18:53:50 2011
New Revision: 23264
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23264&sc=1

Log:


Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java	Wed Aug 31 08:48:50 2011	(r23263)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java	Wed Aug 31 18:53:50 2011	(r23264)
@@ -11,11 +11,11 @@
  */
 public class Token implements IToken, Cloneable {
 	
-	private static final long serialVersionUID = -6972938219235720902L;
+	private transient  static final long serialVersionUID = -6972938219235720902L;
 
-	private static Map<String, Integer> asyncAllTokenKinds;
+	private transient  static Map<String, Integer> asyncAllTokenKinds;
 
-	private ITokenizer tokenizer;
+	private transient ITokenizer tokenizer;
 	
 	private final int line;
 	

From M.A.Akhter at student.tudelft.nl  Wed Aug 31 20:55:33 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 31 Aug 2011 18:55:33 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23265 -
	spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder
Message-ID: <20110831185533.B6039CC0BE@mx4.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 31 18:55:33 2011
New Revision: 23265
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23265&sc=1

Log:
setting tokenizer to transient. otherwise, its failing during serialization.

Modified:
   spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java

Modified: spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java	Wed Aug 31 18:53:50 2011	(r23264)
+++ spoofax/trunk/spoofax/org.spoofax.jsglr/src/org/spoofax/jsglr/client/imploder/Token.java	Wed Aug 31 18:55:33 2011	(r23265)
@@ -11,9 +11,9 @@
  */
 public class Token implements IToken, Cloneable {
 	
-	private transient  static final long serialVersionUID = -6972938219235720902L;
+	private static final long serialVersionUID = -6972938219235720902L;
 
-	private transient  static Map<String, Integer> asyncAllTokenKinds;
+	private transient static Map<String, Integer> asyncAllTokenKinds;
 
 	private transient ITokenizer tokenizer;
 	

From M.A.Akhter at student.tudelft.nl  Wed Aug 31 23:58:07 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 31 Aug 2011 21:58:07 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23266 -
	spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests
Message-ID: <20110831215807.1CEAE7F803D@mx1.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 31 21:58:05 2011
New Revision: 23266
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23266&sc=1

Log:


Modified:
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/path.str
   spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/symboltable.str

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/path.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/path.str	Wed Aug 31 18:55:33 2011	(r23265)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/path.str	Wed Aug 31 21:58:05 2011	(r23266)
@@ -4,6 +4,9 @@
 	common
 	utils/path
 	include/SpoofaxLang
+	
+
+	
 rules
 
 	has-known-extensions-success-test:

Modified: spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/symboltable.str
==============================================================================
--- spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/symboltable.str	Wed Aug 31 18:55:33 2011	(r23265)
+++ spoofax-imp/trunk/org.strategoxt.imp.editors.spoofax/trans/unit-tests/symboltable.str	Wed Aug 31 21:58:05 2011	(r23266)
@@ -3,6 +3,8 @@
 imports 
 	normalize/-
 	include/spoofaxlang
+	lib/editor-common.generated
+	
 signature constructors
 
 
@@ -53,12 +55,25 @@
 	
 	
 	test-spx-index-compilation-unit-save: 
-		(selected, position, ast, path, project-path) -> None()
+		(selected, position, ast, path, project-path) ->(filename, result) 
+		
+		where 
+		  project-name := "test";
+		   filename := <guarantee-extension(|"test.aterm")> path
     where
-    	full-path := <concat-strings>[project-path, "/" , path]
-    
-    	
- 
+      prim("SPX_index_init" , project-name);
+    	full-path := <concat-strings>[project-path, "/" , path];
+ 		  parsedAST := <parse-file>full-path  ;
+ 		  <debug(!"Storing AST : ")>parsedAST ;
+ 		  prim("SPX_index_compilation_unit" , project-name , full-path , parsedAST);
+ 		  debug(!"Saving!");
+ 		  prim("SPX_index_save" , project-name);
+ 		  debug(!"Now reading it!");
+ 		  prim("SPX_index_init" , project-name);
+ 		  debug(!"Init is done!");
+ 		  debug(!"getting comp unit ? !");
+ 		  prim("SPX_index_compilation_unit_get" , project-name , full-path);
+      ?result
 rules 
 	
   // Initializes index  with the project name specifed  

From M.A.Akhter at student.tudelft.nl  Wed Aug 31 23:58:31 2011
From: M.A.Akhter at student.tudelft.nl (Md Adil Akhter)
Date: Wed, 31 Aug 2011 21:58:31 +0000
Subject: [Stratego-commits] SVN commit: StrategoXT - r23267 - in
	spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language:
	. spxlang
Message-ID: <20110831215831.2A8B92B801D@mx2.tudelft.nl>

Author: MdAdilAkhter
Date: Wed Aug 31 21:58:30 2011
New Revision: 23267
URL: https://svn.strategoxt.org/websvn/StrategoXT/?rev=23267&sc=1

Log:


Added:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_close.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit_get.java
      - copied, changed from r23261, spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_get_compilation_unit.java
Deleted:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_get_compilation_unit.java
Modified:
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_init.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
   spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacadeRegistry.java

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/LanguageLibrary.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -27,9 +27,13 @@
 		SpxSemanticIndex spxIndex= new SpxSemanticIndex();
 		
 		add(new SPX_index_init(spxIndex));
+		add(new SPX_index_close(spxIndex));
 		add(new SPX_index_save(spxIndex));
+		
 		add(new SPX_index_add_module(spxIndex));
+		
 		add(new SPX_index_compilation_unit(spxIndex));
+		add(new SPX_index_compilation_unit_get(spxIndex));
 	}
 
 	public String getOperatorRegistryName() {

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/ISpxPersistenceManager.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -19,4 +19,6 @@
 	public <K,V> PrimaryHashMap<K,V> loadHashMap ( String mapName);
 
 	public SpxCompilationUnitSymbolTable  spxCompilcationUnitTable();
+
+	public void commit() throws IOException;
 }
\ No newline at end of file

Added: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_close.java
==============================================================================
--- /dev/null	00:00:00 1970	(empty, because file is newly added)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_close.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -0,0 +1,52 @@
+package org.spoofax.interpreter.library.language.spxlang;
+
+import static org.spoofax.interpreter.core.Tools.isTermAppl;
+
+import java.io.IOException;
+
+import org.spoofax.interpreter.core.IContext;
+import org.spoofax.interpreter.core.InterpreterException;
+import org.spoofax.interpreter.core.Tools;
+import org.spoofax.interpreter.library.AbstractPrimitive;
+import org.spoofax.interpreter.library.ssl.SSLLibrary;
+import org.spoofax.interpreter.stratego.Strategy;
+import org.spoofax.interpreter.terms.IStrategoTerm;
+
+/**
+ * @author Md. Adil Akhter
+ * Created On : Aug 25, 2011
+ */
+public class SPX_index_close extends AbstractPrimitive {
+
+	private static String NAME = "SPX_index_save";
+
+	private final SpxSemanticIndex index;
+
+	public SPX_index_close(SpxSemanticIndex index) {
+		super(NAME, 0, 1);
+		this.index = index;
+	}
+	
+	/* (non-Javadoc)
+	 * @see org.spoofax.interpreter.library.AbstractPrimitive#call(org.spoofax.interpreter.core.IContext, org.spoofax.interpreter.stratego.Strategy[], org.spoofax.interpreter.terms.IStrategoTerm[])
+	 */
+	@Override
+	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
+			throws InterpreterException {
+	
+		if (!Tools.isTermString(tvars[0]))
+			return false;
+		
+		try 
+		{
+			return index.close(tvars[0]);
+		}
+		catch(Exception ex)
+		{
+			SSLLibrary.instance(env).getIOAgent().printError("["+NAME+"] Invokation failed. Error : "+ ex.getMessage());
+			return false;
+		}
+		
+	}
+
+}

Copied and modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit_get.java (from r23261, spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_get_compilation_unit.java)
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_get_compilation_unit.java	Tue Aug 30 11:23:54 2011	(r23261, copy source)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_compilation_unit_get.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -3,12 +3,10 @@
 import java.io.IOException;
 
 import org.spoofax.interpreter.core.IContext;
-import org.spoofax.interpreter.core.InterpreterException;
 import org.spoofax.interpreter.core.Tools;
 import org.spoofax.interpreter.library.AbstractPrimitive;
 import org.spoofax.interpreter.library.ssl.SSLLibrary;
 import org.spoofax.interpreter.stratego.Strategy;
-import org.spoofax.interpreter.terms.IStrategoAppl;
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 
@@ -16,13 +14,13 @@
  * @author Md. Adil Akhter
  * Created On : Aug 25, 2011
  */
-public class SPX_index_get_compilation_unit extends AbstractPrimitive {
+public class SPX_index_compilation_unit_get extends AbstractPrimitive {
 
-	private static String NAME = "SPX_index_get_compilation_unit";
+	private static String NAME = "SPX_index_compilation_unit_get";
 
 	private final SpxSemanticIndex index;
 
-	public SPX_index_get_compilation_unit(SpxSemanticIndex index) {
+	public SPX_index_compilation_unit_get(SpxSemanticIndex index) {
 		super(NAME, 0, 2);
 		this.index = index;
 	}
@@ -41,11 +39,14 @@
 			IStrategoString spxCompilationUnitPath = (IStrategoString)tvars[1];
 			
 			try {
-				successStatement  = index.getCompilationUnit(projectName ,  spxCompilationUnitPath);
+				IStrategoTerm t = index.getCompilationUnit(projectName ,  spxCompilationUnitPath);
+				env.setCurrent(t);
+				
+				successStatement = true;
 			} 
 			catch(Exception ex)
 			{
-				// logging any unhandled exception 
+				// logging any un-handled exception 
 				SSLLibrary.instance(env).getIOAgent().printError("["+NAME+" Invokation failed . ] Error : "+ ex.getMessage());
 			}
 		}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_init.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_init.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_init.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -35,7 +35,7 @@
 			return false;
 
 		IStrategoString projectName = (IStrategoString)tvars[0];
-		
+	
 		return index.initialize(projectName , env.getFactory(), SSLLibrary.instance(env).getIOAgent());
 
 	}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SPX_index_save.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -34,7 +34,7 @@
 	public boolean call(IContext env, Strategy[] svars, IStrategoTerm[] tvars)
 			throws InterpreterException {
 	
-		if (Tools.isTermString(tvars[0]))
+		if (!Tools.isTermString(tvars[0]))
 			return false;
 		
 		try 

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxCompilationUnitSymbolTable.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -23,8 +23,8 @@
 	 */
 	public SpxCompilationUnitSymbolTable(String tableName , ISpxPersistenceManager manager)
 	{
-		_infoMap = manager.loadHashMap(tableName+ "._infomap");
-		_spxUnitStoreMap = manager.loadStoreMap(tableName + "._spxUnitStorageMap");
+		_infoMap = manager.loadHashMap(tableName+ "._infomap.idx");
+		_spxUnitStoreMap = manager.loadStoreMap(tableName + "._spxUnitStorageMap.idx");
 	}
 	
 	/**

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxPersistenceManager.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -25,25 +25,25 @@
 	//and perform operation on that.  
 	private final RecordManager _recordManager;
 	
-	private final String indexDirectory = ".index" ; //TODO : remove hardcoding  
+	private String indexDirectory;  
 	
 	private final SpxCompilationUnitSymbolTable _spxUnitsTable;  
 	
-	
-	//TODO : All the maps will be hosted by this  object 
-	public SpxPersistenceManager(String projectName) throws IOException
-	{
-		this( projectName, null);
+
+	public SpxPersistenceManager(String projectName, String projectAbsPath) throws IOException{
+		this(projectName, projectAbsPath+ "/.Index" , null);
 	}
 	
-	public SpxPersistenceManager (String projectName , Properties options) throws IOException
+	public SpxPersistenceManager (String projectName ,String indexDirectory, Properties options) throws IOException
 	{
+		this.indexDirectory = indexDirectory;
+		
 		// Creating empty properties collection if it is null
 		if( options  == null)
 			options = new Properties();
 		
 		// setting up the working directory for the Index 
-		options.put(RecordManagerOptions.INDEX_RELATIVE_PATH_OPTION, indexDirectory + "/" + projectName);
+		options.put(RecordManagerOptions.INDEX_RELATIVE_PATH_OPTION, indexDirectory + "/" + projectName + ".idx");
 	
 		//creating recordmanager for the particular project
 		_recordManager = RecordManagerFactory.createRecordManager(projectName , options);
@@ -51,7 +51,8 @@
 		_spxUnitsTable = new SpxCompilationUnitSymbolTable(projectName+"_spxUnitTable", this);
 	}
 	
-	
+		
+
 	/**
 	 * Instantiates a new HashMap 
 	 * 
@@ -84,7 +85,7 @@
 	 * Commits any unsaved changes to the disk 
 	 * @throws IOException
 	 */
-	void commit() throws IOException
+	public void commit() throws IOException
 	{
 		_recordManager.commit();
 	}

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndex.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -82,41 +82,10 @@
 	// adds module definition in the index . 
 	public void addModuleDefinition(IStrategoTerm moduleDefinition , URI file)
 	{
-
-	}
-
-	/**
-	 * Saves the indexes of the project specified by the projectName
-	 * @param projectName Term representation of the projectName 
-	 * @return true if the operation is successful ; otherwise false.
-	 */
-	public boolean save(IStrategoTerm projectName) throws IllegalStateException
-	{
-		boolean retvalue = false;
 		
-		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
-		try {
-			
-			idxFacade.persistChanges();
-			retvalue = true;
-		} catch (Exception e) {
-			idxFacade.printError( "[SPX_Index_Save failed] Error : "+ e.getMessage()) ; //e.printStackTrace();
-		}
 
-		return retvalue;
 	}
 
-	private SpxSemanticIndexFacade getFacade(IStrategoTerm projectName) {
-
-		SpxSemanticIndexFacade facade = _facadeRegistry.getFacade(projectName);
-		ensureInitialized(facade);
-		return facade;
-	}
-	
-	private void ensureInitialized(SpxSemanticIndexFacade idxFactory) throws IllegalStateException {
-		if (idxFactory == null)
-			throw new IllegalStateException("Semantic index not initialized");
-	}
 	
 	public boolean indexCompilationUnit(IStrategoString projectName,
 			IStrategoString spxCompilationUnitPath,
@@ -136,21 +105,12 @@
 		return successStatement;
 	}
 
-	public boolean getCompilationUnit(IStrategoString projectName,
+	public IStrategoTerm getCompilationUnit(IStrategoString projectName,
 			IStrategoString spxCompilationUnitPath) {
 		
-		boolean successStatement = false;
-		
 		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
-		try {
-			idxFacade.getCompilationUnit(spxCompilationUnitPath);
-			successStatement = true; // setting the flag to indicate the operation is successful
-		}
-		catch (Exception ex)
-		{	
-			idxFacade.printError( "[SPX_Index_getCompilationUnit failed] Error : "+ ex.getMessage()) ;	//logging exception.
-		}
-		return successStatement;
+		
+		return idxFacade.getCompilationUnit(spxCompilationUnitPath);
 	}
 	
 	public boolean removeCompilationUnit(IStrategoString projectName,
@@ -169,4 +129,45 @@
 		}
 		return successStatement;
 	}
+	
+	/**
+	 * Saves the indexes of the project specified by the projectName
+	 * @param projectName Term representation of the projectName 
+	 * @return true if the operation is successful ; otherwise false.
+	 * @throws IOException 
+	 */
+	public boolean save(IStrategoTerm projectName) throws IllegalStateException, IOException
+	{
+		SpxSemanticIndexFacade idxFacade = getFacade(projectName);
+		idxFacade.persistChanges();
+		return true;
+	}
+	
+	public boolean close(IStrategoTerm projectName) throws IOException {
+		SpxSemanticIndexFacade idxFacade = removeFacade(projectName);
+		idxFacade.close();
+		return true;
+	}
+	
+	private SpxSemanticIndexFacade getFacade(IStrategoTerm projectName) {
+
+		SpxSemanticIndexFacade facade = _facadeRegistry.getFacade(projectName);
+		ensureInitialized(facade);
+		return facade;
+	}
+	
+	
+	private SpxSemanticIndexFacade removeFacade(IStrategoTerm projectName) {
+
+		SpxSemanticIndexFacade facade = _facadeRegistry.removeFacade(projectName);
+		ensureInitialized(facade);
+		return facade;
+	}
+	
+	private void ensureInitialized(SpxSemanticIndexFacade idxFactory) throws IllegalStateException {
+		if (idxFactory == null)
+			throw new IllegalStateException("Spoofaxlang Semantic index not initialized");
+	}
+	
+	
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacade.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -13,6 +13,8 @@
 import org.spoofax.interpreter.terms.IStrategoString;
 import org.spoofax.interpreter.terms.IStrategoTerm;
 import org.spoofax.interpreter.terms.ITermFactory;
+import org.spoofax.jsglr.client.imploder.ImploderAttachment;
+import org.spoofax.terms.attachments.TermAttachmentStripper;
 
 
 
@@ -27,7 +29,8 @@
 	private final IOAgent _agent;
 
 	private final SpxSemanticIndexEntryFactory _entryFactory;
-
+	
+	private final TermAttachmentStripper stripper;
 	/**
 	 * Initializes the SemanticIndexFactory
 	 * @param projectName
@@ -39,14 +42,20 @@
 		_projectName = asJavaString(projectName);	
 		_entryFactory = new SpxSemanticIndexEntryFactory(termFactory);
 
-		//Initializes persistent manager
-		_persistenceManager = new SpxPersistenceManager(_projectName);
-
 		//Sets the Term Factory 
 		_termFactory = termFactory;
 
 		//IOAgent to handle URI
 		_agent = agent;
+		
+		stripper = new TermAttachmentStripper(termFactory);
+		
+		String projectAbsPath = _agent.getWorkingDir();
+		
+		//Initializes persistent manager
+		_persistenceManager = new SpxPersistenceManager(_projectName , projectAbsPath);
+
+		
 	}
 
 	/**
@@ -111,11 +120,7 @@
 		return _agent;
 	}
 
-	public void persistChanges() throws IOException 
-	{
-		_persistenceManager.commitAndClose();
-	}
-
+	
 	/**
 	 * Prints error message
 	 * 
@@ -139,8 +144,14 @@
 
 		URI resUri = toFileURI(spxCompilationUnitPath); // Converting IStrategoString to File URI 
 		
+		ImploderAttachment astAttachment = ImploderAttachment.getCompactPositionAttachment(spxCompilationUnitAST, true);
+		IStrategoTerm astTerm = stripper.strip(spxCompilationUnitAST);
+		astTerm.putAttachment(astAttachment);
+
+		//TODO : Implement Custom Serializer for the IStrategoTerm 
+		
 		SpxCompilationUnitSymbolTable table = _persistenceManager.spxCompilcationUnitTable();
-		table.define(resUri, spxCompilationUnitAST);
+		table.define(resUri, astTerm);
 	}
 
 	public IStrategoTerm getCompilationUnit(IStrategoString spxCompilationUnitPath)
@@ -160,4 +171,13 @@
 		
 		table.remove(resUri);
 	}
+	public void persistChanges() throws IOException 
+	{
+		_persistenceManager.commit();
+	}
+
+	public void close() throws IOException {
+		_persistenceManager.commitAndClose();
+		
+	}
 }

Modified: spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacadeRegistry.java
==============================================================================
--- spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacadeRegistry.java	Wed Aug 31 21:58:05 2011	(r23266)
+++ spoofax/trunk/spoofax/org.spoofax.interpreter.library.language/src/org/spoofax/interpreter/library/language/spxlang/SpxSemanticIndexFacadeRegistry.java	Wed Aug 31 21:58:30 2011	(r23267)
@@ -55,5 +55,12 @@
 	{
 		_registry.clear();
 	}
+
+
+	public SpxSemanticIndexFacade removeFacade(IStrategoTerm projectName) {
+		String key = asJavaString(projectName);
+		
+		return _registry.remove(key);
+	}
 	
 }
\ No newline at end of file

